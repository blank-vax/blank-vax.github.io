<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">

<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">


  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="LFSR,Fast Correlation Attack,z3-solver,">





  <link rel="alternate" href="/atom.xml" title="B1ank" type="application/atom+xml">






<meta name="description" content="0x00 LFSR概述线性反馈移位寄存器（linear feedback shift register, LFSR）是指,给定前一状态的输出,将该输出的线性函数再用作输入的移位寄存器.异或运算是最常见的单比特线性函数:对寄存器的某些位进行异或操作后作为输入,再对寄存器中的各比特进行整体移位.该结构具有结构简单,运行速度快的特点,常被应用于伪随机数和伪随机噪声的生成中.同时,该原件常与流密码相关部分">
<meta name="keywords" content="LFSR,Fast Correlation Attack,z3-solver">
<meta property="og:type" content="article">
<meta property="og:title" content="LFSR原理及CTF相关">
<meta property="og:url" content="https://blank-vax.github.io/2019/10/30/LFSR原理及CTF相关/index.html">
<meta property="og:site_name" content="B1ank">
<meta property="og:description" content="0x00 LFSR概述线性反馈移位寄存器（linear feedback shift register, LFSR）是指,给定前一状态的输出,将该输出的线性函数再用作输入的移位寄存器.异或运算是最常见的单比特线性函数:对寄存器的某些位进行异或操作后作为输入,再对寄存器中的各比特进行整体移位.该结构具有结构简单,运行速度快的特点,常被应用于伪随机数和伪随机噪声的生成中.同时,该原件常与流密码相关部分">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://blank-vax.github.io/2019/10/30/LFSR原理及CTF相关/1.PNG">
<meta property="og:image" content="https://blank-vax.github.io/2019/10/30/LFSR原理及CTF相关/2.PNG">
<meta property="og:image" content="https://blank-vax.github.io/2019/10/30/LFSR原理及CTF相关/3.PNG">
<meta property="og:image" content="https://blank-vax.github.io/2019/10/30/LFSR原理及CTF相关/4.PNG">
<meta property="og:image" content="https://blank-vax.github.io/2019/10/30/LFSR原理及CTF相关/6.PNG">
<meta property="og:image" content="https://blank-vax.github.io/2019/10/30/LFSR原理及CTF相关/7.PNG">
<meta property="og:updated_time" content="2021-07-07T07:51:07.670Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LFSR原理及CTF相关">
<meta name="twitter:description" content="0x00 LFSR概述线性反馈移位寄存器（linear feedback shift register, LFSR）是指,给定前一状态的输出,将该输出的线性函数再用作输入的移位寄存器.异或运算是最常见的单比特线性函数:对寄存器的某些位进行异或操作后作为输入,再对寄存器中的各比特进行整体移位.该结构具有结构简单,运行速度快的特点,常被应用于伪随机数和伪随机噪声的生成中.同时,该原件常与流密码相关部分">
<meta name="twitter:image" content="https://blank-vax.github.io/2019/10/30/LFSR原理及CTF相关/1.PNG">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blank-vax.github.io/2019/10/30/LFSR原理及CTF相关/">





  <title>LFSR原理及CTF相关 | B1ank</title>
  









</head>


<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
	<a href="https://github.com/blank-vax" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">B1ank</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blank-vax.github.io/2019/10/30/LFSR原理及CTF相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="B1ank">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/picture.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="B1ank">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">LFSR原理及CTF相关</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-30T21:34:00+08:00">
                2019-10-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Crypto-Attack/" itemprop="url" rel="index">
                    <span itemprop="name">Crypto_Attack</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/10/30/LFSR原理及CTF相关/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/10/30/LFSR原理及CTF相关/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/10/30/LFSR原理及CTF相关/" class="leancloud_visitors" data-flag-title="LFSR原理及CTF相关">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">热度&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
                 <span>℃<span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4,975
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  21
                </span>
              
            </div>
          

          

        </span></span></div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="0x00-LFSR概述"><a href="#0x00-LFSR概述" class="headerlink" title="0x00 LFSR概述"></a>0x00 LFSR概述</h2><p>线性反馈移位寄存器（linear feedback shift register, LFSR）是指,给定前一状态的输出,将该输出的线性函数再用作输入的移位寄存器.异或运算是最常见的单比特线性函数:对寄存器的某些位进行异或操作后作为输入,再对寄存器中的各比特进行整体移位.该结构具有结构简单,运行速度快的特点,常被应用于伪随机数和伪随机噪声的生成中.同时,该原件常与流密码相关部分联合使用.</p>
<h2 id="0x01-LFSR原理"><a href="#0x01-LFSR原理" class="headerlink" title="0x01 LFSR原理"></a>0x01 LFSR原理</h2><p>LFSR属于反馈移位寄存器(FSR)的一种,另一种为NFSR.FSR是流密码产生密钥流的一个重要组成部分,在GF(2)上的一个n级FSR通常由n个二元存储器和一个反馈函数组成,如下图所示.</p>
<p><img src="/2019/10/30/LFSR原理及CTF相关/1.PNG" alt="FSR.png-53.4kB"></p>
<p>如果这里的反馈函数是线性的,我们则称之为LFSR,此时该反馈函数可以表示为:    </p>
<script type="math/tex; mode=display">f(a_{1},a_{2},...,a_{n}) = c_{n} \cdot a_{1} \oplus c_{(n-1)} \cdot a_{2} \oplus ... \oplus c_{1} \cdot a{n}</script><p>其中ci为0/1.我们通过举例来具体说明该过程.   </p>
<p>假设给定一个5级LFSR,初始状态为:<code>(a1,a2,a3,a4,a5) = (1,0,0,1,1)</code>,反馈函数为:<code>f(a1,a2,a3,a4,a5) = a4 ^ a1</code>.整个过程如下图所示.</p>
<p><img src="/2019/10/30/LFSR原理及CTF相关/2.PNG" alt="LFSR.png-65.3kB"></p>
<p>前五位初始状态为10011,则<code>a6 = a4 ^ a1 = 0</code>,<code>a7 = a5 ^ a2 = 1</code>,以此类推我们得到前31位的计算结果如下: 1001101001000010101110110001111.    </p>
<p>对于一个n级LFSR来说,其最大周期为2^n-1,对于这里选取的5级LFSR,其最大周期可以确定为31.故产生的随机数为前31位的周期循环.通过这些分析可以发现,对于LFSR系统,我们关心<code>初始状态</code>,<code>反馈函数</code>和<code>输出序列</code>这三个部分,而在CTF题目中经常给出反馈函数和输出序列,将待求的初始状态作为需要提交的flag来设题.   </p>
<h2 id="0x03-LFSR在CTF中的应用"><a href="#0x03-LFSR在CTF中的应用" class="headerlink" title="0x03 LFSR在CTF中的应用"></a>0x03 LFSR在CTF中的应用</h2><p>本部分来总结CTF中一些比较有趣的LFSR类题目.本篇文章重点介绍已知掩码mask情况下进行的求解.   </p>
<h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><h4 id="爆破解法"><a href="#爆破解法" class="headerlink" title="爆破解法"></a>爆破解法</h4><p>本类题目由于待求的初始状态(即flag)位数较少的情况.由于初始状态下每个位置只有两种可能,所以爆破算法时间复杂度为2的指数级,当位数较少时,可以通过直接爆破的方法得到flag.    </p>
<p><strong>典型例题</strong>         </p>
<p>题目来源: 2018 强网杯 streamgame1   </p>
<p>题目说明:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">assert</span> flag.startswith(<span class="string">"flag&#123;"</span>)</span><br><span class="line"><span class="keyword">assert</span> flag.endswith(<span class="string">"&#125;"</span>)</span><br><span class="line"><span class="keyword">assert</span> len(flag)==<span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lfsr</span><span class="params">(R,mask)</span>:</span></span><br><span class="line">    output = (R &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xffffff</span></span><br><span class="line">    i=(R&amp;mask)&amp;<span class="number">0xffffff</span></span><br><span class="line">    lastbit=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i!=<span class="number">0</span>:</span><br><span class="line">        lastbit^=(i&amp;<span class="number">1</span>)</span><br><span class="line">        i=i&gt;&gt;<span class="number">1</span></span><br><span class="line">    output^=lastbit</span><br><span class="line">    <span class="keyword">return</span> (output,lastbit)</span><br><span class="line">R=int(flag[<span class="number">5</span>:<span class="number">-1</span>],<span class="number">2</span>)</span><br><span class="line">mask    =   <span class="number">0b1010011000100011100</span></span><br><span class="line"></span><br><span class="line">f=open(<span class="string">"key"</span>,<span class="string">"ab"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>):</span><br><span class="line">    tmp=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        (R,out)=lfsr(R,mask)</span><br><span class="line">        tmp=(tmp &lt;&lt; <span class="number">1</span>)^out</span><br><span class="line">    f.write(chr(tmp))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>爆破关键脚本:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">2</span>**<span class="number">19</span>):</span><br><span class="line">    R=k;</span><br><span class="line">    a=<span class="string">''</span></span><br><span class="line">    judge=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>):</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">            (k, out) = lfsr(k, mask)</span><br><span class="line">            tmp = (tmp &lt;&lt; <span class="number">1</span>) ^ out</span><br><span class="line">        <span class="keyword">if</span>(key[i]!=tmp):</span><br><span class="line">           judge=<span class="number">0</span></span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span>(judge==<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'flag&#123;'</span>+bin(R)[<span class="number">2</span>:]+<span class="string">'&#125;'</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h4 id="分析解法"><a href="#分析解法" class="headerlink" title="分析解法"></a>分析解法</h4><p>当初始状态位数过多时,显然直接爆破所需要的成本将大大提高.此时我们需要从原理对题目提供的LFSR进行分析,然后逆向求解.<br><strong>典型例题</strong>    </p>
<p>题目来源: 2018 CISCN线上赛 oldstreamgame<br>题目说明:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="string">"flag&#123;xxxxxxxxxxxxxxxx&#125;"</span></span><br><span class="line"><span class="keyword">assert</span> flag.startswith(<span class="string">"flag&#123;"</span>)</span><br><span class="line"><span class="keyword">assert</span> flag.endswith(<span class="string">"&#125;"</span>)</span><br><span class="line"><span class="keyword">assert</span> len(flag)==<span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lfsr</span><span class="params">(R,mask)</span>:</span></span><br><span class="line">    output = (R &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xffffffff</span></span><br><span class="line">    i=(R&amp;mask)&amp;<span class="number">0xffffffff</span></span><br><span class="line">    lastbit=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i!=<span class="number">0</span>:</span><br><span class="line">        lastbit^=(i&amp;<span class="number">1</span>)</span><br><span class="line">        i=i&gt;&gt;<span class="number">1</span></span><br><span class="line">    output^=lastbit </span><br><span class="line">    <span class="keyword">return</span> (output,lastbit)</span><br><span class="line"></span><br><span class="line">R=int(flag[<span class="number">5</span>:<span class="number">-1</span>],<span class="number">16</span>)</span><br><span class="line">mask = <span class="number">0b10100100000010000000100010010100</span></span><br><span class="line"></span><br><span class="line">f=open(<span class="string">"key"</span>,<span class="string">"w"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    tmp=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        (R,out)=lfsr(R,mask)</span><br><span class="line">        tmp=(tmp &lt;&lt; <span class="number">1</span>)^out</span><br><span class="line">    f.write(chr(tmp))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>题目分析:    </p>
<p>本题显然是一个线性反馈移位寄存器的结构,flag为8位十六进制,即32bits,我们可以使用暴力枚举的方法,但最好还是分析一下原理并逆向求解.我们已知输出结果和代码表示的反馈函数,现在只需要还原出原始状态即可.<br>首先拆解分析lfsr函数.</p>
<p>该函数的输入为8位十六进制初始状态R和已知二进制掩码mask.</p>
<p><code>output = (R &lt;&lt; 1) &amp; 0xffffffff</code>: 取R左移一位后的低32位,将值赋给output;   </p>
<p><code>i = (R &amp; mask) &amp; 0xffffffff</code>: 把传入的R和mask进行按位与运算,结果取低32位并赋于i;  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lastbit = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i != <span class="number">0</span>:</span><br><span class="line">    lastbit ^= (i &amp; <span class="number">1</span>)</span><br><span class="line">    i = i &gt;&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>从i的最低位向最高位依次进行异或运算,将运算结果赋给lastbit变量;  </p>
<p><code>output ^= lasbit</code>: 将output变量的最后一位设置成lastbit变量的值; <code>return (output, lastbit)</code>: output为经过一轮lfsr之后的新序列,lastbit为经过一轮lfsr之后的输出.    </p>
<p>对于提供的常数mask,只有其第3,5,8,12,20,27,30,32这几位为1,其余位为0.考虑到后面的将i每位进行相互异或这一过程可知,mask为0的位是清零位,输入R中对应位的值不会影响最终结果;而mask为1的位是保持位,输入R对应位的结果不变.从而<code>lastbit = R3 ^ R5 ^ R8 ^ R12 ^ R20 ^ R27 ^ R30 ^ R32</code>,显然R与lasbit之间满足线性关系.    </p>
<p>当即将输出第32位lasbit时,R已经左移31位,我们得到以下示意图.    </p>
<p><img src="/2019/10/30/LFSR原理及CTF相关/3.PNG" alt="first-bit.png-92.9kB"></p>
<p>这样我们可以还原出R的第1位,使用同样的方法我们可以得到R的第2位.   </p>
<p><img src="/2019/10/30/LFSR原理及CTF相关/4.PNG" alt="second-bit.png-101.4kB"></p>
<p>使用此类方法,我们可以实现R的32位全部还原,脚本如下:   </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mask = <span class="string">'10100100000010000000100010010100'</span></span><br><span class="line">key = <span class="string">'00100000111111011110111011111000'</span></span><br><span class="line"></span><br><span class="line">tmp = key</span><br><span class="line"></span><br><span class="line">R = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">    output = <span class="string">'?'</span> + key[:<span class="number">31</span>]</span><br><span class="line">    ans = int(tmp[<span class="number">-1</span>-i])^int(output[<span class="number">-3</span>])^int(output[<span class="number">-5</span>])^int(output[<span class="number">-8</span>])^int(output[<span class="number">-12</span>])^int(output[<span class="number">-20</span>])^int(output[<span class="number">-27</span>])^int(output[<span class="number">-30</span>])</span><br><span class="line">    R += str(ans)</span><br><span class="line">    key = str(ans) + key[:<span class="number">31</span>]</span><br><span class="line"></span><br><span class="line">R = format(int(R[::<span class="number">-1</span>],<span class="number">2</span>),<span class="string">'x'</span>)</span><br><span class="line">flag = <span class="string">"flag&#123;"</span> + R + <span class="string">"&#125;"</span></span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure>
<h4 id="类似题目"><a href="#类似题目" class="headerlink" title="类似题目"></a>类似题目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018 强网杯 线上赛 streamgame1</span><br><span class="line">2018 强网杯 线上赛 streamgame2</span><br><span class="line">2018 强网杯 线上赛 streamgame4</span><br><span class="line">2018 HITB-XCTF 线上赛 streamgamex</span><br></pre></td></tr></table></figure>
<h3 id="分组码基底相关解法"><a href="#分组码基底相关解法" class="headerlink" title="分组码基底相关解法"></a>分组码基底相关解法</h3><h4 id="分组码"><a href="#分组码" class="headerlink" title="分组码"></a>分组码</h4><p>对每段长度为k的信息,以一定的规则增加r=n-k个校验元,组成长为n的序列,称这个序列为码字.   </p>
<p>在GF(2)下,信息组共有2^k个,相应的码字也有2^k个,我们称这2^k个码字的集合为(n,k)分组码.当校验元与信息元之间是线性关系时,我们称之为线性分组码,一般用[n,k]表示.    </p>
<p>[n,k]线性分组码是定义在F2上的n维线性空间中的一个k维子空间,由于该线性子空间在加法运算下构成阿贝尔群,所以线性分组码也被称为群码.     </p>
<p>[n,k]线性分组码的2^k个码字组成了一个k维子空间,因此这2^k个码字完全可由k个独立矢量所组成的基底张成.我们设基底为:    </p>
<p><img src="/2019/10/30/LFSR原理及CTF相关/6.PNG" alt="block_code2.png"></p>
<p>将这组基底写成矩阵形式,则有,   </p>
<p>[n,k]码中的任何码字都可以由这组基底的线性组合生成,即:    </p>
<p><img src="/2019/10/30/LFSR原理及CTF相关/7.PNG" alt="block_code3.png-58.5kB"> </p>
<p>其中,m = (m1,m2,….,mk)是k个信息元组成的信息组.因此若已知信息组m,可通过上式求得对应的码字,称G为[n,k]的生成矩阵.</p>
<h4 id="Fast-Correlation-Attacks"><a href="#Fast-Correlation-Attacks" class="headerlink" title="Fast Correlation Attacks"></a>Fast Correlation Attacks</h4><p><strong>算法分析</strong><br>相关攻击correlation<br>attacks最早由Siegenthaler提出,攻击思路是<strong>利用单个LFSR的输出序列和函数运算之后大的LFSR的输出序列之间具有的一定相关性这一特点,来还原LFSR大的初始状态</strong>.后来快速相关攻击被提出.参考论文如下:</p>
<p><a href="https://link.springer.com/content/pdf/10.1007/978-3-642-21702-9_4.pdf" target="_blank" rel="noopener">Fast Correlation Attacks:Method and Countermeasures</a>    </p>
<p>该论文中提出两种重要的快速相关攻击方法: 一次通过法和迭代译码法.在论文作者建立的模型之下,当单个LFSR的输出序列和函数运算之后的LFSR输出序列之间的相关性大于0.53时,通常认为满足这类攻击的条件.此类攻击方法有一个特点,即在抽头(影响异或结果的比特位数量,亦即mask中为1的位数)数量较少的时候,作用效果比较明显.        </p>
<p>下面根据论文内容对两类算法进行分析.设截取输出序列z的长度为N,抽头数为t,级数为L,LFSR序列的相关概率为<code>q = 1-p</code>    </p>
<p><strong>算法A</strong></p>
<p>计算截取序列每比特所需要的平均方程数: </p>
<script type="math/tex; mode=display">m = m(N,L,t) = \log_2(N/2L) \cdot (t+1)</script><p>计算截取序列的比特的模二加和原LFSR序列的相应比特的模二加相同的概率<code>s(q, t)</code>:  </p>
<script type="math/tex; mode=display">s(q,1) = q</script><script type="math/tex; mode=display">s(q,t) = qs(q,t-1)+(1-q)(1-s(q,t-1))</script><p>计算在m个方程中至少有h个方程成立的概率<code>Q(q,m,h)</code>:</p>
<script type="math/tex; mode=display">Q(m,q,h) = \sum_{i=h}^{m}{C_{m}^{i}(qs^{i}(1-s)^{m-i}+(1-q)(1-s)^{i}s^{m-i})}</script><p><code>zn = un</code>并且m个方程中至少有h个方程成立的概率为:</p>
<script type="math/tex; mode=display">R(q,m,h) = \sum_{i=h}^{m}{C_{m}^{i}qs^{i}(1-s)^{m-i}}</script><p>在这种条件下,<code>zn = un</code>的概率为:</p>
<script type="math/tex; mode=display">T(q,m,h) = \frac{R(q,m,h)}{Q(q,m,h)}</script><p>然后我们求出一个最大的h,并记为hmax,使得如下表达式成立:</p>
<script type="math/tex; mode=display">Q(q,m,h_{max}) \cdot N \geq L</script><p>计算在L个比特中错误的平均数:</p>
<script type="math/tex; mode=display">r = (1-T(q,m,h_{max})) \cdot L</script><p>从下式中选取至少满足hmax个校验等式的L个比特:</p>
<script type="math/tex; mode=display">z = \lbrace z_{n} \rbrace _{n=1}^{N}</script><p>将z这L个比特作为LFSR输出序列的对应位置的估计I0,由I0可以得到寄存器序列{un}的估计,根据{un}的估计和{zn}的相关性来判断I0是否正确.如果不正确,则对I0依次加上重量为1,2,3…n的向量,得到I0的修正值,重复这一过程,直到找到正确解.   </p>
<p><strong>算法B</strong></p>
<p>计算截取序列每比特所需要大的平均方程数:</p>
<script type="math/tex; mode=display">m = m(N,L,t) = \log_{2}(N/2L) \cdot (t+1)</script><p>对{un}的任一比特un均可以得到如下m个校验等式:</p>
<script type="math/tex; mode=display">
    \begin{cases}
    u_{n} \oplus b_{1} = 0 \\ 
    u_{n} \oplus b_{2} = 0 \\ 
    ....         ....     .. \\
    u_{n} \oplus b_{m} = 0
    \end{cases}</script><p>其中bi是{un}中t个不同元素的和.把{zn}中对应位置的元素代入上式得:</p>
<script type="math/tex; mode=display">
\begin{cases}
    z_{n} \oplus y_{1} = L_{1} \\
    z_{n} \oplus y_{2} = L_{2} \\
    ....        ......   ....  \\
    z_{n} \oplus y_{m} = L_{m} 
    \end{cases}</script><p>设yi中t个不同位置的正确概率分别为q1,q2,…,qt,则有:  </p>
<script type="math/tex; mode=display">s(q,1) = q</script><p>并且</p>
<script type="math/tex; mode=display">s_{i}(q_{1},q_{2},...,q_{t},t) = q_{1}s_{i}(q_{1},q_{2},....,q_{(t-1)}, t-1) + (1-q_{1})(1-s_{i}(q_{1},q_{2},...,q_{(t-1)}, t-1))</script><p>当zn满足第i1,i2,…,ih校验等式,而不满足j1,j2,…..,jm-h校验等式时,有:</p>
<script type="math/tex; mode=display">V(q,m,h) = \sum_{i=0}^{k}{C_{m}^{i}qs^{i}(1-s)^{m-i}}</script><p>zn至多满足h个校验等式的概率为:</p>
<script type="math/tex; mode=display">U(q,m,h) = \sum_{i=0}^{k}{C_{m}^{i}(qs^{i}(1-s)^{m-i}+(1-q)(1-s)^{i}s^{m-i})}</script><p>当<code>zn = un</code>,且至多满足h个校验等式的概率为:</p>
<script type="math/tex; mode=display">V(q,m,h) = \sum_{i=0}^{k}{C_{m}^{i}qs^{i}(1-s)^{m-i})}</script><p>当<code>zn != un</code>,且至多满足h个校验等式的概率为:</p>
<script type="math/tex; mode=display">W(q,m,h) = \sum_{i=0}^{k}{C_{m}^{i}(1-q)(1-s)^{i}s^{m-i}}</script><p>若zn至多满足h个校验等式，则取补，z中取补元素个数的期望值为:</p>
<script type="math/tex; mode=display">U(q,m,h) \cdot N</script><p>取补后错误的个数为:   </p>
<script type="math/tex; mode=display">V(q,m,h) \cdot N</script><p>取补后正确的个数为:   </p>
<script type="math/tex; mode=display">W(q,m,h) \cdot N</script><p>取补后正确比特位增加的概率为:   </p>
<script type="math/tex; mode=display">I(q,m,h) = W(q,m,h) - V(q,m,h)</script><p>对给定的q、m,找出使得I(q,m,h)最大的h,记为hmax.<br>若I(q,m,h)&lt;=0,表示该算法没有起到校正作用,算法失败.<br>若I(q,m,h)&gt;0,则第一次迭代后,有:   </p>
<script type="math/tex; mode=display">N_{thr} = U(q,m,h_{max}) \cdot N</script><ul>
<li>两算法对比<ul>
<li>算法A<ul>
<li>优点: 错误率接近0.75时攻击效果显著.</li>
<li>缺点: 当抽头数量较多时,该攻击将逐渐退化为穷举攻击.</li>
</ul>
</li>
<li>算法B<ul>
<li>优点: 错误率接近0.5时攻击效果显著.</li>
<li>缺点: 该攻击需要进行大量的双精度计算,计算量较大</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>攻击工具</strong>   </p>
<p>开普敦大学于2011年发布如下项目:<a href="http://pubs.cs.uct.ac.za/honsproj/cgi-bin/view/2011/desai.zip/crypto_desai/dl/" target="_blank" rel="noopener">fast correlation attacks project</a>,该项目中包含了很详细的攻击思想,设计流程和实现方案,我们可以采用该方案来施展一次标准的Fast Correlation Attacks(需要GNU Scientific Library库依赖).编译和报错及提取脚本编写可以参考: <a href="https://www.anquanke.com/post/id/184828" target="_blank" rel="noopener">参考文章</a>.     </p>
<p><strong>典型题目</strong><br>题目来源: 2019 0CTF/TCTF 线上赛 zero0lfsr<br>题目说明: </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> init1,init2,init3,FLAG</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">assert</span>(FLAG==<span class="string">"flag&#123;"</span>+hashlib.sha256(init1+init2+init3).hexdigest()+<span class="string">"&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lfsr</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, init, mask, length)</span>:</span></span><br><span class="line">        self.init = init</span><br><span class="line">        self.mask = mask</span><br><span class="line">        self.lengthmask = <span class="number">2</span>**(length+<span class="number">1</span>)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        nextdata = (self.init &lt;&lt; <span class="number">1</span>) &amp; self.lengthmask </span><br><span class="line">        i = self.init &amp; self.mask &amp; self.lengthmask </span><br><span class="line">        output = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i != <span class="number">0</span>:</span><br><span class="line">            output ^= (i &amp; <span class="number">1</span>)</span><br><span class="line">            i = i &gt;&gt; <span class="number">1</span></span><br><span class="line">        nextdata ^= output</span><br><span class="line">        self.init = nextdata</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(x1,x2,x3)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (x1*x2)^(x2*x3)^(x1*x3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    l1 = lfsr(int.from_bytes(init1,<span class="string">"big"</span>),<span class="number">0b100000000000000000000000010000000000000000000000</span>,<span class="number">48</span>)</span><br><span class="line">    l2 = lfsr(int.from_bytes(init2,<span class="string">"big"</span>),<span class="number">0b100000000000000000000000000000000010000000000000</span>,<span class="number">48</span>)</span><br><span class="line">    l3 = lfsr(int.from_bytes(init3,<span class="string">"big"</span>),<span class="number">0b100000100000000000000000000000000000000000000000</span>,<span class="number">48</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"keystream"</span>,<span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8192</span>):</span><br><span class="line">            b = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">                b = (b&lt;&lt;<span class="number">1</span>)+combine(l1.next(),l2.next(),l3.next())</span><br><span class="line">            f.write(chr(b).encode())</span><br></pre></td></tr></table></figure>
<p>题目分析:    </p>
<p>观察该题目所给出的加密脚本,我们可以看到,lfsr部分虽然是以class的形式给出,但由于给出的反馈函数形式相同,可以用与上文类似的方法进行分析.观察3个mask不难发现,每个mask只有2位为1,其余部分全为0,于是我们可以得出:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l1.next() = init1[48] xor init1[23]</span><br><span class="line">l2.next() = init1[48] xor init1[14]</span><br><span class="line">l3.next() = init1[48] xor init1[42]</span><br></pre></td></tr></table></figure>
<p>到目前为止的分析和上面提及的相差无几,如果给出三组特定的输出序列,我们就可以采用上面的方法进行序列还原,从而得到flag.但这道题目显然没有给出每个初始状态独立的初始序列,而是对输出进行如下混合运算:<code>b = (b&lt;&lt;1) + combine(l1.next(), l2.next(), l3.next())</code>.该函数的返回结果为:<code>(x1*x2)^(x2*x3)^(X1*x3)</code>,由于x1,x2,x3均为GF(2)上的数字,因此该表达式则等价为:<code>(x1&amp;x2)^(x2&amp;x3)^(x1&amp;x3)</code>.    </p>
<p>下面对该函数进行分析,首先对x1,x2,x3及combine()函数的所有返回结果进行穷举:    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x1 = 0, x2 = 0, x3 = 0 ——&gt; result = 0</span><br><span class="line">x1 = 0, x2 = 0, x3 = 1 ——&gt; result = 0</span><br><span class="line">x1 = 0, x2 = 1, x3 = 0 ——&gt; result = 0</span><br><span class="line">x1 = 0, x2 = 1, x3 = 1 ——&gt; result = 1</span><br><span class="line">x1 = 1, x2 = 0, x3 = 0 ——&gt; result = 0</span><br><span class="line">x1 = 1, x2 = 0, x3 = 1 ——&gt; result = 1</span><br><span class="line">x1 = 1, x2 = 1, x3 = 0 ——&gt; result = 1</span><br><span class="line">x1 = 1, x2 = 1, x3 = 1 ——&gt; result = 1</span><br></pre></td></tr></table></figure>
<p>观察结果可以发现,当x1=0时,对应的4个result值其中3个为0,1个为1,即x1和result相同的概率为0.75,同理x2和x3也满足这个规律.于是我们发现单个x的值和combine之后的值相同的概率为0.75,从而我们可以考虑上文提到的快速相关攻击,通过概率预测筛选逼近的方法还原最终的output1,output2,output3.     </p>
<p>完成对output的提取分离之后,我们按照常规方法还原出各自的init后,按照题目要求拼接计算哈希值,即可得到flag.相关解题脚本如下:    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">mask1 = <span class="string">'100000000000000000000000010000000000000000000000'</span></span><br><span class="line">mask2 = <span class="string">'100000000000000000000000000000000010000000000000'</span></span><br><span class="line">mask3 = <span class="string">'100000100000000000000000000000000000000000000000'</span></span><br><span class="line"></span><br><span class="line">key1 = <span class="string">'100100011111111010101110010010110100101000110011'</span></span><br><span class="line">key2 = <span class="string">'001101101101101111001001101101110000001001000011'</span></span><br><span class="line">key3 = <span class="string">'001000101001101100100001101111101011101010100001'</span></span><br><span class="line"></span><br><span class="line">tmp1=key1</span><br><span class="line">tmp2=key2</span><br><span class="line">tmp3=key3</span><br><span class="line"></span><br><span class="line">init1 = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">48</span>):</span><br><span class="line">    output = <span class="string">'?'</span> + key1[:<span class="number">47</span>]</span><br><span class="line">    ans = int(tmp1[<span class="number">-1</span>-i])^int(output[<span class="number">-23</span>])</span><br><span class="line">    init1 += str(ans)</span><br><span class="line">    key1 = str(ans) + key1[:<span class="number">47</span>]</span><br><span class="line"></span><br><span class="line">init1 = long_to_bytes(int(init1[::<span class="number">-1</span>],<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">init2 = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">48</span>):</span><br><span class="line">    output = <span class="string">'?'</span> + key2[:<span class="number">47</span>]</span><br><span class="line">    ans = int(tmp2[<span class="number">-1</span>-i])^int(output[<span class="number">-14</span>])</span><br><span class="line">    init2 += str(ans)</span><br><span class="line">    key2 = str(ans) + key2[:<span class="number">47</span>]</span><br><span class="line"></span><br><span class="line">init2 = long_to_bytes(int(init2[::<span class="number">-1</span>],<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">init3 = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">48</span>):</span><br><span class="line">    output = <span class="string">'?'</span> + key3[:<span class="number">47</span>]</span><br><span class="line">    ans = int(tmp3[<span class="number">-1</span>-i])^int(output[<span class="number">-42</span>])</span><br><span class="line">    init3 += str(ans)</span><br><span class="line">    key3 = str(ans) + key3[:<span class="number">47</span>]</span><br><span class="line"></span><br><span class="line">init3 = long_to_bytes(int(init3[::<span class="number">-1</span>],<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">flag=<span class="string">"flag&#123;"</span>+hashlib.sha256(init1+init2+init3).hexdigest()+<span class="string">"&#125;"</span></span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure>
<p>上面提及的是一种需要运用数理知识(即快速相关攻击)的解法,下面介绍一种使用<code>z3-solver</code>库进行的爆破解法.<br>z3约束器根据题目提供的或挖掘出的方程约束来列方程和解方程.值得注意的是,对于正确约束的方程,z3约束器在求解过程中只会返回一组解,但这组解不一定是正确解,此时就需要我们继续为方程组添加约束条件,从而得到精确结果.<br>解题脚本如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lfsr</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, init, mask, length)</span>:</span></span><br><span class="line">        self.init = init</span><br><span class="line">        self.mask = mask</span><br><span class="line">        self.lengthmask = <span class="number">2</span>**(length+<span class="number">1</span>)<span class="number">-1</span></span><br><span class="line">        self.length = length</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        nextdata = (self.init &lt;&lt; <span class="number">1</span>) &amp; self.lengthmask</span><br><span class="line">        i = self.init &amp; self.mask &amp; self.lengthmask</span><br><span class="line">        output = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(self.length):</span><br><span class="line">            output ^= (i &amp; <span class="number">1</span>)</span><br><span class="line">            i = i &gt;&gt; <span class="number">1</span></span><br><span class="line">        nextdata ^= output</span><br><span class="line">        self.init = nextdata</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(x1,x2,x3)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (x1*x2)^(x2*x3)^(x1*x3)</span><br><span class="line"></span><br><span class="line">init1 = BitVec(<span class="string">'init1'</span>, <span class="number">48</span>)</span><br><span class="line">init2 = BitVec(<span class="string">'init2'</span>, <span class="number">48</span>)</span><br><span class="line">init3 = BitVec(<span class="string">'init3'</span>, <span class="number">48</span>)</span><br><span class="line"></span><br><span class="line">l1 = lfsr(init1, <span class="number">0b100000000000000000000000010000000000000000000000</span>, <span class="number">48</span>)</span><br><span class="line">l2 = lfsr(init2, <span class="number">0b100000000000000000000000000000000010000000000000</span>, <span class="number">48</span>)</span><br><span class="line">l3 = lfsr(init3, <span class="number">0b100000100000000000000000000000000000000000000000</span>, <span class="number">48</span>)</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line"><span class="keyword">with</span> codecs.open(<span class="string">'keystream'</span>, <span class="string">'rb'</span>, <span class="string">'utf8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    keystream = f.read()</span><br><span class="line"></span><br><span class="line">outputs = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> keystream:</span><br><span class="line">    a = ord(i)</span><br><span class="line">    b = str(bin(a)[<span class="number">2</span>:]).zfill(<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> b:</span><br><span class="line">        outputs.append(int(j))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">200</span>):</span><br><span class="line">    s.add(outputs[i] == combine(l1.next(), l2.next(), l3.next()))</span><br><span class="line"></span><br><span class="line">s.check()</span><br><span class="line">print(s.model())</span><br></pre></td></tr></table></figure>
<p>结合脚本简单说明几点.</p>
<ul>
<li>对于z3约束器,常用数据类型有Int和BitVec两种.对于需要进行与或非和同异或等比特位之间操作的函数,我们使用BitVec数据类型进行初始化.其他的函数可以使用Int数据类型初始化.</li>
<li>建立解题Solver并添加约束,最后使用check函数和model函数输出解题结果.在添加约束方程过程中,按理来说一共有<code>len(outputs)</code>个方程,不过如果全部添加至约束器中会导致求解速度较慢,经过反复试验得出添加方程数量为200时,既可以保证解的唯一性,又可以在较短的理论实践内求解.</li>
<li>在<code>class lfsr()</code>内进行了修改,初始化过程中添加代码<code>self.length = length</code>,这是因为next()函数中使用<code>while i != 0</code>来控制循环,且<code>i = self.init&amp;self.mask&amp;self.lengthmask</code>,在z3求解过程中,init是以未知数的形式传进去的,无法当作具体数值进行判断从而停止循环.于是我们定义与init长度相等的参数,控制直接循环length次.<strong>z3待求解的未知数无法作为确定数字参与比较,这也是z3的一个特性</strong>,例如如下代码是不合法的: </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init = BitVec(&apos;init&apos;, 48)</span><br><span class="line">if init != 0:   some codes</span><br></pre></td></tr></table></figure>
<p>在编写脚本过程中出现了一个非常有意思的编码问题.加密程序的最后部分代码段显示,程序执行了8192次循环,每次循环写入1字节,但最后keystream文件并不是8192字节,而是11990字节.这就涉及到编码问题.加密过程中并不是使用<code>f.write(chr(b))</code>来进行文件写入,而是使用了<code>f.write(chr(b)).encode()</code>,这就造成了长度的实际值与理论值不同.    </p>
<p>在python2下,当使用<code>chr().encode()</code>操作大于127的数字时,程序会报错;而在python3中,程序会选择使用2个字节进行表示而不是报错.当数字小于等于127时,python2和python3下都可以正常的使用1个字节表示.该编码过程采用如下规则:   </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在区间[128, 192)内,数字的表示形式会加上xc2前缀:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">130</span>).encode()</span><br><span class="line"><span class="string">b'\xc2\x80'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在区间[192, 255)内,数字的表示形式会加上xc3前缀,同时数字本身减去64:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">200</span>).encode()</span><br><span class="line"><span class="string">b'\xc3\x88'</span></span><br></pre></td></tr></table></figure>
<p>了解编码规则之后我们可以进行还原.  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3 环境</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'keystream'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read().decode()</span><br><span class="line"><span class="comment"># then len(data) = 8192</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python2 环境</span></span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">with</span> codecs.open(<span class="string">'keystream'</span>, <span class="string">'rb'</span>, <span class="string">'utf8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line"><span class="comment"># then len(data) = 8192</span></span><br></pre></td></tr></table></figure>
<h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>LFSR这一组件有三个关键点:<code>初始状态</code>,<code>反馈函数</code>和<code>输出序列</code>.因此题目的设置也围绕这三个关键点进行.已知mask的情况相当于明确反馈函数,这种情况的题目一般会在输出序列上做文章:简单的题目会直接给出单个LFSR的输出序列,复杂一些的则对多个LFSR的输出序列进行函数操作并最终给出输出结果.</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/LFSR/" rel="tag"><i class="fa fa-tag"></i> LFSR</a>
          
            <a href="/tags/Fast-Correlation-Attack/" rel="tag"><i class="fa fa-tag"></i> Fast Correlation Attack</a>
          
            <a href="/tags/z3-solver/" rel="tag"><i class="fa fa-tag"></i> z3-solver</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/10/30/两道CTF-RSA类题目总结/" rel="next" title="两道CTF-RSA类题目总结">
                <i class="fa fa-chevron-left"></i> 两道CTF-RSA类题目总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/11/13/Cryptopals解题报告(一)/" rel="prev" title="Cryptopals解题报告(一)">
                Cryptopals解题报告(一) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript">
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/picture.png" alt="B1ank">
            
              <p class="site-author-name" itemprop="name">B1ank</p>
              <p class="site-description motion-element" itemprop="description">U can be what you wanna B</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">48</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">47</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/blank-vax" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:18682924517@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://lzwgiter.github.io" title="flo@t" target="_blank">flo@t</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://alicerabbit.github.io" title="Compass" target="_blank">Compass</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://k1ng0fic3.github.io" title="k1ng0fic3" target="_blank">k1ng0fic3</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://59lx.github.io" title="rt95" target="_blank">rt95</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x00-LFSR概述"><span class="nav-number">1.</span> <span class="nav-text">0x00 LFSR概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x01-LFSR原理"><span class="nav-number">2.</span> <span class="nav-text">0x01 LFSR原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x03-LFSR在CTF中的应用"><span class="nav-number">3.</span> <span class="nav-text">0x03 LFSR在CTF中的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础类型"><span class="nav-number">3.1.</span> <span class="nav-text">基础类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#爆破解法"><span class="nav-number">3.1.1.</span> <span class="nav-text">爆破解法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分析解法"><span class="nav-number">3.1.2.</span> <span class="nav-text">分析解法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类似题目"><span class="nav-number">3.1.3.</span> <span class="nav-text">类似题目</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分组码基底相关解法"><span class="nav-number">3.2.</span> <span class="nav-text">分组码基底相关解法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分组码"><span class="nav-number">3.2.1.</span> <span class="nav-text">分组码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Fast-Correlation-Attacks"><span class="nav-number">3.2.2.</span> <span class="nav-text">Fast Correlation Attacks</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x04-总结"><span class="nav-number">4.</span> <span class="nav-text">0x04 总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">B1ank</span>

  
</div>


 <div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  访客数量:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

 <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共153.5k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
   <!-- ҳ����С���� -->
  <script type="text/javascript" src="/js/src/love.js"></script>

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: '9OdpjYSHQirwAMeIVy8C5SBk-gzGzoHsz',
        appKey: 'WoxonMaRanAKt1yVo9JgIS7n',
        placeholder: 'Let's Chat',
        avatar:'/uploads/picture.png',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("YPjXkPpqx6UDV4Qi9FeAtmb7-gzGzoHsz", "ftBBWgvQkPRDCOJfwV7zzsfr");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
