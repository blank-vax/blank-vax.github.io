<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>B1ank</title>
  
  
  <link href="/blank-vax.github.io/atom.xml" rel="self"/>
  
  <link href="https://blank-vax.github.io/"/>
  <updated>2020-11-22T03:36:52.176Z</updated>
  <id>https://blank-vax.github.io/</id>
  
  <author>
    <name>B1ank</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Euler-Project(V)</title>
    <link href="https://blank-vax.github.io/2020/11/22/Euler-Project(V)/"/>
    <id>https://blank-vax.github.io/2020/11/22/Euler-Project(V)/</id>
    <published>2020-11-22T03:36:00.000Z</published>
    <updated>2020-11-22T03:36:52.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="41-Pandigital-prime"><a href="#41-Pandigital-prime" class="headerlink" title="41. Pandigital prime"></a>41. Pandigital prime</h2><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>We shall say that an <em>n</em>-digit number is pandigital if it makes use of all the digits 1 to <em>n</em> exactly once. For example, 2143 is a 4-digit pandigital and is also prime.</p><p>What is the largest <em>n</em>-digit pandigital prime that exists?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># What is the largest n-digit pandigital prime that exists?</span></span><br><span class="line"><span class="comment"># The maximum pandigital prime may be located in range 123456789 to 987654321</span></span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllPermutations</span><span class="params">(n)</span>:</span></span><br><span class="line">    original_list = list(permutations(range(<span class="number">1</span>, n+<span class="number">1</span>)))</span><br><span class="line">    final_list = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> original_list:</span><br><span class="line">        tmp_result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> tuple_object <span class="keyword">in</span> item:</span><br><span class="line">            tmp_result += str(tuple_object)</span><br><span class="line">        final_list.append(tmp_result)</span><br><span class="line">    <span class="keyword">return</span> final_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPrime</span><span class="params">(combinations_result)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> reversed(combinations_result):</span><br><span class="line">        <span class="keyword">if</span> sympy.isprime(int(item)):</span><br><span class="line">            <span class="keyword">return</span> int(item)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    max_result = <span class="number">0</span></span><br><span class="line">    <span class="comment"># After some computation, we can find the aiming number is located in 7654321 to 1234567, which is a 7-digit pandigital prime</span></span><br><span class="line">    combinations_result = getAllPermutations(<span class="number">7</span>)</span><br><span class="line">    final_result = findPrime(combinations_result)</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h2 id="42-Coded-triangle-numbers"><a href="#42-Coded-triangle-numbers" class="headerlink" title="42. Coded triangle numbers"></a>42. Coded triangle numbers</h2><h3 id="Problem-Description-1"><a href="#Problem-Description-1" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The $n^{th}$ term of the sequence of triangle numbers is given by, $t_{n} = ½<em>n</em>(n+1)$; so the first ten triangle numbers are:</p><p>1, 3, 6, 10, 15, 21, 28, 36, 45, 55, …</p><p>By converting each letter in a word to a number corresponding to its alphabetical position and adding these values we form a word value. For example, the word value for SKY is $ 19 + 11 + 25 = 55 = t_{10} $. If the word value is a triangle number then we shall call the word a triangle word.</p><p>Using <a href="https://projecteuler.net/project/resources/p042_words.txt" target="_blank" rel="noopener">words.txt</a> (right click and ‘Save Link/Target As…’), a 16K text file containing nearly two-thousand common English words, how many are triangle words?</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How many are triangle words?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateTriangleNumbers</span><span class="params">(upper_bound)</span>:</span></span><br><span class="line">    triangle_number_set = [<span class="number">1</span>]</span><br><span class="line">    generator_element = <span class="number">1</span></span><br><span class="line">    generatedNumber = triangle_number_set[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> generatedNumber &lt; upper_bound:</span><br><span class="line">        generatedNumber = generator_element * (generator_element+<span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        triangle_number_set.append(generatedNumber)</span><br><span class="line">        generator_element += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> triangle_number_set</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countWordValue</span><span class="params">(word_string)</span>:</span></span><br><span class="line">    count_result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> word_string:</span><br><span class="line">        count_result += ord(item) - <span class="number">64</span></span><br><span class="line">    <span class="keyword">return</span> count_result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    triangle_word_count = <span class="number">0</span></span><br><span class="line">    triangle_number_set = generateTriangleNumbers(<span class="number">520</span>)</span><br><span class="line">    file_pointer = p042_word_path</span><br><span class="line">    word_list = file_pointer.read().replace(<span class="string">"\""</span>, <span class="string">""</span>).split(<span class="string">","</span>)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> word_list:</span><br><span class="line">        <span class="keyword">if</span> countWordValue(word) <span class="keyword">in</span> triangle_number_set:</span><br><span class="line">            triangle_word_count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> triangle_word_count</span><br></pre></td></tr></table></figure><h2 id="43-Sub-string-divisibility"><a href="#43-Sub-string-divisibility" class="headerlink" title="43. Sub-string divisibility"></a>43. Sub-string divisibility</h2><h3 id="Problem-Description-2"><a href="#Problem-Description-2" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The number, 1406357289, is a 0 to 9 pandigital number because it is made up of each of the digits 0 to 9 in some order, but it also has a rather interesting sub-string divisibility property.</p><p>Let $ d<em>{1} $ be the $ 1^{st} $ digit,$ d</em>{2} $ be the $ 2^{nd} $ digit, and so on. In this way, we note the following:</p><ul><li>$ d<em>{2}*d</em>{3}*d_{4} = 406 $ is divisible by 2</li><li>$ d<em>{3}*d</em>{4}*d_{5} = 063 $ is divisible by 3</li><li>$ d<em>{4}*d</em>{5}*d_{6}=635 $ is divisible by 5</li><li>$ d<em>{5}*d</em>{6}*d_{7}=357 $ is divisible by 7</li><li>$ d<em>{6}*d</em>{7}*d_{8}=572 $ is divisible by 11</li><li>$ d<em>{7}*d</em>{8}*d_{9} = 728 $ is divisible by 13</li><li>$ d<em>{8}*d</em>{9}*d_{10} = 289 $ is divisible by 17</li></ul><p>Find the sum of all 0 to 9 pandigital numbers with this property.</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>题解引入<code>sympy.nextprime(n)</code>函数以持续不断地获取素数，从而用于性质判断。该函数返回大于参数n的第一个素数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of all 0 to 9 pandigital numbers with this property</span></span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasProperty</span><span class="params">(input_string)</span>:</span></span><br><span class="line">    generated_prime = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> index_number <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">8</span>):</span><br><span class="line">        generated_prime = sympy.nextprime(generated_prime)</span><br><span class="line">        <span class="keyword">if</span> int(input_string[index_number: index_number+<span class="number">3</span>]) % generated_prime != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllPermutations</span><span class="params">(n)</span>:</span></span><br><span class="line">    original_list = list(permutations(range(n)))</span><br><span class="line">    final_list = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> original_list:</span><br><span class="line">        tmp_result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> tuple_object <span class="keyword">in</span> item:</span><br><span class="line">            tmp_result += str(tuple_object)</span><br><span class="line">        final_list.append(tmp_result)</span><br><span class="line">    <span class="keyword">return</span> final_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sum_result = <span class="number">0</span></span><br><span class="line">    combination_result = getAllPermutations(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> combination_result:</span><br><span class="line">        <span class="keyword">if</span> hasProperty(item):</span><br><span class="line">            sum_result += int(item)</span><br><span class="line">    <span class="keyword">print</span> sum_result</span><br></pre></td></tr></table></figure><h2 id="44-Pentagon-numbers"><a href="#44-Pentagon-numbers" class="headerlink" title="44. Pentagon numbers"></a>44. Pentagon numbers</h2><h3 id="Problem-Description-3"><a href="#Problem-Description-3" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Pentagonal numbers are generated by the formula,$ P_{n} = n(3n−1)/2 $. The first ten pentagonal numbers are:</p><p>1, 5, 12, 22, 35, 51, 70, 92, 117, 145, …</p><p>It can be seen that $ P<em>{4} + P</em>{7} = 22 + 70 = 92 = P_{8} $. However, their difference, 70 − 22 = 48, is not pentagonal.</p><p>Find the pair of pentagonal numbers, $ P<em>{j} $ and$ P</em>{k} $, for which their sum and difference are pentagonal and $ D = |P<em>{k} − P</em>{j}| $ is minimised; what is the value of D?</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>题解引入operator函数库，运用其中的底层函数提高运算效率，该库内函数说明如下：</p><p>operator库函数说明：<a href="https://docs.python.org/zh-cn/3/library/operator.html。" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/operator.html。</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the pair of pentagonal numbers, Pj and Pk</span></span><br><span class="line"><span class="comment"># The sum of these two number and the difference of these are both pentagonal</span></span><br><span class="line"><span class="comment"># Output the minimum D = |Pk - Pj|</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPentagonalNumbers</span><span class="params">(upper_bound)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> set(n*(<span class="number">3</span>*n<span class="number">-1</span>)//<span class="number">2</span> <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>, upper_bound+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    result_list = []</span><br><span class="line">    pentagonal_number_set = getPentagonalNumbers(<span class="number">3000</span>)</span><br><span class="line">    combination_result = combinations(pentagonal_number_set, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> combination_result:</span><br><span class="line">        <span class="keyword">if</span> add(item[<span class="number">0</span>], item[<span class="number">1</span>]) <span class="keyword">in</span> pentagonal_number_set <span class="keyword">and</span> abs(sub(item[<span class="number">0</span>], item[<span class="number">1</span>])) <span class="keyword">in</span> pentagonal_number_set:</span><br><span class="line">            result_list.append(abs(item[<span class="number">0</span>]-item[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">print</span> min(result_list)</span><br></pre></td></tr></table></figure><h2 id="45-Triangular-pentagonal-and-hexagonal"><a href="#45-Triangular-pentagonal-and-hexagonal" class="headerlink" title="45. Triangular, pentagonal, and hexagonal"></a>45. Triangular, pentagonal, and hexagonal</h2><h3 id="Problem-Description-4"><a href="#Problem-Description-4" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:</p><div class="table-container"><table><thead><tr><th>NumberType</th><th>Formulae</th><th>Example</th></tr></thead><tbody><tr><td>Triangle</td><td>$ T_{n} = n*(n+1) / 2 $</td><td>1, 3, 6, 10, 15, …</td></tr><tr><td>Pentagonal</td><td>$ P_{n} = n<em>(3</em>n-1) / 2 $</td><td>1, 5, 12, 22, 35, …</td></tr><tr><td>Hexagonal</td><td>$ H_{n} = n<em>(2</em>n-1) $</td><td>1, 6, 15, 28, 45</td></tr></tbody></table></div><p>It can be verified that $ T<em>{285} = P</em>{165} = H_{143} = 40755 $.</p><p>Find the next triangle number that is also pentagonal and hexagonal.</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><p>根据题意，以1—60000为生成元构造三角形数、五边形数和六边形数对应的集合，随后求交集并输出大于40755的第一个数字即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the next triangle number bigger than 40755 that is also pentagonal and hexagonal</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTriangleNumber</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> set(generator*(generator+<span class="number">1</span>)//<span class="number">2</span> <span class="keyword">for</span> generator <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPentagonalNumber</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(generator*(<span class="number">3</span>*generator<span class="number">-1</span>)//<span class="number">2</span> <span class="keyword">for</span> generator <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHexagonalNumber</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(generator*(<span class="number">2</span>*generator<span class="number">-1</span>) <span class="keyword">for</span> generator <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    triangle_set = getTriangleNumber(<span class="number">60000</span>)</span><br><span class="line">    pentagonal_set = getPentagonalNumber(<span class="number">60000</span>)</span><br><span class="line">    hexagonal_set = getHexagonalNumber(<span class="number">60000</span>)</span><br><span class="line">    result = set(triangle_set) &amp; set(pentagonal_set) &amp; set(hexagonal_set)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> result:</span><br><span class="line">        <span class="keyword">if</span> item &gt; <span class="number">40755</span>:</span><br><span class="line">            <span class="keyword">print</span> item</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h3><p>通过观察这三类数字的生成表达式可以获得三角形数、五边形数和六边形数的判断方法：</p><ul><li>若数字x是一个三角形数，则$ (\sqrt{(8*x+1)}-1) / 2 $必为一个整数；</li><li>若数字x是一个五边形数，则$ (\sqrt{(24*x+1)}+1) / 6 $必为一个整数；</li><li>若数字x是一个六边形数，则$ (\sqrt{(8*x+1)}+1) / 4 $必为一个整数 </li></ul><p>同时，这三类数的生成过程满足性质：$ H(n) = T(2n-1) $，即生成元n得到的六边形数一定对应更大生成元得到的三角形数。于是可以从第144个六边形数开始逐个验证其是否可表示为五边形数即可。暴力代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the next triangle number bigger than 40755 that is also pentagonal and hexagonal</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPentagonalNumber</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    integer_n = (math.sqrt(<span class="number">24</span>*input_number+<span class="number">1</span>)+<span class="number">1</span>) / <span class="number">6</span></span><br><span class="line">    <span class="keyword">if</span> integer_n % <span class="number">1</span> &gt; <span class="number">0</span> <span class="keyword">and</span> integer_n % <span class="number">1</span> &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHexagonalNumber</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n*(<span class="number">2</span>*n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    origin_generator = <span class="number">144</span></span><br><span class="line">    hexagonal_number = getHexagonalNumber(origin_generator)</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">print</span> origin_generator</span><br><span class="line">        <span class="keyword">if</span> isPentagonalNumber(hexagonal_number):</span><br><span class="line">            <span class="keyword">print</span> hexagonal_number</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        origin_generator += <span class="number">1</span></span><br><span class="line">        hexagonal_number = getHexagonalNumber(origin_generator)</span><br></pre></td></tr></table></figure><h2 id="46-Goldbach’s-other-conjecture"><a href="#46-Goldbach’s-other-conjecture" class="headerlink" title="46. Goldbach’s other conjecture"></a>46. Goldbach’s other conjecture</h2><h3 id="Problem-Description-5"><a href="#Problem-Description-5" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>It was proposed by Christian Goldbach that every odd composite number can be written as the sum of a prime and twice a square.</p><script type="math/tex; mode=display">9 = 7 + 2×1^{2}</script><script type="math/tex; mode=display">15 = 7 + 2×2^{2}</script><script type="math/tex; mode=display">21 = 3 + 2×3^{2}</script><script type="math/tex; mode=display">25 = 7 + 2×3^{2}</script><script type="math/tex; mode=display">27 = 19 + 2×2^{2}</script><script type="math/tex; mode=display">33 = 31 + 2×1^{2}</script><p>It turns out that the conjecture was false.</p><p>What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?</span></span><br><span class="line"><span class="comment"># odd_composite = odd_prime + 2 * square_number</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPrimes</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sorted(list(sympy.primerange(<span class="number">3</span>, n+<span class="number">1</span>)))</span><br><span class="line"><span class="comment"># Get the odd composites</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getOddComposite</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sorted(list(set(list(i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n+<span class="number">1</span>, <span class="number">2</span>))) - set(getPrimes(n))))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSquare</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    possible_square = math.sqrt(input_number / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> possible_square % <span class="number">1</span> &gt; <span class="number">0</span> <span class="keyword">and</span> possible_square % <span class="number">1</span> &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    odd_composite = getOddComposite(<span class="number">6000</span>)</span><br><span class="line">    prime_set = getPrimes(<span class="number">6000</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> odd_composite:</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> prime <span class="keyword">in</span> prime_set:</span><br><span class="line">            <span class="keyword">if</span> prime &gt;= item:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> isSquare(item - prime):</span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">print</span> item</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="47-Distinct-primes-factors"><a href="#47-Distinct-primes-factors" class="headerlink" title="47. Distinct primes factors"></a>47. Distinct primes factors</h2><h3 id="Problem-Description-6"><a href="#Problem-Description-6" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The first two consecutive numbers to have two distinct prime factors are:</p><script type="math/tex; mode=display">14 = 2 × 7</script><script type="math/tex; mode=display">15 = 3 × 5</script><p>The first three consecutive numbers to have three distinct prime factors are:</p><script type="math/tex; mode=display">644 = 2^{2} × 7 × 23</script><script type="math/tex; mode=display">645 = 3 × 5 × 43</script><script type="math/tex; mode=display">646 = 2 × 17 × 19</script><p>Find the first four consecutive integers to have four distinct prime factors each. What is the first of these numbers?</p><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the first four consecutive integers to have four distinct prime factors each.</span></span><br><span class="line"><span class="comment"># What is the first of these numbers?</span></span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPrimeFactorSet</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> set(sympy.primerange(a, b+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countPrimeFactors</span><span class="params">(n, factor_set, prime_set)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> prime_set:</span><br><span class="line">        <span class="keyword">if</span> n % item == <span class="number">0</span>:</span><br><span class="line">            factor_set.add(item)</span><br><span class="line">            <span class="keyword">return</span> countPrimeFactors(n/item, factor_set, prime_set)</span><br><span class="line">    <span class="keyword">return</span> factor_set</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    prime_set = getPrimeFactorSet(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">for</span> item_object <span class="keyword">in</span> range(<span class="number">100000</span>, <span class="number">150000</span>):</span><br><span class="line">        <span class="keyword">if</span> len(countPrimeFactors(item_object, set(), prime_set)) == <span class="number">4</span> <span class="keyword">and</span> len(countPrimeFactors(item_object+<span class="number">1</span>, set(), prime_set)) == <span class="number">4</span> <span class="keyword">and</span> len(countPrimeFactors(item_object+<span class="number">2</span>, set(), prime_set)) == <span class="number">4</span> <span class="keyword">and</span> len(countPrimeFactors(item_object+<span class="number">3</span>, set(), prime_set)) == <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">print</span> item_object</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="comment"># Program running time: The function run time is : 0.384 seconds.</span></span><br></pre></td></tr></table></figure><h2 id="48-Self-powers"><a href="#48-Self-powers" class="headerlink" title="48. Self powers"></a>48. Self powers</h2><h3 id="Problem-Description-7"><a href="#Problem-Description-7" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The series, $ 1^{1} + 2^{2} + 3^{3} + … + 10^{10} = 10405071317 $.</p><p>Find the last ten digits of the series, $ 1^{1} + 2^{2} + 3^{3} + … + 1000^{1000} $.</p><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the last ten digits of the series, sum(pow(n, n) for n in range(1, 1000))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    result_digits = str(sum(list(pow(i, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">1000</span>))))[<span class="number">-10</span>:]</span><br><span class="line">    <span class="keyword">print</span> result_digits</span><br></pre></td></tr></table></figure><h2 id="49-Prime-permutations"><a href="#49-Prime-permutations" class="headerlink" title="49. Prime permutations"></a>49. Prime permutations</h2><h3 id="Problem-Description-8"><a href="#Problem-Description-8" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The arithmetic sequence, 1487, 4817, 8147, in which each of the terms increases by 3330, is unusual in two ways: (i) each of the three terms are prime, and, (ii) each of the 4-digit numbers are permutations of one another.</p><p>There are no arithmetic sequences made up of three 1-, 2-, or 3-digit primes, exhibiting this property, but there is one other 4-digit increasing sequence.</p><p>What 12-digit number do you form by concatenating the three terms in this sequence?</p><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># What 12-digit number do you form by concatenating the three terms in this sequence?</span></span><br><span class="line"><span class="comment"># Brute force in Python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPrimeSet</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(sympy.primerange(a, b+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPermutations</span><span class="params">(input_list)</span>:</span></span><br><span class="line">    result_list = []</span><br><span class="line">    permutation_list = list(permutations(input_list, <span class="number">4</span>))</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> permutation_list:</span><br><span class="line">        result_list.append(item[<span class="number">0</span>]*<span class="number">1000</span>+item[<span class="number">1</span>]*<span class="number">100</span>+item[<span class="number">2</span>]*<span class="number">10</span>+item[<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">return</span> set(permutations(result_list, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrimePermutations</span><span class="params">(input_item, prime_set)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> input_item[<span class="number">0</span>] == input_item[<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> input_item[<span class="number">2</span>] + input_item[<span class="number">0</span>] != <span class="number">2</span>*input_item[<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> input_item[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> prime_set <span class="keyword">or</span> input_item[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> prime_set <span class="keyword">or</span> input_item[<span class="number">2</span>] <span class="keyword">not</span> <span class="keyword">in</span> prime_set:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getEachDigitList</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    result_list = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> str(input_number):</span><br><span class="line">        result_list.append(eval(item))</span><br><span class="line">    <span class="keyword">return</span> result_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    prime_set = getPrimeSet(<span class="number">1000</span>, <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">for</span> possible_number <span class="keyword">in</span> prime_set:</span><br><span class="line">        possible_number_list = getEachDigitList(possible_number)</span><br><span class="line">        final_result_list = getPermutations(possible_number_list)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> final_result_list:</span><br><span class="line">            item = sorted(item)</span><br><span class="line">            <span class="keyword">if</span> isPrimePermutations(item, prime_set):</span><br><span class="line">                <span class="keyword">print</span> str(item[<span class="number">0</span>]) + str(item[<span class="number">1</span>]) + str(item[<span class="number">2</span>])</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="50-Consecutive-prime-sum"><a href="#50-Consecutive-prime-sum" class="headerlink" title="50. Consecutive prime sum"></a>50. Consecutive prime sum</h2><h3 id="Problem-Description-9"><a href="#Problem-Description-9" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The prime 41, can be written as the sum of six consecutive primes:</p><p>41 = 2 + 3 + 5 + 7 + 11 + 13</p><p>This is the longest sum of consecutive primes that adds to a prime below one-hundred.</p><p>The longest sum of consecutive primes below one-thousand that adds to a prime, contains 21 terms, and is equal to 953.</p><p>Which prime, below one-million, can be written as the sum of the most consecutive primes?</p><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Which prime, below one-million, can be written as the sum of the most consecutive primes?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPrimeSet</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(sympy.primerange(a, b+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllSumResult</span><span class="params">(upper_bound, prime_set)</span>:</span></span><br><span class="line">    result_list = []</span><br><span class="line">    <span class="keyword">for</span> index_number <span class="keyword">in</span> range(len(prime_set)):</span><br><span class="line">        sum_result = sum(prime_set[:index_number])</span><br><span class="line">        <span class="keyword">if</span> sum_result &lt; upper_bound:</span><br><span class="line">            result_list.append(sum_result)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> result_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">originalSumResultJudge</span><span class="params">(stored_dict, prime_set, sum_result)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index_number <span class="keyword">in</span> range(len(sum_result)<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> sum_result[index_number] <span class="keyword">in</span> prime_set:</span><br><span class="line">            stored_dict[index_number] = sum_result[index_number]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> stored_dict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getConsecutivePrimeRange</span><span class="params">(prime_set, sum_result)</span>:</span></span><br><span class="line">    stored_dict = &#123;&#125;</span><br><span class="line">    first_processed_dict = originalSumResultJudge(stored_dict, prime_set, sum_result)</span><br><span class="line">    <span class="keyword">for</span> index_number1 <span class="keyword">in</span> range(len(sum_result)<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> index_number2 <span class="keyword">in</span> range(len(sum_result)):</span><br><span class="line">            <span class="keyword">if</span> sum_result[index_number1] - sum_result[index_number2] <span class="keyword">in</span> prime_set:</span><br><span class="line">                first_processed_dict[index_number1-index_number2] = sum_result[index_number1] - sum_result[index_number2]</span><br><span class="line">                <span class="keyword">return</span> first_processed_dict</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    prime_set = getPrimeSet(<span class="number">2</span>, <span class="number">1000000</span>)</span><br><span class="line">    result_list = getAllSumResult(<span class="number">1000000</span>, prime_set)</span><br><span class="line">    final_result = getConsecutivePrimeRange(prime_set, result_list)</span><br><span class="line">    sorted_dict = sorted(final_result.iteritems(), key=<span class="keyword">lambda</span> d: d[<span class="number">0</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">print</span> sorted_dict[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;41-Pandigital-prime&quot;&gt;&lt;a href=&quot;#41-Pandigital-prime&quot; class=&quot;headerlink&quot; title=&quot;41. Pandigital prime&quot;&gt;&lt;/a&gt;41. Pandigital prime&lt;/h2&gt;&lt;h3
      
    
    </summary>
    
      <category term="Mathematics" scheme="https://blank-vax.github.io/categories/Mathematics/"/>
    
    
      <category term="Euler-Project" scheme="https://blank-vax.github.io/tags/Euler-Project/"/>
    
  </entry>
  
  <entry>
    <title>Euler-Project(IV)</title>
    <link href="https://blank-vax.github.io/2020/11/17/Euler-Project(IV)/"/>
    <id>https://blank-vax.github.io/2020/11/17/Euler-Project(IV)/</id>
    <published>2020-11-17T06:40:00.000Z</published>
    <updated>2020-11-17T06:41:36.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="31-Coin-sums"><a href="#31-Coin-sums" class="headerlink" title="31. Coin sums"></a>31. Coin sums</h2><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>In the United Kingdom the currency is made up of pound (£) and pence (p). There are eight coins in general circulation:</p><blockquote><p>1p, 2p, 5p, 10p, 20p, 50p, £1 (100p), and £2 (200p).</p></blockquote><p>It is possible to make £2 in the following way:</p><blockquote><p>1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p</p></blockquote><p>How many different ways can £2 be made using any number of coins?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>题目本质为经典的找零问题，可以通过动态规划的方法解决。</p><p>以本题给出的条件为例进行详细说明。题目给出1，2，5，10，20，50，100，200这八种面额的便士类型，要求通过组合获得200便士并求出所有组合的数量。首先将问题进行分解，结果为200便士的组合可分为以下三种：</p><ul><li>不引入100便士而是使用其他便士进行组合（单体最多为200便士）</li><li>引入一个100便士，剩余的100便士由其他便士组合（单体最多为100便士）</li><li>引入两个100便士完成组合</li></ul><p>故可得以下递推公式：</p><p><img src="http://static.zybuluo.com/B1ank/o08d2mk6j3miaccmrhmz6a91/31_problem1.PNG" alt="31_problem1.PNG-20.5kB"></p><p>各字符含义如下：</p><ul><li>t表示目标量；</li><li>c表示最大可用的硬币面值；</li><li>s(c)表示除c外更小的硬币面值；</li><li>w(t, c)表示使用面值为c或更小的硬币组成目标量的所有方法数。</li></ul><p>根据以上递推公式采用动态规划的方法，将大问题分割成多个小问题并进行分类讨论处理，该方法为第一类动态规划，遵循自顶向下的问题划分原则。同时引入二维数组记录不同(t, c)组对应的方法数，以提高程序运行效率。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How many different ways can 2 pound be made using any number of coins?</span></span><br><span class="line"><span class="comment"># 2 pound equals to 200p</span></span><br><span class="line"><span class="comment"># There are eight coins in general circulation: 1p, 2p, 5p, 10p, 20p, 50p, 100p, 200p</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countWays</span><span class="params">(target, avc)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> avc &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    t = target</span><br><span class="line">    <span class="keyword">if</span> memoset[t<span class="number">-1</span>][avc<span class="number">-1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> memoset[t<span class="number">-1</span>][avc<span class="number">-1</span>]</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> target &gt;= <span class="number">0</span>:</span><br><span class="line">        result += countWays(target, avc<span class="number">-1</span>)</span><br><span class="line">        target = target - coins[avc<span class="number">-1</span>]</span><br><span class="line">    memoset[t<span class="number">-1</span>][avc<span class="number">-1</span>] = result</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span>]</span><br><span class="line">    amount_result = <span class="number">200</span></span><br><span class="line">    memoset = [[<span class="number">0</span> <span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">9</span>)] <span class="keyword">for</span> row <span class="keyword">in</span> range(amount_result+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">print</span> countWays(amount_result, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>以上算法还可以进一步优化。首先我们观察(t, c)取值不同时w(t, c)的运算结果，对应如下表：</p><p><img src="http://static.zybuluo.com/B1ank/ne7b2aqnoo1bes7oqb9ew74h/31_solution1.PNG" alt="31_solution1.PNG-44.5kB"></p><p>根据以上对应关系归纳递推公式如下：</p><p><img src="http://static.zybuluo.com/B1ank/ojji9qwuox0evoe8zoqjwlvy/31_formula.PNG" alt="31_formula.PNG-25.2kB"></p><p>经过深入分析，我们可以得出w’(t, c)函数不同参数对应结果之间的关系图如下所示：</p><p><img src="http://static.zybuluo.com/B1ank/924ba04azv6jzg2aty4b4pgd/31_solution2.PNG" alt="31_solution2.PNG-44kB"></p><p>可以看出第一行和第一列的数值1达到最终目的地需要较长的加和路径。除此之外其他所有元素都可由最多另外两个元素相加得到。从而每个w’(t, c)的值最多决定于另外两个数值，即：</p><ul><li>同列c的前一个元素；</li><li>同行t，前一列c-1对应的元素；</li></ul><p>该方法为第二种动态规划方法，遵循自底向上的问题划分原则，从较小的问题开始解决，逐步解决更大的子问题。此类方法在处理以下问题时具有更高的效率：</p><ul><li>每个元素可以通过至多两个其他元素相加获得；</li><li>要求较低的时间复杂度及空间复杂度；</li><li>使用循环而非函数调用解决问题；</li></ul><p>结合以上分析，对应代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How many different ways can 2 pound be made using any number of coins?</span></span><br><span class="line"><span class="comment"># 2 pound equals to 200p</span></span><br><span class="line"><span class="comment"># There are eight coins in general circulation: 1p, 2p, 5p, 10p, 20p, 50p, 100p, 200p</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countWays</span><span class="params">(upper_bound, coins, aim_amount, final_ways)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(upper_bound):</span><br><span class="line">        j = coins[i]</span><br><span class="line">        <span class="keyword">print</span> final_ways</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(j, aim_amount+<span class="number">1</span>):</span><br><span class="line">            final_ways[k] += final_ways[k-j]</span><br><span class="line">    <span class="keyword">return</span> final_ways</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span>]</span><br><span class="line">    amount_result = <span class="number">200</span></span><br><span class="line">    answer = [<span class="number">1</span>] + [<span class="number">0</span>]*amount_result</span><br><span class="line">    final_result = countWays(<span class="number">8</span>, coins, amount_result, answer)</span><br><span class="line">    <span class="keyword">print</span> final_result[amount_result]</span><br></pre></td></tr></table></figure><h3 id="找零问题参考资料"><a href="#找零问题参考资料" class="headerlink" title="找零问题参考资料"></a>找零问题参考资料</h3><p>Euler-Project-Problem31-Overview：<a href="https://projecteuler.net/overview=031" target="_blank" rel="noopener">https://projecteuler.net/overview=031</a></p><p>动态规划2：<a href="https://www.jianshu.com/p/e515efee2310" target="_blank" rel="noopener">https://www.jianshu.com/p/e515efee2310</a></p><p>硬币找零问题：<a href="https://www.cnblogs.com/anzhengyu/p/11176134.html" target="_blank" rel="noopener">https://www.cnblogs.com/anzhengyu/p/11176134.html</a></p><h2 id="32-Pandigital-products"><a href="#32-Pandigital-products" class="headerlink" title="32. Pandigital products"></a>32. Pandigital products</h2><h3 id="Problem-Description-1"><a href="#Problem-Description-1" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once; for example, the 5-digit number, 15234, is 1 through 5 pandigital.</p><p>The product 7254 is unusual, as the identity, 39 × 186 = 7254, containing multiplicand, multiplier, and product is 1 through 9 pandigital.</p><p>Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.</p><p>HINT: Some products can be obtained in more than one way so be sure to only include it once in your sum.</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.</span></span><br><span class="line"><span class="comment"># Example: 39 x 186 = 7254,</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPandigital</span><span class="params">(result_string)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(result_string) == <span class="number">9</span> <span class="keyword">and</span> <span class="string">"123456789"</span>.strip(result_string) == <span class="string">""</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    result_set = set()</span><br><span class="line">    <span class="keyword">for</span> multiplicand <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">        <span class="keyword">for</span> multiplier <span class="keyword">in</span> range(<span class="number">123</span>, <span class="number">9880</span>):</span><br><span class="line">            <span class="keyword">if</span> isPandigital(str(multiplicand)+str(multiplier)+str(multiplicand*multiplier)):</span><br><span class="line">                result_set.add(multiplicand*multiplier)</span><br><span class="line">    <span class="keyword">print</span> sum(result_set)</span><br></pre></td></tr></table></figure><h2 id="33-Digit-cancelling-fractions"><a href="#33-Digit-cancelling-fractions" class="headerlink" title="33. Digit cancelling fractions"></a>33. Digit cancelling fractions</h2><h3 id="Problem-Description-2"><a href="#Problem-Description-2" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The fraction 49/98 is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe that 49/98 = 4/8, which is correct, is obtained by cancelling the 9s.</p><p>We shall consider fractions like, 30/50 = 3/5, to be trivial examples.</p><p>There are exactly four non-trivial examples of this type of fraction, less than one in value, and containing two digits in the numerator and denominator.</p><p>If the product of these four fractions is given in its lowest common terms, find the value of the denominator.</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If the product of these four fractions is given in its lowest common terms, find the value of the denominator.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The mean of sign '/' equals to '//' in Python2, so if we wanna get the deimal, we could import such sentence:</span></span><br><span class="line"><span class="comment"># from __future__ import division</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isCuriousFraction</span><span class="params">(numerator, denominator)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> numerator%<span class="number">10</span> == denominator//<span class="number">10</span> <span class="keyword">and</span> (numerator//<span class="number">10</span>)/(denominator%<span class="number">10</span>) == numerator/denominator:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reductionFraction</span><span class="params">(numerator, denominator)</span>:</span></span><br><span class="line">    certain_range = denominator</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">2</span>, certain_range):</span><br><span class="line">        <span class="keyword">if</span> numerator == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> numerator % item == <span class="number">0</span> <span class="keyword">and</span> denominator % item == <span class="number">0</span>:</span><br><span class="line">            numerator /= item</span><br><span class="line">            denominator /= item</span><br><span class="line">    <span class="keyword">return</span> denominator</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    final_numerator = <span class="number">1</span></span><br><span class="line">    final_denominator = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> numerator <span class="keyword">in</span> range(<span class="number">10</span>, <span class="number">100</span>):</span><br><span class="line">        <span class="keyword">if</span> numerator % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> denominator <span class="keyword">in</span> range(numerator+<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">            <span class="keyword">if</span> denominator % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> isCuriousFraction(numerator, denominator):</span><br><span class="line">                final_numerator *= numerator//<span class="number">10</span></span><br><span class="line">                final_denominator *= denominator%<span class="number">10</span></span><br><span class="line">    final_result = reductionFraction(final_numerator, final_denominator)</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h2 id="34-Digit-factorials"><a href="#34-Digit-factorials" class="headerlink" title="34. Digit factorials"></a>34. Digit factorials</h2><h3 id="Problem-Description-3"><a href="#Problem-Description-3" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.</p><p>Find the sum of all numbers which are equal to the sum of the factorial of their digits.</p><p>Note: As 1! = 1 and 2! = 2 are not sums they are not included.</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of all numbers which are equal to the sum of the factorial of their digits</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFactorial</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> input_number == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y: x*y, range(<span class="number">1</span>, input_number+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSum</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    sum_result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> input_number != <span class="number">0</span>:</span><br><span class="line">        sum_result += getFactorial(input_number%<span class="number">10</span>)</span><br><span class="line">        input_number /= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> sum_result</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    final_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">100000</span>):</span><br><span class="line">        <span class="keyword">if</span> getSum(item) == item:</span><br><span class="line">            final_sum += item</span><br><span class="line">    <span class="keyword">print</span> final_sum</span><br></pre></td></tr></table></figure><h2 id="35-Circular-primes"><a href="#35-Circular-primes" class="headerlink" title="35. Circular primes"></a>35. Circular primes</h2><h3 id="Problem-Description-4"><a href="#Problem-Description-4" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The number, 197, is called a circular prime because all rotations of the digits: 197, 971, and 719, are themselves prime.</p><p>There are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97.</p><p>How many circular primes are there below one million?</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>首先引入python的sympy库筛选出10到1000000之间的所有素数，随后对其进行第二次筛选操作。由于需要对每个素数进行顺序位移，故第一批剔除任意数位为偶数的素数。第三次筛选题目要求进行顺序位移并判断结果是否在第一步获得的素数池内。最后计算长度并作差即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How many circular primes are there below one million</span></span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="comment"># First we should get all the prime numbers</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllPrimes</span><span class="params">(lower_bound ,upper_bound)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(sympy.sieve.primerange(lower_bound, upper_bound))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sieveEvenElements</span><span class="params">(prime_set)</span>:</span></span><br><span class="line">    PossiblePrime_set = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> prime_set:</span><br><span class="line">        item_string = str(item)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'0'</span> <span class="keyword">not</span> <span class="keyword">in</span> item_string <span class="keyword">and</span> <span class="string">'2'</span> <span class="keyword">not</span> <span class="keyword">in</span> item_string <span class="keyword">and</span> <span class="string">'4'</span> <span class="keyword">not</span> <span class="keyword">in</span> item_string <span class="keyword">and</span> <span class="string">'6'</span> <span class="keyword">not</span> <span class="keyword">in</span> item_string <span class="keyword">and</span> <span class="string">'8'</span> <span class="keyword">not</span> <span class="keyword">in</span> item_string:</span><br><span class="line">            PossiblePrime_set.append(item)</span><br><span class="line">    <span class="keyword">return</span> PossiblePrime_set</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testRotationResult</span><span class="params">(SetAfterSieve)</span>:</span></span><br><span class="line">    SetAfterSecondSieve = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> SetAfterSieve:</span><br><span class="line">        item_string = str(item)</span><br><span class="line">        <span class="keyword">for</span> index_number <span class="keyword">in</span> range(len(item_string)):</span><br><span class="line">            <span class="keyword">if</span> int(item_string[index_number:] + item_string[:index_number]) <span class="keyword">not</span> <span class="keyword">in</span>  SetAfterSieve:</span><br><span class="line">                SetAfterSecondSieve.append(item)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> SetAfterSecondSieve</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    original_primeset = getAllPrimes(<span class="number">10</span>, <span class="number">1000000</span>)</span><br><span class="line">    FirstSieveSet = sieveEvenElements(original_primeset)</span><br><span class="line">    SecondSieveSet = testRotationResult(FirstSieveSet)</span><br><span class="line">    final_circular_prime_number = <span class="number">4</span> + len(FirstSieveSet) - len(SecondSieveSet)</span><br><span class="line">    <span class="keyword">print</span> final_circular_prime_number</span><br></pre></td></tr></table></figure><h2 id="36-Double-base-palindromes"><a href="#36-Double-base-palindromes" class="headerlink" title="36. Double-base palindromes"></a>36. Double-base palindromes</h2><h3 id="Problem-Description-5"><a href="#Problem-Description-5" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The decimal number, $ 585 = 1001001001_{2}$ (binary), is palindromic in both bases.</p><p>Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2.</p><p>(Please note that the palindromic number, in either base, may not include leading zeros.)</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindromes</span><span class="params">(input_string)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> input_string == input_string[::<span class="number">-1</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sum_result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">1000000</span>):</span><br><span class="line">        <span class="keyword">if</span> isPalindromes(str(item)) <span class="keyword">and</span> isPalindromes(bin(item)[<span class="number">2</span>:]):</span><br><span class="line">            <span class="keyword">print</span> item</span><br><span class="line">            sum_result += item</span><br><span class="line">    <span class="keyword">print</span> sum_result</span><br></pre></td></tr></table></figure><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h3><p>除借助python特有的字符串逆序特性方便地解决问题外，我们设计任意进制下判定某个数字是否为回文数字的函数<code>isPalindromes()</code>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(input_number, base)</span>:</span></span><br><span class="line">    reverse_result = <span class="number">0</span></span><br><span class="line">    k = input_number</span><br><span class="line">    <span class="keyword">while</span> k != <span class="number">0</span>:</span><br><span class="line">        reverse_result = base*reverse_result + k % base</span><br><span class="line">        k /= base</span><br><span class="line">    <span class="keyword">return</span> input_number == reverse_result</span><br></pre></td></tr></table></figure><p>注意在二进制运算中，可以使用<code>&amp;1</code>代替模运算，使用<code>&lt;&lt;1</code>代替乘法运算。</p><p>由于题目需要在二进制下保持回文状态且不考虑前导零的存在，故排除所有的偶数，即循环过程中以奇数起始，步长选择为2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sum_result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">1000000</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> isPalindrome(item, <span class="number">10</span>) <span class="keyword">and</span> isPalindrome(item, <span class="number">2</span>):</span><br><span class="line">            sum_result += item</span><br><span class="line">    <span class="keyword">print</span> sum_result</span><br></pre></td></tr></table></figure><h3 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h3><p>在题目给出的限制范围内，解法二可保持较高的效率，但随着数字上限的扩大，程序运行时间会大大增长。故考虑”生成+判定”的方法：假设在b进制下存在回文数字xyzzyx，取前三个数字xyz为回文结，则该六位数字由三位回文结xyz定义。同时xyz亦可定义五位回文数字xyzyx。故我们可得出如下结论：</p><p><strong>对于任意b进制，任意小于$b^{n}$的整数可作为回文结生成两个小于$b^{2n}$的回文数字，这两个回文数字的位数一奇一偶。</strong></p><p>应用以上结论，我们选择在二进制下生成两个回文数字并检验十进制下该数字是否为回文数字。如果需要得到奇数位数的回文数字，则设置标志位为true，并进行运算<code>生成元n/进制b</code>，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(input_number, base)</span>:</span></span><br><span class="line">    reverse_result = <span class="number">0</span></span><br><span class="line">    k = input_number</span><br><span class="line">    <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">        reverse_result = base*reverse_result + k % base</span><br><span class="line">        k /= base</span><br><span class="line">    <span class="keyword">return</span> input_number == reverse_result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makePalindromeBase2</span><span class="params">(n, oddflag)</span>:</span></span><br><span class="line">    result = n</span><br><span class="line">    <span class="keyword">if</span> oddflag:</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        result = (result &lt;&lt; <span class="number">1</span>) + (n &amp; <span class="number">1</span>)</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    upper_bound = <span class="number">1000000</span></span><br><span class="line">    sum_result = <span class="number">0</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    generated_result = makePalindromeBase2(i, <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">while</span> generated_result &lt; upper_bound:</span><br><span class="line">        <span class="keyword">if</span> isPalindrome(generated_result, <span class="number">10</span>):</span><br><span class="line">            sum_result += generated_result</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        generated_result = makePalindromeBase2(i, <span class="literal">True</span>)</span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    generated_result2 = makePalindromeBase2(j, <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">while</span> generated_result2 &lt; upper_bound:</span><br><span class="line">        <span class="keyword">if</span> isPalindrome(generated_result2, <span class="number">10</span>):</span><br><span class="line">            sum_result += generated_result2</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        generated_result2 = makePalindromeBase2(j, <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">print</span> sum_result</span><br></pre></td></tr></table></figure><h2 id="37-Truncatable-primes"><a href="#37-Truncatable-primes" class="headerlink" title="37. Truncatable primes"></a>37. Truncatable primes</h2><h3 id="Problem-Description-6"><a href="#Problem-Description-6" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The number 3797 has an interesting property. Being prime itself, it is possible to continuously remove digits from left to right, and remain prime at each stage: 3797, 797, 97, and 7. Similarly we can work from right to left: 3797, 379, 37, and 3.</p><p>Find the sum of the only eleven primes that are both truncatable from left to right and right to left.</p><p>NOTE: 2, 3, 5, and 7 are not considered to be truncatable primes.</p><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of the only eleven primes that are both truncatable from left to right and right to left</span></span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rightToLeft</span><span class="params">(given_prime, primeSet)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> given_prime != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> given_prime <span class="keyword">not</span> <span class="keyword">in</span> primeSet:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        given_prime /= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leftToRight</span><span class="params">(given_prime, primeSet)</span>:</span></span><br><span class="line">    given_prime_string = str(given_prime)</span><br><span class="line">    <span class="keyword">for</span> index_number <span class="keyword">in</span> range(len(given_prime_string)):</span><br><span class="line">        <span class="keyword">if</span> int(given_prime_string[index_number:]) <span class="keyword">not</span> <span class="keyword">in</span> primeSet:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isTruncatablePrimes</span><span class="params">(given_prime, primeSet)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> given_prime == <span class="number">2</span> <span class="keyword">or</span> given_prime == <span class="number">3</span> <span class="keyword">or</span> given_prime == <span class="number">5</span> <span class="keyword">or</span> given_prime == <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> rightToLeft(given_prime, primeSet) <span class="keyword">and</span> leftToRight(given_prime, primeSet)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sum_result = <span class="number">0</span></span><br><span class="line">    final_result = []</span><br><span class="line">    primeSet = list(sympy.sieve.primerange(<span class="number">2</span>, <span class="number">1000000</span>))</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> primeSet:</span><br><span class="line">        <span class="keyword">if</span> isTruncatablePrimes(item, primeSet):</span><br><span class="line">            final_result.append(item)</span><br><span class="line">            sum_result += item</span><br><span class="line">    <span class="keyword">print</span> sum_result</span><br></pre></td></tr></table></figure><h2 id="38-Pandigital-multiples"><a href="#38-Pandigital-multiples" class="headerlink" title="38. Pandigital multiples"></a>38. Pandigital multiples</h2><h3 id="Problem-Description-7"><a href="#Problem-Description-7" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Take the number 192 and multiply it by each of 1, 2, and 3:</p><blockquote><p>192 × 1 = 192<br>192 × 2 = 384<br>192 × 3 = 576</p></blockquote><p>By concatenating each product we get the 1 to 9 pandigital, 192384576. We will call 192384576 the concatenated product of 192 and (1,2,3)</p><p>The same can be achieved by starting with 9 and multiplying by 1, 2, 3, 4, and 5, giving the pandigital, 918273645, which is the concatenated product of 9 and (1,2,3,4,5).</p><p>What is the largest 1 to 9 pandigital 9-digit number that can be formed as the concatenated product of an integer with (1,2, … , n) where n &gt; 1?</p><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># What is the largest 1 to 9 pandigital 9-digit number that can be formed as the concatenated product of an integer with (1,2, ... , n) where n &gt; 1?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getConcatenatedResult</span><span class="params">(multiple_time, max_result, final_item)</span>:</span></span><br><span class="line">    upper_bound = <span class="number">6</span> - multiple_time</span><br><span class="line">    lower_bound = <span class="number">5</span> - multiple_time</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">10</span>**lower_bound, <span class="number">10</span>**upper_bound):</span><br><span class="line">        concatenated_result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> time <span class="keyword">in</span> range(<span class="number">1</span>, multiple_time+<span class="number">1</span>):</span><br><span class="line">            concatenated_result += str(item*time)</span><br><span class="line">        tmp_result = comparisonFunction(concatenated_result, max_result, item)</span><br><span class="line">        max_result = tmp_result[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> tmp_result[<span class="number">1</span>] != <span class="number">0</span>:</span><br><span class="line">            final_item = tmp_result[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> (max_result, final_item)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">comparisonFunction</span><span class="params">(concatenated_result, max_result, item)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> judgePandigitalNumber(concatenated_result) <span class="keyword">and</span> int(concatenated_result) &gt; max_result:</span><br><span class="line">        <span class="keyword">return</span> (int(concatenated_result), item)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> (max_result, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judgePandigitalNumber</span><span class="params">(input_number_string)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(input_number_string) == <span class="number">9</span> <span class="keyword">and</span> len(set(input_number_string)) == <span class="number">9</span> <span class="keyword">and</span> <span class="string">'0'</span> <span class="keyword">not</span> <span class="keyword">in</span> input_number_string:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    final_item, max_result = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> multiply_factor <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">6</span>):</span><br><span class="line">        concatenated_result = getConcatenatedResult(multiply_factor, max_result, final_item)</span><br><span class="line">        max_result = concatenated_result[<span class="number">0</span>]</span><br><span class="line">        final_item = concatenated_result[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">print</span> max_result</span><br></pre></td></tr></table></figure><h2 id="39-Integer-right-triangles"><a href="#39-Integer-right-triangles" class="headerlink" title="39. Integer right triangles"></a>39. Integer right triangles</h2><h3 id="Problem-Description-8"><a href="#Problem-Description-8" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>If <em>p</em> is the perimeter of a right angle triangle with integral length sides, {<em>a</em>,<em>b</em>,<em>c</em>}, there are exactly three solutions for <em>p</em> = 120.</p><p>{20,48,52}, {24,45,51}, {30,40,50}</p><p>For which value of <em>p</em> ≤ 1000, is the number of solutions maximised?</p><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For which value of p &lt;= 1000, is the numnber of solutions maximised?</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judgeTriangle</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> a**<span class="number">2</span> + b**<span class="number">2</span> == c**<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSolutions</span><span class="params">(p)</span>:</span></span><br><span class="line">    solution_number = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">2</span>, int(p/<span class="number">2</span>)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> range(<span class="number">1</span>, a+<span class="number">1</span>):</span><br><span class="line">            c = p - a - b</span><br><span class="line">            <span class="keyword">if</span> judgeTriangle(a, b, c):</span><br><span class="line">                solution_number += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> solution_number</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    maximum_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> range(<span class="number">12</span>, <span class="number">1001</span>):</span><br><span class="line">        count_result = getSolutions(p)</span><br><span class="line">        <span class="keyword">if</span> count_result &gt; maximum_count:</span><br><span class="line">            maximum_count = count_result</span><br><span class="line">            maximum_count_p = p</span><br><span class="line">    <span class="keyword">print</span> maximum_count_p</span><br></pre></td></tr></table></figure><h2 id="40-Champernowne’s-constant"><a href="#40-Champernowne’s-constant" class="headerlink" title="40. Champernowne’s constant"></a>40. Champernowne’s constant</h2><h3 id="Probelm-Description"><a href="#Probelm-Description" class="headerlink" title="Probelm Description"></a>Probelm Description</h3><p>An irrational decimal fraction is created by concatenating the positive integers:</p><p>0.12345678910<strong>1</strong>112131415161718192021…</p><p>It can be seen that the $12^{th}$ digit of the fractional part is 1.</p><p>If $d_{n}$ represents the $n^{th}$ digit of the fractional part, find the value of the following expression.</p><script type="math/tex; mode=display">d_{1} × d_{10} × d_{100} × d_{1000} × d_{10000} × d_{100000} × d_{1000000}</script><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the value of the following expression</span></span><br><span class="line"><span class="comment"># d1 x d10 x d100 x d1000 x d10000 x d100000 x d1000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDecimalFraction</span><span class="params">()</span>:</span></span><br><span class="line">    positive_integer = <span class="number">1</span></span><br><span class="line">    decimalfraction_string = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> len(decimalfraction_string) &lt; <span class="number">1000000</span>:</span><br><span class="line">        decimalfraction_string += str(positive_integer)</span><br><span class="line">        positive_integer += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> decimalfraction_string</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    final_fraction = getDecimalFraction()</span><br><span class="line">    result = int(final_fraction[<span class="number">0</span>])*int(final_fraction[<span class="number">9</span>])*int(final_fraction[<span class="number">99</span>])*int(final_fraction[<span class="number">999</span>])*int(final_fraction[<span class="number">9999</span>])*int(final_fraction[<span class="number">99999</span>])*int(final_fraction[<span class="number">999999</span>])</span><br><span class="line">    <span class="keyword">print</span> result</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;31-Coin-sums&quot;&gt;&lt;a href=&quot;#31-Coin-sums&quot; class=&quot;headerlink&quot; title=&quot;31. Coin sums&quot;&gt;&lt;/a&gt;31. Coin sums&lt;/h2&gt;&lt;h3 id=&quot;Problem-Description&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="Mathematics" scheme="https://blank-vax.github.io/categories/Mathematics/"/>
    
    
      <category term="Euler-Project" scheme="https://blank-vax.github.io/tags/Euler-Project/"/>
    
  </entry>
  
  <entry>
    <title>Euler-Project(III)</title>
    <link href="https://blank-vax.github.io/2020/11/10/Euler-Project(III)/"/>
    <id>https://blank-vax.github.io/2020/11/10/Euler-Project(III)/</id>
    <published>2020-11-09T16:20:00.000Z</published>
    <updated>2020-11-09T16:21:33.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="21-Amicable-numbers"><a href="#21-Amicable-numbers" class="headerlink" title="21. Amicable numbers"></a>21. Amicable numbers</h2><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Let d(<em>n</em>) be defined as the sum of proper divisors of <em>n</em> (numbers less than <em>n</em> which divide evenly into <em>n</em>).<br>If d(<em>a</em>) = <em>b</em> and d(<em>b</em>) = <em>a</em>, where <em>a</em> ≠ <em>b</em>, then <em>a</em> and <em>b</em> are an amicable pair and each of <em>a</em> and <em>b</em> are called amicable numbers.</p><p>For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220.</p><p>Evaluate the sum of all the amicable numbers under 10000.</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><p>根据题目抓住关键点：</p><ul><li>本题需要统计满足<code>d(a) == b and d(b) == a, while a != b</code>条件的数字对(a, b) ，故需要关注<code>d(a) == a</code>的情况；</li><li>统计因子之和的函数中，引入set数据结构，在结果中排除重复添加的情况，最后加上1。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSumOfDivisors</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> input_number == <span class="number">1</span> <span class="keyword">or</span> input_number == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    important_set = set()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">2</span>, int(input_number/<span class="number">2</span>)):</span><br><span class="line">        <span class="keyword">if</span> input_number % item == <span class="number">0</span>:</span><br><span class="line">            important_set.add(item)</span><br><span class="line">            important_set.add(input_number/item)</span><br><span class="line">    <span class="keyword">return</span> sum(important_set)+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    blank_list = []</span><br><span class="line">    <span class="keyword">for</span> index_number <span class="keyword">in</span> xrange(<span class="number">10000</span>):</span><br><span class="line">        <span class="keyword">if</span> index_number <span class="keyword">in</span> blank_list:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        tmp_result = getSumOfDivisors(index_number)</span><br><span class="line">        <span class="keyword">if</span> tmp_result == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> (index_number == getSumOfDivisors(tmp_result)) <span class="keyword">and</span> (index_number != tmp_result) :</span><br><span class="line">            blank_list.append(tmp_result)</span><br><span class="line">            blank_list.append(index_number)</span><br><span class="line">    <span class="keyword">print</span> sum(blank_list)</span><br></pre></td></tr></table></figure><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h3><p>从第十题的分析可以看出，任何一个数字都可以表示成素数幂乘积的形式。下面对素数幂的因子之和进行推导分析：</p><p>设p为任意素数，由于素数只包含1和其本身两个因子，则：$\sigma(p) = p + 1$；</p><p>考虑p的a次幂，$\sigma(p^{a}) = 1 + p + p^{2} + p^{3} + … + p^{a}$ (1)；</p><p>式子(1)两侧同乘p，有$p*\sigma(p^{a}) = p + p^{2} + p^{3} + p^{4} + … + p^{a+1} (2)$;</p><p>(2) - (1)得，$p<em>\sigma(p^{a}) - \sigma(p^{a}) = (p-1) </em> \sigma(p^{a}) = p^{a+1} - 1$；</p><p>因此$\sigma(p^{a}) = (p^{a+1} - 1) / (p - 1)$</p><p>使用该公式并结合数字的素数幂分解即可较快求出因子之和，代码实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SumOfDivisors</span><span class="params">(n)</span>:</span></span><br><span class="line">    sum_result = <span class="number">1</span></span><br><span class="line">    p = <span class="number">2</span></span><br><span class="line">    <span class="comment"># Prevents from checking prime factors greater than sqrt(n).</span></span><br><span class="line">    <span class="keyword">while</span> p**<span class="number">2</span> &lt;= n <span class="keyword">and</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> n % p == <span class="number">0</span>:</span><br><span class="line">            j = p**<span class="number">2</span></span><br><span class="line">            n /= p</span><br><span class="line">            <span class="keyword">while</span> n % p == <span class="number">0</span>:</span><br><span class="line">                j *= p</span><br><span class="line">                n /= p</span><br><span class="line">            sum_result *= (j<span class="number">-1</span>)</span><br><span class="line">            sum_result /= (p<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> p == <span class="number">2</span>:</span><br><span class="line">            p = <span class="number">3</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p += <span class="number">2</span></span><br><span class="line">    <span class="comment"># Covers the case that one prime factor greater than sqrt(n) remains.</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        sum_result *= (n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> sum_result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SumOfProperDivisors</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> SumOfDivisors(input_number) - input_number</span><br></pre></td></tr></table></figure><p>与解法一对比，该方法将运算时间 从3s降低到0.3s。</p><h2 id="22-Names-score"><a href="#22-Names-score" class="headerlink" title="22. Names score"></a>22. Names score</h2><h3 id="Problem-Description-1"><a href="#Problem-Description-1" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Using <a href="https://projecteuler.net/project/resources/p022_names.txt" target="_blank" rel="noopener">names.txt</a> (right click and ‘Save Link/Target As…’), a 46K text file containing over five-thousand first names, begin by sorting it into alphabetical order. Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list to obtain a name score.</p><p>For example, when the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. So, COLIN would obtain a score of 938 × 53 = 49714.</p><p>What is the total of all the name scores in the file?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Count the total scores of names</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SortContentAsAlphabeticalPosition</span><span class="params">(txtlocation)</span>:</span></span><br><span class="line">    file = open(txtlocation, <span class="string">"r"</span>)</span><br><span class="line">    content_string = file.read()</span><br><span class="line">    content_list = content_string.replace(<span class="string">"\""</span>, <span class="string">""</span>).split(<span class="string">","</span>)</span><br><span class="line">    <span class="keyword">return</span> sorted(content_list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetWordScore</span><span class="params">(input_word)</span>:</span></span><br><span class="line">    word_Score = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> input_word:</span><br><span class="line">        word_Score += ord(item) - <span class="number">65</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> word_Score</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CountTotalScore</span><span class="params">(content_list)</span>:</span></span><br><span class="line">    total_score = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> xrange(len(content_list)):</span><br><span class="line">        total_score += GetWordScore(content_list[index]) * (index+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> total_score</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    txt_location = given_txt_path</span><br><span class="line">    Sorted_list = SortContentAsAlphabeticalPosition(txt_location)</span><br><span class="line">    total_score = CountTotalScore(Sorted_list)</span><br><span class="line">    <span class="keyword">print</span> total_score</span><br></pre></td></tr></table></figure><h2 id="23-Non-abundant-sums"><a href="#23-Non-abundant-sums" class="headerlink" title="23. Non-abundant sums"></a>23. Non-abundant sums</h2><h3 id="Problem-Description-2"><a href="#Problem-Description-2" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>A perfect number is a number for which the sum of its proper divisors is exactly equal to the number. For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.</p><p>A number n is called deficient if the sum of its proper divisors is less than n and it is called abundant if this sum exceeds n.</p><p>As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be written as the sum of two abundant numbers is 24. By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers. However, this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit.</p><p>Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SumOfDivisors</span><span class="params">(n)</span>:</span></span><br><span class="line">    sum_result = <span class="number">1</span></span><br><span class="line">    p = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> p**<span class="number">2</span> &lt;= n <span class="keyword">and</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> n % p == <span class="number">0</span>:</span><br><span class="line">            j = p**<span class="number">2</span></span><br><span class="line">            n /= p</span><br><span class="line">            <span class="keyword">while</span> n % p == <span class="number">0</span>:</span><br><span class="line">                j *= p</span><br><span class="line">                n /= p</span><br><span class="line">            sum_result *= (j<span class="number">-1</span>)</span><br><span class="line">            sum_result /= (p<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> p == <span class="number">2</span>:</span><br><span class="line">            p = <span class="number">3</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p += <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        sum_result *= (n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> sum_result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SumOfProperDivisors</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> SumOfDivisors(input_number) - input_number</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    final_sum = <span class="number">28123</span>*<span class="number">28124</span>/<span class="number">2</span></span><br><span class="line">    least_abundant_number = <span class="number">12</span></span><br><span class="line">    possible_abundant_number_list = []</span><br><span class="line">    <span class="keyword">while</span> least_abundant_number &lt;= <span class="number">28123</span>:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> possible_abundant_number_list:</span><br><span class="line">            <span class="keyword">if</span> least_abundant_number - item <span class="keyword">in</span> possible_abundant_number_list:</span><br><span class="line">                final_sum -= least_abundant_number</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> SumOfProperDivisors(least_abundant_number) &gt; least_abundant_number:</span><br><span class="line">            possible_abundant_number_list.append(least_abundant_number)</span><br><span class="line">        least_abundant_number += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> final_sum</span><br></pre></td></tr></table></figure><p>使用上述暴力遍历的方法统计结果需要的时间较长，大概为160-180s左右。</p><h2 id="24-Lexicographic-permutations"><a href="#24-Lexicographic-permutations" class="headerlink" title="24. Lexicographic permutations"></a>24. Lexicographic permutations</h2><h3 id="Problem-Description-3"><a href="#Problem-Description-3" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>A permutation is an ordered arrangement of objects. For example, 3124 is one possible permutation of the digits 1, 2, 3 and 4. If all of the permutations are listed numerically or alphabetically, we call it lexicographic order. The lexicographic permutations of 0, 1 and 2 are:</p><p>012  021  102  120  201  210</p><p>What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>偷懒调用了python的itertools库，其中包含<code>permutations()</code>即排列函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    result_string = <span class="string">""</span></span><br><span class="line">    result_list = list(permutations(<span class="string">'0123456789'</span>))</span><br><span class="line">    final_result = sorted(result_list)[<span class="number">999999</span>]</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> final_result:</span><br><span class="line">        result_string += item</span><br><span class="line">    <span class="keyword">print</span> eval(result_string)</span><br></pre></td></tr></table></figure><h2 id="25-1000-digit-Fibonacci-number"><a href="#25-1000-digit-Fibonacci-number" class="headerlink" title="25. 1000-digit Fibonacci number"></a>25. 1000-digit Fibonacci number</h2><h3 id="Problem-Description-4"><a href="#Problem-Description-4" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The Fibonacci sequence is defined by the recurrence relation:</p><script type="math/tex; mode=display">F_{n} = F_{n−1} + F_{n−2}, where F_{1} = 1 and F_{2} = 1</script><p>Hence the first 12 terms will be:</p><script type="math/tex; mode=display">F_{1} = 1</script><script type="math/tex; mode=display">F_{2} = 1</script><script type="math/tex; mode=display">F_{3} = 2</script><script type="math/tex; mode=display">F_{4} = 3</script><script type="math/tex; mode=display">F_{5} = 5</script><script type="math/tex; mode=display">F_{6} = 8</script><script type="math/tex; mode=display">F_{7} = 13</script><script type="math/tex; mode=display">F_{8} = 21</script><script type="math/tex; mode=display">F_{9} = 34</script><script type="math/tex; mode=display">F_{10} = 55</script><script type="math/tex; mode=display">F_{11} = 89</script><script type="math/tex; mode=display">F_{12} = 144</script><p>The 12th term, $F_{12}$, is the first term to contain three digits.</p><p>What is the index of the first term in the Fibonacci sequence to contain 1000 digits?</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># What is the index of the first term in the Fibonacci sequence to contain 1000 digits</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetIndexOfFibonacci</span><span class="params">()</span>:</span></span><br><span class="line">    f = <span class="number">1</span></span><br><span class="line">    g = <span class="number">1</span></span><br><span class="line">    g_count = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> len(str(g)) &lt; <span class="number">1000</span>:</span><br><span class="line">        f, g = g, f+g</span><br><span class="line">        g_count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> g_count</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    final_result = GetIndexOfFibonacci()</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h2 id="26-Reciprocal-cycles"><a href="#26-Reciprocal-cycles" class="headerlink" title="26. Reciprocal cycles"></a>26. Reciprocal cycles</h2><h3 id="Problem-Description-5"><a href="#Problem-Description-5" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>A unit fraction contains 1 in the numerator. The decimal representation of the unit fractions with denominators 2 to 10 are given:</p><blockquote><div class="table-container"><table><thead><tr><th>1/2</th><th>=</th><th>0.5</th></tr></thead><tbody><tr><td>1/3</td><td>=</td><td>0.(3)</td></tr><tr><td>1/4</td><td>=</td><td>0.25</td></tr><tr><td>1/5</td><td>=</td><td>0.2</td></tr><tr><td>1/6</td><td>=</td><td>0.1(6)</td></tr><tr><td>1/7</td><td>=</td><td>0.(142857)</td></tr><tr><td>1/8</td><td>=</td><td>0.125</td></tr><tr><td>1/9</td><td>=</td><td>0.(1)</td></tr><tr><td>1/10</td><td>=</td><td>0.1</td></tr></tbody></table></div></blockquote><p>Where 0.1(6) means 0.166666…, and has a 1-digit recurring cycle. It can be seen that 1/7 has a 6-digit recurring cycle.</p><p>Find the value of <em>d</em> &lt; 1000 for which 1/<em>d</em> contains the longest recurring cycle in its decimal fraction part.</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>本题为经典的循环节计算问题。</p><p>设分母为n，若n为合数，则必可以表示成多个素数的乘积，其循环节与这些分解素数中最大的循环节保持一致。故只需要讨论所给范围内所有素数分母其倒数的循环节即可。值得注意的是，1/2与1/5都是有限小数，故2和5这两个素数需要排除。</p><p>确定循环的范围后下面进行循环节计算：通过查阅资料可知，循环节问题可以等价为大整数分解问题。给定大整数n，求使得$10^{k} \equiv 1 (mod n)$成立的最小的k，该数值即为1/n循环节的长度。根据以上分析采取<code>10**k-1 % n == 0</code>作为限制条件求解。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the value of d &lt; 1000 for which 1/d contains the longest recurring cycle in its decimal fraction part</span></span><br><span class="line"><span class="comment"># Brute force to find the longest recurring cycle</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># Judge whether n is prime</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(math.sqrt(n))+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetRecurringCycle</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    L = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">10</span>**L<span class="number">-1</span>) % input_number == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        L += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    max_recurring_length = <span class="number">1</span></span><br><span class="line">    result_n = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">1001</span>):</span><br><span class="line">        <span class="keyword">if</span> isPrime(i) <span class="keyword">and</span> i != <span class="number">2</span> <span class="keyword">and</span> i != <span class="number">5</span>:</span><br><span class="line">            recurring_length = GetRecurringCycle(i)</span><br><span class="line">            <span class="keyword">if</span> recurring_length &gt; max_recurring_length:</span><br><span class="line">                max_recurring_length = recurring_length</span><br><span class="line">                result_n = i</span><br><span class="line">    <span class="keyword">print</span> (result_n, max_recurring_length)</span><br></pre></td></tr></table></figure><h3 id="Mathematical-Analysis"><a href="#Mathematical-Analysis" class="headerlink" title="Mathematical Analysis"></a>Mathematical Analysis</h3><p>考虑上面提到的一般化问题：求最小的k使得$a^{k} \equiv 1(mod n)$，若n与a互素，求出分母n的欧拉函数值$\Phi(n)$，则循环节长度k必为其约数；若n与a存在公因子则无解。由此可见通过暴力遍历的方法可以求出约数k，从而得出循环节。</p><p>在RSA加密中，给定n=p<em>q，则p，q均为大质数，此时1/n循环节的长度length为gcd(p-1, q-1)的约数。假定已知length的因数分解$length = l<em>{1}^{c</em>{1}}</em>l<em>{2}^{c</em>{2}}<em>l<em>{3}^{c</em>{3}}</em>……*l<em>{k}^{c</em>{k}}$，则length共有$\prod[c_{i}+1]$个约数。将这些约数分别加上1，若某个约数y(j)加1后是质数，则y(j)+1可能是大整数n的约数。对所有小于$\sqrt{n}-1$的y(j)进行检验，必能找到一个恰好满足y(j)+1 = min(p, q)的数字。通过此种方法可以将大整数分解问题转换为求循环节的问题。在最坏的情况下，一个300位的大整数只需通过小于500次转换完成分解。</p><p>关于循环节长度计算公式存在如下改进：</p><p><img src="http://static.zybuluo.com/B1ank/jl4413p7e5aimhgxns9y4oeb/26_recurring_cycle.PNG" alt="26_recurring_cycle.PNG-34.7kB"></p><p>该公式的应用如下：</p><p><img src="http://static.zybuluo.com/B1ank/absa60kgl3ibzasy8l2ff8eg/26_recurring_cycle2.PNG" alt="26_recurring_cycle2.PNG-47.8kB"></p><p>参考论文：关于循环节长度计算公式的改进：<a href="https://www.ixueshu.com/document/6d924626ac37b4ee318947a18e7f9386.html" target="_blank" rel="noopener">https://www.ixueshu.com/document/6d924626ac37b4ee318947a18e7f9386.html</a></p><h2 id="27-Quadratic-primes"><a href="#27-Quadratic-primes" class="headerlink" title="27. Quadratic primes"></a>27. Quadratic primes</h2><h3 id="Problem-Description-6"><a href="#Problem-Description-6" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Euler discovered the remarkable quadratic formula:</p><script type="math/tex; mode=display">n^{2} + n + 41</script><p>It turns out that the formula will produce 40 primes for the consecutive integer values 0≤n≤39. However, when$ n=40, 40^{2}+40+41=40*(40+1)+41$ is divisible by 41, and certainly when $ n=41,41^{2}+41+41 $is clearly divisible by 41.</p><p>The incredible formula $n^{2}−79*n+1601$ was discovered, which produces 80 primes for the consecutive values 0≤n≤79. The product of the coefficients, −79 and 1601, is −126479.</p><p>Considering quadratics of the form:</p><script type="math/tex; mode=display">n^{2}+a*n+b , where|a|<1000 , |b|≤1000</script><p>where |n| is the modulus/absolute value of n<br>e.g. |11|=11 and |−4|=4</p><p>Find the product of the coefficients, a and b, for the quadratic expression that produces the maximum number of primes for consecutive values of n, starting with n=0.</p><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>根据题目，可以仅通过数学推导的方法求解（条件极值问题+二次图像平移），参考链接如下：<a href="https://zhuanlan.zhihu.com/p/62137330。除此之外，还可以按照题意暴力求解，由于本题提供的a" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/62137330。除此之外，还可以按照题意暴力求解，由于本题提供的a</a>, b范围较小，故可以在较短时间内完成计算。根据题目给出的二次多项式$f(n) = n^{2} + a*n + b$可得出以下性质：</p><ul><li>由f(0) = b可知参数b必为素数，故将b的遍历范围缩小为2—999；</li><li>由f(1) = a+b+1且该多项式为素数，可得结论a &gt; -b-1，据此适当缩小a的遍历范围；</li><li>当gcd(a, b) = d且d != 1时，一定存在一个数n’ = minP(d)使得f(n’)为合数，其中minP(d)表示d的最小素因子。从而若a, b不互素，最多生成minP(d)个连续素数，从而在遍历过程中排除a, b不互素的情况即可。（需要用到math.gcd()函数且偷懒不想自己构造，故以下代码需选择Python3.5+版本运行）</li></ul><p>遍历代码具有两个版本，记录如下：</p><h4 id="Version1"><a href="#Version1" class="headerlink" title="Version1"></a>Version1</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the product of the coefficients,a and b, for the quadratic expression that produces the maximum number of primes for consecutive values of n, starting with n = 0</span></span><br><span class="line"><span class="comment"># Some properties:</span></span><br><span class="line">    <span class="comment"># f(0) = b, so b must be a prime</span></span><br><span class="line">    <span class="comment"># a &gt; -b-1</span></span><br><span class="line">    <span class="comment"># if gcd(a, b) = d and d != 1, we could only get as many as the least prime factor of d continuous primes</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(math.sqrt(n))+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    prime_counter = <span class="number">0</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> isPrime(n*n+a*n+b):</span><br><span class="line">            prime_counter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> prime_counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    result_set = []</span><br><span class="line">    max_result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">-995</span>, <span class="number">999</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">1000</span>):</span><br><span class="line">            <span class="keyword">if</span> isPrime(b) <span class="keyword">and</span> math.gcd(a, b) == <span class="number">1</span>:</span><br><span class="line">                count = countPrimes(a, b)</span><br><span class="line">                <span class="keyword">if</span> count &gt; max_result:</span><br><span class="line">                    max_result = count</span><br><span class="line">                    result_set.append(a*b)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">    print(result_set[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h4 id="Version2"><a href="#Version2" class="headerlink" title="Version2"></a>Version2</h4><p>引入python中的数学运算库sympy，该库继承多种数学运算，包括大量素数操作的接口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">isprime(n)              <span class="comment"># Test if n is a prime number (True) or not (False).</span></span><br><span class="line"> </span><br><span class="line">primerange(a, b)        <span class="comment"># Generate a list of all prime numbers in the range [a, b).</span></span><br><span class="line">randprime(a, b)         <span class="comment"># Return a random prime number in the range [a, b).</span></span><br><span class="line">primepi(n)              <span class="comment"># Return the number of prime numbers less than or equal to n.</span></span><br><span class="line"> </span><br><span class="line">prime(nth)              <span class="comment"># Return the nth prime, with the primes indexed as prime(1) = 2. The nth prime is approximately n*log(n) and can never be larger than 2**n.</span></span><br><span class="line">prevprime(n, ith=<span class="number">1</span>)     <span class="comment"># Return the largest prime smaller than n</span></span><br><span class="line">nextprime(n)            <span class="comment"># Return the ith prime greater than n</span></span><br><span class="line"> </span><br><span class="line">sieve.primerange(a, b)  <span class="comment"># Generate all prime numbers in the range [a, b), implemented as a dynamically growing sieve of Eratosthenes.</span></span><br></pre></td></tr></table></figure><p>代码如下，其中应用到<code>sympy.isprime()</code>函数进行素数判断，应用<code>sieve.primerange(a, b)</code>函数生成1—1000内的所有素数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"></span><br><span class="line"><span class="comment"># This function is used to collect all the primes between 1 and 1000</span></span><br><span class="line">Prime = list(sympy.sieve.primerange(<span class="number">1</span>, <span class="number">1000</span>))</span><br><span class="line">dic = &#123;&#125;</span><br><span class="line">dic[<span class="string">'n'</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">-995</span>, <span class="number">999</span>, <span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> Prime:</span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        c = n*n + a*n + b</span><br><span class="line">        <span class="keyword">while</span> sympy.isprime(c):</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            c = n*n + a*n + b</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; dic[<span class="string">'n'</span>]:</span><br><span class="line">            dic[<span class="string">'n'</span>] = n</span><br><span class="line">            dic[<span class="string">'a*b'</span>] = a*b</span><br><span class="line"><span class="keyword">print</span> dic[<span class="string">'a*b'</span>]</span><br></pre></td></tr></table></figure><p>sympy库函数文档：<a href="http://docs.sympy.org/latest/modules/ntheory.html?highlight=prime#ntheory-functions-reference" target="_blank" rel="noopener">http://docs.sympy.org/latest/modules/ntheory.html?highlight=prime#ntheory-functions-reference</a></p><h2 id="28-Number-spiral-diagonals"><a href="#28-Number-spiral-diagonals" class="headerlink" title="28. Number spiral diagonals"></a>28. Number spiral diagonals</h2><h3 id="Problem-Description-7"><a href="#Problem-Description-7" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Starting with the number 1 and moving to the right in a clockwise direction a 5 by 5 spiral is formed as follows:</p><p><img src="http://static.zybuluo.com/B1ank/vlazx7k4veo9vettw7mrf92s/28_problem.PNG" alt="28_problem.PNG-10.2kB"></p><p>It can be verified that the sum of the numbers on the diagonals is 101.</p><p>What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way?</p><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gridA: 5*5 there are 3 circles</span></span><br><span class="line"><span class="comment"># gridB: 7*7 there are 4 circles</span></span><br><span class="line"><span class="comment"># gridN: N*N there must be (N+1)/2 circles</span></span><br><span class="line"><span class="comment"># Arithmetic progression</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCircles</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (n+<span class="number">1</span>) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSum</span><span class="params">(circle_number)</span>:</span></span><br><span class="line">    final_sum = <span class="number">0</span></span><br><span class="line">    step = <span class="number">2</span></span><br><span class="line">    origin_number = <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(circle_number<span class="number">-1</span>):</span><br><span class="line">        final_sum += <span class="number">4</span>*origin_number + <span class="number">6</span>*step</span><br><span class="line">        origin_number += <span class="number">4</span>*step + <span class="number">2</span></span><br><span class="line">        step += <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> final_sum</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    final_result = countSum(getCircles(<span class="number">1001</span>))</span><br><span class="line">    <span class="keyword">print</span> final_result+<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="29-Distinct-powers"><a href="#29-Distinct-powers" class="headerlink" title="29. Distinct powers"></a>29. Distinct powers</h2><h3 id="Problem-Description-8"><a href="#Problem-Description-8" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Consider all integer combinations of $a^{b}$ for 2 ≤ <em>a</em> ≤ 5 and 2 ≤ <em>b</em> ≤ 5:</p><script type="math/tex; mode=display">2^{2}=4, 2^{3}=8, 2^{4}=16, 2^{5}=32</script><script type="math/tex; mode=display">3^{2}=9, 3^{3}=27, 3^{4}=81, 3^{5}=243</script><script type="math/tex; mode=display">4^{2}=16, 4^{3}=64, 4^{4}=256, 4^{5}=1024</script><script type="math/tex; mode=display">5^{2}=25, 5^{3}=125, 5^{4}=625, 5^{5}=3125</script><p>If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:</p><p>4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125</p><p>How many distinct terms are in the sequence generated by $a^{b}$ for 2 ≤ <em>a</em> ≤ 100 and 2 ≤ <em>b</em> ≤ 100?</p><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final_set = set()</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">101</span>):</span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">101</span>):</span><br><span class="line">tmp_a_b = a**b</span><br><span class="line">        tmp_b_a = b**a</span><br><span class="line">        <span class="keyword">if</span> tmp_a_b <span class="keyword">not</span> <span class="keyword">in</span> final_set:</span><br><span class="line">            final_set.add(tmp_a_b)</span><br><span class="line">        <span class="keyword">if</span> tmp_b_a <span class="keyword">not</span> <span class="keyword">in</span> final_set:</span><br><span class="line">            final_set.add(tmp_b_a)</span><br><span class="line"><span class="keyword">print</span> len(final_set)</span><br></pre></td></tr></table></figure><h2 id="30-Digit-fifth-powers"><a href="#30-Digit-fifth-powers" class="headerlink" title="30. Digit fifth powers"></a>30. Digit fifth powers</h2><h3 id="Problem-Description-9"><a href="#Problem-Description-9" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Surprisingly there are only three numbers that can be written as the sum of fourth powers of their digits:</p><script type="math/tex; mode=display">1634 = 1^{4} + 6^{4} + 3^{4} + 4^{4}</script><script type="math/tex; mode=display">8208 = 8^{4} + 2^{4} + 0^{4} + 8^{4}</script><script type="math/tex; mode=display">9474 = 9^{4} + 4^{4} + 7^{4} + 4^{4}</script><p>As$ 1 = 1^{4} $is not a sum it is not included.</p><p>The sum of these numbers is 1634 + 8208 + 9474 = 19316.</p><p>Find the sum of all the numbers that can be written as the sum of fifth powers of their digits.</p><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><p>该问题的关键为确定枚举的上界：设满足题设条件的数字为n位数，取其每位都为9的情况，构造不等式$ 10^{n} &lt;= 9^{5}*n $，计算满足条件n的最小值即可找出上界。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of all the numbers that can be written as the sum of fifth powers of their powers</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSum</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    sum_result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> input_number != <span class="number">0</span>:</span><br><span class="line">        sum_result += (input_number % <span class="number">10</span>)**<span class="number">5</span></span><br><span class="line">        input_number /= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> sum_result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    final_result = <span class="number">0</span></span><br><span class="line">    <span class="comment"># Work out the upper bound of the enumeration range</span></span><br><span class="line">    <span class="comment"># 10^n &lt;= 9^5*n =&gt; we can get the minimum value of n is 5</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">9</span>**<span class="number">5</span>*<span class="number">6</span>):</span><br><span class="line">        <span class="keyword">if</span> item == getSum(item):</span><br><span class="line">            final_result += item</span><br><span class="line">            <span class="keyword">print</span> item</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;21-Amicable-numbers&quot;&gt;&lt;a href=&quot;#21-Amicable-numbers&quot; class=&quot;headerlink&quot; title=&quot;21. Amicable numbers&quot;&gt;&lt;/a&gt;21. Amicable numbers&lt;/h2&gt;&lt;h3
      
    
    </summary>
    
      <category term="Mathematics" scheme="https://blank-vax.github.io/categories/Mathematics/"/>
    
    
      <category term="Euler-Project" scheme="https://blank-vax.github.io/tags/Euler-Project/"/>
    
  </entry>
  
  <entry>
    <title>Euler-Project(II)</title>
    <link href="https://blank-vax.github.io/2020/10/25/Euler-Project(II)/"/>
    <id>https://blank-vax.github.io/2020/10/25/Euler-Project(II)/</id>
    <published>2020-10-25T04:16:00.000Z</published>
    <updated>2020-11-09T03:41:15.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11-Largest-product-in-a-grid"><a href="#11-Largest-product-in-a-grid" class="headerlink" title="11. Largest product in a grid"></a>11. Largest product in a grid</h2><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>In the 20×20 grid below, four numbers along a diagonal line have been marked in bold.</p><p>08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08<br>49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00<br>81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65<br>52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91<br>22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80<br>24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50<br>32 98 81 28 64 23 67 10 <strong>26</strong> 38 40 67 59 54 70 66 18 38 64 70<br>67 26 20 68 02 62 12 20 95 <strong>63</strong> 94 39 63 08 40 91 66 49 94 21<br>24 55 58 05 66 73 99 26 97 17 <strong>78</strong> 78 96 83 14 88 34 89 63 72<br>21 36 23 09 75 00 76 44 20 45 35 <strong>14</strong> 00 61 33 97 34 31 33 95<br>78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92<br>16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57<br>86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58<br>19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40<br>04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66<br>88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69<br>04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36<br>20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16<br>20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54<br>01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48</p><p>The product of these numbers is 26 × 63 × 78 × 14 = 1788696.</p><p>What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Simply rotation and comparison in four types of direction</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">grid_given =<span class="string">'''08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08</span></span><br><span class="line"><span class="string">49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00</span></span><br><span class="line"><span class="string">81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65</span></span><br><span class="line"><span class="string">52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91</span></span><br><span class="line"><span class="string">22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80</span></span><br><span class="line"><span class="string">24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50</span></span><br><span class="line"><span class="string">32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70</span></span><br><span class="line"><span class="string">67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21</span></span><br><span class="line"><span class="string">24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72</span></span><br><span class="line"><span class="string">21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95</span></span><br><span class="line"><span class="string">78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92</span></span><br><span class="line"><span class="string">16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57</span></span><br><span class="line"><span class="string">86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58</span></span><br><span class="line"><span class="string">19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40</span></span><br><span class="line"><span class="string">04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66</span></span><br><span class="line"><span class="string">88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69</span></span><br><span class="line"><span class="string">04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36</span></span><br><span class="line"><span class="string">20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16</span></span><br><span class="line"><span class="string">20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54</span></span><br><span class="line"><span class="string">01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48'''</span></span><br><span class="line"><span class="comment"># Alist variable is used to slice the given grid</span></span><br><span class="line">alist = [re.split(<span class="string">' '</span>, everyrow) <span class="keyword">for</span> everyrow <span class="keyword">in</span> re.split(<span class="string">'\n'</span>, grid_given)]</span><br><span class="line">result_list = []</span><br><span class="line"><span class="comment"># rows</span></span><br><span class="line"><span class="keyword">for</span> row_index <span class="keyword">in</span> range(len(alist)):</span><br><span class="line">    <span class="keyword">for</span> columns_index <span class="keyword">in</span> xrange(len(alist[row_index])<span class="number">-3</span>):</span><br><span class="line">        result_list.append(int(alist[row_index][columns_index])*int(alist[row_index][columns_index+<span class="number">1</span>])*int(alist[row_index][columns_index+<span class="number">2</span>])*int(alist[row_index][columns_index+<span class="number">3</span>]))</span><br><span class="line"><span class="comment"># columns</span></span><br><span class="line"><span class="keyword">for</span> columns_index <span class="keyword">in</span> range(len(alist[<span class="number">0</span>])):</span><br><span class="line">    <span class="keyword">for</span> row_index <span class="keyword">in</span> xrange(len(alist)<span class="number">-3</span>):</span><br><span class="line">        result_list.append(int(alist[row_index][columns_index])*int(alist[row_index+<span class="number">1</span>][columns_index])*int(alist[row_index+<span class="number">2</span>][columns_index])*int(alist[row_index+<span class="number">3</span>][columns_index]))</span><br><span class="line"><span class="comment"># diagonal</span></span><br><span class="line"><span class="keyword">for</span> row_index <span class="keyword">in</span> range(len(alist)<span class="number">-3</span>):</span><br><span class="line">    <span class="keyword">for</span> columns_index <span class="keyword">in</span> range(len(alist[row_index])<span class="number">-3</span>):</span><br><span class="line">        <span class="comment"># main diagonal</span></span><br><span class="line">        result_list.append(int(alist[row_index][columns_index])*int(alist[row_index+<span class="number">1</span>][columns_index+<span class="number">1</span>])*int(alist[row_index+<span class="number">2</span>][columns_index+<span class="number">2</span>])*int(alist[row_index+<span class="number">3</span>][columns_index+<span class="number">3</span>]))</span><br><span class="line">        <span class="comment"># vice diagonal</span></span><br><span class="line">        result_list.append(int(alist[row_index+<span class="number">3</span>][columns_index])*int(alist[row_index+<span class="number">2</span>][columns_index+<span class="number">1</span>])*int(alist[row_index+<span class="number">1</span>][columns_index+<span class="number">2</span>])*int(alist[row_index][columns_index+<span class="number">3</span>]))</span><br><span class="line"><span class="keyword">print</span> max(result_list)</span><br></pre></td></tr></table></figure><h2 id="12-Highly-divisible-triangular-number"><a href="#12-Highly-divisible-triangular-number" class="headerlink" title="12. Highly divisible triangular number"></a>12. Highly divisible triangular number</h2><h3 id="Problem-Description-1"><a href="#Problem-Description-1" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:</p><p>1, 3, 6, 10, 15, 21, 28, 36, 45, 55, …</p><p>Let us list the factors of the first seven triangle numbers:</p><blockquote><p> <strong>1</strong>: 1<br> <strong>3</strong>: 1,3<br> <strong>6</strong>: 1,2,3,6<br><strong>10</strong>: 1,2,5,10<br><strong>15</strong>: 1,3,5,15<br><strong>21</strong>: 1,3,7,21<br><strong>28</strong>: 1,2,4,7,14,28</p></blockquote><p>We can see that 28 is the first triangle number to have over five divisors.</p><p>What is the value of the first triangle number to have over five hundred divisors?</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><p>通过观察可以发现，数字N的全部因子可分为大于$\sqrt{N}$和小于$\sqrt{N}$两部分，且这两部分的因子数量相等。故以$\sqrt{N}$为界限，统计前半部分因子数量，当大于250时跳出循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Triangular number</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">basic = <span class="number">1</span></span><br><span class="line">step = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    basic += step</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= int(math.sqrt(basic)):</span><br><span class="line">        <span class="keyword">if</span> basic % i == <span class="number">0</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> count &gt;= <span class="number">250</span>:</span><br><span class="line">        <span class="keyword">print</span> basic</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        step += <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h3><p>每个整数N可以分解为如下模式：</p><script type="math/tex; mode=display">N = p_{1}^{a1} * p_{2}^{a2} * p_{3}^{a3} * ...</script><p>此处$p<em>{n}$必为素数，$a</em>{n}$是其对应的幂指数。例如$28 = 2^{2} * 7^{1}$。继续推广下去，对于任意正整数N，其因子的数量D(N)可用如下式子表示：</p><script type="math/tex; mode=display">D(N) = (a_{1}+1) * (a_{2}+1) * (a_{3}+1) * ...</script><p>故首先采用埃氏筛法构造大素数表，随后对循环内每个数字进行分解以获得$a<em>{1}，a</em>{2}，a_{3}$等参数，连乘可得D(N)。对该常规方法进行改进，首先对三角形数进行等差数列求和，结果为$t = n * (n+1) / 2$，此处n和n+1必互素。随后采用如下公式分解D(t)：</p><p>$D(t) = D(n/2) * D(n+1)$, if n is even</p><p>$D(t) = D(n) * D((n+1)/2)$, if n is odd</p><p>实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Highly divisible triangular number</span></span><br><span class="line"><span class="comment"># First get the possible prime facotrs below 1000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPossiblePrimeFactors</span><span class="params">(upper_bound)</span>:</span></span><br><span class="line">    L = range(<span class="number">2</span>, upper_bound)</span><br><span class="line">    primes_list = findPrime(L)</span><br><span class="line">    <span class="keyword">return</span> primes_list</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPrime</span><span class="params">(L)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> L[i]**<span class="number">2</span> &lt; L[<span class="number">-1</span>]:</span><br><span class="line">        <span class="comment"># Eratosthenes algorithm</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(L)):</span><br><span class="line">            <span class="keyword">if</span> L[j] % L[i] == <span class="number">0</span>:</span><br><span class="line">                L[j] = <span class="number">0</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        L.sort()</span><br><span class="line">        L = L[count:]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countD</span><span class="params">(n, Dn, count_range, primes_list)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count &lt;= count_range:</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        n1 = n</span><br><span class="line">        <span class="keyword">if</span> n1 % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            n1 /= <span class="number">2</span></span><br><span class="line">        Dn1 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, primes_list[<span class="number">-1</span>]):</span><br><span class="line">            <span class="keyword">if</span> primes_list[i]**<span class="number">2</span> &gt; n1:</span><br><span class="line">                <span class="string">'''</span></span><br><span class="line"><span class="string">                When the prime divisor would be greater than the residual n1, that residual n1 is the last prime factor with an exponent = 1</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">                Dn1 = <span class="number">2</span>*Dn1</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># ause D(n) = (a1+1)*(a2+1)*(a3+1)*...., so initialize the exponent to 1</span></span><br><span class="line">            exponent = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> n1 % primes_list[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># resolve n1 to the form of multiplication, count a1, a2, a3, ...</span></span><br><span class="line">                exponent += <span class="number">1</span></span><br><span class="line">                n1 = n1 // primes_list[i]</span><br><span class="line">            <span class="keyword">if</span> exponent &gt; <span class="number">1</span>:</span><br><span class="line">                Dn1 = Dn1*exponent</span><br><span class="line">            <span class="keyword">if</span> n1 == <span class="number">1</span>: <span class="keyword">break</span></span><br><span class="line">        count = Dn*Dn1</span><br><span class="line">        Dn = Dn1</span><br><span class="line">    <span class="keyword">return</span> n*(n<span class="number">-1</span>) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">Dn = <span class="number">2</span></span><br><span class="line">primes_list = getPossiblePrimeFactors(<span class="number">1000</span>)</span><br><span class="line">final_result = countD(n, Dn, <span class="number">500</span>, primes_list)</span><br><span class="line"><span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><p>理解上述代码过程中，值得注意的是countD()函数的返回结果为n*(n-1) / 2而非n*(n+1) / 2，从而代码每次迭代计算的D(t)由传入while循环之前的n值表示，与上面提到的性质对应。</p><h2 id="13-Large-sum"><a href="#13-Large-sum" class="headerlink" title="13. Large sum"></a>13. Large sum</h2><h3 id="Problem-Description-2"><a href="#Problem-Description-2" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.</p><p>37107287533902102798797998220837590246510135740250<br>46376937677490009712648124896970078050417018260538<br>74324986199524741059474233309513058123726617309629<br>91942213363574161572522430563301811072406154908250<br>23067588207539346171171980310421047513778063246676<br>89261670696623633820136378418383684178734361726757<br>28112879812849979408065481931592621691275889832738<br>44274228917432520321923589422876796487670272189318<br>47451445736001306439091167216856844588711603153276<br>70386486105843025439939619828917593665686757934951<br>62176457141856560629502157223196586755079324193331<br>64906352462741904929101432445813822663347944758178<br>92575867718337217661963751590579239728245598838407<br>58203565325359399008402633568948830189458628227828<br>80181199384826282014278194139940567587151170094390<br>35398664372827112653829987240784473053190104293586<br>86515506006295864861532075273371959191420517255829<br>71693888707715466499115593487603532921714970056938<br>54370070576826684624621495650076471787294438377604<br>53282654108756828443191190634694037855217779295145<br>36123272525000296071075082563815656710885258350721<br>45876576172410976447339110607218265236877223636045<br>17423706905851860660448207621209813287860733969412<br>81142660418086830619328460811191061556940512689692<br>51934325451728388641918047049293215058642563049483<br>62467221648435076201727918039944693004732956340691<br>15732444386908125794514089057706229429197107928209<br>55037687525678773091862540744969844508330393682126<br>18336384825330154686196124348767681297534375946515<br>80386287592878490201521685554828717201219257766954<br>78182833757993103614740356856449095527097864797581<br>16726320100436897842553539920931837441497806860984<br>48403098129077791799088218795327364475675590848030<br>87086987551392711854517078544161852424320693150332<br>59959406895756536782107074926966537676326235447210<br>69793950679652694742597709739166693763042633987085<br>41052684708299085211399427365734116182760315001271<br>65378607361501080857009149939512557028198746004375<br>35829035317434717326932123578154982629742552737307<br>94953759765105305946966067683156574377167401875275<br>88902802571733229619176668713819931811048770190271<br>25267680276078003013678680992525463401061632866526<br>36270218540497705585629946580636237993140746255962<br>24074486908231174977792365466257246923322810917141<br>91430288197103288597806669760892938638285025333403<br>34413065578016127815921815005561868836468420090470<br>23053081172816430487623791969842487255036638784583<br>11487696932154902810424020138335124462181441773470<br>63783299490636259666498587618221225225512486764533<br>67720186971698544312419572409913959008952310058822<br>95548255300263520781532296796249481641953868218774<br>76085327132285723110424803456124867697064507995236<br>37774242535411291684276865538926205024910326572967<br>23701913275725675285653248258265463092207058596522<br>29798860272258331913126375147341994889534765745501<br>18495701454879288984856827726077713721403798879715<br>38298203783031473527721580348144513491373226651381<br>34829543829199918180278916522431027392251122869539<br>40957953066405232632538044100059654939159879593635<br>29746152185502371307642255121183693803580388584903<br>41698116222072977186158236678424689157993532961922<br>62467957194401269043877107275048102390895523597457<br>23189706772547915061505504953922979530901129967519<br>86188088225875314529584099251203829009407770775672<br>11306739708304724483816533873502340845647058077308<br>82959174767140363198008187129011875491310547126581<br>97623331044818386269515456334926366572897563400500<br>42846280183517070527831839425882145521227251250327<br>55121603546981200581762165212827652751691296897789<br>32238195734329339946437501907836945765883352399886<br>75506164965184775180738168837861091527357929701337<br>62177842752192623401942399639168044983993173312731<br>32924185707147349566916674687634660915035914677504<br>99518671430235219628894890102423325116913619626622<br>73267460800591547471830798392868535206946944540724<br>76841822524674417161514036427982273348055556214818<br>97142617910342598647204516893989422179826088076852<br>87783646182799346313767754307809363333018982642090<br>10848802521674670883215120185883543223812876952786<br>71329612474782464538636993009049310363619763878039<br>62184073572399794223406235393808339651327408011116<br>66627891981488087797941876876144230030984490851411<br>60661826293682836764744779239180335110989069790714<br>85786944089552990653640447425576083659976645795096<br>66024396409905389607120198219976047599490197230297<br>64913982680032973156037120041377903785566085089252<br>16730939319872750275468906903707539413042652315011<br>94809377245048795150954100921645863754710598436791<br>78639167021187492431995700641917969777599028300699<br>15368713711936614952811305876380278410754449733078<br>40789923115535562561142322423255033685442488917353<br>44889911501440648020369068063960672322193204149535<br>41503128880339536053299340368006977710650566631954<br>81234880673210146739058568557934581403627822703280<br>82616570773948327592232845941706525094512325230608<br>22918802058777319719839450180888072429661980811197<br>77158542502016545090413245809786882778948721859617<br>72107838435069186155435662884062257473692284509516<br>20849603980134001723930671666823555245252804609722<br>53503534226472524250874054075591789781264330331690</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">all_numbers = given_50_digit_numbers</span><br><span class="line">sum_result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> all_numbers.split(<span class="string">'\n'</span>):</span><br><span class="line">    <span class="keyword">if</span> item == <span class="string">''</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sum_result += int(item)</span><br><span class="line"><span class="keyword">print</span> str(sum_result)[<span class="number">0</span>:<span class="number">10</span>]</span><br></pre></td></tr></table></figure><h2 id="14-Longest-Collatz-sequence"><a href="#14-Longest-Collatz-sequence" class="headerlink" title="14. Longest Collatz sequence"></a>14. Longest Collatz sequence</h2><h3 id="Problem-Description-3"><a href="#Problem-Description-3" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The following iterative sequence is defined for the set of positive integers:</p><p>n → n/2 (n is even)<br>n → 3n + 1 (n is odd)</p><p>Using the rule above and starting with 13, we generate the following sequence:</p><p>13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1</p><p>It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.</p><p>Which starting number, under one million, produces the longest chain?</p><p><strong>NOTE:</strong> Once the chain starts the terms are allowed to go above one million.</p><h3 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1"></a>Solution1</h3><p>按照题意直接进行暴力遍历，可以采用递归和迭代的方法。采用靠近计算机底层的位运算代替普通运算可以适当提高效率：n &amp; 1 代替 n % 2，n &gt;&gt; 1代替 n / 2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Iteration</span></span><br><span class="line"><span class="comment"># Longest Collatz Sequence</span></span><br><span class="line"><span class="comment"># Which starting number, under one million, produces the longest chain</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCollatzSquence</span><span class="params">(n)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> n &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            n = <span class="number">3</span>*n+<span class="number">1</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    maxlength = <span class="number">1</span></span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>, <span class="number">1000000</span>):</span><br><span class="line">        count_number = getCollatzSquence(i)</span><br><span class="line">        <span class="keyword">if</span> count_number &gt; maxlength:</span><br><span class="line">            maxlength = count_number</span><br><span class="line">            flag = i</span><br><span class="line">    <span class="keyword">print</span> (maxlength, flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Recursion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countCollatzChain</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + countCollatzChain(n &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + countCollatzChain(<span class="number">3</span> * n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    longest_chain = <span class="number">0</span></span><br><span class="line">    result = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> range(<span class="number">100</span>, <span class="number">10</span>**<span class="number">6</span><span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> countCollatzChain(number) &gt; longest_chain:</span><br><span class="line">            longest_chain = countCollatzChain(number)</span><br><span class="line">            result = number</span><br><span class="line">    <span class="keyword">print</span> result</span><br></pre></td></tr></table></figure><p>二者效率对比如下，可以看出迭代调用所需时间明显小于递归调用。</p><p><img src="http://static.zybuluo.com/B1ank/uyvffvzjqsggcoh2px3uvhaz/14_sufficiency.PNG" alt="14_sufficiency.PNG-10.6kB"></p><h3 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2"></a>Solution2</h3><p>无论采用递归或是迭代的方法进行暴力遍历，我们都可以明确看出有部分数值经过重复计算，导致运算时间过长。于是进行以下优化：</p><ul><li>引入字典存储已经计算过的考拉兹链长度；</li><li>根据考拉兹猜想提出的运算规则，我们可以得到Collatz(n) = Collatz(n/2) + 1。因此对于所有整数k，Collatz(2k) &gt; Collatz(k)必定成立，所以我们不必计算小于LIMIT/2的所有k值，本例中即无需计算低于500000的k的考拉兹链长度；</li><li>若n是奇数，则3*n+1必定为偶数，从而n经过考拉兹变换后最终得到(3*n+1) / 2。故当n是奇数时，采用以下公式简化运算过程：Collatz(n) = Collatz((3*n+1) / 2) + 2。</li></ul><p>代码复现如下，但效率无法达到相关题解中提及的1.5s。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the longest Collatz sequence chain</span></span><br><span class="line"><span class="comment"># Which starting number, under one million, produces the longest chain</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countCollatzChain</span><span class="params">(n, values)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> values.keys():</span><br><span class="line">        <span class="keyword">return</span> values[n]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> n &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">        values[n] = <span class="number">1</span> + countCollatzChain(n &gt;&gt; <span class="number">1</span>, values)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        values[n] = <span class="number">2</span> + countCollatzChain((<span class="number">3</span> * n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, values)</span><br><span class="line">    <span class="keyword">return</span> values[n] </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    longest_chain = <span class="number">0</span></span><br><span class="line">    final_result = <span class="number">-1</span></span><br><span class="line">    values = &#123;<span class="number">1</span>: <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> range(<span class="number">500000</span>, <span class="number">10</span>**<span class="number">6</span> - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> countCollatzChain(number, values) &gt; longest_chain:</span><br><span class="line">            longest_chain = countCollatzChain(number, values)</span><br><span class="line">            final_result = number</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h2 id="15-Lattice-paths"><a href="#15-Lattice-paths" class="headerlink" title="15. Lattice paths"></a>15. Lattice paths</h2><h3 id="Problem-Description-4"><a href="#Problem-Description-4" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner.</p><p><img src="http://static.zybuluo.com/B1ank/n7ypagm1g8czqrkn4z3txlq8/4.png" alt="4.png-9.7kB"></p><p>How many such routes are there through a 20×20 grid?</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>本题目为简单格子路径问题，可以采用迭代、递归与组合数三种方法求解。</p><h4 id="Recursive-Solution"><a href="#Recursive-Solution" class="headerlink" title="Recursive Solution"></a>Recursive Solution</h4><p>将题目所给信息转换为一般问题，即求从(0, 0)点运动到(m, n)点的所有路径数量，该数量等于(0, 0)点到点(m-1, n)和(0, 0)点到点(m, n-1)的路径数量之和。以此类推，当m或n等于0时，(0, 0)点到达该点只存在一直向右或向下两条道路，此时递归算法返回1。值得注意的是，该方法存在重复计算问题，故可引入大容量数组存储可能需要的计算结果。</p><h4 id="Iterative-Solution"><a href="#Iterative-Solution" class="headerlink" title="Iterative Solution"></a>Iterative Solution</h4><p>递归法较易编写，但需要消耗较多计算资源，故考虑结合动态规划进行迭代求解。如果说递归法是”执果索因”，动态规划就是”由因导果”。首先建立20x20数组，由于第一行和第一列所有元素到达点(0, 0)只有一条路径，故数组中对应位置全部设置为1。随后从第二行第二列开始按照<code>grid[i][j] = grid[i][j-1] + grid[i-1][j]</code>进行数组赋值，目标位置<code>grid[m][n]</code>即为待求结果。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Lattice paths problem</span></span><br><span class="line"><span class="comment"># Simple dynamic programming</span></span><br><span class="line"><span class="comment"># Solution1 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllPaths</span><span class="params">(m, n)</span>:</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp[k][l] = dp[k<span class="number">-1</span>][l] + dp[k][l<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">print</span> dp</span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># Get all possible paths of 20 x 20 grids</span></span><br><span class="line">    final_result = getAllPaths(<span class="number">21</span>, <span class="number">21</span>)</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h4 id="Combinatorial-Solution"><a href="#Combinatorial-Solution" class="headerlink" title="Combinatorial Solution"></a>Combinatorial Solution</h4><p>以上两种方法时间复杂度均为O(mn)，我们可以使用组合数学以提高效率。</p><p>首先分析一般问题的本质，即从点(0, 0)到点(m, n)共需要走m+n步，其中需要向下走m步，向右走n步。于是引出简单无顺序组合问题即$\binom{m+n}{m}$。然而本题给出m=n=20，从而得到如下公式：</p><p><img src="http://static.zybuluo.com/B1ank/wlruky2d3a92kt7szsuxw4al/15_formula.PNG" alt="15_formula.PNG-20.8kB"></p><p>至此我们得到复杂度为O(n)的算法，实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Solution2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllPaths2</span><span class="params">(n)</span>:</span></span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        result = result * (n+i) / i</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># Get all possible paths of 20 x 20 grids</span></span><br><span class="line">    final_result2 = getAllPaths2(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">print</span> final_result2</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>方格问题升级之路（详细讨论格子路径问题）：<a href="https://blog.csdn.net/cookieZZ/article/details/70306757" target="_blank" rel="noopener">https://blog.csdn.net/cookieZZ/article/details/70306757</a></p><p>格子路径问题+组合数学：<a href="https://www.cnblogs.com/yhm138/p/13610626.html#102-lattice-paths-without-restrictions-无限制格子路径" target="_blank" rel="noopener">https://www.cnblogs.com/yhm138/p/13610626.html#102-lattice-paths-without-restrictions-无限制格子路径</a></p><h2 id="16-Power-digit-sum"><a href="#16-Power-digit-sum" class="headerlink" title="16. Power digit sum"></a>16. Power digit sum</h2><h3 id="Problem-Description-5"><a href="#Problem-Description-5" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>$2^{15} = 32768$ and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.</p><p>What is the sum of the digits of the number $2^{1000}$?</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Power digit sum</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDigitSum</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    digitsum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> input_number != <span class="number">0</span>:</span><br><span class="line">        digitsum += input_number % <span class="number">10</span></span><br><span class="line">        input_number /= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> digitsum</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    final_result = getDigitSum(<span class="number">2</span>**<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h2 id="17-Number-letter-counts"><a href="#17-Number-letter-counts" class="headerlink" title="17. Number letter counts"></a>17. Number letter counts</h2><h3 id="Problem-Description-6"><a href="#Problem-Description-6" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.</p><p>If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?</p><p><strong>NOTE:</strong> Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. The use of “and” when writing out numbers is in compliance with British usage.</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>最简单的方法为建立三个字典，分别存储个位数字1-9，十位数字1-9（即10-90）以及11-19，然后判断输入数字的位数并进行相关处理。该方法需要讨论的情况较多，例如三位数字便需要讨论100，1X0，10X，11X，1XX五种情况，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Count the letters of numbers 1 to 1000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countLetters</span><span class="params">(input_number, length, dict1, dict2, dict3)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> length == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> dict1[input_number]</span><br><span class="line">    <span class="keyword">elif</span> length == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> input_number / <span class="number">10</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> dict2[input_number]</span><br><span class="line">        <span class="keyword">elif</span> input_number % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> dict3[input_number/<span class="number">10</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> dict3[input_number/<span class="number">10</span>] + dict1[input_number%<span class="number">10</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> input_number % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> dict1[input_number/<span class="number">100</span>] + <span class="number">7</span></span><br><span class="line">        <span class="keyword">elif</span> input_number % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> dict1[input_number/<span class="number">100</span>] + dict3[input_number%<span class="number">100</span>/<span class="number">10</span>] + <span class="number">10</span></span><br><span class="line">        <span class="keyword">elif</span> input_number / <span class="number">10</span> % <span class="number">10</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> dict1[input_number/<span class="number">100</span>] + <span class="number">10</span> + dict2[input_number%<span class="number">100</span>]</span><br><span class="line">        <span class="keyword">elif</span> input_number / <span class="number">10</span> % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> dict1[input_number/<span class="number">100</span>] + <span class="number">10</span> + dict1[input_number%<span class="number">10</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> dict1[input_number/<span class="number">100</span>] + dict3[input_number%<span class="number">100</span>/<span class="number">10</span>] + dict1[input_number%<span class="number">10</span>] + <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># digits</span></span><br><span class="line">    dict1 = &#123;<span class="number">1</span>:<span class="number">3</span>, <span class="number">2</span>:<span class="number">3</span>, <span class="number">3</span>:<span class="number">5</span>, <span class="number">4</span>:<span class="number">4</span>, <span class="number">5</span>:<span class="number">4</span>, <span class="number">6</span>:<span class="number">3</span>, <span class="number">7</span>:<span class="number">5</span>, <span class="number">8</span>:<span class="number">5</span>, <span class="number">9</span>:<span class="number">4</span>&#125;</span><br><span class="line">    <span class="comment"># 10-tens</span></span><br><span class="line">    dict2 = &#123;<span class="number">10</span>:<span class="number">3</span>, <span class="number">11</span>:<span class="number">6</span>, <span class="number">12</span>:<span class="number">6</span>, <span class="number">13</span>:<span class="number">8</span>, <span class="number">14</span>:<span class="number">8</span>, <span class="number">15</span>:<span class="number">7</span>, <span class="number">16</span>:<span class="number">7</span>, <span class="number">17</span>:<span class="number">9</span>, <span class="number">18</span>:<span class="number">8</span>, <span class="number">19</span>:<span class="number">8</span>&#125;</span><br><span class="line">    <span class="comment"># tens</span></span><br><span class="line">    dict3 = &#123;<span class="number">1</span>:<span class="number">3</span>, <span class="number">2</span>:<span class="number">6</span>, <span class="number">3</span>:<span class="number">6</span>, <span class="number">4</span>:<span class="number">5</span>, <span class="number">5</span>:<span class="number">5</span>, <span class="number">6</span>:<span class="number">5</span>, <span class="number">7</span>:<span class="number">7</span>, <span class="number">8</span>:<span class="number">6</span>, <span class="number">9</span>:<span class="number">6</span>&#125;</span><br><span class="line">    total_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">1000</span>):</span><br><span class="line">        <span class="keyword">print</span> item</span><br><span class="line">        item_length = len(str(item))</span><br><span class="line">        <span class="comment"># print item_length</span></span><br><span class="line">        total_sum += countLetters(item, item_length, dict1, dict2, dict3)</span><br><span class="line">    </span><br><span class="line">    total_sum += <span class="number">11</span></span><br><span class="line">    <span class="keyword">print</span> total_sum</span><br></pre></td></tr></table></figure><p>由于三位数字与两位数字相比仅增加了对百位数字的讨论，本质为增加<code>X hundred and</code>这几个字符。故可以1-99为基础进行适当求和，从而省略了三位数字包含字符数量的判断，节约了运算时间，关键代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">        item_length = len(str(item))</span><br><span class="line">        total_sum += countLetters(item, item_length, dict1, dict2, dict3)</span><br><span class="line">    block_sum = total_sum</span><br><span class="line">    <span class="keyword">for</span> hundredstype <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        total_sum += dict1[hundredstype] + <span class="number">7</span> + (dict1[hundredstype] + <span class="number">10</span>) * <span class="number">99</span> + block_sum</span><br><span class="line">    total_sum += <span class="number">11</span></span><br><span class="line">    <span class="keyword">print</span> total_sum</span><br></pre></td></tr></table></figure><h2 id="18-Maximum-path-sum-I"><a href="#18-Maximum-path-sum-I" class="headerlink" title="18. Maximum path sum I"></a>18. Maximum path sum I</h2><h3 id="Problem-Description-7"><a href="#Problem-Description-7" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.</p><p><img src="http://static.zybuluo.com/B1ank/p14xzlcma3agwuw1hg8xjio5/18_problem_1.PNG" alt="18_problem_1.PNG-2.4kB"></p><p>That is, 3 + 7 + 4 + 9 = 23.</p><p>Find the maximum total from top to bottom of the triangle below:</p><p><img src="http://static.zybuluo.com/B1ank/63np17e8993jnuzuancgtixu/18_problem_2.PNG" alt="18_problem_2.PNG-29.6kB"></p><p><strong>NOTE:</strong> As there are only 16384 routes, it is possible to solve this problem by trying every route. However, <a href="https://projecteuler.net/problem=67" target="_blank" rel="noopener">Problem 67</a>, is the same challenge with a triangle containing one-hundred rows; it cannot be solved by brute force, and requires a clever method! ;o)</p><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>根据题目说明采用动态规划进行逐级递归。</p><p>首先将所给的字符串类型转换为二维数组，随后进行分析，核心思想为<strong>将上一行的数字更新为其本身与下一行相邻两数字中较大数字之和</strong>：以倒数第二行元素为例，63可更新为63+max(04, 62)即125，66可更新为66+max(62, 98)即164…以此类推，更新结束后二维数组第一个元素即为所求最长路径。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the maximum total from top to bottom of the triangle below:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transformToList</span><span class="params">(grid_string)</span>:</span></span><br><span class="line">    <span class="comment"># First transform the string to list</span></span><br><span class="line">    tmp_list = [item.split(<span class="string">' '</span>) <span class="keyword">for</span> item <span class="keyword">in</span> grid_string.split(<span class="string">'\n'</span>)]</span><br><span class="line">    <span class="comment"># print tmp_list</span></span><br><span class="line">    list_length = len(tmp_list)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(list_length):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>):</span><br><span class="line">            tmp_list[i][j] = int(tmp_list[i][j])</span><br><span class="line">    <span class="keyword">return</span> tmp_list</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dynamicProgramming</span><span class="params">(grid_list)</span>:</span></span><br><span class="line">    list_length = len(grid_list)</span><br><span class="line">    <span class="comment"># Start from the last but one line</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(list_length<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>):</span><br><span class="line">            grid_list[i][j] = grid_list[i][j] + max(grid_list[i+<span class="number">1</span>][j], grid_list[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> grid_list[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    grid = <span class="string">'''75</span></span><br><span class="line"><span class="string">95 64</span></span><br><span class="line"><span class="string">17 47 82</span></span><br><span class="line"><span class="string">18 35 87 10</span></span><br><span class="line"><span class="string">20 04 82 47 65</span></span><br><span class="line"><span class="string">19 01 23 75 03 34</span></span><br><span class="line"><span class="string">88 02 77 73 07 63 67</span></span><br><span class="line"><span class="string">99 65 04 28 06 16 70 92</span></span><br><span class="line"><span class="string">41 41 26 56 83 40 80 70 33</span></span><br><span class="line"><span class="string">41 48 72 33 47 32 37 16 94 29</span></span><br><span class="line"><span class="string">53 71 44 65 25 43 91 52 97 51 14</span></span><br><span class="line"><span class="string">70 11 33 28 77 73 17 78 39 68 17 57</span></span><br><span class="line"><span class="string">91 71 52 38 17 14 91 43 58 50 27 29 48</span></span><br><span class="line"><span class="string">63 66 04 68 89 53 67 30 73 16 69 87 40 31</span></span><br><span class="line"><span class="string">04 62 98 27 23 09 70 98 73 93 38 53 60 04 23'''</span></span><br><span class="line">    result_list = transformToList(grid)</span><br><span class="line">    final_result = dynamicProgramming(result_list)</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h2 id="19-Counting-Sundays"><a href="#19-Counting-Sundays" class="headerlink" title="19. Counting Sundays"></a>19. Counting Sundays</h2><h3 id="Problem-Description-8"><a href="#Problem-Description-8" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>You are given the following information, but you may prefer to do some research for yourself.</p><ul><li>1 Jan 1900 was a Monday.</li><li>Thirty days has September,<br>April, June and November.<br>All the rest have thirty-one,<br>Saving February alone,<br>Which has twenty-eight, rain or shine.<br>And on leap years, twenty-nine.</li><li>A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.</li></ul><p>How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?</p><h3 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1"></a>Solution1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?</span></span><br><span class="line"><span class="comment"># First we need to find the sum of the days from Febrary to December every year from 1901 to 2000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSundaysPerYear</span><span class="params">(input_year, first_day)</span>:</span></span><br><span class="line">    <span class="comment"># 31 days per month</span></span><br><span class="line">    month_list1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br><span class="line">    <span class="comment"># 30 days per month</span></span><br><span class="line">    month_list2 = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">11</span>]</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    month = <span class="number">1</span></span><br><span class="line">    <span class="comment"># input the location of the first day in this year as variable first_day</span></span><br><span class="line">    <span class="keyword">while</span> month &lt;= <span class="number">12</span>:</span><br><span class="line">        <span class="keyword">if</span> first_day % <span class="number">7</span> == <span class="number">0</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> month <span class="keyword">in</span> month_list1:</span><br><span class="line">            first_day += <span class="number">31</span></span><br><span class="line">        <span class="keyword">elif</span> month <span class="keyword">in</span> month_list2:</span><br><span class="line">            first_day += <span class="number">30</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> (input_year % <span class="number">4</span> == <span class="number">0</span> <span class="keyword">and</span> input_year % <span class="number">100</span> != <span class="number">0</span>) <span class="keyword">or</span> (input_year % <span class="number">400</span> == <span class="number">0</span>):</span><br><span class="line">                first_day += <span class="number">29</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                first_day += <span class="number">28</span></span><br><span class="line">        month += <span class="number">1</span></span><br><span class="line">    <span class="comment"># print count</span></span><br><span class="line">    <span class="keyword">return</span> (first_day % <span class="number">7</span>, count)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_day = <span class="number">2</span></span><br><span class="line">    final_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> year <span class="keyword">in</span> xrange(<span class="number">1901</span>, <span class="number">2001</span>):</span><br><span class="line">        <span class="comment"># print (year, start_day)</span></span><br><span class="line">        <span class="comment"># print "-------"</span></span><br><span class="line">        result_tuple = countSundaysPerYear(year, start_day)</span><br><span class="line">        start_day = result_tuple[<span class="number">0</span>]</span><br><span class="line">        final_count += result_tuple[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">print</span> final_count</span><br></pre></td></tr></table></figure><h3 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2"></a>Solution2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line">result_list = [calendar.weekday(year,month,<span class="number">1</span>) <span class="keyword">for</span> year <span class="keyword">in</span> range(<span class="number">1901</span>, <span class="number">2001</span>) <span class="keyword">for</span> month <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">13</span>)]</span><br><span class="line"><span class="keyword">print</span> result_list.count(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>python提供<code>calendar</code>模块实现日历功能，提供对日期的操作函数，常用函数说明如下：<a href="https://www.cnblogs.com/liuxiaowei/p/7263888.html。" target="_blank" rel="noopener">https://www.cnblogs.com/liuxiaowei/p/7263888.html。</a></p><h2 id="20-Factorial-digit-sum"><a href="#20-Factorial-digit-sum" class="headerlink" title="20. Factorial digit sum"></a>20. Factorial digit sum</h2><h3 id="Problem-Description-9"><a href="#Problem-Description-9" class="headerlink" title="Problem Description"></a>Problem Description</h3><p><em>n</em>! means <em>n</em> × (<em>n</em> − 1) × … × 3 × 2 × 1</p><p>For example, 10! = 10 × 9 × … × 3 × 2 × 1 = 3628800,<br>and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.</p><p>Find the sum of the digits in the number 100!</p><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Count the sum of digits of 100!</span></span><br><span class="line"><span class="keyword">import</span> math </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countDigitSum</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    sum_number = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> input_number != <span class="number">0</span>:</span><br><span class="line">        sum_number += input_number % <span class="number">10</span></span><br><span class="line">        input_number /= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> sum_number</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    final_result = countDigitSum(math.factorial(<span class="number">100</span>))</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;11-Largest-product-in-a-grid&quot;&gt;&lt;a href=&quot;#11-Largest-product-in-a-grid&quot; class=&quot;headerlink&quot; title=&quot;11. Largest product in a grid&quot;&gt;&lt;/a&gt;1
      
    
    </summary>
    
      <category term="Mathematics" scheme="https://blank-vax.github.io/categories/Mathematics/"/>
    
    
      <category term="Euler-Project" scheme="https://blank-vax.github.io/tags/Euler-Project/"/>
    
  </entry>
  
  <entry>
    <title>Euler-Project(I)</title>
    <link href="https://blank-vax.github.io/2020/10/13/Euler-Project(I)/"/>
    <id>https://blank-vax.github.io/2020/10/13/Euler-Project(I)/</id>
    <published>2020-10-13T13:40:00.000Z</published>
    <updated>2020-11-09T03:42:02.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Multiples-of-3-and-5"><a href="#1-Multiples-of-3-and-5" class="headerlink" title="1. Multiples of 3 and 5"></a>1. Multiples of 3 and 5</h2><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p><p>Find the sum of all the multiples of 3 or 5 below 1000.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># below 1000 </span></span><br><span class="line"><span class="comment"># multiples of 3 and 5</span></span><br><span class="line"><span class="comment"># 3*(1+2+3+...+999/3) + 5*(1+2+3+...+999/5) - 15*(1+2+3+...+999/15)</span></span><br><span class="line"><span class="comment"># Note that 1+2+3+...+p = 1/2*p*(p+1)</span></span><br><span class="line"></span><br><span class="line">count_result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">1000</span>, <span class="number">3</span>):</span><br><span class="line">    count_result += item</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item2 <span class="keyword">in</span> range(<span class="number">5</span>, <span class="number">1000</span>, <span class="number">5</span>):</span><br><span class="line">    <span class="keyword">if</span> item2 % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        count_result += item2</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> count_result</span><br></pre></td></tr></table></figure><h2 id="2-Even-Fibonacci-numbers"><a href="#2-Even-Fibonacci-numbers" class="headerlink" title="2. Even Fibonacci numbers"></a>2. Even Fibonacci numbers</h2><h3 id="Problem-Description-1"><a href="#Problem-Description-1" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:</p><p>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …</p><p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</span></span><br><span class="line"><span class="comment"># odd even odd odd even odd odd even odd odd even</span></span><br><span class="line"><span class="comment"># Find the total number of the Fibonacci numbers below four million</span></span><br><span class="line">origin1 = <span class="number">1</span></span><br><span class="line">origin2 = <span class="number">2</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">final_result = <span class="number">2</span></span><br><span class="line">origin_new = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> origin_new &lt; <span class="number">4000000</span>:</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    origin_new = origin1 + origin2</span><br><span class="line">    <span class="keyword">if</span> count % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        final_result += origin_new</span><br><span class="line">    origin1, origin2 = origin2, origin_new</span><br><span class="line"><span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/B1ank/jc6fdpc0v7fvtpnzuxsevck1/image-20200905003907639.png" alt="image-20200905003907639.png-85.4kB"></p><p><img src="http://static.zybuluo.com/B1ank/pr151z8yj1cs4mvt1e9v5idz/image-20200905003924792.png" alt="image-20200905003924792.png-79.6kB"></p><h2 id="3-Largest-prime-factor"><a href="#3-Largest-prime-factor" class="headerlink" title="3. Largest prime factor"></a>3. Largest prime factor</h2><h3 id="Problem-Description-2"><a href="#Problem-Description-2" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The prime factors of 13195 are 5, 7, 13 and 29.</p><p>What is the largest prime factor of the number 600851475143 ?</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Largest prime factor of designated number 600851475143</span></span><br><span class="line"><span class="comment"># Note the key word: prime factor</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Those numbers who are some times of evens or some odd must be composite numbers</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">3</span>, int(math.sqrt(n))+<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> n % item == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime2</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    All numbers can be shown as such numbers:6n, 6n+1, 6n+2, 6n+3, 6n+4, 6n+5</span></span><br><span class="line"><span class="string">    In these numbers, besides 2 and 3, only 6n+1 and 6n+5 may be primes.</span></span><br><span class="line"><span class="string">    For those who can be shown by 6n+1 and 6n+5 but aren't primes, they can be some times of 6n+1 or 6n+5</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span> <span class="keyword">or</span> n == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">6</span> != <span class="number">1</span> <span class="keyword">and</span> n % <span class="number">6</span> != <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(math.sqrt(n))+<span class="number">1</span>):</span><br><span class="line">        division = <span class="number">5</span> + (i+<span class="number">1</span>)*<span class="number">6</span> </span><br><span class="line">        <span class="keyword">if</span> (n // division &gt; <span class="number">1</span>) <span class="keyword">or</span> (n // (division+<span class="number">2</span>) &gt; <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># division == 6n+5, division+2 == 6n+1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">possible_result = []</span><br><span class="line">final_number = <span class="number">600851475143</span></span><br><span class="line">item = int(math.sqrt(final_number))+<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> item &gt;= <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> final_number % item == <span class="number">0</span>:</span><br><span class="line">        possible_result.append(item)</span><br><span class="line">    item -= <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> possible_result:</span><br><span class="line">    <span class="keyword">if</span> isPrime(result):</span><br><span class="line">        <span class="keyword">print</span> result</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h3><p>本题也可以使用厄拉多塞筛法寻找输入数字范围内所有的素数。因为素数的倍数一定不是素数，所以我们找到一个素数时可以将其倍数从所给范围内排除。这种方法称为素数筛。例如求100以内的素数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">100</span></span><br><span class="line">L = list(range(<span class="number">2</span>, n))</span><br><span class="line">ans = set()</span><br><span class="line"><span class="keyword">while</span> L:</span><br><span class="line">    x = L.pop(<span class="number">0</span>)</span><br><span class="line">    ans.add(x)</span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> i*x &lt; n:</span><br><span class="line">        <span class="keyword">if</span> i*x <span class="keyword">in</span> L:</span><br><span class="line">            L.remove(i*x)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">print(ans)</span><br><span class="line"><span class="comment"># ans = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97&#125;</span></span><br></pre></td></tr></table></figure><p>基于以上思想，在找输入数字因数时可以将合数筛出，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ans = []</span><br><span class="line">n = <span class="number">600851475143</span></span><br><span class="line">iter_max = int(n ** <span class="number">0.5</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">2</span>,iter_max):</span><br><span class="line">    <span class="keyword">if</span> n%num == <span class="number">0</span>:</span><br><span class="line">        ans.append(num)</span><br><span class="line">        n/=num</span><br><span class="line">        <span class="keyword">while</span> n%num == <span class="number">0</span>:</span><br><span class="line">            n/=num <span class="comment"># 保证n已被num除尽，此时n不会再有num*i的因数</span></span><br><span class="line">print(ans)</span><br><span class="line">ans = [<span class="number">71</span>, <span class="number">839</span>, <span class="number">1471</span>, <span class="number">6857</span>]</span><br></pre></td></tr></table></figure><h3 id="素数判别法"><a href="#素数判别法" class="headerlink" title="素数判别法"></a>素数判别法</h3><h4 id="根号判别法"><a href="#根号判别法" class="headerlink" title="根号判别法"></a>根号判别法</h4><p>设输入的数字为n，则可以通过遍历方法暴力搜索其素因子，若出现非1及其本身的素因子，则可断定该数字为素数。常见的遍历范围为1—n-1，其实将遍历范围调节至1—$\sqrt{n}$亦可实现素数判定的目的。</p><h4 id="奇偶判别法"><a href="#奇偶判别法" class="headerlink" title="奇偶判别法"></a>奇偶判别法</h4><p>对于所有可能成为数字x素因子的n-1个数字，偶数中除了2均不是质数，且奇数的因数没有偶数，因此可以继续优化。首先将n与2进行比较，其次判断2是否为n的素因子，最后从3开始以2为增幅逐次判断数字n是否包含奇数因子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Those numbers who are some times of evens or some odd must be composite numbers</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">3</span>, int(math.sqrt(n))+<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> n % item == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="6n系判别"><a href="#6n系判别" class="headerlink" title="6n系判别"></a>6n系判别</h4><p>所有数字均可表示为6n，6n+1，6n+2，6n+3，6n+4，6n+5的形式，除2和3以外，所有的素数都可以表示为6n+1和6n+5的形式，如果输入数字x是6n+1和6n+5的整数倍，则必为合数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime2</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    All numbers can be shown as such numbers:6n, 6n+1, 6n+2, 6n+3, 6n+4, 6n+5</span></span><br><span class="line"><span class="string">    In these numbers, besides 2 and 3, only 6n+1 and 6n+5 may be primes.</span></span><br><span class="line"><span class="string">    For those who can be shown by 6n+1 and 6n+5 but aren't primes, they can be some times of 6n+1 or 6n+5</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span> <span class="keyword">or</span> n == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">6</span> != <span class="number">1</span> <span class="keyword">and</span> n % <span class="number">6</span> != <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(math.sqrt(n))+<span class="number">1</span>):</span><br><span class="line">        division = <span class="number">5</span> + (i+<span class="number">1</span>)*<span class="number">6</span> </span><br><span class="line">        <span class="keyword">if</span> (n // division &gt; <span class="number">1</span>) <span class="keyword">or</span> (n // (division+<span class="number">2</span>) &gt; <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># division == 6n+5, division+2 == 6n+1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="Miller-Rabin素数判别法"><a href="#Miller-Rabin素数判别法" class="headerlink" title="Miller-Rabin素数判别法"></a>Miller-Rabin素数判别法</h4><p>该素数判别方法应用费马小定理对素数进行概率判定，若输入数字N通过t次测试，则N不是素数的概率仅为$(1/4)^{t}$，随着通过测试次数的增加，N是素数的概率无穷逼近于1。在实际运用中，可首先用300—500个小素数对N进行测试，以提高测试通过的概率与算法的速度。</p><p>具体步骤如下：</p><ul><li>计算奇数M，使得N=$2^{r}*M+1$；</li><li>选择随机数A&lt;N；</li><li>对于任意i&lt;r，若$A^{(2^{i}*M)}mod N=N-1$，则N通过随机数A的测试；</li><li>或者若$A^{M}modN=1$，则N通过随机数A的测试；</li><li>改变随机数A的值对N进行多次测试（一般为5—10次，较高需求的情况下可进行20—30次），若全部通过则判定N为素数。</li></ul><p>相关代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fast_power</span><span class="params">(base, power, n)</span>:</span></span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    tmp = base</span><br><span class="line">    <span class="keyword">while</span> power &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> power&amp;<span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">            result = (result * tmp) % n</span><br><span class="line">        tmp = (tmp * tmp) % n </span><br><span class="line">        power = power&gt;&gt;<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Miller_Rabin</span><span class="params">(n, iter_num)</span>:</span></span><br><span class="line">    <span class="comment"># 2 is prime</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="comment"># if n is even or less than 2, then n is not a prime</span></span><br><span class="line">    <span class="keyword">if</span> n&amp;<span class="number">1</span> == <span class="number">0</span> <span class="keyword">or</span> n&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># n-1 = (2^s)m</span></span><br><span class="line">    <span class="comment"># get random odd m</span></span><br><span class="line">    m,s = n - <span class="number">1</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> m&amp;<span class="number">1</span>==<span class="number">0</span>:</span><br><span class="line">        m = m&gt;&gt;<span class="number">1</span></span><br><span class="line">        s += <span class="number">1</span></span><br><span class="line">    <span class="comment"># M-R </span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(iter_num):</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        key algorithm</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        b = fast_power(random.randint(<span class="number">2</span>,n<span class="number">-1</span>), m, n)</span><br><span class="line">        <span class="keyword">if</span> b==<span class="number">1</span> <span class="keyword">or</span> b== n<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> __ <span class="keyword">in</span> range(s<span class="number">-1</span>):</span><br><span class="line">            b = fast_power(b, <span class="number">2</span>, n)</span><br><span class="line">            <span class="keyword">if</span> b == n<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># example</span></span><br><span class="line">    print(Miller_Rabin(<span class="number">49139</span>, <span class="number">10</span>))</span><br><span class="line">    print(Miller_Rabin(<span class="number">561</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><h4 id="素数筛查"><a href="#素数筛查" class="headerlink" title="素数筛查"></a>素数筛查</h4><p>除了上述的高级试除法外，还可以使用素数筛查的方法。常见的素数筛查包括埃拉托斯特尼筛法和欧拉筛法。</p><p>埃氏筛法由希腊数学家埃拉托斯特尼提出，用以简单鉴定素数，方法如下：要获取自然数n（上界）内的全部素数，必须剔除所有小于等于sqrt(n)的素数的倍数，经过此种筛查后，剩下的就是素数。</p><p>欧拉筛法是埃氏筛法的改进。采用欧拉筛法进行筛选过程中，对于含多个因子的数字需要进行多次筛选，耗费部分运行时间。例如，对于合数20，可分解为2*10，4*5，故至少需要筛选两次。欧拉筛过程中引入语句<code>if i%prime[j] == 0: break</code>，保证每个合数只被这个合数最小的质因子筛除，而且不出现重复筛除。</p><p>代码实现可参考：<a href="https://blog.csdn.net/FeilingGong/article/details/83660779?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">素数筛法详解（欧拉筛&amp;埃氏筛）</a>。</p><h2 id="4-Largest-palindrome-product"><a href="#4-Largest-palindrome-product" class="headerlink" title="4. Largest palindrome product"></a>4. Largest palindrome product</h2><h3 id="Problem-Description-3"><a href="#Problem-Description-3" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.</p><p>Find the largest palindrome made from the product of two 3-digit numbers.</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    Suppose that P = a*b = 100000*x+10000*y+1000*z+100*z+10*y+x = 11*(9091*x+910*y+100*z)</span></span><br><span class="line"><span class="string">    The range of a and b are both 100 to 999</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    reversed = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> input_number &gt; <span class="number">0</span>:</span><br><span class="line">        reversed = reversed*<span class="number">10</span> + input_number % <span class="number">10</span></span><br><span class="line">        input_number /= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> reversed</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> input_number == reverse(input_number)</span><br><span class="line"></span><br><span class="line">largest_number = <span class="number">0</span></span><br><span class="line">a = <span class="number">999</span></span><br><span class="line"><span class="keyword">while</span> a &gt;= <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">if</span> a % <span class="number">11</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># Then b doesn't need to contain prime factor 11</span></span><br><span class="line">        b = <span class="number">999</span></span><br><span class="line">        b_down = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># b needs to contain prime factor 11</span></span><br><span class="line">        b = <span class="number">990</span></span><br><span class="line">        b_down = <span class="number">11</span></span><br><span class="line">    <span class="keyword">while</span> b &gt;= <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">if</span> a*b &lt;= largest_number:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> isPalindrome(a*b):</span><br><span class="line">            largest_number = a*b</span><br><span class="line">        b = b - b_down</span><br><span class="line">    a = a - <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> largest_number</span><br></pre></td></tr></table></figure><h2 id="5-Smallest-multiple"><a href="#5-Smallest-multiple" class="headerlink" title="5. Smallest multiple"></a>5. Smallest multiple</h2><h3 id="Problem-Description-4"><a href="#Problem-Description-4" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.</p><p>What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    The factors are 20 numbers from 1 to 20</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    All numbers can be shown as such numbers:6n, 6n+1, 6n+2, 6n+3, 6n+4, 6n+5</span></span><br><span class="line"><span class="string">    In these numbers, besides 2 and 3, only 6n+1 and 6n+5 may be primes.</span></span><br><span class="line"><span class="string">    For those who can be shown by 6n+1 and 6n+5 but aren't primes, they can be some times of 6n+1 or 6n+5</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span> <span class="keyword">or</span> n == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">6</span> != <span class="number">1</span> <span class="keyword">and</span> n % <span class="number">6</span> != <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(math.sqrt(n))+<span class="number">1</span>):</span><br><span class="line">        division = <span class="number">5</span> + (i+<span class="number">1</span>)*<span class="number">6</span> </span><br><span class="line">        <span class="keyword">if</span> (n // division &gt; <span class="number">1</span>) <span class="keyword">or</span> (n // (division+<span class="number">2</span>) &gt; <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># division == 6n+5, division+2 == 6n+1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">factors_list = []</span><br><span class="line">original_list = [x+<span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">20</span>)]</span><br><span class="line"><span class="keyword">print</span> original_list</span><br><span class="line"><span class="comment"># Get all primes</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> original_list:</span><br><span class="line">    <span class="keyword">if</span> isPrime(item):</span><br><span class="line">        factors_list.append(item)</span><br><span class="line"></span><br><span class="line">k = <span class="number">20</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">N = <span class="number">1</span></span><br><span class="line">edge_number = math.sqrt(k)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> i == len(factors_list):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> factors_list[i] &lt;= edge_number:</span><br><span class="line">        N = N*pow(factors_list[i], math.floor(math.log(k)/math.log(factors_list[i])))</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> N</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        N = N*factors_list[i]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> N</span><br><span class="line"><span class="keyword">print</span> N</span><br></pre></td></tr></table></figure><p>分析题目，首先以1—10之间的数字为例，我们进行以下操作：</p><ul><li>Step1：寻找2—10内所有素数，即2、3、5、7，则剩余合数均可以素数的幂乘积的形式表示；待求的最小倍数可以表示为$min_multiply = 2^a<em>3^b</em>5^c*7^d$。</li><li>Step2：分解剩余合数，均表示为min_multiply所示形式。</li><li>Step3：取最大指数作为待求参数a，b，c，d的值。</li></ul><p>现令N为可被2—k间所有数字整除的最小数字，分析求解N的过程。参考上述k=10时的分析，首先确定所有小于k的素数，存入列表P。随后确定列表中每个元素的次数，令$P[i]^{a[i]} = k$，两侧同时进行对数运算并向下取整，得$a[i] = floor(log(k) / log(P[i]))$。值得注意的是，当$P[i]^{2} &gt; k$时，a[i]==1，故只需要计算满足$P[i] &lt;= \sqrt(k)$对应素数的次数a[i]。最终$N=P[0]^{a[0]}<em>P<a href="http://static.zybuluo.com/B1ank/jc6fdpc0v7fvtpnzuxsevck1/image-20200905003907639.png" target="_blank" rel="noopener">1</a>^{a<a href="http://static.zybuluo.com/B1ank/jc6fdpc0v7fvtpnzuxsevck1/image-20200905003907639.png" target="_blank" rel="noopener">1</a>}</em>P<a href="http://static.zybuluo.com/B1ank/pr151z8yj1cs4mvt1e9v5idz/image-20200905003924792.png" target="_blank" rel="noopener">2</a>^{a<a href="http://static.zybuluo.com/B1ank/pr151z8yj1cs4mvt1e9v5idz/image-20200905003924792.png" target="_blank" rel="noopener">2</a>}*……..$</p><h2 id="6-Sum-square-difference"><a href="#6-Sum-square-difference" class="headerlink" title="6. Sum square difference"></a>6. Sum square difference</h2><h3 id="Problem-Description-5"><a href="#Problem-Description-5" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The sum of the squares of the first ten natural numbers is,</p><script type="math/tex; mode=display">1^2 + 2^2 + ... + 10^2 = 385</script><p>The square of the sum of the first ten natural numbers is,</p><script type="math/tex; mode=display">(1 + 2 + ... + 10)^2 = 55^2 = 3025</script><p>Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is $3025 - 385 = 2640$.</p><p>Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    sum1 = 1+2+3+..+n = n*(n+1)/2</span></span><br><span class="line"><span class="string">    sum2 = 1**2 + 2**2 + 3**2 +...+ n**2 = n*(n+1)*(2*n+1)/6</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">sum1 = <span class="number">100</span>*<span class="number">101</span>/<span class="number">2</span></span><br><span class="line">sum2 = <span class="number">100</span>*<span class="number">101</span>*<span class="number">201</span>/<span class="number">6</span></span><br><span class="line"><span class="keyword">print</span> sum2-sum1</span><br></pre></td></tr></table></figure><h2 id="7-10001st-prime"><a href="#7-10001st-prime" class="headerlink" title="7. 10001st prime"></a>7. 10001st prime</h2><h3 id="Problem-Description-6"><a href="#Problem-Description-6" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.</p><p>What is the 10 001st prime number?</p><h3 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1"></a>Solution1</h3><p>题目只给出素数的个数，最简单的思路就是循环计数与素数判断相结合。素数判断过程中，现补充事实如下：</p><ul><li>1不是素数</li><li>除2以外的所有素数均为奇数</li><li>所有比3大的素数均可以写成6k+/-1的形式，k为整数</li><li>如果我们无法找到小于等于sqrt(n)并能够整除n的数字f，则可以判定n为素数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Method1: Round and prime judgement</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> input_number == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> input_number &lt; <span class="number">4</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">    <span class="keyword">elif</span> input_number % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> input_number &lt; <span class="number">9</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> input_number % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        limit = math.floor(math.sqrt(input_number))</span><br><span class="line">        f = <span class="number">5</span></span><br><span class="line">        <span class="keyword">while</span> f &lt;= limit:</span><br><span class="line">            <span class="comment"># Which means 6n-1</span></span><br><span class="line">            <span class="keyword">if</span> input_number % f == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># We must plus 2 to get 6n+1</span></span><br><span class="line">            <span class="keyword">if</span> input_number % (f+<span class="number">2</span>) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            f += <span class="number">6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">final_number = <span class="number">3</span></span><br><span class="line">count = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">10001</span>:</span><br><span class="line">    final_number += <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> isPrime(final_number):</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">print</span> final_number</span><br></pre></td></tr></table></figure><h3 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2"></a>Solution2</h3><p>本题也可以采用埃拉托斯特尼筛法进行求解，求解的关键是确定第10001个素数的上界。为确保一定会出现第10001个素数，取较大的上界为1000000。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Method2: a sieve of Eratosthenes</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPrime</span><span class="params">(L)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> L[i]**<span class="number">2</span> &lt; L[<span class="number">-1</span>]:</span><br><span class="line">        <span class="comment"># Eratosthenes algorithm</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(L)):</span><br><span class="line">            <span class="keyword">if</span> L[j] % L[i] == <span class="number">0</span>:</span><br><span class="line">                L[j] = <span class="number">0</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        L.sort()</span><br><span class="line">        L = L[count:]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"><span class="comment"># L = (2,3,4,...,1000000)</span></span><br><span class="line">L = range(<span class="number">2</span>, <span class="number">1000000</span>)</span><br><span class="line">primes_list = findPrime(L)</span><br><span class="line">print(primes_list[<span class="number">10000</span>])</span><br></pre></td></tr></table></figure><h2 id="8-Largest-product-in-a-series"><a href="#8-Largest-product-in-a-series" class="headerlink" title="8. Largest product in a series"></a>8. Largest product in a series</h2><h3 id="Problem-Description-7"><a href="#Problem-Description-7" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.</p><p>73167176531330624919225119674426574742355349194934<br>96983520312774506326239578318016984801869478851843<br>85861560789112949495459501737958331952853208805511<br>12540698747158523863050715693290963295227443043557<br>66896648950445244523161731856403098711121722383113<br>62229893423380308135336276614282806444486645238749<br>30358907296290491560440772390713810515859307960866<br>70172427121883998797908792274921901699720888093776<br>65727333001053367881220235421809751254540594752243<br>52584907711670556013604839586446706324415722155397<br>53697817977846174064955149290862569321978468622482<br>83972241375657056057490261407972968652414535100474<br>82166370484403199890008895243450658541227588666881<br>16427171479924442928230863465674813919123162824586<br>17866458359124566529476545682848912883142607690042<br>24219022671055626321111109370544217506941658960408<br>07198403850962455444362981230987879927244284909188<br>84580156166097919133875499200524063689912560717606<br>05886116467109405077541002256983155200055935729725<br>71636269561882670428252483600823257530420752963450</p><p>Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?</p><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    Find the thirteen adjacent digits in the 1000-digits number</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">input_number = given_string</span><br><span class="line"><span class="comment"># Transform the 1000-digits number to number list in order to get each number seperately</span></span><br><span class="line">input_number_list = [eval(input_number[i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(input_number))]</span><br><span class="line">maximum_number = <span class="number">0</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt;= len(input_number) - <span class="number">13</span>:</span><br><span class="line">    <span class="comment"># Combination of function reduce() and lambda function</span></span><br><span class="line">    result_number = reduce(<span class="keyword">lambda</span> x, y: x*y, input_number_list[count:count+<span class="number">13</span>])</span><br><span class="line">    <span class="keyword">if</span> result_number &gt; maximum_number:</span><br><span class="line">        maximum_number = result_number</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> maximum_number</span><br></pre></td></tr></table></figure><h2 id="9-Special-Pythagorean-triplet"><a href="#9-Special-Pythagorean-triplet" class="headerlink" title="9. Special Pythagorean triplet"></a>9. Special Pythagorean triplet</h2><h3 id="Problem-Description-8"><a href="#Problem-Description-8" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>A Pythagorean triplet is a set of three natural numbers, a &lt; b &lt; c, for which,</p><script type="math/tex; mode=display">a^{2} + b^{2} = c^{2}</script><p>For example, $3^{2} + 4^{2} = 9 + 16 = 25 = 5^{2}$.</p><p>There exists exactly one Pythagorean triplet for which a + b + c = 1000.<br>Find the product abc.</p><h3 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1"></a>Solution1</h3><p>可以采用放缩的方法，以题目所给的1000为例，设$ a=m1<em>k，b=m2</em>k，c=m3*k$，这里m1，m2，m3为小于50的勾股数。故只需要寻找满足1000 % (m1+m2+m3) == 0的勾股数并相应扩大k倍，使其满足a+b+c == 1000即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    1. a+b+c = 1000</span></span><br><span class="line"><span class="string">    2. Suppose a&lt;b&lt;c,then we get a^2 + b^2 = c^2</span></span><br><span class="line"><span class="string">    3. Find a,b,c and calculate abc</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># First find all the Pythagorean triplet number under 50</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">50</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">50</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">50</span>):</span><br><span class="line">            <span class="keyword">if</span> i**<span class="number">2</span>+j**<span class="number">2</span> == k**<span class="number">2</span> <span class="keyword">and</span> <span class="number">1000</span>%(i+j+k) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">print</span> i*j*k*(<span class="number">1000</span>/(i+j+k))**<span class="number">3</span></span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2"></a>Solution2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the only Pythagorean triplet(a, b, c), for which a+b+c = 1000</span></span><br><span class="line"><span class="comment"># a^2+b^2=(s-a-b)^2, cause a&lt;b&lt;c, then a&lt;=(s-3)/3 and b &lt;(s-a)/2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPythagorean</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">3</span>, (s<span class="number">-3</span>)//<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> range(a+<span class="number">1</span>, (s<span class="number">-1</span>-a)//<span class="number">2</span>):</span><br><span class="line">            c = s-a-b</span><br><span class="line">            <span class="keyword">if</span> c*c == a*a + b*b:</span><br><span class="line">                <span class="keyword">print</span> (a,b,c)</span><br><span class="line">                <span class="keyword">return</span> a*b*c</span><br><span class="line"></span><br><span class="line">final_multiply = getPythagorean(<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">print</span> final_multiply</span><br></pre></td></tr></table></figure><h3 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h3><p>下面通过勾股数的一些性质简化解法二中的代码，提高程序运行效率。</p><p>如果勾股数(a, b, c)满足gcd(a, b, c) = 1，定义该类勾股数具有素数性质。同时，任意组勾股数(a, b, c)可表示为：</p><script type="math/tex; mode=display">a = m^{2}-n^{2}，b = 2*m*n，c = m^{2}+n^{2}，m>n>0 (9.1)</script><p>由于勾股数可通过倍乘进行放缩，故可对(a, b, c)进行运算，得到以下结果：</p><script type="math/tex; mode=display">a = (m^{2}-n^{2})*d，b = 2*m*n*d，c = (m^{2}+n^{2})*d, m>n>0 (9.2)</script><p>使用以上性质，我们可得：</p><script type="math/tex; mode=display">a+b+c = 2*m*(m+n)*d (9.3)</script><p>所以想要找到勾股数组合(a, b, c)满足a+b+c = s，我们需要在1—s/2之间寻找除数m，并寻找s/2m的奇除数k（此处k=m+n，k满足m &lt; k &lt; 2m，并且m，k互素）。随后令n = k - m，d = s/2mk，将该结果插入式(9.2)中，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">euclid_gcd</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> a &lt; b:</span><br><span class="line">        a, b = b, a</span><br><span class="line">    <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">        a, b = b, a%b</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPythagorean</span><span class="params">(s2, mlimit)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">2</span>, mlimit):</span><br><span class="line">        <span class="keyword">if</span> s2 % m == <span class="number">0</span>:</span><br><span class="line">            sm = s2 // m</span><br><span class="line">            <span class="keyword">while</span> sm % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                sm = sm // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> m % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                k = m+<span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                k = m+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> k &lt; <span class="number">2</span>*m <span class="keyword">and</span> k &lt;= sm:</span><br><span class="line">                <span class="keyword">if</span> sm % k == <span class="number">0</span> <span class="keyword">and</span> euclid_gcd(k, m) == <span class="number">1</span>:</span><br><span class="line">                    d = s2 // (k*m)</span><br><span class="line">                    n = k - m</span><br><span class="line">                    a = d*(m*m-n*n)</span><br><span class="line">                    b = <span class="number">2</span>*d*m*n</span><br><span class="line">                    c = d*(m*m+n*n)</span><br><span class="line">                    <span class="keyword">print</span> (a, b, c)</span><br><span class="line">                    <span class="keyword">return</span> a*b*c</span><br><span class="line">                k += <span class="number">2</span></span><br><span class="line">s = <span class="number">1000</span></span><br><span class="line">s2 = s // <span class="number">2</span></span><br><span class="line">mlimit = int(math.ceil(math.sqrt(s2))) - <span class="number">1</span></span><br><span class="line">final_result = getPythagorean(s2, mlimit)</span><br><span class="line"><span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h2 id="10-Sum-all-primes-below-N-million"><a href="#10-Sum-all-primes-below-N-million" class="headerlink" title="10. Sum all primes below N million"></a>10. Sum all primes below N million</h2><h3 id="Problem-Description-9"><a href="#Problem-Description-9" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.</p><p>Find the sum of all the primes below two million.</p><h3 id="Solution1-3"><a href="#Solution1-3" class="headerlink" title="Solution1"></a>Solution1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sum after the sieve of Eratosthenes</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPrime</span><span class="params">(L)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> L[i]**<span class="number">2</span> &lt; L[<span class="number">-1</span>]:</span><br><span class="line">        <span class="comment"># Eratosthenes algorithm</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(L)):</span><br><span class="line">            <span class="keyword">if</span> L[j] % L[i] == <span class="number">0</span>:</span><br><span class="line">                L[j] = <span class="number">0</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        L.sort()</span><br><span class="line">        L = L[count:]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line">L = range(<span class="number">2</span>, <span class="number">2000000</span>)</span><br><span class="line">primes_list = findPrime(L)</span><br><span class="line"><span class="keyword">print</span> reduce(<span class="keyword">lambda</span> x,y:x+y, primes_list)</span><br></pre></td></tr></table></figure><h3 id="Solution2-3"><a href="#Solution2-3" class="headerlink" title="Solution2"></a>Solution2</h3><p>除2以外的所有偶数均为合数，故只需要对所给范围2—N内的奇数进行素性判断。我们建立下标i与奇数2*i+1的对应关系。首先建立布尔类型数组，其长度为(N-1)/2，初始值均为False，表示全为素数。设p=2*i+1，则$p^{2}=4<em>i^{2}+4</em>i+1$，其对应的数组下标为2*i+1；设m=k*p，则m+2*p对应的下标为j+p。</p><p>同样参考埃氏筛的思路，下一步需要找外部循环的下标范围、内部循环的初始值以及步进参数。结合以上分析进行讨论。由$2<em>i_max+1&lt;= \sqrt(N)$可得i的范围为$(\lfloor N\rfloor -1) / 2$，该范围是外部循环的下标范围。对于奇数p，所有小于p^2的数字中若为合数则必可被小于p的素数整除，故内部循环的初始值设定为p^2，对应下标为2\</em>i*(i+1)。又$p^{2}+p = 4<em>i^{2}+4</em>i+1+2<em>i+1 = 4</em>i^{2}+6<em>i+2 = 2</em>(2<em>i^{2}+3</em>i+1)$，可知若以p为步进，则得到的结果必为合数，无需进行判断。同时$p^{2}+2<em>p = 2</em>(2<em>i+1)+1 = 4</em>i^{2}+8*i+3 $，可以看出该结果必为合数，同时该结果为p的倍数，将数组对应下标位置标记为True。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Some imporvement of the sieve of Eratosthenes</span></span><br><span class="line"><span class="comment"># Only consider the odd numbers, do some index-arithmetics</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPrimes</span><span class="params">(sievebound, sieve_set, input_number)</span>:</span></span><br><span class="line">    crosslimit = int(math.floor(math.sqrt(input_number)<span class="number">-1</span> // <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, crosslimit):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sieve_set[i]:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>*i*(i+<span class="number">1</span>), sievebound, <span class="number">2</span>*i+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 2*j+1 is compositive</span></span><br><span class="line">                sieve_set[j] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> sieve_set</span><br><span class="line">input_number = <span class="number">2000000</span></span><br><span class="line">sievebound = int(math.floor((input_number<span class="number">-1</span>) // <span class="number">2</span>))</span><br><span class="line">sieve_set = [<span class="literal">False</span>]*input_number</span><br><span class="line">sieve_set_after_deal = findPrimes(sievebound, sieve_set, input_number)</span><br><span class="line">sum_result = <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, sievebound):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sieve_set[k]:</span><br><span class="line">        sum_result += <span class="number">2</span>*k+<span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> sum_result</span><br></pre></td></tr></table></figure><p>以题中所给的2000000为例，解法一运行速度为8s左右，解法二运行速度大大提升，只需要0.417s。</p><p><img src="http://static.zybuluo.com/B1ank/2tqy88plzqi5gbvh1m37hw2r/10_sufficiency.PNG" alt="10_sufficiency.PNG-11.2kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Multiples-of-3-and-5&quot;&gt;&lt;a href=&quot;#1-Multiples-of-3-and-5&quot; class=&quot;headerlink&quot; title=&quot;1. Multiples of 3 and 5&quot;&gt;&lt;/a&gt;1. Multiples of 3 a
      
    
    </summary>
    
      <category term="Mathematics" scheme="https://blank-vax.github.io/categories/Mathematics/"/>
    
    
      <category term="Euler-Project" scheme="https://blank-vax.github.io/tags/Euler-Project/"/>
    
  </entry>
  
  <entry>
    <title>21深信服秋招面试</title>
    <link href="https://blank-vax.github.io/2020/09/26/21%E7%A7%8B%E6%8B%9B%E6%B7%B1%E4%BF%A1%E6%9C%8D%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/"/>
    <id>https://blank-vax.github.io/2020/09/26/21秋招深信服秋招面经/</id>
    <published>2020-09-25T16:27:00.000Z</published>
    <updated>2020-11-09T03:40:59.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近日考研期间，适逢深信服”翔鹰计划”线上实习结束，公司给了秋招提前批的面试机会，准备了大概两天就去面试了，岗位是<strong>技服工程师</strong>。由于前期通过笔试，故直接进入技术面、业务面和HR面。</p><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><ul><li>7.19 2020年”翔鹰计划”结束，成绩考核通过，简历转入公司秋招简历池；</li><li>7.23 技服工程师线上技术（一面）面试</li><li>7.30 技服工程师线上业务（二面）面试</li><li>8.4 技服工程师线上HR面试</li><li>9.18 offer沟通</li><li>9.22 签订三方协定（虽然最后没签</li></ul><h2 id="技术面（一面）"><a href="#技术面（一面）" class="headerlink" title="技术面（一面）"></a>技术面（一面）</h2><p>邮件中面试官约定的事件是上午11：00，大概提前两分钟左右进入房间调试设备，不过不知道是牛客网平台原因还是公司网络原因，面试官声音一直断断续续，中间还出现突然静音的情况，于是后期换了腾讯会议。</p><p>面试时间为45分钟，首先进行自我介绍，然后面试官进行提问。问题包括技术问题和非技术问题合计共十个左右，具体如下。</p><h3 id="技术问题"><a href="#技术问题" class="headerlink" title="技术问题"></a>技术问题</h3><ul><li><p>简要介绍VLAN</p><p>回答了VLAN的定义，虚拟局域网。主要作用为将同一网段根据功能划分成不同的虚拟子网。以公司为例，为保证主管、业务、销售、技术等各个部门之间网络的专有通信，引入VLAN技术，实现各部门人员之间在对应虚拟子网内部的高效安全通信，不会产生业务互相影响的情况。</p></li><li><p>简要介绍交换机</p><p>交换机是二层设备，位于数据链路层，主要作用为端口数据帧转发。提到了ARP协议，提出每个交换机维护一个ARP表，以保证不同主机之间的正常通信。顺便讲了一下ARP广播单播，以及相同网段之间主机如何进行通信。</p></li><li><p>针对ARP协议的攻击</p><p>简单讲了ARP欺骗和ARP洪泛攻击，重点介绍了攻击手法及危害。</p></li><li><p>ARP欺骗的防御方法</p><p>由于对ARP欺骗的防御掌握不深入，所以当时简单提到了修改帧结构及增加校验部分，以及进行相关检测。面试官追问哪个设备进行相关检测，然后就没有答上来。面试结束后，参考FreeBuf上的一篇文章：<a href="https://www.freebuf.com/articles/network/210852.html" target="_blank" rel="noopener">浅谈ARP欺骗的实现与防御</a>，归纳两个防御手段：</p><ul><li>主机欺骗：在本机添加一条静态的ARP映射，这样就无需询问网关MAC地址；</li><li>网关欺骗：在网关中也添加一条到主机的静态ARP映射。</li></ul></li><li><p>对路由选择协议的认识</p><p>回答了路由优先级顺序：<strong>直连路由&gt;静态路由&gt;动态路由&gt;默认路由</strong>。静态路由部分只提到需要在路由器上手动配置。动态路由部分提到了内部网关协议与外部网关协议。外部网关协议包括BGP，内部网关协议又分为基于距离矢量的协议和基于链路状态的协议。详细介绍了RIP协议和OSPF协议的工作原理，重点介绍<strong>衡量路径优劣</strong>的标准。</p></li><li><p>网络排查问题：公司中一楼无法正常连网，二楼可正常连网但网速较慢，三楼可正常上网，针对此种情况如何排查解决。</p><p>由于公司和个人网络的排查有所差别，同时我也没有了解过公司的网络排查标准，于是按照个人网络问题进行排查。首先讲了个人PC无法正常联网的排查步骤：</p><ul><li>ping 127.0.0.1，检查TCP/IP协议是否正常配置；</li><li>ping 本机地址，检查网络适配器是否正常配置；</li><li>ping 网关地址，检查网关是否正常配置；</li><li>ping 外网地址，排查重点放在hosts文件中DNS解析是否正常。</li></ul><p>网速较慢这个问题没怎么关注过，简单提到了猜想——公司访问流量限速，当然这是在胡说八道，但是可以用来缓解尴尬，委婉地告诉面试官不怎么会。</p></li><li><p>攻击网站的常见手段</p><p>回答了SQL注入、XSS、CSRF、一句话木马，然后追问一句话木马的工作原理，笼统地回答了一下。</p></li><li><p>了解磁盘冗余阵列RAID吗？</p><p>由于昨天准备的时候刚看到RAID的相关知识，简要回答了RAID 0，RAID 1，RAID 3，RAID 5，RAID p+q等组合方式的特点及优缺点。RAID p+q以RAID 10为例进行详细介绍。</p></li><li><p>了解虚拟化技术吗？</p><p>将虚拟化与云计算技术结合起来回答，大致提到了SaaS，PaaS，IaaS，公有云，私有云，混合云等名词并进行解释。面试官让说出自己对虚拟化的理解，结合aDesk云桌面产品进行了相关说明（感觉自己讲的语无伦次）。本来还想加上虚拟现实技术，后来面试官话锋转到下个问题，只好作罢。</p></li><li><p>常见的加密算法</p><p>终于问到密码学了！（不是）分成对称加密和非对称加密两部分进行回答。对称加密主要介绍了DES，AES，RC4，RC5。非对称加密介绍了三大困难问题及对应的RSA，DH交换和ECC密码体制。顺带提到了消息摘要算法和数字签名算法。</p></li><li><p>以上提到的算法的实际应用</p><p>刚开始想回答数字证书等知识，后来确定回答主题为<strong>非对称加密+对称加密</strong>：对称加密具有加密效率高的特点，相应地安全性较低；非对称加密无法处理大量数据，但安全性较高。故流行的通信方式为通信双方使用非对称加密算法对对称加密密钥进行加解密，从而实现密钥共享，随后使用该密钥结合对称加解密算法进行消息传输。围绕该主题并结合HTTPS加密过程客户端与服务器的相应操作进行作答。</p></li></ul><h3 id="非技术问题"><a href="#非技术问题" class="headerlink" title="非技术问题"></a>非技术问题</h3><ul><li><p>有没有考过网络认证证书+计算机网络知识学习途径</p><p>没考过证书，计网知识除”翔鹰计划”培训外，还上过学校的对应课程，进行过系统学习。</p></li><li><p>经历的压力较大的事情</p><p>聊了聊”美亚杯”比赛的事情（现在感觉当时的回答驴唇不对马嘴）</p></li><li><p>“基于数字水印与神经网络的图像攻击检测系统”项目相关</p><ul><li><p>这个项目中负责的部分</p><p>水印的提取与嵌入算法的实现，水印置乱算法实现，信噪比检验。</p></li><li><p>项目中遇到哪些难题，如何解决？</p><p>只提到当时嵌入提取算法matlab转python实现过程中出现的问题，即无论怎么调整参数，使用python语言实现的算法嵌入水印后的图像都具有明显的水印标记，无法通过信噪比测试。解决方法就是python调matlab脚本（说出来我自己都觉得low，但是当时这个bug调了大概一晚上，所以印象很深刻）。</p></li><li><p>项目中学到了什么？</p><p>从技术和团队合作两方面进行回答。结合自己负责的技术部分简单讲了一下这些算法，同时提到了matlab和python编程。团队合作方面，首先提到了模块化即各司其职，相互配合，以写代码为例提出即使补充注释，方便后期代码整合；然后提到积极讨论，制定多个方案并进行测试。</p></li><li><p>合作过程中，如果发生冲突或受到质疑如何解决？</p><p>这种问题就非常简单了，首先强调团队精神即荣辱与共，大家为共同目标奋斗；然后回答鼓励大家积极讨论，针对同一解决方案各抒己见；最后就是提出质疑需要有理有据。</p></li></ul></li><li><p>热爱读书吗？读过印象最深刻的书是什么？</p><p>这个问题就俨然成为一股清流。先问了问是技术书还是其他书，得到回答是都可以。后来好像也没怎么介绍看的书，这个问题就奇奇怪怪地一扫而过了。</p></li></ul><h2 id="业务面（二面）"><a href="#业务面（二面）" class="headerlink" title="业务面（二面）"></a>业务面（二面）</h2><p>邮件约定面试时间为上午11：00，大概提前五分钟进入面试房间，11：20左右结束，共面试25分钟左右。主要问题包含自我介绍及相关问题。</p><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>简单介绍了一下自己的学校、专业及学习情况，日常爱好，相关技术栈，参加的比赛及获奖情况，实习经历等。‘</p><h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><ul><li><p>简要介绍印象深刻的项目经历（扮演角色，工作内容，学习内容，结果）</p><p>把参与20年作品赛的项目拿出来详细讲了讲，感觉面试官对合作而非技术细节感兴趣。</p></li><li><p>团队合作时有没有受到质疑？如何解决的？</p><p>结合项目经历简单讲了一下解决办法（其实没什么质疑</p></li><li><p>参加过什么实习？聊一下实习经历</p><p>啊这…显然没参加过什么实习，提到了”翔鹰计划”但是面试官没让继续说下去，这个问题就结束了（感觉不是很满意？</p></li><li><p>大学有没有和人发生过冲突？评价下自己的性格，最讨厌什么样的人？</p><p>这三个问题感觉是对面试者人际交往能力和性格的把握吧，就正常回答了一下。</p></li><li><p>你本科学的是网络空间安全，和网络安全有什么区别？</p><p>这个问题算是遇到的比较有趣的非常规问题了，简单讲了一下国家讲网络空间作为”第五空间”的发展战略，以及这个专业广阔的发展前景，还聊了聊网络空间安全和信息安全的区别与联系。</p></li><li><p>网络空间安全对口的公司有什么？</p><p>举了BAT，360，奇安信，绿盟，安恒等经典公司，当然提到了深信服的网络安全、超融合、云计算等标杆。</p></li><li><p>在学校参加过何种比赛？</p><p>由于校园经历偏作品赛比较多，CTF比赛没拿到什么好成绩，所以就简要介绍了几个本专业作品赛的情况。</p></li><li><p>课余时间如何安排生活？</p><p>看技术书+保持几个爱好。</p></li><li><p>看过哪些技术书籍+日常逛哪些论坛？</p><p>举了几个密码学技术书籍，外加计算机网络自顶向下、深入理解计算机系统、软件测试等。论坛聊了Freebuf、先知社区等。</p></li><li><p>简单聊了下技服工程师跨省调度的政策，就是不能回原籍省份工作也不能在学校所在省份工作。</p></li></ul><h2 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h2><p>邮件约定时间为下午16：45，进入房间大概等到17：00开始面试，整个时长为25min。首先进行自我介绍，然后面试官了解情况，大概问了如下几个问题：</p><ul><li><p>概括本科三年生活。</p><p>从技术和日常生活的角度进行概括，技术上提到了CTF比赛和参加的项目，生活角度没怎么提。</p></li><li><p>本科最有挑战和最有成就的事情。</p><p>最有挑战的事情选择了其中一个做过的项目，最有成就的事情选择了”美亚杯”比赛经历。</p></li><li><p>为什么选择”翔鹰计划”实习？</p><p>一是为了了却去年的遗憾，二是线上实习的形式比较安全高效，结合开学时间与暑假安排的考虑，最终选择了”翔鹰计划”。</p></li><li><p>技服工程师这个岗位是做什么的，为什么选择这个岗位？</p><p>简单介绍了一下自己对技术服务的理解。选择原因确定为两点：个人代码水平不高+热爱与人打交道。</p></li><li><p>追问：为什么不选择售前经理？</p><p>个人还是比较热爱技术。（感觉这个岗位和技术关系不大）</p></li><li><p>概括一下自己的优点和缺点（各两条）。</p></li><li><p>评价一下自己是个怎么样的人？</p></li><li><p>有没有长时间坚持的事情？</p><p>运动。</p></li><li><p>确定不考研了吗，为什么？</p><p>总感觉说正在备考拿不到offer，于是胡乱编造了一些理由。</p></li><li><p>期望岗位是什么？想去什么样的公司？</p><p>这个问题回答的比较粗略，给面试官一种没有准备好进入工作+对未来没有明确规划的感觉。可能是因为真的没有准备好本科毕业直接工作吧。事后仔细想想，个人期望岗位还是管理岗，对专注安全的乙方公司没什么向往，对大厂还是比较向往的（阿里、百度、腾讯、字节）。除此之外当个测试工程师或者去公司实验室进行安全研究感觉也挺好。现阶段还是一门心思学习，重点还是提升下学历吧。</p></li><li><p>还有没有投递其他公司？收到过其他offer吗？</p><p>实话实说，并没有，甚至连华为提前批都没打算投。。。</p></li><li><p>工作情况相关</p><ul><li><p>随机工作省份可以接受吗？偏远地区呢？</p><p>个人不能接受过于偏远的地区，对其他工作地点没有太大的执念。不回原籍和学校所在地倒是无所谓。</p></li><li><p>家庭状况：独生子女？父母同意吗？女朋友呢？</p><p>啊这…</p></li></ul></li><li><p>最后简单聊了一下拿到offer的后续安排以及薪资问题。</p></li></ul><h2 id="目前状态"><a href="#目前状态" class="headerlink" title="目前状态"></a>目前状态</h2><ul><li>7.23 等业务面通知中…</li><li>7.30 等HR面通知中…</li><li>8.4 HR面试结束，等offer中，大概率凉…</li><li>9.18 offer沟通</li><li>9.22 没有去签三方协定，选择继续考研</li></ul><h2 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h2><p>各种意义上来说这次面试都是人生中经历的第一次完整的企业面试，不仅体验了整套面试流程，还发现了一些重点问题，并且引发一些思考。</p><ul><li>仔细回顾大学本科真的没有做什么惊天动地的事情，技术水平也比较平庸，这种状态下直接工作感觉难度较大。倒不是说找不到工作，但是能进的公司个人不太喜欢。当然也不想当拿钱少的用爱发电的社畜。</li><li>技术方面：大学阅读的技术书籍太少了，对于Web安全的掌握并不到位，这两点需要后续加强。不管从事哪一个与安全相关的岗位，应聘时技术短板都是致命的。</li><li>应聘技巧：针对不同内容进行准备，多刷面经，提高算法及代码能力。面试时扬长避短，努力主导谈论的话题。该掩饰的时候千万不要实话实说。</li><li>认识到自己的平凡，好好学习，未来可期。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;近日考研期间，适逢深信服”翔鹰计划”线上实习结束，公司给了秋招提前批的面试机会，准备了大概两天就去面试了，岗位是&lt;strong&gt;技服工程师&lt;
      
    
    </summary>
    
      <category term="Interview" scheme="https://blank-vax.github.io/categories/Interview/"/>
    
    
      <category term="Sangfor" scheme="https://blank-vax.github.io/tags/Sangfor/"/>
    
  </entry>
  
  <entry>
    <title>Windows基础及常用命令</title>
    <link href="https://blank-vax.github.io/2020/07/23/Windows%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://blank-vax.github.io/2020/07/23/Windows基础及常用命令/</id>
    <published>2020-07-22T16:20:00.000Z</published>
    <updated>2020-11-09T03:40:18.849Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows常见目录"><a href="#Windows常见目录" class="headerlink" title="Windows常见目录"></a>Windows常见目录</h2><ul><li><p>Documents and Settings/用户</p><p>存储用户设置，包括用户文档、上网浏览信息、配置文件等数据</p></li><li><p>Windows目录</p><p>Windows安装目录，用来放置Windows程序的使用数据、设置等文件。不建议修改此目录下数据，易造成Windows系统使用异常</p></li><li><p>Program File</p><p>应用程序文件夹，一般软件默认安装位置。当然此处也包含系统自带的应用程序。Windows10系统中，64位用户多出一个Program Files(x86)文件夹，用作系统中32位软件的安装目录</p></li><li><p>Temp目录 临时文件目录</p><p>文件路径：C:\Users\user\AppData\Local\Temp</p><p>上面存在许多垃圾文件，包括使用压缩软件等解压的临时文件。此目录也是病毒检测过程中快速扫描的位置。</p></li></ul><h2 id="Windows注册表"><a href="#Windows注册表" class="headerlink" title="Windows注册表"></a>Windows注册表</h2><p>注册表是Windows操作系统中的一个核心数据库，其中存放各种参数，直接控制Windows的启动、硬件驱动程序的装装载以及一些Windows应用程序的运行。</p><p>恶意病毒通常通过修改注册表的键<strong>HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\Main Start Page</strong>项对应的URL值来修改IE起始页面。</p><h2 id="系统启动项"><a href="#系统启动项" class="headerlink" title="系统启动项"></a>系统启动项</h2><p>开机时系统会在前台或后台自动运行的程序。查看方式为msconfig命令。</p><p>将文件、程序等放入位于<strong>C:\Users\user\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</strong>的启动文件夹中即可实现开机自启动。</p><h2 id="设备管理器"><a href="#设备管理器" class="headerlink" title="设备管理器"></a>设备管理器</h2><p>设备管理器常被用来查看和更改设备属性、更新设备驱动程序、配置设备设置和卸载设备。所有设备通过<strong>设备驱动程序</strong>与Windows进行通信。</p><ul><li>超融合迁移（虚拟机网卡网络适配器）</li><li>云桌面外设（USB白名单）</li></ul><p>使用设备管理器可以安装和更新硬件设备的驱动程序、修改这些设备的硬件设置以及通过查看硬件设备状态信息来排查问题。</p><h2 id="任务管理器"><a href="#任务管理器" class="headerlink" title="任务管理器"></a>任务管理器</h2><p>Windows任务管理器提供了有关计算机性能的信息，并显示了计算机上所运行的程序和进程的详细信息（哪个用户创建了哪个进程或程序，该进程或程序占用了多少CPU及其他系统资源）。</p><ul><li>应用程序</li><li>进程（*32代表32位系统进程）</li><li>服务</li><li>性能（详细Windows系统资源占用情况）</li><li>联网（网卡流量）</li><li>用户（当前运行的用户名）</li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是正在运行的程序实例。每个进程存在属于自己的地址空间，一般包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储<strong>处理器执行的代码</strong>；数据区域存储<strong>变量和进程执行期间使用的动态分配的内存</strong>；堆栈区域存储<strong>活动过程调用的指令和本地变量</strong>。</p><ul><li>虚拟机出现CPU、内存异常偏高时，可以通过任务管理器查看进程的资源利用率</li><li>病毒常伪装成<strong>svchost.exe</strong>，<strong>explorer.exe</strong>和<strong>rundll32.exe</strong>等系统进程，当发现这些进程CPU及内存资源占用异常时，需要重点查杀</li></ul><h2 id="组策略"><a href="#组策略" class="headerlink" title="组策略"></a>组策略</h2><p>组策略在部分意义上可控制用户可以或无法在计算机上执行什么操作，提供了操作系统、应用程序和活动目录中用户设置的集中化管理和配置。在运行模式下输入<strong>gpedit.msc</strong>可以打开组策略配置。</p><h3 id="刷新时间"><a href="#刷新时间" class="headerlink" title="刷新时间"></a>刷新时间</h3><p>默认情况下，Mircosoft Windows每90分钟刷新一次组策略，随机偏移为30分钟。在域控制器上，Microsoft Windows每隔5分钟刷新一次。</p><h3 id="处理顺序"><a href="#处理顺序" class="headerlink" title="处理顺序"></a>处理顺序</h3><ul><li>本地——任何在本地计算机的设置。在Windows Vista和之后的Windows版本中，允许每个用户账户分别拥有组策略</li><li>站点——任何与计算机所在的活动目录站点关联的组策略。活动目录站点旨在管理促进物理上接近的计算机的一种逻辑分组。如果多个策略链接到一个站点，将按照管理员设置的顺序处理</li><li>域——任何与计算机所在Windows域关联的组策略。如果多个策略链接到一个域，将按照管理员设置的顺序处理</li><li>组织单元——任何与计算机或用户所在的活动目录组织单元（OU）关联的组策略。OU是帮助组织和管理一组用户、计算机或其他活动目录对象的逻辑单元。如果多个策略链接到一个OU，将按照管理员设置的顺序处理</li></ul><h2 id="安全组"><a href="#安全组" class="headerlink" title="安全组"></a>安全组</h2><p>可以列出用于定义资源和对象权限的任意访问控制列表（DACL）中的组。Windows安全组策略其实是组策略中关于安全设置的部分，囊括了账户安全策略、Windows防火墙配置等配置目录。</p><p>在运行任务栏输入<strong>secpol.msc</strong>，修改安全组相关配置之后，需要重新登录Windows用户方可生效。</p><h2 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h2><p>工作组就是将不同的电脑按功能分别列入不同的组中，以方便管理。</p><p>Windows 9x/NT/2000引入工作组概念后，若要访问某个系列的资源，需要在网上邻居内找到对应的工作组名，即可找到该系列资源。</p><h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2><p>工作组中一切设置在本机上进行，包括各种策略、用户登录等过程，对应密码也存放在本机数据库中进行验证。</p><p>域作为工作组的升级版，计算机的各种策略通过域控制器统一设定，用户名和密码的验证过程也在域控制器中完成。因此，用户信息可以实现在域中电脑上的漫游。</p><h3 id="域控制器"><a href="#域控制器" class="headerlink" title="域控制器"></a>域控制器</h3><p>在域模式下，至少有一台服务器负责每台联入网络的电脑和用户的验证工作，被称为<strong>域控制器（Domain Controller，DC）</strong>。域控制器包含由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。</p><h2 id="安全日志"><a href="#安全日志" class="headerlink" title="安全日志"></a>安全日志</h2><p>Windows用户所有的登录注销、安全策略更改都会以安全日志的形式记录。</p><p>日志位置：计算机管理—&gt;系统工具—&gt;事件查看器—&gt;Windows日志—&gt;安全</p><ul><li>溯源黑客入侵行为</li><li>通过事件ID快速检索日志</li></ul><h2 id="常用网络排查命令"><a href="#常用网络排查命令" class="headerlink" title="常用网络排查命令"></a>常用网络排查命令</h2><h3 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h3><p>通过发送Internet控制消息协议（ICMP）验证与其他TCP/IP计算机的IP级连接回显请求消息。显示相应的回音回复信息的接受以及往返时间。该命令可用于解决连接、可访问性和名称解析等问题。</p><h4 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><code>Ping IP/域名 -t</code>：长时间执行Ping命令，以推断连接健壮性</li><li><code>Ping IP/域名 -n number</code>： 指定发送数据包的数量</li><li><code>Ping IP/域名 -l length</code>： 指定发送数据包的长度（默认长度为32Bytes）</li></ul><p>一般使用<code>Ping IP/域名 -l big-number -n big-number</code>探测连接稳定性，其中big-number为大于1000的数字，需要多次尝试以找到合适的数据包长度。</p><h4 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h4><ul><li>找不到主机：排查DNS是否正确解析指定域名</li><li>请求超时：目标地址禁止Ping/目标地址不存在</li><li>传输失败：主机网络存在问题</li></ul><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>显示和修改地址解析协议缓存中的条目，其中包含一个或多个用于存储IP地址及其解析结果的以太网或令牌环物理地址的表。计算机上安装的每个以太网或令牌环网络适配器都存在单独的表。</p><h4 id="常用选项-1"><a href="#常用选项-1" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><code>Arp -a</code>：显示所有的地址信息及接口信息</li><li><code>Arp -s ip_addr mac_addr</code>：静态配置ARP地址表项</li><li><code>Arp -d</code>：用于删除当前ARP信息</li></ul><h3 id="Tracert"><a href="#Tracert" class="headerlink" title="Tracert"></a>Tracert</h3><p>确定通过发送Internet控制消息协议（ICMP）回显请求或以递增的生存时间（TTL）字段值向目标发送消息。路径显示源主机和目标之间路径中路由器的近/侧路由器接口列表。无参数使用。</p><h4 id="常用选项-2"><a href="#常用选项-2" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><p><code>Tracert -d</code>：不将地址解析成主机名</p></li><li><p><code>Tracert -h maximum_hops</code>：搜索目标的最大跃点数</p></li></ul><h3 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h3><p>显示并修改本地IP路由表中的输入。无参数使用。需要<strong>以管理员身份打开</strong>以进行相关配置。常用命令结构：<code>Route command ip_addr mask mask_number gateway_addr</code>。</p><h4 id="常用选项-3"><a href="#常用选项-3" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><p>command</p><ul><li><code>Route PRINT</code>：打印路由表</li><li><code>Route ADD</code>：添加静态路由（临时，重启后消失）</li><li><code>Route DELETE</code>：删除路由信息</li><li><code>Route CHANGE</code>：修改现有路由的网关和跃点数</li></ul></li><li><p><code>Route -p</code>：使得对路由表的添加操作永久生效</p></li></ul><h3 id="Ipconfig"><a href="#Ipconfig" class="headerlink" title="Ipconfig"></a>Ipconfig</h3><p>显示所有当前TCP/IP网络配置值，并刷新动态主机配置协议（DHCP）和域名系统（DNS）设置。无参数使用时，为所有适配器显示Internet协议版本4和IPv6地址、子网掩码和默认网关。</p><h4 id="常用选项-4"><a href="#常用选项-4" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><code>Ipconfig /all</code>：显示所有网络适配器的所有信息</li><li><code>Ipconfig /release</code>：释放当前所有网卡的DHCP信息</li><li><code>Ipconfig /renew</code>：释放当前网卡的所有DHCP信息并重新获取</li><li><code>Ipconfig /displaydns</code>：展示当前DNS缓存信息</li><li><code>Ipconfig /flushdns</code>：清理当前DNS缓存信息</li></ul><h3 id="Netstat"><a href="#Netstat" class="headerlink" title="Netstat"></a>Netstat</h3><p>显示有源TCP连接，计算机在哪个端口被侦听，以太网统计，IP路由表，IPv4统计和IPv6统计。无参数使用时，网络显示激活TCP连接。</p><h4 id="常用选项-5"><a href="#常用选项-5" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><code>Netstat -a</code>：展示当前监听的所有网口信息</li><li><code>Netstat -n</code>：展示所有TCP&amp;UDP连接信息及端口详细信息</li><li><code>Netstat -o</code>：展示当前连接的PID</li><li><code>Netstat -p</code>：指定当前监听协议</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Windows常见目录&quot;&gt;&lt;a href=&quot;#Windows常见目录&quot; class=&quot;headerlink&quot; title=&quot;Windows常见目录&quot;&gt;&lt;/a&gt;Windows常见目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Documents and Settings/用户
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Windows Foundation" scheme="https://blank-vax.github.io/tags/Windows-Foundation/"/>
    
  </entry>
  
  <entry>
    <title>云计算基础</title>
    <link href="https://blank-vax.github.io/2020/07/15/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80/"/>
    <id>https://blank-vax.github.io/2020/07/15/云计算基础/</id>
    <published>2020-07-14T16:09:00.000Z</published>
    <updated>2020-11-09T03:39:49.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="云计算基础"><a href="#云计算基础" class="headerlink" title="云计算基础"></a>云计算基础</h2><h3 id="云计算定义"><a href="#云计算定义" class="headerlink" title="云计算定义"></a>云计算定义</h3><ul><li>技术角度：云计算是一种基于互联网的计算方式，通过这种方式，共享的软硬件资源和信息可以按需求提供给计算机和其他设备。</li><li><p>经济学角度：云计算依赖资源的共享以达成规模经济，类似基础设施如电力网等。</p></li><li><p>云计算现阶段的发展还远远未达到基础设施建设水平。</p></li></ul><p><img src="http://static.zybuluo.com/B1ank/bmg3x73stk7ol7hgyap45g4o/image-20200711112223579.png" alt="image-20200711112223579.png-264.8kB"></p><ul><li>滴滴打车</li></ul><h3 id="云计算本质"><a href="#云计算本质" class="headerlink" title="云计算本质"></a>云计算本质</h3><p>云计算是新技术+IT业务模式的创新，随着数字化时代的发展，IT消费模式产生重大转变：云计算通过技术将IT资源池化和服务化，通过互联网提供IT服务，而用户由网络浏览器或轻量级终端软件来获取和使用这些IT服务。整个IT市场商业模式正实现<strong>“从产品到服务”</strong>的转型。</p><h3 id="云计算特性"><a href="#云计算特性" class="headerlink" title="云计算特性"></a>云计算特性</h3><ul><li>按需自助</li><li>可度量服务</li><li>快速灵活</li><li>资源池</li><li>广阔网络访问</li></ul><h3 id="相关分类"><a href="#相关分类" class="headerlink" title="相关分类"></a>相关分类</h3><h4 id="服务模型分类"><a href="#服务模型分类" class="headerlink" title="服务模型分类"></a>服务模型分类</h4><ul><li><p>IaaS（Infrastructure as a Service）：基础架构即服务</p><p>用户通过网络使用计算机（物理机或虚拟机）、存储空间、网络连接等完善的计算机基础设施服务。</p></li><li><p>PaaS（Platform as a Service）：平台即服务</p><p>将软件研发的平台作为一种服务提交给用户，意在加快SaaS应用的开发速度。</p></li><li><p>SaaS（Software as a Service）：软件即服务</p><p>通过Internet提供软件的模式，用户无需购买软件，而是向提供商租用基于Web的软件来管理企业经营活动。</p></li></ul><h4 id="部署模型分类"><a href="#部署模型分类" class="headerlink" title="部署模型分类"></a>部署模型分类</h4><ul><li>公有云</li><li>私有云</li><li>混合云</li></ul><h3 id="公有云"><a href="#公有云" class="headerlink" title="公有云"></a>公有云</h3><p>通过Internet为外部客户提供服务的云。典型公有云包括Amazon EC2、阿里云、腾讯云等。</p><ul><li><p>优点</p><p>所有应用服务数据等均存放在公有云提供商处，客户无需硬件投资与建设，使用成本低；</p></li><li><p>缺点</p><p>数据存放在供应商处，安全性存在风险。公有云的可用性不受使用者控制，存在不确定性。</p></li></ul><h3 id="私有云"><a href="#私有云" class="headerlink" title="私有云"></a>私有云</h3><p>由企业或机构独享使用和掌控的云，仅供自己内部人员或分支机构使用，一般部署在企业或机构的数据中心。</p><ul><li><p>优点</p><p>数据安全性和系统可用性可控，对现有IT流程管理影响小、IT资源利用率高；</p></li><li><p>缺点</p><p>投资较大。</p></li></ul><h3 id="混合云"><a href="#混合云" class="headerlink" title="混合云"></a>混合云</h3><p>同一份数据、同一套应用，同时采用私有云技术构建自己的IT服务平台，同时又采购了公有云服务商提供的IT服务。为保证数据安全，企业将核心数据和关键技术存放于私有云上，而将面向用户的服务托管在公有云上，具有较高的弹性。一般是需要具备可控的前提下，具备一定的弹性或可靠性。多应用于潮汐应用及混合云灾备。</p><ul><li><p>优点</p><p>具备较大弹性，并且可以在保障可控性的同时兼顾建设成本；</p></li><li><p>缺点</p><p>IT业务管理界面不统一，需要投入相应的混合云管理成本。</p></li></ul><h2 id="数据中心基础"><a href="#数据中心基础" class="headerlink" title="数据中心基础"></a>数据中心基础</h2><h3 id="重要组成要素"><a href="#重要组成要素" class="headerlink" title="重要组成要素"></a>重要组成要素</h3><ul><li>处理资源请求和资源分发的云平台</li><li>网络管道</li><li>终端用户</li></ul><h3 id="数据中心"><a href="#数据中心" class="headerlink" title="数据中心"></a>数据中心</h3><p>数据中心是云计算后端基础设施的承载体，云计算依托数据中心提供各种云计算服务。数据中心内部除包含基础物理设施外，还包含网络、安全、优化、存储、服务器、操作系统、虚拟机及应用软件等成分。</p><h3 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h3><p><img src="http://static.zybuluo.com/B1ank/llbtq6h73ym6pvcx50wqnl3z/%E4%BA%91%E8%AE%A1%E7%AE%97%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.png" alt="云计算逻辑架构.png-140.1kB"></p><h2 id="计算基础"><a href="#计算基础" class="headerlink" title="计算基础"></a>计算基础</h2><h3 id="服务器分类"><a href="#服务器分类" class="headerlink" title="服务器分类"></a>服务器分类</h3><p>随着云计算技术的发展与并行计算思想的出现，未来x86服务器在市场中将占据主导地位。</p><h4 id="x86服务器"><a href="#x86服务器" class="headerlink" title="x86服务器"></a>x86服务器</h4><p>又称CISC（复杂指令集）架构服务器，即通常所讲的PC服务器，它基于PC机体系结构，使用Intel或其它兼容x86指令集的处理器芯片和Windows/Linux操作系统的服务器。</p><h4 id="非x86服务器"><a href="#非x86服务器" class="headerlink" title="非x86服务器"></a>非x86服务器</h4><p>包括大型机、小型机和UNIX服务器，它们是使用RISC（精简指令集）或EPIC（并行指令代码）的处理器，并且主要采用UNIX和其他专用操作系统的服务器。</p><h3 id="小型机"><a href="#小型机" class="headerlink" title="小型机"></a>小型机</h3><p>中国业内习惯上称UNIX服务器为小型机，其最引以为傲的特点就是高RAS——高可靠性、高可用性与高服务性。随着CPU和虚拟化技术的发展，x86服务器的可靠性与可用性不再是问题，为用户提供更多选择，小型机的竞争力逐渐下降。</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>Central Process Unit，是一块超大规模的集成电路，是一台计算机的运算核心和控制核心。常见参数如下：</p><ul><li>主频：表示CPU的处理频率，常见的频率为1.7-3.1GHz。数值越高，处理的速度越快。超频表示CPU可以超越主频规定的处理频率进行运算处理。当计算机进入节能模式时，为提高电量续航，采用降频策略，主动下调CPU的计算效率。</li><li>核数：表示CPU的并行处理能力。核数越多则并行处理速度越快。超线程表示CPU可以高负荷处理数据。</li></ul><p>为适应信息化发展，Intel推出VT（Virtualization Technology，虚拟化技术）系列以满足不同的上层操作系统对底层处理器的调用，如VT-x、VT-d、VT-c。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>Memory，也被称为内存储器，用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。内存主频与CPU主频一样，习惯上被用来表示内存的速度，代表着该内存所能达到的最高工作频率。可分为ROM只读存储器、RAM随机存储器和Cache高速缓存三类。</p><h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><p>Disk，数据的最终归属地。可分为机械硬盘HDD与固态硬盘SSD。</p><h3 id="常见卡"><a href="#常见卡" class="headerlink" title="常见卡"></a>常见卡</h3><ul><li>网卡：通过网络连接线与网络交换机连接。</li><li>存储卡：通过网络连接线和存储设备对接。</li><li>RAID卡：通过总线和硬盘连接。</li></ul><p>常见接口为PCI、PCI-X和PCI-E。</p><h3 id="光模块"><a href="#光模块" class="headerlink" title="光模块"></a>光模块</h3><p>光模块的作用为光电转换，发送端将电信号转换为光信号，通过光纤传送后，接收端再将光信号转换为电信号。光模块具有传输速率高，传输距离远的特点。</p><h3 id="光纤跳线"><a href="#光纤跳线" class="headerlink" title="光纤跳线"></a>光纤跳线</h3><p>用来做从设备到光纤布线链路的跳接线。常见LC接口的光模块为：SFF、SFP、SFP+和XFP。常见SC接口的光明模块为GBIC。而FC、ST接口多用于光纤配线架。</p><h3 id="操作系统OS"><a href="#操作系统OS" class="headerlink" title="操作系统OS"></a>操作系统OS</h3><p>管理和控制计算机硬件与软件资源的计算机程序，具有承上启下的功能：对上有效管理系统资源，为应用软件提供基础的底层环境，提高系统资源使用效率。对下屏蔽硬件物理特性和操作细节，为用户使用计算机提供便利。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;云计算基础&quot;&gt;&lt;a href=&quot;#云计算基础&quot; class=&quot;headerlink&quot; title=&quot;云计算基础&quot;&gt;&lt;/a&gt;云计算基础&lt;/h2&gt;&lt;h3 id=&quot;云计算定义&quot;&gt;&lt;a href=&quot;#云计算定义&quot; class=&quot;headerlink&quot; title=&quot;云计算
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Cloud Computing" scheme="https://blank-vax.github.io/tags/Cloud-Computing/"/>
    
  </entry>
  
  <entry>
    <title>终端安全检测及防御技术</title>
    <link href="https://blank-vax.github.io/2020/07/06/%E7%BB%88%E7%AB%AF%E5%AE%89%E5%85%A8%E6%A3%80%E6%B5%8B%E5%8F%8A%E9%98%B2%E5%BE%A1%E6%8A%80%E6%9C%AF/"/>
    <id>https://blank-vax.github.io/2020/07/06/终端安全检测及防御技术/</id>
    <published>2020-07-06T01:20:00.000Z</published>
    <updated>2020-11-09T03:39:33.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="终端安全风险"><a href="#终端安全风险" class="headerlink" title="终端安全风险"></a>终端安全风险</h2><p>黑客可以利用僵尸网络展开更多的危害行为，如APT攻击最常采用的跳板就是僵尸网络。黑客利用僵尸网络来实现渗透、监视、窃取敏感数据等目的，造成严重危害。</p><p>僵尸网络主要危害有：</p><ul><li>未知风险</li><li>高级持续威胁</li><li>本地渗透扩散</li><li>敏感信息窃取</li><li>脆弱信息收集</li></ul><h2 id="终端上网安全可视可控技术"><a href="#终端上网安全可视可控技术" class="headerlink" title="终端上网安全可视可控技术"></a>终端上网安全可视可控技术</h2><p>基于七层应用的深度数据包检测可实现终端安全可控。AF中实现了可视化的应用管控与全面的应用安全。可视化应用管控中包含<strong>应用识别</strong>与<strong>流量管控</strong>两大模块。</p><h3 id="应用控制策略"><a href="#应用控制策略" class="headerlink" title="应用控制策略"></a>应用控制策略</h3><p>应用控制策略可对应用/服务的访问做双向控制，AF存在一条默认拒绝所有应用/服务的控制策略。</p><ul><li>基于应用的控制策略：通过匹配数据包特征来进行过滤动作，需要一定数量的包通行后才能判断应用类型，然后进行拦截动作的判断。</li><li>基于服务的控制策略：通过匹配数据包的五元组（源/目的IP地址+源/目的端口号+协议类型）来进行过滤动作，对任何包可以立即进行拦截动作判断。</li></ul><h3 id="Web过滤"><a href="#Web过滤" class="headerlink" title="Web过滤"></a>Web过滤</h3><p>Web过滤指针对符合设定条件的访问网页数据进行过滤，包括URL过滤与文件过滤，同时可以针对HTTPS URL进行过滤。</p><h2 id="网关杀毒技术"><a href="#网关杀毒技术" class="headerlink" title="网关杀毒技术"></a>网关杀毒技术</h2><h3 id="计算机病毒"><a href="#计算机病毒" class="headerlink" title="计算机病毒"></a>计算机病毒</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>隐蔽性</li><li>破坏性</li><li>潜伏性</li><li>不可预见性</li><li>繁殖性</li><li>传染性</li></ul><h4 id="工作步骤"><a href="#工作步骤" class="headerlink" title="工作步骤"></a>工作步骤</h4><p><img src="http://static.zybuluo.com/B1ank/q220r9z8dhph5x9jbd066ox3/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92%E5%B7%A5%E4%BD%9C%E6%AD%A5%E9%AA%A4.png" alt="计算机病毒工作步骤.png-233.6kB"></p><h3 id="网关杀毒实现方式"><a href="#网关杀毒实现方式" class="headerlink" title="网关杀毒实现方式"></a>网关杀毒实现方式</h3><h4 id="代理扫描方式"><a href="#代理扫描方式" class="headerlink" title="代理扫描方式"></a>代理扫描方式</h4><p>将所有经过网关的需要进行病毒检测的数据报文透明地转交给网关自身的协议栈，通过网关自身的协议栈将文件全部缓存下来后，再送入病毒检测引擎进行病毒检测。</p><h4 id="流扫描方式"><a href="#流扫描方式" class="headerlink" title="流扫描方式"></a>流扫描方式</h4><p>依赖于状态检测技术以及协议解析技术，简单地提取文件的特征与本地签名库进行匹配。由于流扫描方式只针对部分数据进行扫描，故查准率低于代理扫描方式，属于轻量级检测技术。</p><h3 id="AF网关杀毒实现方式"><a href="#AF网关杀毒实现方式" class="headerlink" title="AF网关杀毒实现方式"></a>AF网关杀毒实现方式</h3><p><img src="http://static.zybuluo.com/B1ank/bkkhf877533ca6ulcqgasvnr/AF%E7%BD%91%E5%85%B3%E6%9D%80%E6%AF%92%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.png" alt="AF网关杀毒实现方式.png-430.3kB"></p><p>该杀毒体系具有以下特点：</p><ul><li>防火墙AF提供捕获文件能力和拦截处置能力。</li><li>SAVE提供本地无规则的检测能力。</li><li>云脑提供安全能力的更新和云端威胁情报查杀的能力。</li><li>具备威胁情报、本地引擎SAVE查杀、云沙箱能力。</li></ul><h3 id="网关杀毒配置思路"><a href="#网关杀毒配置思路" class="headerlink" title="网关杀毒配置思路"></a>网关杀毒配置思路</h3><ul><li>新建模块</li><li>选择杀毒协议</li><li>选择文件类型</li><li>新增安全策略</li></ul><h2 id="僵尸网络检测与防御技术"><a href="#僵尸网络检测与防御技术" class="headerlink" title="僵尸网络检测与防御技术"></a>僵尸网络检测与防御技术</h2><h3 id="僵尸网络"><a href="#僵尸网络" class="headerlink" title="僵尸网络"></a>僵尸网络</h3><p>僵尸网络（Botnet）是指骇客利用自己编写的分布式拒绝服务攻击程序将数万个沦陷的机器组织成一个个控制节点用来发送伪造包或垃圾数据包，使预定攻击目标瘫痪并拒绝服务。通常蠕虫病毒也可以被用来组成僵尸网络。</p><h3 id="僵尸网络感染过程"><a href="#僵尸网络感染过程" class="headerlink" title="僵尸网络感染过程"></a>僵尸网络感染过程</h3><ul><li>僵尸主控传播木马到网络中的感染终端。</li><li>主机受到感染，连接C&amp;C服务器，获取指令。</li><li>C&amp;C服务器下发指令给受感染主机，扫描网络并感染更多主机。</li><li>更多主机被感染并组成僵尸网络，连接C&amp;C服务器并获取操作指令。</li></ul><h3 id="异常流量检测"><a href="#异常流量检测" class="headerlink" title="异常流量检测"></a>异常流量检测</h3><p>通过对当前的网络层及应用层行为与安全模型进行偏离度分析，能够发现隐藏的网络异常行为，并根据行为特征确定攻击类型，发现特征匹配无法发现的攻击。</p><p>外发流量异常功能是一种启发式的DOS攻击检测手段，能够检测源IP不变的SYN Flood、UDP Flood等泛洪攻击。该功能原理为：当特定协议的外发包pps超过配置的阈值时，基于5分钟左右的抓包样本检测数据包是否为单向流量、是否有正常响应内容，得出分析结论并将发现的攻击提交日志显示。</p><h3 id="误判排除"><a href="#误判排除" class="headerlink" title="误判排除"></a>误判排除</h3><h4 id="AF僵尸网络防护排除"><a href="#AF僵尸网络防护排除" class="headerlink" title="AF僵尸网络防护排除"></a>AF僵尸网络防护排除</h4><p>AF僵尸网络防护排除方式具有以下三种：</p><ul><li>在僵尸网络功能模块下排除指定IP。</li><li>若误判由拦截规则引起，则可在【安全防护对象】-【僵尸网络规则库】找到并禁用指定规则。</li><li>可以在内置数据中心中，查询僵尸网络日志后使用【添加例外】排除。</li></ul><h4 id="DNS场景误判排除"><a href="#DNS场景误判排除" class="headerlink" title="DNS场景误判排除"></a>DNS场景误判排除</h4><p>通过蜜罐技术解决内网存在DNS服务器时，用于定位内网感染僵尸网络主机的真实IP地址。防止配置过程中忽略蜜罐设置，导致后续无法溯源的问题，策略配置界面新增DNS服务器服务界面。</p><h3 id="杀毒通知推送"><a href="#杀毒通知推送" class="headerlink" title="杀毒通知推送"></a>杀毒通知推送</h3><p>AF检测到的风险主机可以推送杀毒通知。重定向页面支持自定义，同时支持下载病毒查杀软件。</p><p>注意：杀毒通知推送设定的时间内，风险主机下载工具并查杀后也无法直接上网，需要等待指定时间，或管理员取消推送才可正常访问网站。重定向页面只对HTTP生效，HTTPS及NAT场景均不生效。</p><h2 id="勒索病毒防护"><a href="#勒索病毒防护" class="headerlink" title="勒索病毒防护"></a>勒索病毒防护</h2><h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>勒索病毒是一种新型电脑病毒，主机感染勒索病毒文件后，会自动运行勒索程序，遍历本地所有磁盘指定类型文件进行加密操作，加密后文件无法读取。随后生成勒索通知，要求受害者支付虚拟货币作为赎金。主要包含两种场景：</p><ul><li>服务器文件被加密</li><li>内网主机成片出现蓝屏现象，蓝屏代码提示<code>srv.sys驱动出现问题</code></li></ul><h3 id="防护措施"><a href="#防护措施" class="headerlink" title="防护措施"></a>防护措施</h3><ul><li>事前加固：勒索病毒风险评估，精准评估勒索病毒进入点风险，配置勒索病毒专项策略，全面防护勒索风险。</li><li>事中积极防御：通过配置的勒索病毒专项策略，全面防护勒索风险。</li><li>事后快速响应与处置：隔离识别已失陷的主机，采用专项工具进行杀毒。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;终端安全风险&quot;&gt;&lt;a href=&quot;#终端安全风险&quot; class=&quot;headerlink&quot; title=&quot;终端安全风险&quot;&gt;&lt;/a&gt;终端安全风险&lt;/h2&gt;&lt;p&gt;黑客可以利用僵尸网络展开更多的危害行为，如APT攻击最常采用的跳板就是僵尸网络。黑客利用僵尸网络来实现渗透、
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Terminal Security" scheme="https://blank-vax.github.io/tags/Terminal-Security/"/>
    
  </entry>
  
  <entry>
    <title>信息安全概述</title>
    <link href="https://blank-vax.github.io/2020/07/01/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/"/>
    <id>https://blank-vax.github.io/2020/07/01/信息安全概述/</id>
    <published>2020-07-01T03:50:00.000Z</published>
    <updated>2020-11-09T03:39:21.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安全背景"><a href="#安全背景" class="headerlink" title="安全背景"></a>安全背景</h2><ul><li>数字化时代威胁升级</li><li>传统安全防护在数字化转型中逐渐失效</li><li>安全风险能见度不足<ul><li>资产更替较快，无法全方位把握所有资产，导致安全加固操作不到位；</li><li>缺乏对水坑攻击、鱼叉邮件攻击、0day漏洞等新型威胁的及时全面的探测；</li><li>缺乏对预留后门、合法用户伪装等潜藏风险的把控；</li></ul></li><li>缺乏自动化防御手段</li><li>网络安全监管标准愈发严苛</li></ul><h2 id="常见网络安全术语"><a href="#常见网络安全术语" class="headerlink" title="常见网络安全术语"></a>常见网络安全术语</h2><ul><li>漏洞：可能被一个或多个威胁利用的资产或控制的弱点，包括软件漏洞、硬件漏洞、协议漏洞、算法漏洞等。</li><li>0day漏洞：亟待官方发现及开发安全补丁的漏洞。0day漏洞公开后称为Nday漏洞。</li><li>WEBSHELL：以asp、php、jsp或cgi等网页文件形式存在的一种命令执行环境。攻击者利用服务器本身开设的80端口采用POST请求上传WEBSHELL，绕过防火墙的检测，达到入侵服务器并提升用户权限的目的，最终实现完全控制服务器。针对这一攻击，可以通过设置白名单的方式限制文件上传。</li><li>exploit：漏洞利用即exp。本地攻击与远程攻击。</li><li>APT攻击：高级持续性威胁（Advanced Persistent Thread），利用先进的攻击手段对特定目标进行长期持续性网络攻击的攻击形式。</li></ul><h2 id="协议栈自身脆弱性及常见攻击"><a href="#协议栈自身脆弱性及常见攻击" class="headerlink" title="协议栈自身脆弱性及常见攻击"></a>协议栈自身脆弱性及常见攻击</h2><h3 id="协议栈脆弱性"><a href="#协议栈脆弱性" class="headerlink" title="协议栈脆弱性"></a>协议栈脆弱性</h3><ul><li>缺乏数据源验证机制</li><li>缺乏机密性保障机制</li><li>缺乏完整性检验机制</li></ul><h3 id="网络攻击基本模式"><a href="#网络攻击基本模式" class="headerlink" title="网络攻击基本模式"></a>网络攻击基本模式</h3><p>网络攻击包括被动威胁和主动威胁。其中被动威胁主要指截获这一手段，主动威胁包括篡改、中断和伪造这三种手段。</p><ul><li>截获—&gt;机密性：包括嗅探（Sniffing）和监听（Eavesdropping）；</li><li>篡改—&gt;完整性：主要指数据包篡改（Tampering）；</li><li>中断—&gt;可用性：常见的有拒绝服务（Dosing）；</li><li>伪造—&gt;真实性：通过欺骗（Spoofing）的方法破坏信息真实性；</li></ul><h3 id="常见攻击手段"><a href="#常见攻击手段" class="headerlink" title="常见攻击手段"></a>常见攻击手段</h3><ul><li>物理层：设备破坏、线路侦听</li><li>数据链路层：MAC欺骗、MAC泛洪、ARP欺骗</li><li>网络层：IP欺骗、Smurf攻击、ICMP攻击、地址扫描</li><li>传输层：TCP欺骗、TCP DOS、UDP DOS、端口扫描</li><li>应用层：漏洞、缓冲区溢出攻击、WEB应用攻击、病毒木马</li></ul><h4 id="物理层——物理攻击"><a href="#物理层——物理攻击" class="headerlink" title="物理层——物理攻击"></a>物理层——物理攻击</h4><ul><li>物理设备破坏：设备破坏攻击的目的主要是为了中断网络服务；</li><li>物理设备窃听：包括光纤监听和红外监听。</li><li>自然灾害：为尽量减少突发自然灾害对重要数据的破坏，常建设异地灾备数据中心。</li></ul><h4 id="数据链路层——MAC泛洪攻击"><a href="#数据链路层——MAC泛洪攻击" class="headerlink" title="数据链路层——MAC泛洪攻击"></a>数据链路层——MAC泛洪攻击</h4><p>泛洪攻击中，攻击者利用交换机中存储的MAC地址表的自动学习机制不断发送不同MAC地址给交换机，从而填满整个MAC表，此时交换机只能进行数据广播，攻击者凭此获得信息。由于交换机之间具有级联机制，故与受感交换机相连的所有交换机MAC地址表均被填满，整个网络出现数据发送缓慢、丢包甚至瘫痪的情况。可以在交换机上设置相应的端口保护机制以限制单个端口最大MAC数据接收条目数量。</p><h4 id="数据链路层——ARP欺骗"><a href="#数据链路层——ARP欺骗" class="headerlink" title="数据链路层——ARP欺骗"></a>数据链路层——ARP欺骗</h4><p>当A、B需要通讯时，A发送ARP请求询问B的MAC地址。攻击者冒充B持续发送ARP响应给A，并传递攻击者主机MAC地址，随后A发送给B的正常数据包都会被转发到攻击者主机处。</p><h4 id="网络层——ICMP攻击"><a href="#网络层——ICMP攻击" class="headerlink" title="网络层——ICMP攻击"></a>网络层——ICMP攻击</h4><p>ICMP具有多个控制报文如重定向和网络不可达等，常用于指导数据包的正确路由。</p><ul><li>ICMP重定向攻击中，攻击者主动向受害者发送ICMP重定向报文，改变受害者数据包传输路由，使其发送到不存在的网关，从而使得网关无法收到数据包，实现拒绝服务攻击。</li><li>ICMP不可达攻击中，攻击者向网关发送特定IP地址主机ICMP不可达报文，网关收到后便将受害者主机标记为不可达，从而导致受害者无法收到数据包。</li></ul><p>解决方法：通过修改注册表关闭ICMP不可达报文及重定向报文的处理功能。</p><h4 id="传输层——TCP-SYN-Flood攻击"><a href="#传输层——TCP-SYN-Flood攻击" class="headerlink" title="传输层——TCP SYN Flood攻击"></a>传输层——TCP SYN Flood攻击</h4><p>SYN报文是TCP连接的第一个报文，攻击者通过大量发送SYN报文，造成大量未完全建立的TCP连接，从而占用被攻击者的资源，以达到拒绝服务攻击的目的。</p><h4 id="应用层——DNS欺骗攻击"><a href="#应用层——DNS欺骗攻击" class="headerlink" title="应用层——DNS欺骗攻击"></a>应用层——DNS欺骗攻击</h4><p>攻击者通过篡改DNS服务器上的DNS数据破坏域名与IP地址的对应关系，当用户输入访问网站的URL后，该域名被解析成攻击者事先设置好的钓鱼网站对应的IP地址，随后用户主机会访问该IP地址进入钓鱼网站。</p><h3 id="DDoS攻击风险防护方案"><a href="#DDoS攻击风险防护方案" class="headerlink" title="DDoS攻击风险防护方案"></a>DDoS攻击风险防护方案</h3><ul><li><p>网络设备性能充裕</p><p>防火墙、路由器、交换机性能富余。</p></li><li><p>网络带宽资源充裕</p><p>保持一定比例的网络带宽余量。</p></li><li><p>异常流量清洗</p><p>通过抗D设备清洗异常流量。</p></li><li><p>通过CDN分流</p><p>多节点分担DDoS攻击流量。</p></li><li><p>分布式集群</p><p>每个节点分配足够资源数据回发瘫痪攻击源。</p></li></ul><h2 id="操作系统的脆弱性及常见攻击"><a href="#操作系统的脆弱性及常见攻击" class="headerlink" title="操作系统的脆弱性及常见攻击"></a>操作系统的脆弱性及常见攻击</h2><h3 id="操作系统漏洞分类"><a href="#操作系统漏洞分类" class="headerlink" title="操作系统漏洞分类"></a>操作系统漏洞分类</h3><ul><li>人为原因：开发者在程序代码中故意隐藏后门。</li><li>客观原因：受开发者能力、经验及当时安全技术限制，程序设计过程中存在不足之处，导致权限提升等后果。</li><li>硬件原因：编程人员无法弥补硬件自身的安全漏洞，从而使硬件问题通过软件体现。</li></ul><h3 id="缓冲区溢出攻击"><a href="#缓冲区溢出攻击" class="headerlink" title="缓冲区溢出攻击"></a>缓冲区溢出攻击</h3><p>缓冲区溢出攻击利用编写不够严谨的程序，通过向程序的缓冲区写入超过预定长度的数据，造成缓存溢出，从而破坏程序的堆栈结构，导致程序执行流程的改变，达到破坏系统或提取关键信息的目的。攻击者如果可以精确控制内存跳转地址，就可以执行指定代码，获得权限或破坏系统。</p><p><img src="http://static.zybuluo.com/B1ank/iqj0joxzi58uv01phvganocc/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA.png" alt="缓冲区溢出.png-160.9kB"></p><p>缓冲区溢出的防范可以通过以下方面考虑：</p><ul><li>用户层面需要及时更新系统及软件补丁，并保持防火墙常开。</li><li>开发人员开发程序过程中，需要编写安全代码，对输入数据进行验证，如限制输入数据的长度。同时需要使用相对安全的函数，如C语言在字符串处理过程中提供大量安全函数，如<code>strcat_s()</code>，<code>strcpy_s()</code>，<code>gets_s()</code>等。</li><li>系统层面可以运用缓冲区不可执行技术来防止缓冲区恶意代码执行，也可以采用虚拟化技术来防止缓冲区溢出漏洞的产生。</li></ul><p>由于现阶段大量程序执行过程中均会由操作系统分配随机起始地址，故对于攻击者来说获取准确的函数返回地址并实现恶意代码执行较为困难。</p><h2 id="终端的脆弱性及常见攻击"><a href="#终端的脆弱性及常见攻击" class="headerlink" title="终端的脆弱性及常见攻击"></a>终端的脆弱性及常见攻击</h2><h3 id="勒索病毒"><a href="#勒索病毒" class="headerlink" title="勒索病毒"></a>勒索病毒</h3><p>作为一种恶意程序，勒索病毒可以感染设备、网络与数据中心并使其瘫痪，直至用户支付赎金使系统解锁。该类病毒执行过程如下：受害者主机植入勒索病毒后，病毒本身调用加密算法库解密自身数据并回连服务器，随后通过脚本文件执行HTTP GET请求并下载加密后的文件，随后在受害者主机环境中进行文件解密并将该文件封装成动态链接库，随后通过wscript执行DLL文件通过遍历系统文件的方法收集计算机信息。勒索病毒会将电脑中的各类文档进行加密，让用户无法打开，并弹窗限时勒索付款提示信息，达到勒索赎金的目的。</p><h4 id="发展阶段"><a href="#发展阶段" class="headerlink" title="发展阶段"></a>发展阶段</h4><ul><li>第一阶段：2008年以前，只锁定用户设备不加密数据，以LockScreen为代表家族。</li><li>第二阶段：2013年以前，采用高强度对称和非对称加密算法加密用户数据，以CTB-Locker、TeslaCrypt、Cerber为代表家族。</li><li><p>第三阶段：2017年前后，通过系统漏洞或弱口令等方式发起蠕虫式攻击，攻陷单点设备后还会在内网中横向扩散，以WannaCry和Satan为代表。</p></li><li><p>第四阶段：加密货币的出现改变勒索格局，加密货币具有匿名性与去中心化的特点，解决攻击者的传统问题，脱离货币交易链的追查与监管，黑色产业因此蓬勃发展。</p></li><li>第五阶段：勒索软件服务化，RaaS模式初见规模。</li></ul><h4 id="勒索病毒感染与传播方式"><a href="#勒索病毒感染与传播方式" class="headerlink" title="勒索病毒感染与传播方式"></a>勒索病毒感染与传播方式</h4><p><img src="http://static.zybuluo.com/B1ank/kf8g2f60fue34frqaqbdqzti/%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E6%84%9F%E6%9F%93%E4%B8%8E%E4%BC%A0%E6%92%AD%E6%96%B9%E5%BC%8F.png" alt="勒索病毒感染与传播方式.png-798.9kB"></p><h4 id="勒索病毒攻击链"><a href="#勒索病毒攻击链" class="headerlink" title="勒索病毒攻击链"></a>勒索病毒攻击链</h4><p><strong>感染媒介—&gt;C&amp;C通信—&gt;文件加密—&gt;横向移动</strong></p><h4 id="高效勒索病毒协同防护体系"><a href="#高效勒索病毒协同防护体系" class="headerlink" title="高效勒索病毒协同防护体系"></a>高效勒索病毒协同防护体系</h4><p><img src="http://static.zybuluo.com/B1ank/46s9biegbyjcg5rdic2oteuz/%E6%9E%84%E5%BB%BA%E9%AB%98%E6%95%88%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%8D%8F%E5%90%8C%E9%98%B2%E6%8A%A4%E4%BD%93%E7%B3%BB.png" alt="构建高效勒索病毒协同防护体系.png-1277.5kB"></p><h3 id="挖矿病毒"><a href="#挖矿病毒" class="headerlink" title="挖矿病毒"></a>挖矿病毒</h3><p>作为一种恶意程序，挖矿程序可以自动传播，在未授权的情况下占用系统资源，为攻击者牟利，使得受害者机器性能明显下降，影响正常使用。挖矿病毒占用CPU或GPU等计算资源，自动创建后门与混淆进程，同时该病毒定期改变进程名与PID并检测系统中是否存在对应的挖矿软件，若被查杀则再次从远端服务器上获取资源。同时该病毒通过扫描SSH文件感染其他机器，实现横向传播。</p><h3 id="特洛伊木马"><a href="#特洛伊木马" class="headerlink" title="特洛伊木马"></a>特洛伊木马</h3><p>完整的木马程序一般由服务器程序与控制器程序两部分组成，当受害者主机安装了木马的服务器程序后，拥有控制器程序的攻击者就可以通过网络控制受害者主机。木马程序通常注入正常程序中，当用户执行正常程序时启动。同时，木马程序自动在任务管理器中隐藏，并以”系统服务”的方式欺骗操作系统，包含具有未公开并且可能产生危险后果的功能的程序，具备自动恢复与打开特殊端口的功能。</p><h3 id="蠕虫病毒"><a href="#蠕虫病毒" class="headerlink" title="蠕虫病毒"></a>蠕虫病毒</h3><p>蠕虫是一种可以自我复制并通过网络传播的代码，通常无需人为干预即可实现传播。蠕虫病毒入侵并完全控制一台计算机后，就会把这台主机作为宿主，进而扫描并感染其他计算机。蠕虫病毒具有不依赖宿主程序、利用漏洞主动攻击、通过蠕虫网络隐藏攻击者位置的特点。该类病毒易造成拒绝服务与隐私信息丢失。</p><h3 id="宏病毒"><a href="#宏病毒" class="headerlink" title="宏病毒"></a>宏病毒</h3><p>宏病毒是一种寄存在文档或模板的宏中的计算机病毒，具有感染文档、传播速度快、病毒制作周期短、可实现多平台交叉感染的特点。宏病毒通过调用系统命令造成系统破坏，除此之外，感染宏病毒的文档无法正常打印，并具有封闭或改变文件存储路径、非法复制文件等行为。</p><h3 id="僵尸网络"><a href="#僵尸网络" class="headerlink" title="僵尸网络"></a>僵尸网络</h3><p>采用一种或多种传播手段，将大量主机感染僵尸程序，从而在控制者和被感染主机之间形成一个一对多控制网络。僵尸网络的形成过程包含<strong>加入、传播和控制</strong>三个阶段。</p><p>僵尸程序多指实现恶意控制功能的程序代码，控制服务器多指控制和通信的中心服务器。</p><h2 id="其他常见攻击"><a href="#其他常见攻击" class="headerlink" title="其他常见攻击"></a>其他常见攻击</h2><h3 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h3><p>社会工程攻击通常被认为是一种欺诈他人以收集信息、行骗和入侵计算机系统的行为，可以通过定期更换各种系统账号密码或使用高强度密码等防御该类攻击。</p><h3 id="人为因素"><a href="#人为因素" class="headerlink" title="人为因素"></a>人为因素</h3><ul><li>无意行为：如工作失误、经验问题、体制不健全等；</li><li>恶意行为：攻击者出于政治、经济、商业或个人目的制造病毒及破坏性程序，攻击企业信息系统并获取重要资料。</li><li>防范措施<ul><li>提升安全意识</li><li>最低权限访问模式</li><li>完善和落地管理措施</li><li>利用已有安全手段对核心资产进行安全保护</li></ul></li></ul><h3 id="拖库洗库撞库"><a href="#拖库洗库撞库" class="headerlink" title="拖库洗库撞库"></a>拖库洗库撞库</h3><p>拖库是指黑客入侵有价值的网络站点并将注册用户的资料数据库全部盗走的行为。</p><p>洗库指在获取大量用户数据后，黑客通过一系列的技术手段和黑色产业链将有价值的用户数据变现的行为。</p><p>撞库指黑客利用获得的私密数据在其他网站上进行登录尝试的行为。</p><h3 id="跳板攻击"><a href="#跳板攻击" class="headerlink" title="跳板攻击"></a>跳板攻击</h3><p>攻击者通常不直接通过自己的系统向目标发动攻击，而是先攻破若干中间系统并将其作为”跳板”，借助这些计算机完成攻击行动。用户可以通过安装防火墙以控制流量进出、更改系统默认登录用户为普通用户并做好权限控制等手段抵御此类攻击。</p><h3 id="钓鱼式攻击"><a href="#钓鱼式攻击" class="headerlink" title="钓鱼式攻击"></a>钓鱼式攻击</h3><p>钓鱼攻击是一种企图从电子通讯中，通过伪装成信誉卓著的法人媒体以获得如用户名、密码和信用卡明细等个人敏感信息的犯罪诈骗过程。鱼叉式钓鱼攻击指针对特定受害公司或组织的钓鱼攻击，其钓鱼页面设计与整体操作流程具有定制化、精准化的特点，成功率较高。可以通过保证网络站点与用户之间的安全传输、加强网络站点的认证过程与监管等方式防御此类攻击。</p><h3 id="水坑攻击"><a href="#水坑攻击" class="headerlink" title="水坑攻击"></a>水坑攻击</h3><p>攻击者首先通过观察或猜测确定特定目标经常访问的网站，并入侵其中一个或多个网站，植入恶意软件。当目标组织或组织中部分成员访问该类网站时会被重定向到恶意网址，导致恶意软件执行，最终造成该组织机器的大量感染。为抵御此类攻击，运维人员通常在浏览器或软件上进行安全杀毒和检测工作，若检测到恶意内容，则持续监控该网站流量并阻止恶意流量。此外，运维人员可以通过定期更新补丁的方式减少浏览器漏洞。</p><h2 id="信息安全要素"><a href="#信息安全要素" class="headerlink" title="信息安全要素"></a>信息安全要素</h2><ul><li><p>保密性Confidentiality</p><p>确保信息不暴露给未授权的实体或进程。</p></li><li><p>完整性Integrity</p><p>只有得到允许的用户才能修改实体或进程，并且能够判别出实体或进程是否被篡改。</p></li><li><p>可用性Availability</p><p>得到授权的实体可获得服务，攻击者不能占用所有资源而阻碍授权者的工作。</p></li><li><p>可控性Controllability</p><p>可控性主要指对危害国家信息（包括利用加密的非法通信活动）的监视审计。</p></li><li><p>不可否认性Non-repudiation</p><p>为出现的安全问题提供调查的依据和手段，使用审计、监控、防抵赖等安全机制使得攻击者无法否认相关操作。</p></li></ul><h2 id="安全解决方案"><a href="#安全解决方案" class="headerlink" title="安全解决方案"></a>安全解决方案</h2><h3 id="企业安全解决方案构建"><a href="#企业安全解决方案构建" class="headerlink" title="企业安全解决方案构建"></a>企业安全解决方案构建</h3><h4 id="企业信息安全建设规划目标"><a href="#企业信息安全建设规划目标" class="headerlink" title="企业信息安全建设规划目标"></a>企业信息安全建设规划目标</h4><ul><li>风险可视化Visibility</li><li>防御主动话Proactive</li><li>运行自动化Automation</li><li>安全智能化Intelligent</li></ul><h4 id="传统安全方案痛点"><a href="#传统安全方案痛点" class="headerlink" title="传统安全方案痛点"></a>传统安全方案痛点</h4><ul><li>产品堆叠为主</li><li>边界防护为主</li><li>被动防守为主</li></ul><h4 id="APDRO智安全架构"><a href="#APDRO智安全架构" class="headerlink" title="APDRO智安全架构"></a>APDRO智安全架构</h4><ul><li>智能Artificial Intelligence</li><li>防御Protect</li><li>检测Detect</li><li>响应Respond</li><li>运营Operate</li></ul><h4 id="安全域划分"><a href="#安全域划分" class="headerlink" title="安全域划分"></a>安全域划分</h4><p>将企业数据区域进行安全等级划分，分成<strong>非安全区</strong>、<strong>半安全区</strong>、<strong>安全区</strong>和<strong>核心安全区</strong>四个部分。</p><ul><li>非安全区是数据中心等关键区域与外部直接连接的区域，属于非信任区域。</li><li>半安全区是非安全区与安全区之间的过渡区域，用于分割它们之间的直接联系，隐藏安全区的内部资源。</li><li>安全区是安全级别次高的区域。</li><li>核心安全区是安全级别最高的区域。</li></ul><p>各安全域访问原则如下：</p><p><img src="http://static.zybuluo.com/B1ank/3ks10jb35kbi99384msudatw/%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86.png" alt="安全区域划分.png-118.4kB"></p><h3 id="上网行为安全解决方案-AC"><a href="#上网行为安全解决方案-AC" class="headerlink" title="上网行为安全解决方案 AC"></a>上网行为安全解决方案 AC</h3><h4 id="上网行为可视"><a href="#上网行为可视" class="headerlink" title="上网行为可视"></a>上网行为可视</h4><ul><li>用户可视</li><li>流量&amp;应用可视</li><li>内容可视</li></ul><h4 id="上网行为可控"><a href="#上网行为可控" class="headerlink" title="上网行为可控"></a>上网行为可控</h4><ul><li>工作效率提升</li><li>流量可视可控</li><li>规避法律法规法风险</li></ul><h3 id="纵深边界安全解决方案-Firewall"><a href="#纵深边界安全解决方案-Firewall" class="headerlink" title="纵深边界安全解决方案 Firewall"></a>纵深边界安全解决方案 Firewall</h3><h4 id="精细化资产攻击面管理"><a href="#精细化资产攻击面管理" class="headerlink" title="精细化资产攻击面管理"></a>精细化资产攻击面管理</h4><ul><li>资产可视</li><li>高危端口可视</li><li>策略智能调优</li></ul><h4 id="场景化安全防护实践"><a href="#场景化安全防护实践" class="headerlink" title="场景化安全防护实践"></a>场景化安全防护实践</h4><ul><li>防黑客渗透</li><li>防内网病毒扩散</li><li>办公环境安全性&amp;连续性保障</li><li>资产失陷外连泄密防护</li></ul><h3 id="移动接入安全解决方案"><a href="#移动接入安全解决方案" class="headerlink" title="移动接入安全解决方案"></a>移动接入安全解决方案</h3><h4 id="端到端移动安全"><a href="#端到端移动安全" class="headerlink" title="端到端移动安全"></a>端到端移动安全</h4><ul><li>精确身份认证</li><li>角色授权与URL级别授权</li><li>支持1024、2028位商密或国密算法</li><li>主从账号绑定、服务器地址伪装、应用隐藏</li></ul><h4 id="创新移动终端安全"><a href="#创新移动终端安全" class="headerlink" title="创新移动终端安全"></a>创新移动终端安全</h4><ul><li>移动终端个人域与工作域隔离</li><li>防中间人攻击、客户端安全检查</li><li>SSL专线、客户端痕迹清除</li></ul><h3 id="端点安全"><a href="#端点安全" class="headerlink" title="端点安全"></a>端点安全</h3><h4 id="方案优势"><a href="#方案优势" class="headerlink" title="方案优势"></a>方案优势</h4><ul><li>支持多个操作系统</li><li>实现跨平台</li><li>集中管控</li><li>轻量级</li></ul><h4 id="加固"><a href="#加固" class="headerlink" title="加固"></a>加固</h4><p>用于业务域内部及业务域之间，基于应用策略，实现主机东西向流量访问控制。</p><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><p>全面探测服务器主机和网络上的威胁活动，进行入侵行为主动IP封堵与恶意文件隔离。</p><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><p>结合传统技术与人工智能，采用机器学习模型实现针对病毒木马、僵尸网络及暴力破解行为的检测。</p><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><p>采用IP黑白名单机制及文件隔离机制，监控进程的可疑行为，以即时拦阻恶意代码。</p><h3 id="网络安全拓扑参考"><a href="#网络安全拓扑参考" class="headerlink" title="网络安全拓扑参考"></a>网络安全拓扑参考</h3><p><img src="http://static.zybuluo.com/B1ank/0oyed4w8i7oqhv4wlm20lt2s/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8B%93%E6%89%91%E5%8F%82%E8%80%83.png" alt="网络安全拓扑参考.png-1531.1kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安全背景&quot;&gt;&lt;a href=&quot;#安全背景&quot; class=&quot;headerlink&quot; title=&quot;安全背景&quot;&gt;&lt;/a&gt;安全背景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数字化时代威胁升级&lt;/li&gt;
&lt;li&gt;传统安全防护在数字化转型中逐渐失效&lt;/li&gt;
&lt;li&gt;安全风险能见度不足&lt;
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Information Security" scheme="https://blank-vax.github.io/tags/Information-Security/"/>
    
  </entry>
  
  <entry>
    <title>服务器安全检测和防御技术</title>
    <link href="https://blank-vax.github.io/2020/06/26/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%A3%80%E6%B5%8B%E5%92%8C%E9%98%B2%E5%BE%A1%E6%8A%80%E6%9C%AF/"/>
    <id>https://blank-vax.github.io/2020/06/26/服务器安全检测和防御技术/</id>
    <published>2020-06-26T02:32:00.000Z</published>
    <updated>2020-11-09T03:39:09.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DoS攻击检测与防御"><a href="#DoS攻击检测与防御" class="headerlink" title="DoS攻击检测与防御"></a>DoS攻击检测与防御</h2><h3 id="DoS攻击"><a href="#DoS攻击" class="headerlink" title="DoS攻击"></a>DoS攻击</h3><p>Denial of Service，是一种拒绝服务攻击，常用来使服务器或网络瘫痪。</p><p>Distributed Denial of Service，简称为DDoS攻击，是一种分布式拒绝服务攻击。</p><h3 id="DoS类型"><a href="#DoS类型" class="headerlink" title="DoS类型"></a>DoS类型</h3><ul><li>发送大量所属协议的数据包达到占据服务端带宽并堵塞线路的目的<ul><li>ICMP洪水攻击</li><li>UDP洪水攻击</li><li>SYN洪水攻击</li></ul></li><li>利用TCP三次握手特性，大量发起请求包以占用服务器资源，最终实现服务器资源耗尽<ul><li>SYN洪水攻击</li></ul></li><li>畸形数据包攻击<ul><li>PingofDeath</li><li>TearDrop</li></ul></li><li>CC攻击（主要用来攻击页面）</li><li>慢速攻击</li></ul><h3 id="SYN洪水防护"><a href="#SYN洪水防护" class="headerlink" title="SYN洪水防护"></a>SYN洪水防护</h3><h4 id="每目的IP激活阈值"><a href="#每目的IP激活阈值" class="headerlink" title="每目的IP激活阈值"></a>每目的IP激活阈值</h4><p>每目的IP激活阈值指当针对策略设置的目的IP组内某IP发起的SYN请求速率数据包超过设定值，则触发AF的SYN代理功能。</p><h4 id="每目的IP丢包阈值"><a href="#每目的IP丢包阈值" class="headerlink" title="每目的IP丢包阈值"></a>每目的IP丢包阈值</h4><p>每目的IP丢包阈值指当针对策略设置的目的IP组内某IP发起的SYN请求速率数据包超过设定值，则AF不再启用SYN代理，直接丢弃SYN包。</p><h2 id="漏洞攻击防护入侵检测与防御"><a href="#漏洞攻击防护入侵检测与防御" class="headerlink" title="漏洞攻击防护入侵检测与防御"></a>漏洞攻击防护入侵检测与防御</h2><h3 id="IDS"><a href="#IDS" class="headerlink" title="IDS"></a>IDS</h3><p>Intrusion Detection Systems，即入侵检测系统，对网络、系统的运行状况进行监视，尽可能发现各种攻击企图、攻击行为或攻击结果。通过旁路镜像模式部署，多用于被动检测。</p><h3 id="IPS"><a href="#IPS" class="headerlink" title="IPS"></a>IPS</h3><p>Intrusion Prevention Systems，即入侵防御系统，可对网络、系统的运行状况进行监视，并可发现阻止各种攻击企图、攻击行为。通过路由模式、透明模式及并联模式部署，多用于主动检测。</p><h3 id="常见漏洞攻击手段"><a href="#常见漏洞攻击手段" class="headerlink" title="常见漏洞攻击手段"></a>常见漏洞攻击手段</h3><h4 id="Worm蠕虫"><a href="#Worm蠕虫" class="headerlink" title="Worm蠕虫"></a>Worm蠕虫</h4><p><img src="http://static.zybuluo.com/B1ank/cd1w8ekz3l3d1zdqn5flqy5x/worm%E8%A0%95%E8%99%AB.png" alt="worm蠕虫.png-291.6kB"></p><h4 id="口令暴力破解"><a href="#口令暴力破解" class="headerlink" title="口令暴力破解"></a>口令暴力破解</h4><p>常见的暴力破解方法包括<strong>字典法</strong>与<strong>规则破解法</strong>。</p><ul><li>字典法：黑客通过各种手段获取一些网络用户经常使用的弱密码，集合在一起形成文本文件，并使用该文件进行口令爆破。</li><li>规则破解法：通过账户相关信息或用户个人信息进行破解。</li></ul><h3 id="漏洞攻击防护原理"><a href="#漏洞攻击防护原理" class="headerlink" title="漏洞攻击防护原理"></a>漏洞攻击防护原理</h3><p>漏洞攻击防护通过对数据包应用层里的数据内容进行威胁特征检查，并与漏洞攻击防护规则库进行比对，如果匹配则拒绝该数据包，从而实现应用层漏洞攻击的防护。</p><h3 id="误判处置"><a href="#误判处置" class="headerlink" title="误判处置"></a>误判处置</h3><ul><li>配置漏洞攻击防护规则时，在漏洞攻击防护日志中勾选”记录”。</li><li>根据数据中心的日志，查询到误判规则的漏洞ID。</li><li>【对象】-【安全防护规则库】-【安全规则库】-漏洞特征识别库中，修改相应漏洞ID的动作。</li><li>白名单添加例外。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>配置漏洞攻击防护保护客户端和服务器时，源区域为数据连接发起的区域。</li><li>漏洞攻击防护保护客户端与保护服务器中的客户端漏洞和服务器漏洞规则是不同的。</li></ul><h2 id="Web攻击检测与防御"><a href="#Web攻击检测与防御" class="headerlink" title="Web攻击检测与防御"></a>Web攻击检测与防御</h2><h3 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h3><p>Web Application Firewall，即Web应用防护，主要用于保护Web服务器不受攻击，而导致软件服务中断或被远程控制。WAF常见攻击手段包括：</p><ul><li>SQL注入</li><li>XSS攻击</li><li>网页木马</li><li>网站扫描</li><li>WEBSHELL</li><li>跨站请求伪造</li><li>系统命令注入</li><li>文件包含攻击</li><li>目录遍历攻击</li><li>信息泄漏攻击</li></ul><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>通过将SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意SQL命令的目的。</p><h4 id="GET与POST请求"><a href="#GET与POST请求" class="headerlink" title="GET与POST请求"></a>GET与POST请求</h4><p>GET请求提交的内容经过URL编码直接在URL栏中显示。</p><p>POST提交的内容不会直接显示在URL部分，而是呈现在POST包的DATA字段中。</p><h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><p>Cross Site Request Fogery，即跨站请求伪造，攻击者盗用受害用户的身份，以其名义发送恶意请求，对服务器来说这个请求是合法的，但完成了攻击者所期望的操作，如以受害用户的名义发送邮件和信息，盗取账号，添加系统管理员等非法操作。</p><h3 id="误判处置-1"><a href="#误判处置-1" class="headerlink" title="误判处置"></a>误判处置</h3><ul><li><p>在【策略】-【安全策略】-【安全防护策略】-【高级设置】中新增URL参数排除后，Web应用防护的网站攻击检测将跳过这些参数的检查。主要用于正常业务下某些请求参数因携带特征串而被检测为攻击的情况，可以只针对这类参数进行排除。</p></li><li><p>在【内置数据中心】-【日志查询】-【WEB应用防护】中查询日志，找出误判日志然后点击日志后面的”添加例外”。</p></li></ul><h2 id="联动封锁技术"><a href="#联动封锁技术" class="headerlink" title="联动封锁技术"></a>联动封锁技术</h2><h3 id="联动封锁类型"><a href="#联动封锁类型" class="headerlink" title="联动封锁类型"></a>联动封锁类型</h3><p>高危行为联动封锁：仅封锁具有高危行为特征的IP，优先保证用户流畅上网、业务稳定；</p><p>任意攻击行为联动封锁：对任意具有攻击特征的IP执行访问封锁，最大化业务和用户的安全防御能力。</p><h3 id="联动封锁机制"><a href="#联动封锁机制" class="headerlink" title="联动封锁机制"></a>联动封锁机制</h3><ul><li>高危行为联动封锁功能仅关联。</li><li>任意攻击行为联动功能关联。</li><li>策略触发的联动封锁是针对数据包的会话五元组进行拦截。</li></ul><h2 id="网页防篡改技术"><a href="#网页防篡改技术" class="headerlink" title="网页防篡改技术"></a>网页防篡改技术</h2><p>深信服网页防篡改解决方案采用<strong>文件保护系统+下一代防火墙</strong>紧密结合，<strong>文件监控+二次认证</strong>功能紧密联动，保证网站内容不被篡改，其中文件保护系统采用业界防篡改技术中最先进的文件过滤驱动技术。</p><h3 id="管理员认证流程"><a href="#管理员认证流程" class="headerlink" title="管理员认证流程"></a>管理员认证流程</h3><p><img src="http://static.zybuluo.com/B1ank/3y4y65j05h0g5asinforhet8/%E7%BD%91%E9%A1%B5%E9%98%B2%E7%AF%A1%E6%94%B9.png" alt="网页防篡改.png-328.4kB"></p><ul><li>访问网站后台</li><li>AF重定向提交管理员邮箱地址的认证页面</li><li>提交接收验证码的管理员邮箱</li><li>发送带有验证码的邮件至上述管理员邮箱</li><li>管理员登录邮箱获取验证码</li><li>管理员提交验证码通过认证</li><li>通过验证后自动跳转到后台页面</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>防篡改客户端必须连接防火墙并匹配防篡改策略后才会生效，防篡改客户端生效后，即使防火墙不在线，功能依然生效。</li><li>若网站本身有webshell未删除，则防篡改客户端无法拦截webshell的文件篡改行为。</li><li>Windows系统中，防篡改客户端无法通过控制面板-卸载程序进行卸载，需要使用安装目录中的<code>tamper.exe</code>进行卸载，卸载时需要输入客户端密码。</li><li>Linux系统中，针对防篡改功能开启前已经建立的会话或连接，防篡改功能不会生效。</li><li>Linux系统中，已经被防篡改保护的会话或连接在防篡改进程停止的情况下依然会生效。</li><li>Linux系统中，开启防篡改的服务器，如果需要完全消除防篡改的影响，则需要先卸载防篡改程序后重启所有服务或直接重启服务器。</li><li>Linux系统中，Agent自身存在bypass机制，当服务器内存系统资源超过70%时，功能可以生效但无法向AF同步安全日志。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DoS攻击检测与防御&quot;&gt;&lt;a href=&quot;#DoS攻击检测与防御&quot; class=&quot;headerlink&quot; title=&quot;DoS攻击检测与防御&quot;&gt;&lt;/a&gt;DoS攻击检测与防御&lt;/h2&gt;&lt;h3 id=&quot;DoS攻击&quot;&gt;&lt;a href=&quot;#DoS攻击&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Server Security" scheme="https://blank-vax.github.io/tags/Server-Security/"/>
    
  </entry>
  
  <entry>
    <title>数字证书</title>
    <link href="https://blank-vax.github.io/2020/06/21/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"/>
    <id>https://blank-vax.github.io/2020/06/21/数字证书/</id>
    <published>2020-06-21T10:13:00.000Z</published>
    <updated>2020-11-09T03:38:52.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h2><h3 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h3><ul><li>对称加密过程中，Alice和Bob使用相同的密钥进行数据加密</li><li>非对称加密过程中，密钥由（公钥，私钥）密钥对构成。<ul><li><strong>非对称密钥加解密</strong>：Alice与Bob通信过程中，Alice首先在公开信道上发送公钥。Bob使用Alice的公钥加密信息，随后Alice使用自己的私钥进行解密。</li><li><strong>非对称密钥签名</strong>：Alice使用私钥加密签名消息，Bob使用Alice的公钥对签名进行相关验证，以确认Alice的身份。</li></ul></li></ul><h3 id="特点及应用场景"><a href="#特点及应用场景" class="headerlink" title="特点及应用场景"></a>特点及应用场景</h3><p>由于对称加密具有更快的数据传输速度，而非对称加密具有更高的安全性，故实际应用过程中常常通过非对称加密的公钥对对称加密的密钥进行加密处理，随后接收方使用私钥进行解密，至此双方实现密钥共享。之后二者便可以用相同的对称加密密钥实现对大量数据的对称加解密过程。</p><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>数字证书（Digital Certificate or Public Key Certificate）指在互联网通讯中标志通讯各方身份信息的数字认证，在网络中使用其识别对方身份，本质上是一种身份证明电子文档。</p><p>证书授权中心CA（Certificate Authority）负责发放和管理数字证书，具有足够的权威性。</p><h3 id="证书分类"><a href="#证书分类" class="headerlink" title="证书分类"></a>证书分类</h3><p>按照持有者可分为个人证书、单位证书及系统证书。</p><p>按照证书用途可分为签名证书及加密证书，具体区别如下：</p><ul><li>签名证书用于签名和验证签名，为确保密钥安全，一般在客户端产生和保存密钥对。</li><li>加密证书用于加密，密钥对由CA产生，通过保护算法和协议发送给用户使用，同时CA中心对该密钥进行备份处理。</li></ul><h3 id="证书格式"><a href="#证书格式" class="headerlink" title="证书格式"></a>证书格式</h3><p>证书具有PEM和DER两种编码格式，其中PEM采用Base64编码字符保存，而DER格式采用二进制保存。</p><p>一张证书包含非对称加密密钥对，通常用.crt后缀标识公钥，用.key后缀标识私钥。还有一种将公钥与私钥捆绑保存的方法，其后缀通常为.pfx或.p12。</p><h3 id="证书内容"><a href="#证书内容" class="headerlink" title="证书内容"></a>证书内容</h3><p>证书公钥除保存公钥内容外，通常包含颁发者、使用者、有效期和签名等信息。</p><p>证书私钥中包含公钥信息以及所有非对称加密算法的参数。</p><h3 id="证书信任链"><a href="#证书信任链" class="headerlink" title="证书信任链"></a>证书信任链</h3><ul><li>CA：数字证书认证中心的简称。</li><li>根CA：处在信任链的顶端，其证书公钥默认导入各种操作系统和浏览器中。</li><li>中级CA：处于信任链的中部，由根CA或其他中级CA颁发的证书，本身还可以继续颁发子证书。</li><li><p>个人证书：处在信任链末端，由中级CA或根CA颁发的证书。</p></li><li><p>证书之间的信任关系可以嵌套。只要信任链上的头部证书，则后续证书均可信任。证书链的存在作用为降低中级CA私钥泄露造成的影响。</p></li></ul><p><img src="http://static.zybuluo.com/B1ank/td398udjr4yvi1054ybyl3wg/CA%E9%93%BE.png" alt="CA链.png-189.8kB"></p><h3 id="证书吊销列表"><a href="#证书吊销列表" class="headerlink" title="证书吊销列表"></a>证书吊销列表</h3><p>为防止证书持有者泄露证书私钥造成的身份冒用，各CA都维护一张CRL列表，内部标记虽处于有效期内但无法正常使用的证书。</p><h3 id="证书工作原理"><a href="#证书工作原理" class="headerlink" title="证书工作原理"></a>证书工作原理</h3><h4 id="数字证书生成"><a href="#数字证书生成" class="headerlink" title="数字证书生成"></a>数字证书生成</h4><p>服务器给客户端发送公钥的过程中，将公钥与服务器的个人信息通过哈希算法生成消息摘要。为防止摘要被人调换，服务器还会用CA提供的私钥对消息摘要进行加密，从而形成数字签名。最后服务器将未经哈希处理的信息与数字签名合并在一起形成数字证书。</p><p><img src="http://static.zybuluo.com/B1ank/6oq68hu6r9u1u5q3sepxub6y/certificate_generation.png" alt="certificate_generation.png-47.7kB"></p><h4 id="数字证书验证"><a href="#数字证书验证" class="headerlink" title="数字证书验证"></a>数字证书验证</h4><p>客户端收到数字证书后，使用CA提供的公钥对数字证书内部的数字签名进行解密得到消息摘要，随后对数字证书内部服务器的公钥和个人信息进行哈希计算以获取另外一份消息摘要。对比这两份摘要，若吻合则通过服务器身份验证，否则不通过验证。</p><p><img src="http://static.zybuluo.com/B1ank/hru2f9uxqjlulau1qtwurf3j/certificate_verification.png" alt="certificate_verification.png-108.7kB"></p><h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><p>SSL（Secure Sockets Layer，安全套接层）是HTTPS下的协议加密层，建立在可靠的传输协议上，为高层协议提供数据封装、压缩、加密等基本功能，主要分为以下两层：</p><h4 id="SSL记录协议层"><a href="#SSL记录协议层" class="headerlink" title="SSL记录协议层"></a>SSL记录协议层</h4><p>SSL记录协议层为高层协议提供基本的安全服务，记录封装各种高层协议，具体实施压缩解压缩、加密解密、计算和校验MAC等与安全有关的操作。</p><h4 id="SSL握手协议层"><a href="#SSL握手协议层" class="headerlink" title="SSL握手协议层"></a>SSL握手协议层</h4><p>SSL握手协议层包括SSL握手协议（SSL HandShake Protocol）、SSL密码参数修改协议（SSL Change Cipher Spec Protocol）、应用数据协议（Application Data Protocol）和SSL告警协议（SSL Alert Protocol）。这些协议用于SSL管理信息的交换，允许应用协议传送数据之前相互验证，执行协商加密算法和生成密钥等操作，以建立同步状态。</p><h4 id="SSL单向认证过程"><a href="#SSL单向认证过程" class="headerlink" title="SSL单向认证过程"></a>SSL单向认证过程</h4><p><img src="http://static.zybuluo.com/B1ank/exmuhynb7xl7tt7n8qirtmc4/SSL%E5%8D%95%E5%90%91%E8%AE%A4%E8%AF%81.png" alt="SSL单向认证.png-260kB"></p><p>单向认证过程中只进行客户端对服务器的认证。客户端首先向服务器发送<code>Client Hello</code>数据包，包含随机数A以及可供选择的加密套件与加密算法参数。服务器收到后回复<code>Server Hello</code>数据包，包含随机数B及服务器选择的加密套件，随后回复证书链并完成服务器数据发送。客户端收到后验证服务器证书链并发送使用服务器公钥加密后的随机数C，服务器端使用私钥对客户端发送信息进行解密以获取随机数C。至此双方均获得随机数A、B、C，使用这三个随机数并结合服务器选择的加密套件，对数据流进行对称加密，实现安全传输。</p><h4 id="SSL双向认证过程"><a href="#SSL双向认证过程" class="headerlink" title="SSL双向认证过程"></a>SSL双向认证过程</h4><p><img src="http://static.zybuluo.com/B1ank/s7e55r8ztxga58iz3er1qqrt/SSL%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81.png" alt="SSL双向认证.png-325.8kB"></p><p>与单向认证相比，双向认证过程中除进行客户端对服务器证书链的验证外，还包含服务器对客户端的证书链验证操作，从而实现双向安全认证。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;密码学基础&quot;&gt;&lt;a href=&quot;#密码学基础&quot; class=&quot;headerlink&quot; title=&quot;密码学基础&quot;&gt;&lt;/a&gt;密码学基础&lt;/h2&gt;&lt;h3 id=&quot;对称加密与非对称加密&quot;&gt;&lt;a href=&quot;#对称加密与非对称加密&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Digital Certificate" scheme="https://blank-vax.github.io/tags/Digital-Certificate/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础及常用命令</title>
    <link href="https://blank-vax.github.io/2020/06/17/Linux%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://blank-vax.github.io/2020/06/17/Linux基础及常用命令/</id>
    <published>2020-06-17T01:25:00.000Z</published>
    <updated>2020-11-09T03:38:38.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux系统基础"><a href="#Linux系统基础" class="headerlink" title="Linux系统基础"></a>Linux系统基础</h2><p>Linux系统是一个类Unix操作系统，设计初衷为替代Unix系统。系统命令实际上是一个在用户编程接口上的可执行程序，内部引用API来实现相应的功能。</p><p>与Windows系统不同，Linux系统中所有部件（包括硬件）均使用文件保存，且不存在多个并列驱动器盘符，即不存在多个并列根目录，而是所有目录均在同一根目录下。Windows系统使用扩展名区分文件，而Linux系统中不存在扩展名概念，为方便区分使用部分扩展。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul><li><strong>/bin</strong>：存放二进制可执行文件，常用命令一般存放在此处。</li><li><strong>/etc</strong>：存放系统管理和配置文件。</li><li><strong>/home</strong>：存放所有用户文件的根目录，是用户主目录的基点，可使用<code>~</code>表示。</li><li><strong>/usr</strong>：用于存放系统应用程序，比较重要的目录<code>/usr/local</code>是本地系统管理员软件安装目录，用于存放系统级应用。</li><li><strong>/opt</strong>：额外安装的可选应用程序包存放的位置。</li><li><strong>/proc</strong>：此目录的数据如系统核心、外部设备、网络状态等均存放于内存中，不占用磁盘空间。较为重要的目录有：<code>/proc/cpuinfo</code>，<code>/proc/interrupts</code>，<code>/proc/dma</code>，<code>/proc/net/*</code>等。</li><li><strong>/root</strong>：系统管理员root的家目录。</li><li><strong>/sbin、/usr/sbin、/usr/local/sbin</strong>：放置系统管理员使用的可执行命令，如<code>fdsk</code>、<code>shutdown</code>、<code>mount</code>等。由于这些目录存放root用户可使用的命令，故一般用户只能查看而无法设置和使用。</li><li><strong>/tmp</strong>：一般用户或正在执行的程序临时存放文件的目录，任何人均可访问。</li><li><strong>/var</strong>：放置系统执行过程中经常变化的文件，如随时更改的日志文件<code>/var/log</code>，所有登录文件存放目录<code>/var/log/message</code>，邮件存放目录<code>/var/spool/mail</code>，程序或服务启动后PID存放目录<code>/var/run</code>。</li></ul><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="命令基础知识"><a href="#命令基础知识" class="headerlink" title="命令基础知识"></a>命令基础知识</h4><ul><li>Linux系统命令区分大小写，而Windows系统命令对大小写不敏感</li><li>Tab补全</li></ul><h4 id="进出目录命令-cd"><a href="#进出目录命令-cd" class="headerlink" title="进出目录命令 cd"></a>进出目录命令 cd</h4><ul><li><code>.</code>代表当前目录，<code>..</code>代表父目录，<code>~</code>代表用户的个人主目录。</li><li>常用选项<ul><li><code>cd ~</code>：进入当前用户主目录</li><li><code>cd -</code>：返回进入此目录之前所在的目录</li><li><code>cd !$</code>：将上个命令的参数作为cd参数使用</li></ul></li></ul><h4 id="查看目录信息-ls"><a href="#查看目录信息-ls" class="headerlink" title="查看目录信息 ls"></a>查看目录信息 ls</h4><p>ls命令列出文件或目录信息，常用参数如下：</p><ul><li>-a：显示包含以”.”开头的隐藏文件。</li><li>-A：显示指定目录下所有的子目录及文件，包括隐藏文件，但不显示”.”和”..”。</li><li>-c：按文件的修改时间排序。</li><li>-C：分成多列显示各行。</li><li>-d：如果参数为目录，只显示其名称而不显示其下的各个文件。</li><li>-l：以长格形式显示文件的详细信息</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="查看文件命令"><a href="#查看文件命令" class="headerlink" title="查看文件命令"></a>查看文件命令</h3><h4 id="Linux系统文件概述"><a href="#Linux系统文件概述" class="headerlink" title="Linux系统文件概述"></a>Linux系统文件概述</h4><p><img src="http://static.zybuluo.com/B1ank/oe5uwe8ibb7nj9r5gg321xf5/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png" alt="文件系统.png-570.2kB"></p><h4 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h4><p>该命令主要用于滚屏显示文件内容。常用选项参数如下：</p><ul><li><code>-b</code>：对输出内容中的非空行标注行号。</li><li><code>-n</code>：对输出内容中的所有行标注行号。</li></ul><h4 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h4><p>使用more命令可以实现分屏显示文件内容。按下【Enter】键可以向下移动一行，按下【Space】键可以向下移动一页，按【q】键可以退出more命令。常用选项参数如下：</p><ul><li><code>-num</code>：用来指定分页显示时每页的行数。</li><li><code>+num</code>：指定从文件的第num行开始显示。</li></ul><h4 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h4><p>作为more命令的改进版，具有更加强大的功能， 可以实现向上向下翻页以及前后左右移动。</p><p>进入less状态后可执行以下操作：</p><ul><li>按【Enter】键向下移动一行</li><li>按【Space】键向下移动一页</li><li>按【b】键向上移动一页</li><li>使用光标键向前后左右移动</li><li>按【q】键退出less命令</li><li>按下【/】后输入待查找的单词可实现快速查找</li></ul><h4 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h4><p>该命令用于显示文件的开头部分，默认情况下只显示前10行的内容。常用选项参数如下：</p><ul><li><code>-n num</code>：显示指定文件的前num行</li><li><code>-c num</code>：显示指定文件的前num个字符</li></ul><h4 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h4><p>该命令用于显示文件的末尾部分，默认情况下只显示文件的末尾10行内容。常用选项参数如下：</p><ul><li><code>-n num</code>：显示指定文件的末尾num行</li><li><code>-c num</code>：显示指定文件的末尾num个字符</li><li><code>+num</code>：从第num行开始显示指定文件的内容</li></ul><h3 id="查找文件或目录命令"><a href="#查找文件或目录命令" class="headerlink" title="查找文件或目录命令"></a>查找文件或目录命令</h3><h4 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h4><p>find命令支持多种查找模式匹配，具有强大的查找功能。语法为<code>find path [parameter]</code>。常用选项参数如下：</p><ul><li><p><code>-name &lt;表达式&gt;</code>：根据文件名查找文件</p></li><li><p><code>-user &lt;用户名&gt;</code>：按归属用户查找文件</p></li><li><p><code>-type &lt;文件类型&gt;</code>：根据文件类型查找文件（b块设备、c字符设备、d目录、p管道文件、f普通文件、l链接、s端口文件）</p></li><li><p><code>-size &lt;大小&gt;</code>：根据文件大小进行查找</p></li><li><code>|xargs tar cvzf &lt;文件名&gt;</code>：将查询结果压缩</li></ul><h4 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h4><p>grep命令用于查找文件中包含指定字符串的行。语法为<code>grep [parameter] aimed_string filename</code>。常用选项参数如下：</p><ul><li><code>-v</code>：列出不匹配的行</li><li><code>-c</code>：对匹配的行计数</li><li><code>-l</code>：只显示包含匹配模式的文件名</li><li><code>-h</code>：抑制包含匹配模式的文件名的显示</li><li><code>-n</code>：每个匹配行只按照相对行号显示</li><li><code>-i</code>：匹配模式不区分大小写</li></ul><h4 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h4><p>该命令主要用于文件或目录的复制。常用选项参数如下：</p><ul><li><code>-f</code>：如果目标文件或目录存在，则执行覆盖操作，并且不进行用户提示。</li><li><code>-i</code>：如果目标文件或目录存在，提示是否覆盖已有文件。</li><li><code>-R</code>：递归复制目录，即包含目录下的各级子目录。</li></ul><h4 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h4><p>在不同目录之间进行操作，则该命令用于文件或目录的移动。在相同目录之间进行操作，则该命令用于文件或目录的改名。常用选项参数如下：</p><ul><li><code>-i</code>：如果目标文件或目录存在，提示是否覆盖。</li><li><code>-f</code>：无论目标文件或目录是否存在，均直接覆盖并不进行提示。</li></ul><h4 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h4><p>该命令主要用来查看文件系统各个分区的占用情况。命令列出系统上所有已挂载的分区大小、已占用的空间、可用空间以及占有率。</p><h4 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a>du命令</h4><p>该命令主要用来查看某个目录中的各级子目录所使用的硬盘空间数。常用选项参数如下：</p><ul><li><code>-a</code>：显示目录中个别文件的大小。</li><li><code>-c</code>：除显示个别目录或文件大小外，同时显示所有目录或文件的总和。</li><li><code>-k</code>/<code>-m</code>：以KB/MB为单位输出结果。</li><li><code>-s</code>：仅显示总计。</li><li><code>-h</code>：以K，M，G为单位，提高信息的可读性。</li><li><code>--max-depth=k</code>：显示k级目录的情况。</li></ul><h3 id="常用Linux命令及作用"><a href="#常用Linux命令及作用" class="headerlink" title="常用Linux命令及作用"></a>常用Linux命令及作用</h3><h4 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h4><p>该命令常用来测试与目标主机的连通性。通过发送ICMP ECHO_REQUEST数据包到网络主机并显示响应情况来判断连通状态。常用选项参数如下：</p><ul><li><code>-c packet_number</code>：在发送指定数目的数据包后停止。</li><li><code>-s byte_number</code>：指定发送的数据字节数，预设值为56，加上8字节ICMP头共构成64字节ICMP数据。一般设定为千数量级来探测大包的发送能力。</li><li><code>-i time</code>：设定间隔几秒发送一个网络封包给一台机器，预设值为1s。</li><li><code>-t TTL</code>：设置存活数值TTL的大小。</li></ul><h4 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h4><p>该命令用来配置或查看网卡接口。单独使用ifconfig时，只显示激活状态的网络设备信息。常用参数选项如下：</p><ul><li><code>up</code>：启动指定网络设备/网卡。</li><li><code>down</code>：关闭指定网络设备/网卡。只起到临时阻止指定接口IP信息流的作用，若需永久关闭则需要从核心路由表中删除接口全部信息。</li><li><code>-a</code>：显示全部接口信息。</li><li><code>-s</code>：显示摘要信息。</li><li><code>add</code>：给指定网卡配置IP。</li><li><code>del</code>：删除指定网卡地址。</li></ul><h4 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>该命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat作为在内核中访问网络及相关信息的程序，提供TCP连接，TCP和UDP监听，进程内存管理的相关报告等功能。常用参数选项如下：</p><ul><li><code>-a</code>：显示所有连线中的socket。</li><li><code>-n</code>：不通过域名服务器直接使用IP地址。</li><li><code>-t</code>/<code>-u</code>：显示TCP/UDP传输协议的连线状况。</li><li><code>-p</code>：显示正在使用socket的程序识别码和程序名称。</li><li><code>-c</code>：持续列出网络状态。</li></ul><h4 id="route命令"><a href="#route命令" class="headerlink" title="route命令"></a>route命令</h4><p>该命令用于显示和操作IP路由表。常用参数选项如下：</p><ul><li><code>add</code>/<code>del</code>：添加/删除一条路由规则。</li><li><code>-net</code>/<code>-host</code>：目的地址是一个网络/主机。</li><li><code>target</code>：目的网络或主机。</li><li><code>netmask</code>：目的地址网络掩码。</li><li><code>gw</code>：指定路由数据包通过的网关。</li><li><code>dev</code>：为路由指定的网络接口。</li></ul><h4 id="tcpdump命令"><a href="#tcpdump命令" class="headerlink" title="tcpdump命令"></a>tcpdump命令</h4><p>该命令将网络中传输的数据包报头信息完全截获以供分析，支持针对网络层、协议、主机、网络或端口的过滤，提供and、or、not等连接词用以构建完整过滤逻辑。常用参数选项如下：</p><ul><li><code>-i</code>：指定监听的网络接口。</li><li><code>-v</code>：输出稍微详细的报文信息。</li><li><code>-vv</code>：输出详细报文信息。</li><li><code>-c</code>：指定数据包数量，收到该数量的数据包后，tcpdump停止。</li><li><code>-e</code>：在输出行打印出数据链路层的头部信息，包括源mac和目的mac，以及网络层协议。</li><li><code>-f</code>：将外部的Internet地址以数字的形式打印出来。</li><li><code>-w</code>：直接将包写入文件，不进行分析和打印。</li><li><code>-X</code>：将原始协议头和包内容显示出来（默认以十六进制和ASCII形式显示）。</li></ul><h4 id="iptables命令"><a href="#iptables命令" class="headerlink" title="iptables命令"></a>iptables命令</h4><p>iptables服务不是真正的防火墙，只作为用来定义防火墙规则功能的管理工具，其将定义好的规则交由内核中的netfilter即网络过滤器进行读取，从而实现防火墙功能。我们经常使用以下两条命令：</p><ul><li><code>iptables -L -n</code>：显示当前所有防火墙过滤规则。</li><li><code>service iptables stop</code>：关闭防火墙过滤规则，实现全连通。</li></ul><h4 id="iperf命令"><a href="#iperf命令" class="headerlink" title="iperf命令"></a>iperf命令</h4><p>iperf作为网络性能测试工具，可以测试最大TCP和UDP的带宽性能，具有多种参数和UDP特性，可以根据需要进行调整，多用以报告带宽、延迟抖动和数据包丢失。该命令结合C/S架构进行使用。</p><h4 id="ethtool命令"><a href="#ethtool命令" class="headerlink" title="ethtool命令"></a>ethtool命令</h4><p>该命令用于查询及设置网卡参数。常用选项：</p><ul><li><code>ethtool -i ethX</code>：查询ethX网口的相关信息。</li><li><code>ethtool -d ethX</code>：查询ethX网口注册性信息。</li><li><code>ethtool -r ethX</code>：重置ethX网口到自适应模式。</li><li><code>ethtool -S ethX</code>：查询ethX网口收发包统计。</li><li><code>ethtool -s ethX [speed 10|100|1000]</code>：设置网口速率为10/100/1000M。</li></ul><h4 id="telnet命令"><a href="#telnet命令" class="headerlink" title="telnet命令"></a>telnet命令</h4><p>该命令通常由于远程登录，还可用于确定远程服务的状态即某个端口是否开放访问。但由于telnet协议报文采用明文传输，故安全性较差，Linux系统中telnet服务多被ssh取代。</p><h4 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h4><p>该命令主要用来查看系统内存和虚拟机内存的大小及占用情况。常用选项参数如下：</p><ul><li><code>-b</code>/<code>-k</code>/<code>-m</code>/<code>-g</code>：以Byte/KB/MB/GB为单位显示内存使用情况。</li><li><code>-s &lt;gap seconds&gt;</code>：持续观察内存使用状况。</li><li><code>-t</code>：显示内存总和列。</li></ul><h4 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h4><p>该命令主要用于查看系统的进程。常用以下参数选项：</p><ul><li><code>-a</code>：显示当前控制终端的进程。</li><li><code>-u</code>：显示进程的用户名和启动时间等信息。</li><li><code>-x</code>：显示没有控制终端的进程。</li></ul><h4 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h4><p>前台进程运行时，可以使用【Ctrl+C】的组合来终止它，后台进程则使用kill命令向进程发送强制终止信号，以达到终止进程的目的。</p><h4 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h4><p>该命令用于实时监控进程的状况，默认5s刷新一次，可以使用<code>top -d time</code>设定top屏幕刷新的时间间隔。</p><p><img src="http://static.zybuluo.com/B1ank/26iu93zp9mukjx7l2bp13h2j/top%E6%BC%94%E7%A4%BA.PNG" alt="top演示.PNG-88.3kB"></p><h4 id="关机命令"><a href="#关机命令" class="headerlink" title="关机命令"></a>关机命令</h4><ul><li>shutdown <ul><li><code>shutdown -h</code>：关闭计算机。</li><li><code>shutdown -r</code>：重新启动。</li></ul></li><li>reboot == <code>shutdown -r now</code></li><li>poweroff == <code>shutdown -h now</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux系统基础&quot;&gt;&lt;a href=&quot;#Linux系统基础&quot; class=&quot;headerlink&quot; title=&quot;Linux系统基础&quot;&gt;&lt;/a&gt;Linux系统基础&lt;/h2&gt;&lt;p&gt;Linux系统是一个类Unix操作系统，设计初衷为替代Unix系统。系统命令实际上是
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Linux Foundation" scheme="https://blank-vax.github.io/tags/Linux-Foundation/"/>
    
  </entry>
  
  <entry>
    <title>LDAP协议及AD域</title>
    <link href="https://blank-vax.github.io/2020/06/13/LDAP%E5%8D%8F%E8%AE%AE%E5%8F%8AAD%E5%9F%9F/"/>
    <id>https://blank-vax.github.io/2020/06/13/LDAP协议及AD域/</id>
    <published>2020-06-12T17:29:00.000Z</published>
    <updated>2020-11-09T03:38:24.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LDAP协议"><a href="#LDAP协议" class="headerlink" title="LDAP协议"></a>LDAP协议</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ul><li>集中管理，更易维护和优化，降低运维成本的需求。</li><li>实现使用PUSH和PULL的方法复制部分或全部数据的需求。</li><li><p>使用者根据需要使用ACL控制数据的读写权限的需求。</p></li><li><p>数据从不同地点读取但无需经常更新的需求。</p></li></ul><h3 id="LDAP概述"><a href="#LDAP概述" class="headerlink" title="LDAP概述"></a>LDAP概述</h3><p><strong>Light Access Protocol</strong>，即轻量级目录访问协议。与目录访问协议X.500相比，LDAP略去X.500中许多不常使用的功能，以TCP/IP协议为基础，使用389端口进行数据传输。LDAP只是一个协议。</p><p>与数据库类似，目录服务引入键—值类型格式存储、整理及表达数据。与数据库不同的是，目录服务专门进行了读优化设计，采用树状结构组织数据，面向<strong>查找、搜索及读取操作</strong>做出优化。目录服务具有优异的读性能，而写性能较差，并且没有事务处理、回滚等复杂功能，不适用于存储修改频繁的数据。</p><h3 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h3><p><img src="http://static.zybuluo.com/B1ank/cv8iw9bvtdq7b5zm4tcyiway/20181110215227340.png" alt="20181110215227340.png-27.2kB"></p><h4 id="常见描述——以果园中的苹果为例"><a href="#常见描述——以果园中的苹果为例" class="headerlink" title="常见描述——以果园中的苹果为例"></a>常见描述——以果园中的苹果为例</h4><blockquote><p>假设你需要树上的一个苹果（一条记录），如何向园丁准确描述它的位置呢？首先需要说明它存在于哪棵树上（dc，相当于MYSQL的DB），然后说明从树根到那个苹果所在位置经过的所有树杈（ou），最后就是这个苹果的名字（uid，相当于MYSQL表主键id）。例如，LDAP的具体位置记录如下：</p><ul><li>树（dc=ljheeee）</li><li>分叉（ou=bei，ou=xi，ou=dong）</li><li>苹果（cn=honglv）</li></ul><p>至此，honglvApple的位置可以表示为：<code>dn：cn=honglv，ou=bei，ou=xi，ou=dong，dcljheee</code>。我们告诉园丁该苹果就是位于果园内那棵老歪脖树的东边分叉上靠西边那个分叉的再靠北边的分叉上半红半绿的那个苹果。其中dn标识一条记录，描述一条数据的详细路径。</p></blockquote><h4 id="LDAP关键字"><a href="#LDAP关键字" class="headerlink" title="LDAP关键字"></a>LDAP关键字</h4><ul><li><p>Domain Component（dc）</p><p>域名的部分，表示过程中将完整域名以点号为界限进行分割（一条记录的所属位置）。例如：Domain Name：example.com&lt;—&gt;DC Format：dc=example，dc=com。</p></li><li><p>User Id（uid）</p><p>用户ID（一条记录的ID），例如：test.wu。</p></li><li><p>Organization Unit（ou）</p><p>组织单位，包括其他各种对象（一条记录的所属组织），例如：oa组。</p></li><li><p>Common Name（cn）</p><p>公共名称（一条记录的名称），例如：Thomas Muller。</p></li><li><p>Surname（sn）姓氏</p></li><li><p>Distinguished Name（dn）</p><p>一条记录的位置（唯一），例如：”uid=songtao.xu, ou=oa组, dc=example.com”。</p></li><li><p>Relative dn（rdn）</p><p>相对辨别名，类似于文件系统中的相对路径，与目录树结构无关。例如：”uid=Tom”或”cn=Thomas Muller”。</p></li></ul><h4 id="四大基本模型"><a href="#四大基本模型" class="headerlink" title="四大基本模型"></a>四大基本模型</h4><ul><li>信息模型</li></ul><p><img src="http://static.zybuluo.com/B1ank/wrmydqg0ojdjuw31ktgiup9u/%E4%BF%A1%E6%81%AF%E6%A8%A1%E5%9E%8B.png" alt="信息模型.png-65.7kB"></p><ul><li>命名模型</li></ul><p><img src="http://static.zybuluo.com/B1ank/ces9r09lfl8zrhab3flyxjbh/%E5%91%BD%E5%90%8D%E6%A8%A1%E5%9E%8B.png" alt="命名模型.png-45.2kB"></p><ul><li>功能模型</li></ul><p><img src="http://static.zybuluo.com/B1ank/uiw5axd29q8w9tlrix3zlmod/%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9E%8B.png" alt="功能模型.png-65.4kB"></p><ul><li>安全模型</li></ul><p><img src="http://static.zybuluo.com/B1ank/3x3z7ynvndiv4ww2b2bza7hr/%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B.png" alt="安全模型.png-31.8kB"></p><h3 id="LDAP使用"><a href="#LDAP使用" class="headerlink" title="LDAP使用"></a>LDAP使用</h3><p>统一身份认证改变原有认证策略，使用LDAP对所有需要认证的软件进行认证。完成统一身份认证之后，用户的所有信息都存储在AD Server中。终端用户在需要使用公司内部服务的时候，都需要通过AD服务器的认证。</p><h3 id="LDAP认证过程"><a href="#LDAP认证过程" class="headerlink" title="LDAP认证过程"></a>LDAP认证过程</h3><p>LDAP采用C/S架构进行认证，常采用MD5认证方式，具体步骤如下：</p><h4 id="客户端发送绑定请求"><a href="#客户端发送绑定请求" class="headerlink" title="客户端发送绑定请求"></a>客户端发送绑定请求</h4><p><img src="http://static.zybuluo.com/B1ank/no82tk78r9t4vlw3r4vkh1sj/client_bind.png" alt="client_bind.png-11.4kB"></p><p>初始化认证阶段，客户端发送绑定请求（bindRequest），具体内容如下：</p><ul><li>协议版本：3</li><li>认证机制：sasl</li><li>认证方式：DIGEST-MD5</li></ul><h4 id="服务器响应绑定结果"><a href="#服务器响应绑定结果" class="headerlink" title="服务器响应绑定结果"></a>服务器响应绑定结果</h4><p><img src="http://static.zybuluo.com/B1ank/yjlrfrxvayr1cmawrw9xplwc/server_bind_result.png" alt="server_bind_result.png-52.5kB"></p><p>与HTTPS通信过程类似，服务器返回一段十六进制加密内容serverSaslCreds，该内容主要包括服务器支持的加密方式、认证方式、算法标准以及验证时间戳等信息，要求客户端选择对应的加密标准并使用相同的sasl机制发送新的绑定请求以继续认证过程。对十六进制数据解码后结果如下：</p><ul><li>服务器支持的摘要认证qop：auth，auth-int，auth-conf</li><li>服务器支持的加密方式cipher：3des，cr4</li><li>服务器支持的加密算法algorithm：md5-sess</li><li>服务器的验证时间戳nonce：一串随机数，用于防御重放攻击与选择明文攻击，提高数据安全性</li><li>Charset编码：utf-8</li><li>Realm：xxx.com</li></ul><p>可以看到，LDAP多采用对称密码与消息摘要算法结合的方式实现身份认证与敏感数据传输。</p><h4 id="客户端发送Response"><a href="#客户端发送Response" class="headerlink" title="客户端发送Response"></a>客户端发送Response</h4><p><img src="http://static.zybuluo.com/B1ank/yymu13a2u107vzm6aruynptr/client_response.png" alt="client_response.png-338.9kB"></p><p>客户端收到服务器的响应之后，从服务器提供的各类标准中选择本次认证使用的标准，返回一段十六进制加密数据credentials，用以请求查询绑定的用户是否存在，发送内容经解码后如下：</p><ul><li>请求查询的用户登录名：test6</li><li>查询的整个域realm：xxx.com</li><li>服务器发来的nonce</li><li>客户端的验证时间戳cnonce：客户端产生的用于对称校验的随机数</li><li>客户端发送的请求次数cn：00000001（表示只会发送一次请求）</li><li>客户端要求使用的qop：auth-conf</li><li>客户端要求使用的加密方式：rc4</li><li>客户端支持的最大字节流长度：16777215</li><li>本次请求的资源位置digest-url：ldap.com</li><li>最终摘要response：根据以上信息和所用密码，通过预设规律计算出的md5码</li></ul><h4 id="服务器返回查询结果"><a href="#服务器返回查询结果" class="headerlink" title="服务器返回查询结果"></a>服务器返回查询结果</h4><p>服务器会返回查询结果，若绑定成功，则报文解码如下：</p><p><img src="http://static.zybuluo.com/B1ank/nndbpo4akoatyns11o0qzl68/bind_success.png" alt="bind_success.png-32.1kB"></p><p>绑定失败则发送错误消息：</p><p><img src="http://static.zybuluo.com/B1ank/ib9si19xxf9shyubj3dvjhuo/bind_fail.png" alt="bind_fail.png-50.2kB"></p><h2 id="AD域"><a href="#AD域" class="headerlink" title="AD域"></a>AD域</h2><h3 id="AD域概述"><a href="#AD域概述" class="headerlink" title="AD域概述"></a>AD域概述</h3><p>活动目录<strong>Active Directory</strong>的缩写，面向微软服务器的目录服务，LDAP协议下的一种产品。它为用户管理网络环境各个组成要素的标识和关系提供了一种有力的手段。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>实现集中式管理。</li><li>回收并管理普通用户对客户机的权限。</li><li>AD域作为大安全边界，用户只需一次登录身份验证，便可直接访问域林中所有允许访问资源，无需多次身份验证，从而提高效率，减少维护成本。</li><li>通过文件夹重定向，可将所有用户桌面的”我的文档”重定向到文件服务器上。</li></ul><h3 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h3><ul><li>用户账号管理</li><li>权限管理</li><li>软件/补丁推送</li></ul><h3 id="域信任关系"><a href="#域信任关系" class="headerlink" title="域信任关系"></a>域信任关系</h3><p>域信任关系具有方向性，域之间的信任方向决定了资源访问方向。</p><p>域的信任关系主动权掌握在被信任域手中。但是如果信任域不对被信任域进行资源分配，则被信任域无法获取任何资源。在Windows2000之后，域树和域林之间的信任关系具有传递特性。</p><h4 id="域树"><a href="#域树" class="headerlink" title="域树"></a>域树</h4><p>域树的父域和子域之间由于使用了层次分明的DNS域名，使用者可根据域名判断出两个域之间的隶属关系从而方便域之间建立和传递相互信任关系。</p><h3 id="组策略"><a href="#组策略" class="headerlink" title="组策略"></a>组策略</h3><p>组策略是一个允许执行针对用户或计算机进行配置的基础架构。与注册表相似，组策略也是一项可以修改用户或计算机设置的技术；但与注册表不同的是，注册表只能针对一个用户或一台计算机进行设置，而组策略却可以针对多个用户和多台计算机进行设置。</p><p>组策略和AD结合使用，可以部署在OU，站点和域级别上，不同级别之间具有以下优先级：本地计算机 &lt; 站点 &lt; 域 &lt; OU，使用者可根据管理任务，为组策略选择合适的部署级别。</p><h4 id="组策略对象"><a href="#组策略对象" class="headerlink" title="组策略对象"></a>组策略对象</h4><p>组策略通过组策略对象（GPO）进行设定，只要将GPO连接到指定站点、域或OU，该GPO内的设定值就会影响到对应级别内的全部用户与计算机。</p><h4 id="组策略存储位置"><a href="#组策略存储位置" class="headerlink" title="组策略存储位置"></a>组策略存储位置</h4><ul><li>链接GPO的AD容器</li><li>域控制器上的Sysvol文件夹</li></ul><h4 id="GPO组成"><a href="#GPO组成" class="headerlink" title="GPO组成"></a>GPO组成</h4><ul><li>组策略容器GPC</li><li>组策略模板GPT</li></ul><h4 id="组策略管理"><a href="#组策略管理" class="headerlink" title="组策略管理"></a>组策略管理</h4><p>组策略管理可以通过组策略编辑器和组策略管理控制台（GPMC）。组策略编辑器是Windows操作系统中自带的组策略管理工具，而GPMC则具有创建、管理和部署GPO等更强大的功能的组策略编辑工具。</p><h4 id="组策略应用"><a href="#组策略应用" class="headerlink" title="组策略应用"></a>组策略应用</h4><ul><li><p>账户策略的设定</p><p>设定用户密码长度、复杂度、使用期限和账号锁定策略等。</p></li><li><p>本地策略的设定</p><p>审核策略的设定、用户权限的指派、安全性的设定等。</p></li><li><p>部署软件</p><p>通过将待部署软件存储在文件服务器的共享文件夹中并运用组策略告知用户或计算机进行下载安装的方法实现软件的批量部署。</p></li></ul><h3 id="搭建AD域"><a href="#搭建AD域" class="headerlink" title="搭建AD域"></a>搭建AD域</h3><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>配置完成后，使用命令<strong>Gpresult或gpresult /r</strong>获取组策略结果，检查客户端电脑是否加入域，以及加入域之后获取的组策略结果。</li><li>每次在域服务器上面修改组策略后，若需要组策略立即生效，则需要在域服务器及客户端电脑上执行命令<strong>Gpupdate /force</strong>强制更新组策略。</li></ul><h4 id="常见问题排查"><a href="#常见问题排查" class="headerlink" title="常见问题排查"></a>常见问题排查</h4><ul><li><strong>域用户认证失败</strong><ul><li>检查用户所属OU是否存在于桌面云设备上配置的搜索入口范围内</li><li>检查用户是否满足相关过滤条件</li><li>检查VDC设备与AD域服务器之间网络是否连通</li><li>检查域用户本身是否存在异常</li></ul></li><li><strong>虚拟机加入域失败</strong><ul><li>检查VDC上虚拟机加入域的配置</li><li>检查虚拟机到域控路由的可达性以及DNS是否能够解析域名</li><li>尝试将虚拟机手动加入域</li></ul></li><li><strong>虚拟机用户登录失败</strong><ul><li>虚拟机未加入域</li><li>检查虚拟机到域控路由的可达性以及DNS是否能够解析域名</li><li>检查域内是否存在针对用户的计算机绑定</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;LDAP协议&quot;&gt;&lt;a href=&quot;#LDAP协议&quot; class=&quot;headerlink&quot; title=&quot;LDAP协议&quot;&gt;&lt;/a&gt;LDAP协议&lt;/h2&gt;&lt;h3 id=&quot;需求分析&quot;&gt;&lt;a href=&quot;#需求分析&quot; class=&quot;headerlink&quot; title=&quot;需
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="LDAP" scheme="https://blank-vax.github.io/tags/LDAP/"/>
    
  </entry>
  
  <entry>
    <title>2020华为勇敢星实习面试记录</title>
    <link href="https://blank-vax.github.io/2020/06/01/2020%E5%8D%8E%E4%B8%BA%E5%8B%87%E6%95%A2%E6%98%9F%E5%AE%9E%E4%B9%A0%E8%AE%A1%E5%88%92%E9%9D%A2%E8%AF%95/"/>
    <id>https://blank-vax.github.io/2020/06/01/2020华为勇敢星实习计划面试/</id>
    <published>2020-05-31T16:50:00.000Z</published>
    <updated>2020-11-09T03:40:38.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-投递流程"><a href="#0x00-投递流程" class="headerlink" title="0x00 投递流程"></a>0x00 投递流程</h2><p>由于专业对口原因，选择的岗位是<strong>网络安全与隐私保护工程师</strong>。这一大岗位分成网络安全与隐私保护两个方向，网络安全方向对渗透测试及Web安全知识要求较高，而隐私保护方向对隐私保护、准入权限等标准要求较高，附带要求一些密码学的知识。</p><p>在投递实习生申请的时候需要选择第一意向部门和第二意向部门，第一次投递时选择流程出现了问题，导致只通过了笔试和性格测试，迟迟没有接到面试的通知。大概在五月底第二次重新投递了<strong>公共开发部</strong>，过了大概十天左右就收到了面试通知。所以整体流程如下：</p><blockquote><p>4.11 第一次投递网络安全与隐私保护工程师 未选择意向部门</p><p>4.15 在线笔试</p><p>4.16 性格测试</p><p>5.20 第二次投递网络安全与隐私保护工程师 第一意向部门 公共开发部 第二意向部门 2012实验室</p><p>6.9 签署《知识产权和商业秘密保护承诺书》</p><p>6.10 技术面试</p><p>6.11 主管面试</p><p>6.12——至今 泡池子</p><p>6.28 入职通知</p></blockquote><h2 id="0x01-在线笔试及性格测试"><a href="#0x01-在线笔试及性格测试" class="headerlink" title="0x01 在线笔试及性格测试"></a>0x01 在线笔试及性格测试</h2><p>刚收到在线笔试通知的时候开始疯狂准备编程题目，收到笔试链接邮件后发现考试没有编程题目，转而去刷安全基础知识。结果笔试题目考察的全部是涉及隐私保护协议及标准的选择题，甚至还有许多涉及用户隐私的正常逻辑推理题（错误选项显而易见）。笔试时间限制为19：00——20：00一个小时，大概用了半小时左右完成了所有的题目。隔壁网络安全的笔试考察比较全面，以Web安全为主题，还会涉及到恶意病毒及密码学的相关知识，还有一道编程题目，大概这个岗位对技术要求比较高吧。</p><p>笔试结束的第二天就收到了性格测试的邮件，然后开始在线测试。性格测试大概是每页六道题目，每个题目包含六个选项（从非常不符合到非常符合），大概有十几页的样子。每页六道题中如果多个题目选择同一选项，需要在这些题目中间选择<strong>最适合</strong>和<strong>最不适合</strong>的选项。经过翻阅网上的大量资料，总结出性格测试的几个要点：</p><ul><li>针对同一问题，前后答案的态度需要保持一致</li><li>需要符合华为公司的文化</li><li>华为比较喜欢平庸的员工，除非自己特别喜欢或特别排斥，尽量少选择<strong>非常不符合</strong>和<strong>非常符合</strong>这两部分</li></ul><p>剩下的攻略在网上也可以找到，一般来说性格测试比较好过，不过也不需要太纠结，毕竟实习和工作都是应聘者和公司的双向选择，如果价值观极其不相符，入职了也没什么意义。性格测试时间限制为2小时，一般速度大概1小时左右完工。</p><h2 id="0x02-技术面试"><a href="#0x02-技术面试" class="headerlink" title="0x02 技术面试"></a>0x02 技术面试</h2><p>今年由于疫情影响，面试都调整为线上进行，使用Zoom会议软件。邮件通知为上午9：30开始，然后9：16发来短信告知会议房间号。进去之后一位非常和蔼的小哥哥戴着口罩，笑眯眯地坐在镜头前。大致问了以下几个问题：</p><ul><li><p>Q1：自我介绍</p></li><li><p>Q2：看你的简历上写了比赛经历，能不能给我详细介绍一下“美亚杯”电子取证比赛的经历呢？</p></li><li><p>Q3：该比赛中，你和你的队友如何分配任务？</p></li><li><p>Q4：既然你投了隐私保护这个岗位，对密码学有什么了解？常见的加密手段有哪些？</p></li><li><p>Q5：代码能力如何？掌握哪些编程语言？</p></li><li><p>Q6：手写代码部分。由于是线上面试，该部分可以选择手写或者IDE共享屏幕（这个选择权也是根据岗位的不同而异，网络安全岗就限制了只能手写）。如果使用IDE可以自行输出和debug。</p><p>题目：分割子串问题。给定任意全字母组合的非空字符串及对应子串相异字母数k。针对每一子串，对其中包含字符的数量不作限制，只限制不同字母的数量为k。</p><p>例如：选定子串为”abcdefffff”，选定相异字母数k=2。则所有分割结果为：”ab”，”bc”，”cd”，”de”，”ef”，”eff”，”efff”，”effff”，”efffff”，共9个。</p><p>解题代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">str_test = <span class="string">"aabcdefaaaaa"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_component</span><span class="params">(str_test, k)</span>:</span></span><br><span class="line">    result_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str_test)-(k<span class="number">-1</span>)):</span><br><span class="line">        tmp = <span class="string">''</span></span><br><span class="line">        index_offset = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> len(set(tmp)) &lt;= k <span class="keyword">and</span> i+index_offset != len(str_test)<span class="number">-1</span>:</span><br><span class="line">            tmp += str_test[i+index_offset]</span><br><span class="line">            index_offset += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> len(set(tmp)) != k:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> tmp <span class="keyword">not</span> <span class="keyword">in</span> result_list:</span><br><span class="line">                result_list.append(tmp)</span><br><span class="line">    <span class="keyword">return</span> result_list</span><br><span class="line"></span><br><span class="line">block_length = int(input())</span><br><span class="line"><span class="keyword">print</span> get_all_component(str_test, block_length)</span><br></pre></td></tr></table></figure><p>说来惭愧，刚开始代码写的并不完美，没有考虑字符串末尾出现大量相同字符时如何处理。最后进行适当调整满足了题目要求。</p></li></ul><p>整体面试体验就是非常的nice，面试官也非常和蔼可亲，在面试者回答问题的时候会轻声附和，在代码调试过程中会给出指导，整套流程下来大概四十分钟左右。基本上没有什么需要注意的地方，因为应聘的是隐私保护这个岗位，问到的技术问题不算太难，手撕代码是面试的祖传项目，需要好好准备。不过前一天晚上准备的大量项目经历没有派上用场，甚至没有提及简历上写的项目。</p><h2 id="0x03-主管面试"><a href="#0x03-主管面试" class="headerlink" title="0x03 主管面试"></a>0x03 主管面试</h2><p>大多数主管面试会安排在技术面试结束后的第二天，少部分会安排在当天。主管面试邮件通知时间为14：30，结果前面一直在排队，拖到了16：40才进入面试会议房间。面试过程中大概问了以下问题，涵盖技术问题、工作理念、未来规划以及逻辑题目，同样没怎么关注项目经历。</p><ul><li>Q1：介绍一下简历上的”美亚杯“电子数据取证比赛</li><li>Q2：电子数据取证分析是如何对Windows内存镜像进行分析的？</li><li>Q3：对密码学了解多少？</li><li>Q4：常见的密码学攻击手段？</li><li>Q5：既然是做隐私保护的，应该对入侵攻击有所了解，简要说明一下SQL注入相关内容</li><li>Q6：家是哪里的？未来打算在哪个城市生活与工作？</li><li>Q7：平时有什么爱好？</li><li>Q8：逻辑题：一个村子里共100个人，其中男人只说真话，女人只说假话。一位探险家来到村子，从第一个人询问至第一百个人村子里女人的数量，得到的回答依次为1，2，3，4，5…..100，则村子里共有多少女人？</li><li>Q9：近日对华为有什么了解？华为受到美国制裁，发展前景堪忧，为什么还考虑来这里工作？</li><li>Q10：如何看待华为的文化？</li><li>Q11：如何看待996的加班机制？</li><li>Q12：有什么问题想要问我吗？</li></ul><p>整体面试时间为半小时左右，期间明显感觉到压力较大（面试官一脸严肃）。可以看到，首先提问技术方面的问题，重点关注参加的比赛及校内获取的奖项，当然也关注简历上注明的研究方向。随后了解个人价值取向，包括未来规划以及个人爱好。最后询问针对华为文化的看法，这里的回答就见仁见智了，不过如果希望拿到实习生职位还是迎合着讲比较好。</p><h2 id="0x04-后续"><a href="#0x04-后续" class="headerlink" title="0x04 后续"></a>0x04 后续</h2><p>6.28 给了入职通知，由于需要考研并且去西安比较麻烦，所以没有去。</p><p>虽然大三暑期实习没有直接转正的机会，但是秋招的时候华为会专门安排实习生招聘专场，面试的流程也比较快。据参加华为实习的朋友讲，实习体验总体令人满意。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-投递流程&quot;&gt;&lt;a href=&quot;#0x00-投递流程&quot; class=&quot;headerlink&quot; title=&quot;0x00 投递流程&quot;&gt;&lt;/a&gt;0x00 投递流程&lt;/h2&gt;&lt;p&gt;由于专业对口原因，选择的岗位是&lt;strong&gt;网络安全与隐私保护工程师&lt;/stron
      
    
    </summary>
    
      <category term="Interview" scheme="https://blank-vax.github.io/categories/Interview/"/>
    
    
      <category term="HUAWEI" scheme="https://blank-vax.github.io/tags/HUAWEI/"/>
    
  </entry>
  
  <entry>
    <title>Bristol Cryptography Blog（三）—— 不同组件的计算和存储能力</title>
    <link href="https://blank-vax.github.io/2020/05/10/Bristol-Cryptography-Blog%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-%E4%B8%8D%E5%90%8C%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%A1%E7%AE%97%E5%92%8C%E5%AD%98%E5%82%A8%E8%83%BD%E5%8A%9B/"/>
    <id>https://blank-vax.github.io/2020/05/10/Bristol-Cryptography-Blog（三）——-不同组件的计算和存储能力/</id>
    <published>2020-05-10T03:08:00.000Z</published>
    <updated>2020-11-09T03:27:36.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文为布里斯托大学推出的<code>52 Things Every PhD Student Should Know to do Cryptography</code>系列学习笔记中的第二篇。原文连接：<a href="http://bristolcrypto.blogspot.com/2014/10/52-things-q3-computational-and-storage.html" target="_blank" rel="noopener">52 Things: Number 3: Computational and storage power of different form factors</a>。</p><h2 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h2><p>简要讨论以下几类组件的计算与存储能力：</p><ul><li>智能卡</li><li>微控制器（例如传感器节点）</li><li>嵌入式或移动计算机（例如移动电话或掌上电脑PDA）</li><li>笔记本电脑或台式机</li></ul><h2 id="计算能力评估"><a href="#计算能力评估" class="headerlink" title="计算能力评估"></a>计算能力评估</h2><p>我们可以通过评估处理器的时钟速率来衡量设备的计算能力。然而如果处理器允许某种形式的并行处理，该评估结果相应地具有误导性——显然在2GHz频率上运行的双核处理器显然比对应频率的单核处理器具有更强的计算能力。因此找到计算能力的直接量化指标并不现实。</p><p>对于诸如通用图形卡之类的特定设备，通常将该类设备能够承受的总FLOPS（Floating Point Operations Per Second，每秒浮点操作数——针对单精度或双精度运算）作为衡量标准。然而该方法应用到特定问题时仍存在局限性。实际上，某些服务可以通过在各种问题实例上对不同设备的性能进行基准测试来衡量计算能力，其中最具代表性的服务即为CompuBench。幸运的是，问题中包含的设备其功能范围使得答案对定量指标具有较低的依赖性。</p><h2 id="存储能力评估"><a href="#存储能力评估" class="headerlink" title="存储能力评估"></a>存储能力评估</h2><p>衡量每个设备存储能力的方法要容易得多：我们可以简单比较设备永久存储信息的大概字节数。</p><h2 id="智能卡相关性能"><a href="#智能卡相关性能" class="headerlink" title="智能卡相关性能"></a>智能卡相关性能</h2><p>智能卡是计算能力最差的设备。尽管时钟速率因不同的实现方法而有所差异，但智能卡的计算核心速度只能达到20MHz左右。在存储方面，典型的智能卡具有2KB左右的可用存储空间。</p><h2 id="微控制器相关性能"><a href="#微控制器相关性能" class="headerlink" title="微控制器相关性能"></a>微控制器相关性能</h2><p>微控制器是<strong>“包含核心处理器、存储器和可编程输入/输出外围设备的单个集成电路上的小型计算机”</strong>。</p><p>由于微控制器的确切定义不同，其可用的存储空间与计算能力范围将有很大区别。这里以前面提及的传感器节点为例，其作为典型的微控制器具有与智能卡类似的计算能力，并且可用的存储量略多（大概在几KB到几MB的数量级）。</p><h2 id="嵌入式或移动计算机相关性能"><a href="#嵌入式或移动计算机相关性能" class="headerlink" title="嵌入式或移动计算机相关性能"></a>嵌入式或移动计算机相关性能</h2><p>诸如移动电话之类的移动计算机具有更强的存储能力和计算能力，并且随着时间的推移，可用算力正在迅速增加。以2008年的iPhone和2013年的Nexus 5手机为例，iPhone使用了412MHz 32位的RISC ARM内核，而Nexus 5 则使用了频率为2.3GHz的四核处理器。在存储方面，如果我们忽略某些具有移动存储功能的手机，2013年的高端手机会提供约16至32GB的存储空间，当然64GB至128GB的手机存储空间在现在看来也是司空见惯了。</p><h2 id="笔记本-台式机相关性能"><a href="#笔记本-台式机相关性能" class="headerlink" title="笔记本/台式机相关性能"></a>笔记本/台式机相关性能</h2><p>大多数笔记本电脑或台式机理所当然地具有比手机更强的处理能力。高端英特尔”Haswell” i7 4960K处理器具有四个处理核心，每个核心的主频率为4GHz，而AMD “Piledriver” FX-9590 CPU包含八个4.7GHz的处理核心。需要注意的是，这两个处理器之间计算能力的比较不仅仅需要评估内核数量及时钟速率，还有其他因素会影响台式机或便携式计算机的计算能力——尤其是增加图形处理单元可以大大提高处理某些问题的性能。笔记本电脑或台式机的存储容量可能相差很大，但是消费者计算机中的典型存储量可能在数百GB到几TB之间。目前为止，最大的单个硬盘驱动器容量约为8TB。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文为布里斯托大学推出的&lt;code&gt;52 Things Every PhD Student Should Know to do Crypto
      
    
    </summary>
    
      <category term="Crypto_Knowledge" scheme="https://blank-vax.github.io/categories/Crypto-Knowledge/"/>
    
    
      <category term="Notes" scheme="https://blank-vax.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界 —— Crypto（进阶区1）</title>
    <link href="https://blank-vax.github.io/2020/05/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%20%E2%80%94%E2%80%94%20Crypto%EF%BC%88%E8%BF%9B%E9%98%B6%E5%8C%BA1%EF%BC%89/"/>
    <id>https://blank-vax.github.io/2020/05/10/攻防世界 —— Crypto（进阶区1）/</id>
    <published>2020-05-10T03:07:00.000Z</published>
    <updated>2020-11-09T03:27:21.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>更新完Crypto新手区的题目之后，接下来开始练习进阶区的题目。本系列文章持续更新中~</p><h2 id="0x01-告诉你个秘密"><a href="#0x01-告诉你个秘密" class="headerlink" title="0x01 告诉你个秘密"></a>0x01 告诉你个秘密</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>打开附件发现为两行十六进制数据，一开始考虑将其转换成十进制，后来发现转完之后不易和字符串建立联系，遂考虑直接将其转换为字符串。</p><p>这里使用python的binascii库中的<code>binascii.a2b_hex(hex)</code>实现将十六进制字符串转换成ASCII字符串并输出。输出结果显然为Base64加密，直接解密得到如下结果：</p><p><img src="http://static.zybuluo.com/B1ank/z9j4icbmpvvzmpep45u3b7o6/%E5%91%8A%E8%AF%89%E4%BD%A0%E4%B8%AA%E7%A7%98%E5%AF%86.PNG" alt="告诉你个秘密.PNG-3.6kB"></p><p>乍看是一堆无意义的字符串，但注意其使用空格作为分隔符分开，考虑到键盘密码，与键盘上的字母对应得到最后的flag。注意本题flag的格式直接为最后得到的字符串，没有任何前缀。</p><h3 id="解题脚本"><a href="#解题脚本" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">cipher1 = <span class="string">'636A56355279427363446C4A49454A7154534230526D6843'</span></span><br><span class="line">cipher2 = <span class="string">'56445A31614342354E326C4B4946467A5769426961453067'</span></span><br><span class="line">final_plain = binascii.a2b_hex(cipher1) + binascii.a2b_hex(cipher2)</span><br><span class="line">final_plain2 = base64.b64decode(final_plain).decode()</span><br><span class="line">print(final_plain2)</span><br></pre></td></tr></table></figure><h3 id="一些经验"><a href="#一些经验" class="headerlink" title="一些经验"></a>一些经验</h3><p>下面来讨论一下使用binascii库进行ASCII字符串与十六进制字符串转换的细节。</p><p><img src="http://static.zybuluo.com/B1ank/sb9mauwpmxxbkihdl3bro6a2/hex_to_string.PNG" alt="hex_to_string.PNG-37.9kB"></p><p>由上图可知，在ASCII字符串与十六进制字符串转换过程中，binascii库提供了四个函数。</p><p>我们可以使用<code>binascii.a2b_hex(hex_string)</code>和<code>binascii.unhexlify(hex_string)</code>这两个函数实现从十六进制字符串到ASCII字符串的转换过程。可以使用<code>binascii.b2a_hex(ASCII_string)</code>和<code>binascii.hexlify(ASCII_string)</code>这两个函数实现从ASCII字符串到十六进制字符串的转换过程。值得注意的是，在python3中，互相转换的数据类型为byte型而非string型，否则就会出现TypeError报错。</p><h2 id="0x02-Broadcast"><a href="#0x02-Broadcast" class="headerlink" title="0x02 Broadcast"></a>0x02 Broadcast</h2><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题目提供了加密脚本<code>task.py</code>，Bob、Dan、Carol和Erin的pem与enc文件。单独看这道题目确实很简单，因为flag直接包含在题目给出的脚本中。但是如果对题目提供的加密方式进行挖掘，可以得到许多有趣的信息。</p><p>题目名字为Broadcast，实际上并不是简单的广播攻击。对于RSA的简单广播攻击，其前提是对同一个m加密，攻击细节如下图：</p><p><img src="http://static.zybuluo.com/B1ank/hnmhfbjcdzqiqm1eejeyxlnp/Basic%20Broadcast%20Attack.PNG" alt="Basic Broadcast Attack.PNG-69.2kB"></p><p>分析加密脚本中对待加密信息的处理过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">'from'</span>: sha256( <span class="string">b'Alice'</span> ).hexdigest(),</span><br><span class="line">        <span class="string">'to'</span>  : sha256( name.encode() ).hexdigest(),</span><br><span class="line">        <span class="string">'msg'</span> : msg</span><br><span class="line">       &#125;</span><br><span class="line">data = json.dumps(data, sort_keys=<span class="literal">True</span>)</span><br><span class="line">m = number.bytes_to_long( data.encode() )</span><br></pre></td></tr></table></figure><p>显然每一次的m不同，并且取<code>e=3</code>和<code>e=5</code>时分别只有两个其他明密文对，无法使用应对传统广播攻击的方法进行处理。</p><p>观察可知，每次m都由以下内容构成：</p><blockquote><ul><li>from Alice（每次相同）</li><li>to name（每次不同）</li><li>msg（每次相同）</li></ul></blockquote><p>其中只有<code>to: name</code>每次变化，而另外两个参数保持不变。由于引入语句<code>data = json.dumps(data, sort_keys=True)</code>，在加密之前会根据data字典的key进行排序，由于三个键的首字母排序为<code>from-msg-to</code>，可以发现msg被放到中间位置。即<code>m = high + mid + low</code>。</p><p>对于每次构造的信息m，其高、中位(<code>&#39;from&#39;:Alice</code>，<code>&#39;msg&#39;: msg</code>)都是不变的，只是低位由于每次接收方不同有所不同。由于<code>high</code>和<code>low</code>已知的（可以通过构造过程中提供的方法进行计算），我们只需要求出<code>mid</code>部分即可。</p><p>由于<code>low</code>部分包含64位的sha256摘要信息以及12位其他符号，故构造m如下：</p><script type="math/tex; mode=display">m_{i} = (high << 1368) + (x << 608) + low_{i}</script><script type="math/tex; mode=display">m_{i} = a*x*2^{608} + b_{i}</script><p>其中a = 1, $b<em>{i} = high*2^{1368} + low</em>{i}$</p><p>且x仅为95*8=760位</p><p>此时可以利用<a href="https://en.wikipedia.org/wiki/Coppersmith%27s_attack#Generalizations" target="_blank" rel="noopener">Broad Attack with Linear Padding</a>结合Copper Smith Attack进行求解。</p><p>构造多项式$f(x) = (x*2^{608} + b) ^{3} - c (mod n<em>{1}n</em>{2})$的<code>small root</code>。</p><p>需要注意的是，<code>small root</code>要求小于模数n的1/e次方，而x为760位，760<em>3 = 2280 &gt; 2048 = 1024</em>2，所以需要使用两组加密信息使得模数的位数增大为4096位，从而760位的x满足<code>small root</code>的条件。 </p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><p>根据以上分析，根据给出的pem和enc文件提取两对使用3作为加密指数的(n, c)对，编写sage脚本解密如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">n = [<span class="number">11743537468135317101480488020144809201914936988461977176868954193874417724397531738707729413940060004291802011501577549223271797288223565654061393379024948557114873802484065401046235691942131446370168987779343797500311519782297945918303703564655987952282482715476136773764831205732478344688915636069116516770855051840466960976764092858799500910720099908106249684080240663853178927556249049193503151085654884527269002477666950572742679984293662085069728877459286849951188181117702216469759179036558783079196215512501682142798495265635852347494193629555160491782509569392767123686061925883459482937083314597325931324903</span>,</span><br><span class="line">    <span class="number">14457209969884668177708697333084651442256193118762305783886170334587420837310297145702128170106972242068185696834421424217621080232658721763477597612126355466640947700608787202555955170003838596141926637700553638034795412618607691704863949191711837596504911369550275265047485577345602266210861036695691235637536527380239331718278464709412846966181787795995822367966392084870050879397930114908541580226650851547317522603090899886280170245299959983054236157294287800393659291904879499563552223080590816177114742527572796924746954499447982388532224932540152177949556088321209870823140903366811600475984145194404542130227</span>]</span><br><span class="line">c = [<span class="number">8190049298225986645065639656298172597926128706450768371303258134744480067344252838541490888036183464705944304534788993901104793815361341756431217860700928158019252752618919437673052832128577726977953950790902559970309709239504865249701468783648614158118356226876181834829777260079340923537145106302704145961190836661375363413110097880213997662546161624163926197325967768410253429584704238310212909716376684130921549808859640649278922277248496022978656354003386568276074858346316327173050731369576404526308212891898482132494538059251451015302281630189059974681450654073047538089109981563439870031087270051532901896822</span>,</span><br><span class="line">    <span class="number">12118101166054737713386215385862569765107262982956699621223784645643668203345111850159614142861485707244381466506582226100758646240135249724760825645393433062905277245716757630096083674730526877271237776864887538290354358982569685278734177038607779153674199245850037034568957234569159850767151815484600506473286544739506911281943726669304436835800686344966600632518764992677531015390701093253398220813342080495059893716294823513371481710159387645437923515728187314225175839309059255201792376404426500260584133880852811820804606509557432184294402579927159295465411669899092463872169344366863225658285149101653314280770</span>]</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment"># b_i = high + low_i</span></span><br><span class="line">b=[<span class="number">15544274873612998989866379328566946388285248570806564503108352867340017880252665817613208325183832507901409765669821491355202065667225050801744228447515864518584620720787409961012061302114074543857882368586098987225919736280924738224995075370843988377198544539266275729089636607095220506662375139381261384398438998662059177913249680151096549632879238896603189241688956490787338355571799212913598318011639865738648621731434747681682396930715043552472778331701738091587062917693835229391950847730617837543337471998802061973389340720433170042633451884844390746043635079083497185464124715717119052915013438803576714502781</span>,</span><br><span class="line">   <span class="number">15544274873612998989866379328566946388285248570806564503108352867340017880252665817613208325183832507901409765669821491355202065667225050801744228447515864518584620720787409961012061302114074543857882368586098987225919736280924738224995075370843988377198544539266275729089636607095220506662375139381261384398438998662059177913249680151096549632879238896603189241688956490787338355571799212913598318011639865738648621731434747681682396930715043552472778331701733991049485714120357663081338580983163588987883815040112341393183479429685436337175694444720513269496978577270272192766705854550355666404326847416678342795901</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chinese_remainder</span><span class="params">(n, a)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    prod = reduce(<span class="keyword">lambda</span> a, b: a * b, n)</span><br><span class="line">    <span class="keyword">for</span> n_i, a_i <span class="keyword">in</span> zip(n, a):</span><br><span class="line">        p = prod // n_i</span><br><span class="line">        sum += a_i * inverse_mod(p, n_i) * p</span><br><span class="line">    <span class="keyword">return</span> int(sum % prod)</span><br><span class="line"></span><br><span class="line">T = []</span><br><span class="line">T.append(chinese_remainder([n[<span class="number">0</span>],n[<span class="number">1</span>]],[<span class="number">1</span>,<span class="number">0</span>]))</span><br><span class="line">T.append(chinese_remainder([n[<span class="number">1</span>],n[<span class="number">0</span>]],[<span class="number">1</span>,<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N = n[<span class="number">0</span>]*n[<span class="number">1</span>]</span><br><span class="line">P.&lt;x&gt; = PolynomialRing(Zmod(N))</span><br><span class="line"></span><br><span class="line">g=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    g += ((a[i]*x *<span class="number">2</span>^<span class="number">608</span> + b[i])^<span class="number">3</span> - c[i])*T[i]</span><br><span class="line">g = g.monic()</span><br><span class="line">x = g.small_roots()[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> x</span><br><span class="line"><span class="keyword">print</span> hex(long(x))[<span class="number">2</span>:].strip(<span class="string">'L'</span>).decode(<span class="string">'hex'</span>)</span><br><span class="line"><span class="comment"># 1714661166087377473014475529806516832214035482305327415277479703776481564871479523924321275498885242003713793314464965569235093750357822116766965311615937698169583931123673327349849371866141948995747458407120138743748898874096942</span></span><br><span class="line"><span class="comment"># Hahaha, Hastad's method don't work on this. Flag is flag&#123;6b6c9731-5189-4937-9ead-310494b8f05b&#125;.</span></span><br></pre></td></tr></table></figure><h2 id="0x03-cr3-what-is-this-encryption"><a href="#0x03-cr3-what-is-this-encryption" class="headerlink" title="0x03 cr3-what-is-this-encryption"></a>0x03 cr3-what-is-this-encryption</h2><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题以十六进制明文的方式给出了<code>p, q, e</code>这三个RSA解密需要的参数以及密文<code>c</code>，直接编写脚本解密即可。需要用到<code>gmpy2</code>和<code>binascii</code>这两个库。</p><h3 id="解题脚本-1"><a href="#解题脚本-1" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">p=<span class="string">'0xa6055ec186de51800ddd6fcbf0192384ff42d707a55f57af4fcfb0d1dc7bd97055e8275cd4b78ec63c5d592f567c66393a061324aa2e6a8d8fc2a910cbee1ed9'</span> </span><br><span class="line">q=<span class="string">'0xfa0f9463ea0a93b929c099320d31c277e0b0dbc65b189ed76124f5a1218f5d91fd0102a4c8de11f28be5e4d0ae91ab319f4537e97ed74bc663e972a4a9119307'</span> </span><br><span class="line">e=<span class="string">'0x6d1fdab4ce3217b3fc32c9ed480a31d067fd57d93a9ab52b472dc393ab7852fbcb11abbebfd6aaae8032db1316dc22d3f7c3d631e24df13ef23d3b381a1c3e04abcc745d402ee3a031ac2718fae63b240837b4f657f29ca4702da9af22a3a019d68904a969ddb01bcf941df70af042f4fae5cbeb9c2151b324f387e525094c41'</span></span><br><span class="line">c=<span class="string">'0x7fe1a4f743675d1987d25d38111fae0f78bbea6852cba5beda47db76d119a3efe24cb04b9449f53becd43b0b46e269826a983f832abb53b7a7e24a43ad15378344ed5c20f51e268186d24c76050c1e73647523bd5f91d9b6ad3e86bbf9126588b1dee21e6997372e36c3e74284734748891829665086e0dc523ed23c386bb520'</span></span><br><span class="line"></span><br><span class="line">p_decimal = int(p, <span class="number">16</span>)</span><br><span class="line">q_decimal = int(q, <span class="number">16</span>)</span><br><span class="line">e_decimal = int(e, <span class="number">16</span>)</span><br><span class="line">c_decimal = int(c, <span class="number">16</span>)</span><br><span class="line">phi_n = (p_decimal<span class="number">-1</span>) * (q_decimal<span class="number">-1</span>)</span><br><span class="line">d = gmpy2.invert(e_decimal, phi_n)</span><br><span class="line">m_decimal = pow(c_decimal, d, (p_decimal)*(q_decimal))</span><br><span class="line">final_message = binascii.a2b_hex(hex(m_decimal)[<span class="number">2</span>:])</span><br><span class="line">print(final_message.decode())</span><br></pre></td></tr></table></figure><h2 id="0x04-flag-in-your-hand1-amp-flag-in-your-hand"><a href="#0x04-flag-in-your-hand1-amp-flag-in-your-hand" class="headerlink" title="0x04 flag_in_your_hand1 &amp; flag_in_your_hand"></a>0x04 flag_in_your_hand1 &amp; flag_in_your_hand</h2><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>这两个题的思路和flag都是一样的（小声逼逼</p><p>下载附件并解压，文件夹中有一个<code>html</code>页面和一个js脚本。首先进入页面，容易得到flag的获取流程为：手动输入Token，并运行<code>getFlag()</code>函数，步进查看该函数细节。</p><p><img src="http://static.zybuluo.com/B1ank/7xmysk8mnvmaeejut6pb0y2m/flag_in_your_hand1.PNG" alt="flag_in_your_hand1.PNG-17.3kB"></p><p>可以很清楚地看到，该函数首先获取输入框中的Token值，并将其传入<code>checkToken()</code>函数，返回结果为ic，然后将其传入<code>bm()</code>函数，该函数返回结果为fg。进入提供的js脚本中查看这两个函数，可以发现<code>bm()</code>函数与flag的生成过程有关，分析可以得到其运用单表替换的编码方式。单独查看<code>checkToken()</code>函数可以发现其返回结果为false。但结合<code>bm()</code>函数的运行流程可以发现，ic的值会通过<code>ck()</code>函数覆盖。</p><p><img src="http://static.zybuluo.com/B1ank/4ke5xx1ohv8a1h2r1r7vate5/flag_in_your_hand11.PNG" alt="flag_in_your_hand11.PNG-35.6kB"></p><p>观察<code>ck()</code>函数内部可知，其检验过程要求输入Token中每个字母的ASCII值与数组a中的对应位置ASCII值相差3，于是可以编写脚本得到验证正确的Token，输入以获得flag。</p><h3 id="解题脚本-2"><a href="#解题脚本-2" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">password = <span class="string">''</span></span><br><span class="line">a = [<span class="number">118</span>, <span class="number">104</span>, <span class="number">102</span>, <span class="number">120</span>, <span class="number">117</span>, <span class="number">108</span>, <span class="number">119</span>, <span class="number">124</span>, <span class="number">48</span>,<span class="number">123</span>,<span class="number">101</span>,<span class="number">120</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> a:</span><br><span class="line">    password += chr(item - <span class="number">3</span>)</span><br><span class="line">print(password)</span><br></pre></td></tr></table></figure><h2 id="0x05-工业协议分析1"><a href="#0x05-工业协议分析1" class="headerlink" title="0x05 工业协议分析1"></a>0x05 工业协议分析1</h2><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>下载附件后发现其为<code>pacap</code>文件，记录网络流量。使用wireshark打开后，追踪TCP流，在结果中搜索flag字符串，发现<code>flag.txt</code>字样，考虑网络流量中包含与flag相关的txt文件。</p><p>在命令行中搜索发现<code>flag.txt</code>结果不存在有意义的明文，遂搜索其他可能发送的文件类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;.txt&quot; -a sample.pcap</span><br><span class="line">grep &quot;.rar&quot; -a sample.pcap</span><br><span class="line">grep &quot;.zip&quot; -a sample.pcap</span><br><span class="line">grep &quot;.png&quot; -a sample.pcap</span><br></pre></td></tr></table></figure><p>当搜索png图片相关时，发现网络环境中传送了base64加密的图片。</p><p><img src="/2020/05/10/攻防世界 —— Crypto（进阶区1）/C:/Users\B1ank\Desktop\攻防世界\Crypto\工业控制协议1.PNG" alt="工业控制协议1"></p><p>编写脚本解密即可得到flag。</p><h3 id="解题脚本-3"><a href="#解题脚本-3" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment"># 将上图中的base64加密结果存入./final_result.txt文件中</span></span><br><span class="line">base_result = open(<span class="string">'./final_result.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">png_result = base_result.read()</span><br><span class="line">png_after_decode = base64.b64decode(png_result)</span><br><span class="line">result = open(<span class="string">'./result.png'</span>, <span class="string">'wb'</span>)</span><br><span class="line">result.write(png_after_decode)</span><br></pre></td></tr></table></figure><h2 id="0x06-你猜猜"><a href="#0x06-你猜猜" class="headerlink" title="0x06 你猜猜"></a>0x06 你猜猜</h2><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>下载并打开题目给出的附件，发现其开头为<code>50 4B 03 04</code>显然是<code>zip</code>格式压缩包的开头，我们将其复制粘贴到Winhex中，注意保存的时候选择<code>ASCII Hex</code>选项，可以看到其ASCII字符以PK开头并且内部包含flag.txt。</p><p>将该压缩包解压发现需要密码，首先考虑zip伪加密发现不符合要求，于是使用密钥爆破软件进行爆破，得到最终密码为123456，解压得flag。</p><h3 id="一些经验-1"><a href="#一些经验-1" class="headerlink" title="一些经验"></a>一些经验</h3><p>先知社区有一篇非常详细的手撕压缩包过程，对压缩包结构的理解有一些帮助：<a href="https://xz.aliyun.com/t/3994" target="_blank" rel="noopener">从做CTF题到手撕ZIP</a>。</p><h2 id="0x07-fanfie"><a href="#0x07-fanfie" class="headerlink" title="0x07 fanfie"></a>0x07 fanfie</h2><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p>攻防世界上的题目既没有提示也没有flag格式，直接给了一堆看上去像base32编码的字符串，完全没有思路。于是找到原题得到两个重要提示。这样我们有如下题目条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.flag的格式为:BITSCTF&#123;&#125;</span><br><span class="line">2.Brute and get the base 32 format of flag</span><br><span class="line">3.encrypted.txt : MZYVMIWLGBL7CIJOGJQVOA3IN5BLYC3NHI</span><br></pre></td></tr></table></figure><p>可以看到题目提供的密文是对base32加密结果进行未知方式加密的结果。所以我们需要将提供的密文先还原成base32加密的结果，再进行base32解密得到最终flag。</p><p>base32转换过程中将明文按照每五个字符为一组进行分组，将结果进行base32加密后长度填充为8的倍数。由于已知flag以<code>BITSCTF</code>开头，我们取前五个字符进行base32加密，得到结果为<code>MZYVMIWL</code>，看起来该未知加密方式为单表替代加密。构建字母表并寻找对应关系如下：</p><p><img src="http://static.zybuluo.com/B1ank/tkv073onf40rhwf1qrq4xyfa/fanfie.PNG" alt="fanfie.PNG-17.5kB"></p><p>整理得到如下关系式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3-&gt;11</span><br><span class="line">4-&gt;24</span><br><span class="line">8-&gt;12</span><br><span class="line">9-&gt;25</span><br><span class="line">20-&gt;8</span><br><span class="line">21-&gt;21</span><br><span class="line">26-&gt;22</span><br></pre></td></tr></table></figure><p>假设为仿射密码，可以解出<code>a = 13, b = 4, modulus = 27</code>，编写脚本解密后将结果进行长度填充至8的倍数，再进行一次base32解密即可。原来这个题目的名字进行移位之后会变成affine啊（小声逼逼</p><h3 id="解题脚本-4"><a href="#解题脚本-4" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">str = <span class="string">'BITSC'</span></span><br><span class="line">print(base64.b32encode(str.encode()))</span><br><span class="line">a = <span class="number">13</span></span><br><span class="line">b = <span class="number">4</span></span><br><span class="line">mod = <span class="number">32</span></span><br><span class="line">a_modinv = gmpy2.invert(a, mod)</span><br><span class="line">print(type(a_modinv))</span><br><span class="line">base32_result_after_encode = <span class="string">'MZYVMIWLGBL7CIJOGJQVOA3IN5BLYC3NHI'</span></span><br><span class="line">alphabet = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'</span></span><br><span class="line">base32_result_after_decode = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> base32_result_after_encode:</span><br><span class="line">    index = alphabet.find(item)</span><br><span class="line">    base32_result_after_decode += alphabet[a_modinv*(index - b) % mod]</span><br><span class="line">print(base32_result_after_decode)</span><br><span class="line">flag = base64.b32decode(base32_result_after_decode+<span class="string">"="</span>*<span class="number">6</span>)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><h2 id="0x08-wtc-rsa-bbq"><a href="#0x08-wtc-rsa-bbq" class="headerlink" title="0x08 wtc rsa bbq"></a>0x08 wtc rsa bbq</h2><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><p>拿到该题目的附件并解压，发现其包括<code>key.pem</code>和<code>cipher.bin</code>，说明密钥以证书的形式存在，而加密结果以二进制文件的形式存在。</p><p>进入到Kali中使用系统自带OpenSSL的命令：<code>rsa -pubin -text -modulus -in warmup -in key.pem</code>，获取公钥对如下：</p><p><img src="http://static.zybuluo.com/B1ank/8trausp5ssc517e8e3w9x5ty/wtc_rsa_bbq.PNG" alt="wtc_rsa_bbq.PNG-112.8kB"></p><p>可以发现其模数N非常大，e为标准加密指数。编写脚本将密文以十六进制的形式从<code>cipher.bin</code>中读出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ciphertext = open(<span class="string">'./cipher.bin'</span>, <span class="string">'rb'</span>).read().encode(<span class="string">'hex'</span>)</span><br></pre></td></tr></table></figure><p>至此，解密数据的提取过程完成。</p><p>整道题目没有其他可以操作的参数，我们只能分解模数。观察模数N，发现其位数较多，显然直接分解这条路行不通（指factordb，这里使用yafu的话理论上是可以跑出来的，我们考虑费马分解法。</p><p>费马分解法适用于RSA加密过程中选取的大素数p,q较为相近的情况，运用到了<code>|p-q|</code>这一参数较小的原理进行爆破，从而实现分解模数N的功能。编写费马分解函数将N分解之后即可正常解密得flag。</p><h3 id="解题脚本-5"><a href="#解题脚本-5" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fermat_resolve</span><span class="params">(N)</span>:</span></span><br><span class="line">    B = math.factorial(<span class="number">2</span>**<span class="number">14</span>)</span><br><span class="line">    u = <span class="number">0</span>;v = <span class="number">0</span>; i = <span class="number">0</span></span><br><span class="line">    u0 = gmpy2.iroot(N, <span class="number">2</span>)[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=(B<span class="number">-1</span>)):</span><br><span class="line">        u = (u0+i)*(u0+i)-N</span><br><span class="line">        <span class="keyword">if</span> gmpy2.is_square(u):</span><br><span class="line">            v = gmpy2.isqrt(u)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">    p = u0+i+v</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">()</span>:</span></span><br><span class="line">    decimal_e = <span class="number">65537</span></span><br><span class="line">    n = <span class="string">'62D3D61C92452630147E89670FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'</span></span><br><span class="line">    decimal_n = int(n, <span class="number">16</span>)</span><br><span class="line">    p = fermat_resolve(decimal_n)</span><br><span class="line">    q = decimal_n // p</span><br><span class="line">    print(<span class="string">'p = '</span> + str(p))</span><br><span class="line">    print(<span class="string">'q = '</span> + str(q))</span><br><span class="line">    phi_n = (p<span class="number">-1</span>) * (q<span class="number">-1</span>)</span><br><span class="line">    d = gmpy2.invert(decimal_e, phi_n)</span><br><span class="line">    ciphertext = <span class="string">'04940e995809b8346a7225a4ef8f175ef3031d33f975b5398cae11e0accb9195c4e351274bb9dbac1d1b9819ae679e8d300457f3e5f8f31150648f8393cbf503e40b11140b8a8a51d22bc5bc74fdbfda0e8dabcc6704d128aa29fe480538801bd4de422e6f1a221e471f75d855a49033289e1f58e0db5e8d2a2dab473912b1b35ed0552890c8b73246266c27edb90b1509a2d5d209236e23050c45acf812df98b1be3a8bcdff9891c773daa17b72db3fd59cd2b65ee103ec7b24e1358ebe14ccb86831a617df10674dd842939ddd455e741d4fc8f1421917b782d1660651a5396928a94661bcdf9f0d2f956fc6ca238478ef44701eefb3b0e5610dd5562fce66be11b1b5d9ffca636a52037d7ce6cd44ea810ba84c49c02ae29bd2de3ffa03ae8f05b3e633f0f11c513528f1404c66217b9d5605e6f0869c25bf024b93ce35aef2ab16d0f14f34c850ec1d13c73e46bd58686903bf63740142579095d7d293f8bd35abf653729ecd0e84954a73a07d8504ca03d3aa44a6b08d776ecf8949c5b71d52e2000ebd6610a3e18f7f739e4958e070ec9b9c9493c990d637850d2aad752fb60859f676a76fc1f3e2956abedd2bdb8eb49f88ac0b9ae01d3c848187536803c7a99e61e9e4d9e10ad60952e9387b4242c24d06f3fdb247f4c8b85425b49a8db6a716144a0e62273cb722709f96f9c254eae9d5fc9b1a0abae30af9da49af765572908251e99beaf1605a40043b7ce8cfbdd49cdbc33c0216d966165a5f04599db3dcc2404139249be6cae78b5794293451a6902c18b7719759475b31b976e40c8d579f84202808836f5ddf04d4a1edf22555c7612df1973e45b343045d02b5a90a760cebb69ef862ffe2c023ee3ee5f3968c07120e9b8d036fdeccaed9f1b7ce678f44c3e507bf5015751078f990efe248fef787f34570134679207d599cab2d58524265167d3af2208325a671f9a0ced94b902121eaa6ee982d4c23b543f863580291aab134fea82c9a711d12d2bc19efa168c05be070258442c46da95ab6f1dbf5bef845fa48524ebcda31d5e19ccb69835bd50812ef0117ff33f4319072f94359cb69eb951133afb2d72e2773a5480d04969389153d831be6007915c571f8817d6d56ed6ed5dfda5d855e4ddab32ecfdabc2b5d2235712d13226093bdac6c7c283415cdde559b638d42a19ca97a842c01bf88bdc3ec55f71dcce5b0dad2527004601ae2b49c5c1a13ecfb7e7170938382b77724c208aed8d7cb1fb23a28596c1e43b64d46336c10dae18146faf4d5eb8c42c167410903d76f80fdde479beffb56a07bb9cef7a559579b637d625b783e74c495c495b162a98340c11ccdc3fd6a127f163757f94cbffc4542b913e993258ffdf85f7b04be637126dc195a7a6910d942cc870214a198a5e984a44a92c0827786515280bf7379bebdefe579c7e5a9a69116f603911d01010d1ca93882c8fe4791bf580a60731444eb09f1f50fca0ddfb9d99310a9ed699551eb17c16433'</span></span><br><span class="line">    c = int(ciphertext, <span class="number">16</span>)</span><br><span class="line">    plaintext = int(pow(c, d, p*q))</span><br><span class="line">    message = binascii.a2b_hex(hex(plaintext)[<span class="number">2</span>:])</span><br><span class="line">    print(message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    decode()</span><br></pre></td></tr></table></figure><h3 id="一些经验-2"><a href="#一些经验-2" class="headerlink" title="一些经验"></a>一些经验</h3><p>当题目只给出一个加密过程（广播攻击不适用）且其他参数没有明显可以攻击的特征时，我们只能考虑直接分解模数N。对于模数N的分解，我们常使用两种方法：借助<a href="www.factordb.com">大整数分解网站</a>和使用Windows自带的工具yafu。前者只适合分解一些初级题目中位数较小的模数，后者包含多种模数分解方法，但效率较低。除此之外我们可以参考GitHub上的CtfRSATools这一项目，其中模数分解环节提供了许多常见的分解算法。</p><p>所有分解算法中，费马分解法和Pollard p-1分解法。下面简要介绍这两种分解方法并给出分解脚本。</p><h4 id="费马分解法"><a href="#费马分解法" class="headerlink" title="费马分解法"></a>费马分解法</h4><p>该方法适用于构成模数N的两个大素数p,q相近即<code>|p-q|</code>较小的情况。过程如下：</p><p>任何一个正整数n都能拆成$n = 2^{k} <em> a$的形式，其中a为一个奇数。若$a = c</em>d$，则令$x = (c+d)/2$，$y = (c-d)/2$，则$x^{2} - y^{2} = a$，枚举$x^{2}$观察$x^{2}-a$是否为完全平方数，如果是，则$c  = x+(x^{2}-a)^{(1/2)}$和$d = x-(x^{2}-a)^{(1/2)}$就是a的因子。我们通过枚举$x^{2}$可以找到a的所有因子。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fermat_resolve</span><span class="params">(N)</span>:</span></span><br><span class="line">    B = math.factorial(<span class="number">2</span>**<span class="number">14</span>)</span><br><span class="line">    u = <span class="number">0</span>;v = <span class="number">0</span>; i = <span class="number">0</span></span><br><span class="line">    u0 = gmpy2.iroot(N, <span class="number">2</span>)[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=(B<span class="number">-1</span>)):</span><br><span class="line">        u = (u0+i)*(u0+i)-N</span><br><span class="line">        <span class="keyword">if</span> gmpy2.is_square(u):</span><br><span class="line">            v = gmpy2.isqrt(u)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">    p = u0+i+v</span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><h4 id="Pollard-p-1分解法"><a href="#Pollard-p-1分解法" class="headerlink" title="Pollard p-1分解法"></a>Pollard p-1分解法</h4><p>Pollard p-1方法由Pollard提出，适用于p-1或q-1能够被小素数整除的情况。具体流程如下：</p><p><img src="http://static.zybuluo.com/B1ank/yl9ag00nxiqztluenw5wvyyj/pollard_p-1.png" alt="pollard_p-1.png-64.9kB"></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pollard_p</span><span class="params">(N)</span>:</span></span><br><span class="line">    B = <span class="number">2</span>**<span class="number">20</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,B+<span class="number">1</span>):</span><br><span class="line">        a = pow(a, i, N)</span><br><span class="line">        d = gmpy2.gcd(a<span class="number">-1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> d&gt;=<span class="number">2</span> <span class="keyword">and</span> d&lt;=(n<span class="number">-1</span>):</span><br><span class="line">            q = n // d</span><br><span class="line">            n = q*d</span><br><span class="line">    <span class="keyword">return</span> d</span><br></pre></td></tr></table></figure><h2 id="0x09-工业协议分析2"><a href="#0x09-工业协议分析2" class="headerlink" title="0x09 工业协议分析2"></a>0x09 工业协议分析2</h2><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题目给出pcap附件，可以想到为流量分析，使用wireshark打开，发现存在关于ARP、UDP、SNA协议的流量包以及大量的UDP流量包。</p><p>观察UDP流量包的长度，可以看到有些长度仅出现一次，其余长度多次出现。于是猜测这些流量包存在异常。分别分析这些流量包，发现长度为147和179的流量包出现异常字符串：</p><p><img src="http://static.zybuluo.com/B1ank/7ilsjwliubokdro7w0vkfgzh/%E5%B7%A5%E6%8E%A72.PNG" alt="工控2.PNG-13kB"></p><p><img src="http://static.zybuluo.com/B1ank/u5dfguc0vwe8xewspa8uxmqz/%E5%B7%A5%E6%8E%A723.PNG" alt="工控23.PNG-13.5kB"></p><p>长度为147的流量包传输的数据以<code>flag</code>结尾。故推测下一个从<code>192.168.1.123</code>向<code>192.168.1.181</code>发送的流量包可能包含flag信息。果然从长度为179的数据包中发现可疑数据：</p><p><img src="http://static.zybuluo.com/B1ank/omejzdg7g7p2xvtxyqdcfl1a/%E5%B7%A5%E6%8E%A722.PNG" alt="工控22.PNG-16.7kB"></p><p>将末尾的十六进制字符串转换为ASCII字符串可得flag。</p><h2 id="0x0A-工控安全取证"><a href="#0x0A-工控安全取证" class="headerlink" title="0x0A 工控安全取证"></a>0x0A 工控安全取证</h2><h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目给出<code>.log</code>文件并要求查找发起第四次扫描时的数据包编号。使用wireshark打开，发现有UDP，ICMP和TCP三种类型的数据包，并存在大量的TCP流量。</p><p>观察发现，UDP流量只有三条记录，TCP流量记录过多，显然第四次扫描时的数据包不在这两类流量中。接着分析剩下的ICMP数据包，可以看到每次发送大量TCP数据包之前，先发送ICMP数据包。找到第四次建立连接发送的ICMP数据包，其编号为flag。</p><p><img src="http://static.zybuluo.com/B1ank/tfsdr97jbo5jf18yfjdhs8tr/%E5%B7%A5%E6%8E%A73.PNG" alt="工控3.PNG-47.7kB"></p><h2 id="0x0B-小结"><a href="#0x0B-小结" class="headerlink" title="0x0B 小结"></a>0x0B 小结</h2><p>这十道题目里面需要特别注意的是第二题Broadcast和第八题wtc rsa bbq。前者提供了一种与普通RSA广播攻击不同的情形，引入了Hastad Attack以及Broadcast Attack with Linear Padding，并且其结合sagemath编写的解题模板值得借鉴。后者考察了只提供一对<code>(c, n, e)</code>情况下对参数n的处理，除在线网站及yafu分解外，还可以考虑Fermat Resolve和Pollard p-1 Resolve，注意二者适用的p,q对应情况。</p><p>以及，高校战疫的Crypto题目真的好少。pwntools杀我，这辈子都不想再看到EOFError了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;更新完Crypto新手区的题目之后，接下来开始练习进阶区的题目。本系列文章持续更新中~&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="CTF_Writeup" scheme="https://blank-vax.github.io/categories/CTF-Writeup/"/>
    
    
      <category term="攻防世界" scheme="https://blank-vax.github.io/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
      <category term="经验文章" scheme="https://blank-vax.github.io/tags/%E7%BB%8F%E9%AA%8C%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>Bristol Cryptography Blog（二）—— 多核处理器和向量处理器</title>
    <link href="https://blank-vax.github.io/2020/05/05/Bristol-Cryptography-Blog%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%E5%90%91%E9%87%8F%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>https://blank-vax.github.io/2020/05/05/Bristol-Cryptography-Blog（二）——-多核处理器和向量处理器/</id>
    <published>2020-05-05T04:28:00.000Z</published>
    <updated>2020-11-09T03:27:08.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文为布里斯托大学推出的<code>52 Things Every PhD Student Should Know to do Cryptography</code>系列学习笔记中的第二篇。原文连接：<a href="http://bristolcrypto.blogspot.com/2014/10/52-things-number-2-what-is-difference.html" target="_blank" rel="noopener">52 Things: Number 2: What is the difference between a multi-core processor and a vector processor?</a>。</p><h2 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h2><p>本篇文章讨论的核心问题可以概括为以下内容：</p><ul><li>多核处理器与矢量处理器的区别</li><li>并行计算问题</li></ul><h2 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h2><p>对于传统的串行处理模型，其解决问题的方法是将计算问题分解为多个指令步骤，在处理器上按照特定的顺序先后执行。执行过程中，处理器分别处理每条指令，最后得出解决问题的答案。尽管这种处理方式良好地解决了对应问题，但它的处理过程凸显出总体计算速度受到单个处理器计算能力的限制这一瓶颈。当需要解决的问题不大时，这一限制表现得并不明显。但是当处理的问题较大时，整个系统的计算效率就会明显地降低，于是我们引入并行计算的方法来突破处理器计算瓶颈，从而加快计算速度。</p><p>并行计算将需要解决的问题分割为许多小问题的集合，对于集合中的每个子问题，同时进行单独计算。通过这种方法，我们将待解决问题分成许多小问题并并行地解决子问题，从而大大加快了计算速度——具体效能由算法和阿姆达尔定律共同决定。为了实现并行计算，我们引入多核处理器与矢量处理器并进行二者区别的相关讨论。</p><h2 id="多核处理器"><a href="#多核处理器" class="headerlink" title="多核处理器"></a>多核处理器</h2><p>多核处理器是单个的计算组件，该组件通过调度多个串行处理器使其同时执行不同的操作来实现并行计算。通过此种调度方法，我们可以轻松地解决前面提到的大问题划分而成的子问题集。这就如同多个人合作项目，每个人各司其职，但所有人都在为该项目做贡献。尽管该种方法可能需要一些额外的组织工作，即统筹调度各个“核”（串行处理器）需要消耗一些时间，但完成项目的总体速度将会更快。</p><h2 id="向量处理器"><a href="#向量处理器" class="headerlink" title="向量处理器"></a>向量处理器</h2><p>尽管向量处理器和串行处理器一样每次处理单条指令，但与在单个数据集上运行的标准串行处理器不同的是，向量处理器的数据集包含许多以一维数组排列的数据并同时对其执行相关指令。如果需要对程序中不同数据集多次执行相同指令，可以考虑引入向量处理器，从而一次性地完成指令执行，大大提高计算效率。通常使用首字母缩写SIMD(Single Instruction Multiple Data)来表示以这种方式工作的指令。</p><h2 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h2><p>下面来讨论多核处理器与向量处理器的区别。经过上面的描述我们可以很明确地得出，多核处理器在计算问题层面进行处理，将大的计算问题进行分解，计算分解后的子问题；向量处理器在数据集层面进行处理，将多个需要执行同一指令的数据集进行合并，本质上没有处理计算问题本身。</p><p>我们使用更形象的例子进行解释。假设我们要在一条道路上滚动四块石头，每次滚动需要一分钟。串行处理器将其一一滚动，因此需要四分钟。双核处理器等价为有两个人同时滚动石头，对于每个人来说只需要滚动两块石头，这两个人同时进行滚动作业，总共需要耗费两分钟。而向量处理器相当于制造一块长木板，将其放在四块石头的后面，推动木板以实现四块石头同时滚动，这样只耗时一分钟便将四块石头滚动到对侧。</p><p>简而言之，多核处理器具有多个工作程序，而矢量处理器同时对多个事件执行相同的操作方式。</p><h2 id="阿姆达尔定律"><a href="#阿姆达尔定律" class="headerlink" title="阿姆达尔定律"></a>阿姆达尔定律</h2><p>阿姆达尔定律用来计算将一个运算过程的某一部分并行化后，该运算速度的提升幅度。</p><h3 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h3><p>阿姆达尔定律将一个可并行化的程序或算法分成两个部分：</p><ul><li>不能被并行化的部分</li><li>可以被并行化的部分</li></ul><p>例如，对于处理硬盘文件的程序来说，这个程序可能有一小部分负责扫描目录并创建文件列表内存对象，随后每个文件对象被发送给另一个单独的线程进行处理。在这个程序中，负责扫描目录和创建文件列表的那部分不能被并行化，但负责处理文件的部分可以。</p><p>我们定义以串行方式执行这个程序时消耗的时间为<code>T</code>,<code>T</code>为可并行化部分和不可并行化部分的时间之和，其中不可并行化部分消耗时间为<code>B</code>，则可并行化部分消耗时间为<code>T-B</code>。</p><p>按照阿姆达尔定律，当可并行化部分使用<code>N</code>个线程或CPU执行时，程序的总体执行时间可由以下公式表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(N) = B + (T - B) / N</span><br></pre></td></tr></table></figure><p>其中<code>T(N)</code>表示以<code>N</code>个并行因子执行时程序的所耗时间；<code>T</code>也可以写作<code>T(1)</code>(可以等同看做以1个并行因子执行时的所耗时间)。如果使用<code>T(1)</code>而不是<code>T</code>表示的话，阿姆达尔定律的形式变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(N) = B + ( T(1) - B ) / N</span><br></pre></td></tr></table></figure><h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p>从阿姆达尔定律来看，显然，可并行部分可以通过增加硬件数量来提升其执行速度，而不可并行化部分则只能通过优化算法来提升。也就是说，优化不可并行部分也可以提升整体执行速度，甚至可能的话，将不可并行化部分中的部分工作划分到可并行化部分，以使程序的不可并行化部分变得更小。</p><h4 id="优化不可并行部分"><a href="#优化不可并行部分" class="headerlink" title="优化不可并行部分"></a>优化不可并行部分</h4><p>在优化不可并行化部分时，可以应用阿姆达尔定律来计算程序优化后的预期执行时间。如果不可并行化部分B的优化因子为O，则其阿姆达尔定律的计算公式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(O,N) = B / O + (1 - B / O) / N</span><br></pre></td></tr></table></figure><p>注意，现在不可并行化部分的所耗时间为<code>B / O</code> 了，相应地可并行化部分的所耗时间应为 <code>1 - B / O</code> 。</p><h4 id="执行时间和加速比"><a href="#执行时间和加速比" class="headerlink" title="执行时间和加速比"></a>执行时间和加速比</h4><p>目前为止，我们仅仅用阿姆达尔定律计算了一个程序（或算法）在优化或并行化之后的执行所耗时间。但阿姆达尔定律不仅限于此，我们还可以用它计算加速比(speedup)，所谓加速比，就是优化后的算法（或程序）相对于旧的算法在速度上的提升倍数。</p><p>假设旧的程序(或算法)的执行时间是T，则加速比可表示为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Speedup = T / T(O,N)</span><br></pre></td></tr></table></figure><p>通常我们将<code>T</code>设为<code>1</code>，加速比为相对于它的分数形式，则加速比的公式变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Speedup = 1 / T(O,N)</span><br></pre></td></tr></table></figure><p>如果我们再将<code>T(O,N)</code>进行代入，则代入后的公式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Speedup = 1 / ( B / O + (1 - B / O) / N )</span><br></pre></td></tr></table></figure><h3 id="定律理论性"><a href="#定律理论性" class="headerlink" title="定律理论性"></a>定律理论性</h3><p>虽然阿姆达尔定律使你能够通过计算得出一个并行化后的算法的预期速度提升值，但是不要过于依赖这样一种计算。因为在实践中，当你优化或者并行化一个算法时，可能会有许多其他因素产生影响。</p><p>例如：内存、CPU缓存，及硬盘、网卡等（如果算法需要与硬盘和网卡交互的话），这些硬件的速度可能也会是一种限制因素。如果并行化一个算法后，引起了大量的“CPU缓存丢失”问题的话，你可能甚至得不到期望的提速效果——“增加N倍的CPU则得到的N倍的速度”；或者，如果优化后的算法最终会导致内存空间、硬盘、网卡、网络连接被占满的话，同样也会得不到预期效果。</p><p>最重要的一点是，有时候一个高度串行化的算法可能胜过并行算法。这是因为串行化算法没有并行算法的协调消耗，而且单一CPU算法更适应底层硬件的工作方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文为布里斯托大学推出的&lt;code&gt;52 Things Every PhD Student Should Know to do Crypto
      
    
    </summary>
    
      <category term="Crypto_Knowledge" scheme="https://blank-vax.github.io/categories/Crypto-Knowledge/"/>
    
    
      <category term="Notes" scheme="https://blank-vax.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>Bristol Cryptography Blog（一）—— 不同种类的处理器</title>
    <link href="https://blank-vax.github.io/2020/04/25/Bristol%20Cryptography%20Blog%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E4%B8%8D%E5%90%8C%E7%A7%8D%E7%B1%BB%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>https://blank-vax.github.io/2020/04/25/Bristol Cryptography Blog（一）—— 不同种类的处理器/</id>
    <published>2020-04-25T09:58:00.000Z</published>
    <updated>2020-11-09T03:26:09.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文为布里斯托大学推出的<code>52 Things Every PhD Student Should Know to do Cryptography</code>系列学习笔记中的第一篇。原文连接：<a href="http://bristolcrypto.blogspot.com/2014/10/52-things-number-1-different-types-of.html" target="_blank" rel="noopener">52 Things:Number 1 : Different Types of Processors</a>。</p><h2 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h2><p>本篇的核心问题可以概括为以下问题：</p><ul><li>通用处理器</li><li>具有指令集扩展的通用处理器</li><li>专用处理器或协同处理器</li><li>FPGA</li></ul><p>以上四种硬件的差异体现在哪些方面？</p><h2 id="通用处理器"><a href="#通用处理器" class="headerlink" title="通用处理器"></a>通用处理器</h2><p>尽管通用处理器没有严格的定义，但是将具有图灵完备的处理器称为通用处理器这一理论被广泛接受。通用处理器包含可以计算任何实际可计算的处理器，它们都可以解决图灵机可以解决的任何问题。在现代处理器背景下，大多数可编程CPU被认为是通用的。</p><h2 id="具有指令集扩展的通用处理器"><a href="#具有指令集扩展的通用处理器" class="headerlink" title="具有指令集扩展的通用处理器"></a>具有指令集扩展的通用处理器</h2><p><strong>处理器达到通用目的的代价通常会导致性能方面的不足</strong>。换句话说，通用处理器也许能够计算任何可计算的东西，但其无法胜任复杂的重复任务。针对那些各类应用程序中在通用处理上有规律地重复执行的任务，处理器设计师可以通过将指令集扩展合并到基本微体系结构中来适应该类任务。尽管微体系结构在功能上差异不大，但实际上用户会获得巨大的性能提升。对于CPU来说，基本的指令集相差甚微，但是许多厂家为了提升某一方面的性能，又开发了扩展指令集，<strong>扩展指令集定义了新的数据和指令，能够大大提高某方面数据处理的能力</strong>，但是对软件支持提出了新的需求。</p><p>我们举一个有关指令集扩展的密码学示例——<strong>具有AES加密磁盘的台式机</strong>。</p><p>该情况下，任何从二级存储（即磁盘）中读取的数据，都需要一个CPU中断来先对数据块进行解密，然后才能加载到内存处理。由于从缓存访问磁盘会影响访问性能，这就需要在磁盘上增加一个解密程序，于是一个值得重新考虑磁盘加密的瓶颈出现了。显然，AES加密是我们选择的复杂重复任务，给定一个简单指令集的通用CPU，我们别无选择只能以线性流操作的方法实现解密。Intel和AMD都意识到磁盘加密的需求，并且自2010年以来完成了<code>AES-NI x86</code>指令集扩展的生产，从而加快了台式机CPU系列磁盘加密的速度。</p><h2 id="专用处理器-协同处理器"><a href="#专用处理器-协同处理器" class="headerlink" title="专用处理器/协同处理器"></a>专用处理器/协同处理器</h2><p>如果希望针对任何计算进行全面加速，最优选择就是专用处理器或专用集成电路ASIC。这样可以实现性能提升，但作为代价会失去通用处理器的灵活性。这些类型的处理器通常紧密耦合到通用处理器中，因此称为协同处理器。需要注意的是，协同处理器可能与通用处理器存在于同一封装体系，但不一定集成到通用体系结构中。如果我们将目光转向现代处理器体系结构，Intel和AMD都将声卡、图形处理器和DSP引擎集成到了它们的CPU中，这种情况下附加功能通过专用寄存器公开，协同处理器被当作单独组件由通用处理器进行管理。</p><h2 id="Field-Programmable-Gate-Array"><a href="#Field-Programmable-Gate-Array" class="headerlink" title="Field Programmable Gate Array"></a>Field Programmable Gate Array</h2><p>场可编程门阵列处于通用处理器和专用处理器的中间地带。如果一个应用需要高性能的吞吐量，同时对修改次数要求较少，那么FPGA可能是最好的选择。</p><p>FPGA的工作原理说明如下：参考一个非常大的电子面包板，其周围遍布成千上万个逻辑门和查找表（通过多路复用的方式附着于内存）。如果将应用描述为一组门和时序约束的集合，那么可以在电路板上用导线将其连接形成一个电路，该电路可以用于计算目标应用。一个FPGA能提供可重编程的灵活性，同时通过生成专用逻辑电路来计算一个目标应用。与通用程序相比，FPGA需要使用硬件描述语言（VHDL或Verilog）来设计和构建你的应用。</p><p>当然，FPGA并非没有缺点。对于大型应用，使用低级构建模块来设计程序是非常麻烦的。此外与通用嵌入式集成电路相比，其具有更高的能耗和硬件成本。由于制造商Xilinx将ARM通用核装载在FPGA上，并封装在一个单独的包中。这使得FPGA可以作为ARM核的一个灵活的协同处理器进行使用，因此可以构建专门的逻辑电路来检测密码原语，以便实现密码操作的加速。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>通用处理器能够计算任何可以计算的任务。</p></li><li><p>拥有指令集扩展的通用处理器与通用处理器类似，不过其针对一些特定的应用能够更高效地执行。</p></li><li><p>专用处理器/协同处理器在计算一些特定任务时很快，但无法计算其它应用。</p></li><li><p>FPGA可以用于构建以上所有硬件，但是与ASIC比较，其通过牺牲速度的方法来保证灵活性。</p></li></ul><p>CPU与FPGA的根本区别在于软件和硬件的差异。CPU为冯诺依曼结构，串行地执行一系列指令；而FPGA可以实现并行操作。一般来说，CPU可以实现的功能，都可以通过硬件设计的方法由FPGA实现。</p><h2 id="附加：图灵机与图灵完备"><a href="#附加：图灵机与图灵完备" class="headerlink" title="附加：图灵机与图灵完备"></a>附加：图灵机与图灵完备</h2><p>上述通用处理器的定义过程中运用到图灵完备的相关知识，以前也接触过这个概念但一直没有仔细记录，现特记录如下。</p><h3 id="图灵机-Turing-Machine"><a href="#图灵机-Turing-Machine" class="headerlink" title="图灵机 Turing Machine"></a>图灵机 Turing Machine</h3><p>图灵机是图灵在1936年发表的<code>On Computable Numbers, with an Application to the Entscheidungsproblem</code>中提出的数学模型。在文章中图灵描述了它的具体定义，并且证明了<strong>只要图灵机可以被实现，就可以用来解决任何可计算问题</strong>。</p><p>图灵机由以下几个部分构成：</p><ul><li>一条无限长的纸带(tape)，纸带被分成一个个相邻的格子(square)，每个格子都可以写上至多一个字符(symbol)。</li><li>一个字符表(alphabet)即字符的集合，它包含纸带上可能出现的所有字符。特殊字符blank意味着此格子中没有任何字符。</li><li>一个读写头(head)，可以理解为指向其中一个格子的指针。它可以实现对当前格子内容的读取/写入/擦除，此外也可以每次向左/右移动一个格子。</li><li>一个状态寄存器(state register)，它追踪着每一步运算过程中，整个机器所处的状态，包含运行和终止两个状态。当状态从运行变为终止时，运算结束，机器停机并交回控制权。</li><li>一个有限的指令集(instructions table)，它记录着读写头在特定情况下应该执行的行为。</li></ul><p><img src="http://static.zybuluo.com/B1ank/3tk6lqk6u66do6sjbrwhbgw1/Turing_Machine.jpg" alt="Turing_Machine.jpg-16.8kB"></p><p>有两点需要注意：</p><ul><li>计算开始前，纸带可以是完全空白或者在某些格子里预先初始化数据。</li><li>运算开始时，读写头从某一位置开始，严格按照此刻的配置（当前所处位置+当前格子内容）来一步步对照指令集进行操作，直到状态变为停止。</li></ul><p>假设上述模型提到的功能都能被以某种形式物理实现，那么任意可计算问题均可被解决。这里的计算问题泛指一切与计算相关的问题。</p><blockquote><p>A computational problem is a mathematical object representing a collection of questions that computers might be able to solve.</p></blockquote><p>也存在一些不可计算的计算问题，比如著名的停机问题(Halting Problem)。</p><blockquote><p>Halting Problem: given the description of an arbitrary program and a finite input, decide whether the program finished running or will run forever.</p></blockquote><p>该问题是一个不可计算问题即不存在一个通用算法，可以在任意输入下解决此问题。</p><h3 id="图灵完备-Turing-Completeness"><a href="#图灵完备-Turing-Completeness" class="headerlink" title="图灵完备 Turing Completeness"></a>图灵完备 Turing Completeness</h3><p>图灵完备性是针对一套数据操作规则而言的概念。数据操作规则可以是编程语言，也可以是计算机里具体实现的指令集。当这套规则<strong>可以实现图灵机模型里的全部功能</strong>时，就称它具有图灵完备性。下面我们以一套编程语言为例对图灵完备性质进行说明。</p><h3 id="Brainfuck语言"><a href="#Brainfuck语言" class="headerlink" title="Brainfuck语言"></a>Brainfuck语言</h3><blockquote><p>Brainfuck is fully Turing-complete.</p></blockquote><p>首先它存储数据的方式是一个不限长的一维整数数组，里面的数值全部初始化为0.此外有一数据指针，每一时刻都指向数组的某一元素，指针可以向左/向右移动，也可以对当前值进行读取/修改。该语言由8个有效字符组成，分别为：</p><ul><li><p><code>&gt;</code> </p><p>指针向右移动一格</p></li><li><p><code>&lt;</code></p><p>指针向左移动一格</p></li><li><p><code>+</code></p><p>指针当前指向格子中的数值加一</p></li><li><p><code>-</code></p><p>指针当前指向格子中的数值减一</p></li><li><p><code>.</code></p><p>把当前指向格子中的数值按照ASCII表输出到终端</p></li><li><p><code>,</code></p><p>从终端接受一字节的数据，将其ASCII数值存储到当前格</p></li><li><p><code>[</code></p><p>当指针当前值为0时，跳转到与之对应的<code>]</code>符号之后，否则程序正常执行</p></li><li><p><code>]</code></p><p>程序跳转回与之对应的<code>[</code>处</p></li></ul><p>可以看到，该语言针对数域上的运算引入了加法和减法（乘法可以分解为加法而除法可以分解为减法），针对ASCII码与字母的转换引入了转换符号，针对循环问题引入了循环符号，同时引入左移右移符号从而控制每个格子。解决了可计算问题，符合图灵机的定义，故该语言图灵完备。</p><p>此外，Brainfuck还可以用于检测编程语言的完备性。对于一个语法功能复杂的新语言，使用数学证明的方式确定性说明其图灵完备较为麻烦，但是只要能够使用这门新语言实现一个Brainfuck解释器，那么就可以证明其图灵完备。</p><p>可视化Brainfuck语言运作流程：<a href="http://link.zhihu.com/?target=http%3A//fatiherikli.github.io/brainfuck-visualizer/" target="_blank" rel="noopener">Brainfuck Visualizer</a>。</p><h3 id="图灵完备判断"><a href="#图灵完备判断" class="headerlink" title="图灵完备判断"></a>图灵完备判断</h3><p>对于一个编程语言，我们可以通过它是否能够模拟出图灵机的运作流程来判断其是否具有图灵完备性。例如，图灵不完备的语言常见原因有循环或递归受限（即无法写出不终止的程序），无法开辟数组和列表这一类数据结构（无法模拟无限长的纸带）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文为布里斯托大学推出的&lt;code&gt;52 Things Every PhD Student Should Know to do Crypto
      
    
    </summary>
    
      <category term="Crypto_Knowledge" scheme="https://blank-vax.github.io/categories/Crypto-Knowledge/"/>
    
    
      <category term="Notes" scheme="https://blank-vax.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>码云合作办公指南</title>
    <link href="https://blank-vax.github.io/2020/04/25/%E7%A0%81%E4%BA%91%E5%90%88%E4%BD%9C%E5%8A%9E%E5%85%AC%E6%8C%87%E5%8D%97/"/>
    <id>https://blank-vax.github.io/2020/04/25/码云合作办公指南/</id>
    <published>2020-04-25T09:58:00.000Z</published>
    <updated>2020-11-09T03:26:20.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-合作场景"><a href="#0x00-合作场景" class="headerlink" title="0x00 合作场景"></a>0x00 合作场景</h2><p>最近团队在进行项目开发时出现了需要共享改动代码这一问题。由于GitHub的上传速度太慢，我们选择了Gitee平台来进行代码托管与合作修改，下面来整理一下流程以备不时之需。</p><h2 id="0x01-项目创建与邀请合作"><a href="#0x01-项目创建与邀请合作" class="headerlink" title="0x01 项目创建与邀请合作"></a>0x01 项目创建与邀请合作</h2><p>首先正常创建合作仓库，尽量选择创建私立仓库。创建好的仓库可以点击相关设置寻找邀请链接相关选项，将该选项中的链接路径复制并发送给其他合作者。参与合作的人登录自己的码云账号，点击该链接，即可作为合作者加入私有仓库。</p><h2 id="0x02-远程合作"><a href="#0x02-远程合作" class="headerlink" title="0x02 远程合作"></a>0x02 远程合作</h2><p>尽管合作参与者可以直接修改合作项目，但容易出现代码覆盖问题，所以我们选择将原项目fork到本账号仓库下，然后对其进行编辑。</p><p><img src="http://static.zybuluo.com/B1ank/xwnk5nfk8z8bjtq0cu73dgx3/original_project.PNG" alt="original_project.PNG-3751.6kB"></p><p>这里右上角的forked说明已经在本账号仓库完成fork。</p><p><img src="http://static.zybuluo.com/B1ank/kjbq5ame4uhkcsl1zsfy2ux4/forked_result.PNG" alt="forked_result.PNG-2572.5kB"></p><p>本账号仓库的内容修改完毕之后，点击<code>+Pull Request</code>可以发送代码合并申请。这样原创建者会收到合并请求即修改细节，待其审核通过后修改可以同步到源文件。与此同时，所有的合作参与者会收到相关通知，详细记录了修改细节。</p><h2 id="0x03-git码云远端库"><a href="#0x03-git码云远端库" class="headerlink" title="0x03 git码云远端库"></a>0x03 git码云远端库</h2><p>首先在网上下载git工具并完成安装。右键选择<code>Git Bash Here</code>，在命令行窗口中输入<code>git --version</code>命令可以查看git版本号。</p><p><img src="http://static.zybuluo.com/B1ank/q3bk8z3dqf8exyrwia8mllf8/git_1.PNG" alt="git_1.PNG-10.3kB"></p><p>然后配置用户名和邮箱：</p><ul><li><code>git config --global user.name &quot;username&quot;</code>。使用该命令设置git的全局姓名或昵称。</li><li><code>git config --global user.email &quot;email_address&quot;</code>。使用该命令设置全局邮箱地址。</li></ul><p>完成上述加入合作仓库以及fork到本账号步骤之后，我们继续进行项目到本地PC的迁移。首先复制该项目的地址，用于下一步的git操作。</p><p><img src="http://static.zybuluo.com/B1ank/mvya5fzubqusqzcirenucpbp/git_2.PNG" alt="git_2.PNG-32kB"></p><p>在本地新建空文件夹，进入文件夹内部执行<code>Git Bash Here</code>命令，使用<code>git init</code>命令将这个目录初始化为一个本地git仓库，继续键入命令并输入复制的git地址<code>git clone + git_address</code>。出现如下结果则可以在本地对项目进行代码修改。</p><p><img src="http://static.zybuluo.com/B1ank/aoz2r4ooqk3jl3miay4sg63b/git_3.PNG" alt="git_3.PNG-28.9kB"></p><p>然后进入clone后的文件目录，在这个目录下添加测试文件test.txt并编写测试内容。然后执行下述命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; git status</span><br><span class="line">&gt; git add .    (这里注意add与.之间存在空格)</span><br><span class="line">&gt; git commit -m &quot;add notification of this modification&quot;     (该操作是添加为本次修改添加注释)</span><br><span class="line">&gt; git remote add nickname git_address      (该命令用于为自己仓库地址取别名，下次提交时不需要执行该命令)</span><br><span class="line">&gt; git push nickname master</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/B1ank/1v46uf475fkjqelqyzz0td6w/git_4.PNG" alt="git_4.PNG-67.7kB"></p><p>以上为流程正确执行时git的返回结果。我们可以在自己的项目内发现新增的内容：</p><p><img src="http://static.zybuluo.com/B1ank/3nqkyzb5kr8871vz5af37by9/git_5.PNG" alt="git_5.PNG-2256.4kB"></p><p>至此，我们完成本地修改项目仓库的配置并实现一次成功提交。修改完成本账号仓库后，根据前述的步骤点击<code>+Pull Request</code>按键向项目拥有者发送审核请求即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-合作场景&quot;&gt;&lt;a href=&quot;#0x00-合作场景&quot; class=&quot;headerlink&quot; title=&quot;0x00 合作场景&quot;&gt;&lt;/a&gt;0x00 合作场景&lt;/h2&gt;&lt;p&gt;最近团队在进行项目开发时出现了需要共享改动代码这一问题。由于GitHub的上传速度太
      
    
    </summary>
    
      <category term="踩坑指南" scheme="https://blank-vax.github.io/categories/%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="Gitee" scheme="https://blank-vax.github.io/tags/Gitee/"/>
    
  </entry>
  
</feed>
