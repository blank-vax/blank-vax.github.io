<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>B1ank</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blank-vax.github.io/"/>
  <updated>2021-09-27T11:43:01.053Z</updated>
  <id>https://blank-vax.github.io/</id>
  
  <author>
    <name>B1ank</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Solidity基础</title>
    <link href="https://blank-vax.github.io/2021/09/27/Solidity%E5%9F%BA%E7%A1%80/"/>
    <id>https://blank-vax.github.io/2021/09/27/Solidity基础/</id>
    <published>2021-09-27T11:32:00.000Z</published>
    <updated>2021-09-27T11:43:01.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-数据类型"><a href="#0x00-数据类型" class="headerlink" title="0x00 数据类型"></a>0x00 数据类型</h2><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><ul><li><code>fixed/unfixed</code>：有符号和无符号的定长浮点型</li><li><code>fixedMxN</code>：带符号的定长浮点型，其中M表示按类型取的位数，N表示小数点。M应该能被8整除，N可以是0到80。<code>fixed</code>默认为<code>fixed128x18</code>。</li><li><code>ufixedMxN</code>：无符号的定长浮点型，其中M表示按类型取的位数，N表示小数点。</li></ul><h3 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h3><p>地址类型表示以太坊地址，长度为20字节。地址可以使用<code>.balance</code>放啊获得余额，也可以使用<code>.transfer</code>方法将余额转到另一个地址。</p><h2 id="0x01-变量"><a href="#0x01-变量" class="headerlink" title="0x01 变量"></a>0x01 变量</h2><p>Solidity支持三种类型的变量：</p><ul><li>状态变量：变量值永久保存在合约存储空间中的变量；</li><li>局部变量：变量值仅在<strong>函数执行过程中</strong>有效的变量，函数退出后变量失效。</li><li>全局变量：保存在全局命名空间，用于获取区块链相关信息的特殊变量。<br>Solidity是一种静态类型语言，这意味着需要在声明期间指定变量类型。每个变量声明时都有一个基于其类型的默认值，不存在<code>undefined</code>和<code>null</code>的概念。</li></ul><h2 id="0x02-变量作用域"><a href="#0x02-变量作用域" class="headerlink" title="0x02 变量作用域"></a>0x02 变量作用域</h2><p>状态变量可以有三种作用域类型：</p><ul><li><strong>Public</strong>：公共状态变量可以在内部访问，也可以通过消息访问。对于公共状态变量，将自动生成一个<code>getter</code>函数。</li><li><strong>Internal</strong>：内部状态变量只能从当前合约或其派生合约内访问。</li><li><strong>Private</strong>：私有状态变量只能从当前合约内部访问，派生合约内不能访问。</li></ul><h2 id="0x03-数据位置-data-location"><a href="#0x03-数据位置-data-location" class="headerlink" title="0x03 数据位置(data location)"></a>0x03 数据位置(data location)</h2><p>Solidity提供四种类型的数据位置：</p><ul><li>Storage</li><li>Memory</li><li>Calldata</li><li>Stack</li></ul><h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><p>该存储位置存储永久数据，这意味着该数据可以被合约中的所有函数访问。可类比为计算机的<strong>硬盘数据</strong>，所有数据都永久存储。与其他数据位置相比，存储区数据位置的成本较高。</p><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>Memory是临时数据，比存储位置便宜，只能在函数中访问。可类比成每个单独函数的内存RAM。</p><h3 id="Calldata"><a href="#Calldata" class="headerlink" title="Calldata"></a>Calldata</h3><p>Calldata是不可修改的非持久性数据位置，所有传递给函数的值都存储在这里。此外，Calldata是外部函数参数的默认位置。</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>堆栈是由EVM维护的非持久性数据。EVM使用堆栈数据位置在执行期间加载变量，该位置最多有1024个级别限制。</p><h2 id="0x04-变量数据位置规则"><a href="#0x04-变量数据位置规则" class="headerlink" title="0x04 变量数据位置规则"></a>0x04 变量数据位置规则</h2><h3 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h3><p>状态变量总是存储在Storage中，不能显式地标记状态变量的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragam solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract DataLocation &#123;</span><br><span class="line">    </span><br><span class="line">    // storage</span><br><span class="line">    uint stateVariable;</span><br><span class="line">    uint[] stateArray;</span><br><span class="line">    </span><br><span class="line">    uint storage stateVariable; // Error</span><br><span class="line">    uint[] memory stateArray; // Error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="函数参数与返回值"><a href="#函数参数与返回值" class="headerlink" title="函数参数与返回值"></a>函数参数与返回值</h3><p>函数参数包括返回参数都存储在Memory中。</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>值类型的局部变量存储在Memory中。但是对于引用类型，需要显式地指定数据位置。不能显式地覆盖具有值类型的局部变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Locations &#123;</span><br><span class="line">    /* 此处是状态变量 */</span><br><span class="line">    </span><br><span class="line">    // 存储在Storage中</span><br><span class="line">    bool flag;</span><br><span class="line">    uint number;</span><br><span class="line">    address account;</span><br><span class="line">    </span><br><span class="line">    function doSomething() public &#123; </span><br><span class="line">        /* 此处是局部变量 */</span><br><span class="line">        // 由于是值类型，故被存储在Memory中</span><br><span class="line">        bool flag2;</span><br><span class="line">        uint number2;</span><br><span class="line">        address account2;</span><br><span class="line">        </span><br><span class="line">        // 引用类型需要显式指定数据位置</span><br><span class="line">        uint[] memory localArray;</span><br><span class="line">        </span><br><span class="line">        // 不能显式覆盖具有值类型的局部变量</span><br><span class="line">        bool memory flag2; // Error</span><br><span class="line">        uint Storage number2; // Error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="外部函数的参数"><a href="#外部函数的参数" class="headerlink" title="外部函数的参数"></a>外部函数的参数</h3><p>外部函数的参数（不包括返回参数）存储在Calldata中。</p><h2 id="0x05-赋值的数据位置规则"><a href="#0x05-赋值的数据位置规则" class="headerlink" title="0x05 赋值的数据位置规则"></a>0x05 赋值的数据位置规则</h2><ul><li>将一个状态存储变量赋值给另一个状态存储变量，将创建一个新的副本。</li><li>从内存变量复制到存储变量，总是会创建一个新的副本。</li><li>从存储变量复制到内存变量，将创建一个副本。</li><li>对于<strong>引用类型</strong>的局部变量，从一个内存变量复制到另一个内存变量不会创建副本。而对于<strong>值类型</strong>的局部变量仍然创建一个新副本。</li></ul><h2 id="0x06-经典结构"><a href="#0x06-经典结构" class="headerlink" title="0x06 经典结构"></a>0x06 经典结构</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>可以使用<code>string()</code>构造函数将bytes转换为字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bytes memory bstr = new bytes(10);</span><br><span class="line">string message = string(bstr);</span><br></pre></td></tr></table></figure></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>对于Storage数组，元素类型可以是任意的，而对于Memory数组，元素类型不能是映射类型，若它是一个公共函数的参数，那么元素类型必须是ABI类型。相比于<code>byte[]</code>，<code>bytes</code>应优先使用。<br>可以使用<code>new</code>关键字在内存中创建动态数组。与存储数组相反，不能通过设置<code>.length</code>成员来调整内存动态数组的长度。</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>使用<code>struct</code>关键字定义结构体，包含多个成员。使用成员访问操作符<code>.</code>访问结构的任何成员。</p><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>与数组和结构体一样，映射也属于引用类型。声明语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping(_KeyType =&gt; _ValueType)</span><br></pre></td></tr></table></figure></p><p>其中，<code>_KeyType</code>可以是任何内置类型，但不允许使用引用类型或复杂对象，<code>_ValueType</code>是任何类型。<br>注意，映射的数据位置只能是Storage，通常用于状态变量。映射可标记为<code>public</code>，Solidity将自动为它创建getter。</p><h2 id="特殊变量-全局变量"><a href="#特殊变量-全局变量" class="headerlink" title="特殊变量/全局变量"></a>特殊变量/全局变量</h2><p><img src="/2021/09/27/Solidity基础/solidity_1.PNG" alt="solidity_1"></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是一组可重用代码的包装，接受输入，返回输出。<br>Solidity中，定义函数的语法如下，函数由关键字<code>function</code>声明，后面跟函数名、参数、可见性和返回值的定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function function-name(parameter-list) scope returns()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Solidity中，函数可以返回多个值。</p><h3 id="函数修饰符"><a href="#函数修饰符" class="headerlink" title="函数修饰符"></a>函数修饰符</h3><p>函数修饰符用于修改函数的行为，可以创建带参数修饰符和不带参数修饰符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">contract Owner &#123;</span><br><span class="line"></span><br><span class="line">   // 定义修饰符 onlyOwner 不带参数</span><br><span class="line">   modifier onlyOwner &#123;</span><br><span class="line">      require(msg.sender == owner);</span><br><span class="line">      _;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 定义修饰符 costs 带参数</span><br><span class="line">   modifier costs(uint price) &#123;</span><br><span class="line">      if (msg.value &gt;= price) &#123;</span><br><span class="line">         _;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="View函数"><a href="#View函数" class="headerlink" title="View函数"></a>View函数</h3><p>视图函数不会修改状态。可以通过在函数声明中添加<code>view</code>关键字来声明视图函数，getter方法是默认的视图函数。</p><h3 id="Pure函数"><a href="#Pure函数" class="headerlink" title="Pure函数"></a>Pure函数</h3><p>纯函数不<strong>读取</strong>或<strong>修改</strong>状态。若发生错误，纯函数可以使用<code>revert()</code>和<code>require()</code>函数来还原潜在的状态更改。可以通过在函数声明中添加<code>pure</code>关键在来声明纯函数。</p><h3 id="Fallback函数"><a href="#Fallback函数" class="headerlink" title="Fallback函数"></a>Fallback函数</h3><p>回退函数是合约中的特殊函数，具有以下特点：</p><ul><li>当合约中不存在的函数被调用时，将调用fallback函数。</li><li>被标记为外部函数。</li><li>它没有名字，没有参数，不能返回任何东西。</li><li>每个合约定义一个fallback函数。</li><li>如果没有被标记为payable，则当合约收到无数据的以太币转账时，将抛出异常。<br>语法如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 没有名字，没有参数，不返回，标记为external，可以标记为payable</span><br><span class="line">function() external &#123; </span><br><span class="line">    // statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>同一作用域内，相同函数名可定义多个函数。这些函数的参数（参数类型或参数数量）必须不同，仅返回值不同不被允许。</p><h3 id="数学函数与加密函数"><a href="#数学函数与加密函数" class="headerlink" title="数学函数与加密函数"></a>数学函数与加密函数</h3><p><img src="/2021/09/27/Solidity基础/solidity_2.PNG" alt="solidity_2"></p><p><img src="/2021/09/27/Solidity基础/solidity_3.PNG" alt="solidity_3"></p><h2 id="0x07-常用模式"><a href="#0x07-常用模式" class="headerlink" title="0x07 常用模式"></a>0x07 常用模式</h2><h3 id="Withdrawal-Mode"><a href="#Withdrawal-Mode" class="headerlink" title="Withdrawal Mode"></a>Withdrawal Mode</h3><p>当在智能合约中，直接向一个地址转账时，如该地址是一个合约地址，合约中可以编写代码，拒绝接受付款，导致交易失败。为避免这种情况，通常会使用提款模式。提款模式是让收款方主动来提取款项，而不是直接转账给收款方。</p><h3 id="Restricted-Visit"><a href="#Restricted-Visit" class="headerlink" title="Restricted Visit"></a>Restricted Visit</h3><p>使用限制访问修饰符可以限制合约状态修改者或调用合约函数，常用限制访问操作如下：</p><ul><li><strong>onlyBy</strong>：根据地址限制函数的调用者；</li><li><strong>onlyAfter</strong>：限制该函数只能在特定的时间段之后调用；</li><li><strong>costs</strong>：调用方法只能在提供特定值的情况下完成。<h2 id="0x08-智能合约"><a href="#0x08-智能合约" class="headerlink" title="0x08 智能合约"></a>0x08 智能合约</h2>Solidity中，合约类似于类，包含以下部分：</li><li>构造函数：使用<code>constructor</code>关键字声明的特殊函数，每个合约执行一次，在创建合约时调用。</li><li>状态变量：用于存储合约状态的变量。</li><li>函数：智能合约中的函数，可以修改状态变量来改变合约的状态。</li></ul><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>合约中的函数和变量具有可见性，包括以下四种关键词：</p><ul><li><code>external</code>：外部函数由其他合约调用，要在合约内部调用外部函数可以使用<code>this.function_name()</code>的方式。<strong>状态变量不能标记为外部变量</strong>。</li><li><code>public</code>：公共函数/变量可以在外部和内部直接使用。对于公共状态变量，Solidity为其自动创建一个getter函数。</li><li><code>internal</code>：内部函数/变量只能在内部或派生合约中使用。</li><li><code>private</code>：私有函数/变量只能在内部使用，派生合约无法使用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">   //private state variable</span><br><span class="line">   uint private data;</span><br><span class="line"></span><br><span class="line">   //public state variable</span><br><span class="line">   uint public info;</span><br><span class="line"></span><br><span class="line">   //constructor</span><br><span class="line">   constructor() public &#123;</span><br><span class="line">      info = 10;</span><br><span class="line">   &#125;</span><br><span class="line">   //private function</span><br><span class="line">   function increment(uint a) private pure returns(uint) &#123; return a + 1; &#125;</span><br><span class="line"></span><br><span class="line">   //public function</span><br><span class="line">   function updateData(uint a) public &#123; data = a; &#125;</span><br><span class="line">   function getData() public view returns(uint) &#123; return data; &#125;</span><br><span class="line">   function compute(uint a, uint b) internal pure returns (uint) &#123; return a + b; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//External Contract</span><br><span class="line">contract D &#123;</span><br><span class="line">   function readData() public returns(uint) &#123;</span><br><span class="line">      C c = new C();</span><br><span class="line">      c.updateData(7);         </span><br><span class="line">      return c.getData();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Derived Contract</span><br><span class="line">contract E is C &#123;</span><br><span class="line">   uint private result;</span><br><span class="line">   C private c;</span><br><span class="line"></span><br><span class="line">   constructor() public &#123;</span><br><span class="line">      c = new C();</span><br><span class="line">   &#125;  </span><br><span class="line">   function getComputedResult() public &#123;      </span><br><span class="line">      result = compute(3, 5); </span><br><span class="line">   &#125;</span><br><span class="line">   function getResult() public view returns(uint) &#123; return result; &#125;</span><br><span class="line">   function getData() public view returns(uint) &#123; return c.info(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>Solidity中的合约继承可类比面向对象语言中的类继承，支持单继承和多继承。继承的主要特点为：</p><ul><li>派生合约可以访问父合约的所有非私有成员，包括内部方法和状态变量。但是不允许使用<code>this</code>。</li><li>如果函数签名保持不变，则允许函数重写。如果输出参数不同，编译将失败。</li><li>可以使用<code>super</code>关键字或父合同名称调用父合同的函数。</li><li>在多重继承的情况下，使用<code>super</code>的父合约函数调用，优先选择被最多继承的合约。</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数是使用<code>construct</code>关键字声明的特殊函数，用于初始化合约的状态变量，构造函数是可选的，可以省略。<br>构造函数具有以下重要特性：</p><ul><li>一个合约只能有一个构造函数。</li><li>构造函数在创建合约时执行一次，用于初始化合约状态。</li><li>在执行构造函数之后，合约最终代码被部署到区块链。合约最终代码包括公共函数和可通过公共函数访问的代码。构造函数代码或仅由构造函数使用的任何内部方法不包括在最终代码中。</li><li>构造函数可以是公共的，也可以是内部的。</li><li>内部构造函数将合约标记为抽象合约。</li><li>如果没有定义构造函数，则使用<strong>默认构造函数</strong>。</li><li>如果基合约具有带参数的构造函数，则每个派生/继承的合约也都必须包含参数。</li><li>不允许直接或间接地初始化基合约构造函数。</li><li>如果派生合约没有将参数传递给基合约构造函数，则派生合约将成为抽象合约。</li></ul><h3 id="抽象合约"><a href="#抽象合约" class="headerlink" title="抽象合约"></a>抽象合约</h3><p>类似Java中的抽象类，抽象合约至少包含一个没有实现的函数。通常抽象合约作为父合约，被用来继承，在继承合约中实现抽象函数。抽象合约也可以包含有实现的函数。<br>若派生合约没有抽象函数，则该派生合约也将被标记为抽象合约。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口类似于抽象合约，使用<code>interface</code>关键字创建，只能包含抽象函数，不能包含函数实现。接口关键特性如下：</p><ul><li>接口的函数只能是外部类型；</li><li>接口不能有构造函数；</li><li>接口不能有状态变量。</li><li>接口可以包含<code>enum</code>，<code>struct</code>定义，可以使用<code>interface_name</code>来访问它们。</li></ul><h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><p>库的主要作用是代码重用，库中包含了可以被合约调用的函数。主要特征如下：</p><ul><li>如果库函数不修改状态，则可以直接调用它们。这意味着纯函数或视图函数只能从库外部调用。</li><li>库不能被销毁，因为它被认为是无状态的。</li><li>库不能有状态变量，不能继承任何其他元素，不能被继承。</li></ul><h3 id="Using-For"><a href="#Using-For" class="headerlink" title="Using For"></a>Using For</h3><p><code>using A for B</code>指令可用于将库A的函数附加到给定类型B。这些函数将把调用者类型作为第一个参数（使用<code>self</code>标识）。</p><h3 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h3><p>使用内联汇编，可以在Solidity源程序中嵌入汇编代码，对EVM具有更细粒度的控制，在编写库函数时很有用。<br>汇编代码嵌入使用以下语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assembly &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>举例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">library Sum &#123;   </span><br><span class="line">   function sumUsingInlineAssembly(uint[] memory _data) public pure returns (uint o_sum) &#123;</span><br><span class="line">      for (uint i = 0; i &lt; _data.length; ++i) &#123;</span><br><span class="line">         assembly &#123;</span><br><span class="line">            o_sum := add(o_sum, mload(add(add(_data, 0x20), mul(i, 0x20))))</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Test &#123;</span><br><span class="line">   uint[] data;</span><br><span class="line"></span><br><span class="line">   constructor() public &#123;</span><br><span class="line">      data.push(1);</span><br><span class="line">      data.push(2);</span><br><span class="line">      data.push(3);</span><br><span class="line">      data.push(4);</span><br><span class="line">      data.push(5);</span><br><span class="line">   &#125;</span><br><span class="line">   function sum() external view returns(uint)&#123;      </span><br><span class="line">      return Sum.sumUsingInlineAssembly(data);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件是智能合约发出的信号，可以被索引，以便以后可以搜索事件记录。<br>Solidity中，可以使用<code>event</code>关键字定义事件，然后可以在函数中使用<code>emit</code>关键字触发事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个事件</span><br><span class="line">event Deposit(address indexed _from, bytes32 indexed _id, uint _value);</span><br><span class="line"></span><br><span class="line">// 触发事件</span><br><span class="line">emit Deposit(msg.sender, _id, msg.value);</span><br></pre></td></tr></table></figure></p><p>按照惯例，事件名称以大写字母开头，以区别于函数。一个事件最多有3个参数可以标记为索引。可以使用索引参数有效地过滤事件。<br>事件构建在Ethereum中，底层的日志接口之上，具有以下局限性：</p><ul><li>日志结构最多有四个主题和一个数据字段；</li><li>日志包括记录在日志中的事件，不能从Ethereum虚拟机中访问，意味着合约无法读取自己的或其他合约的日志及事件。<br>关于事件总结如下：</li><li>Solidity 提供了一种记录交易期间事件的方法。</li><li>智能合约前端(DApp)可以监听这些事件。</li><li>索引(indexed)参数为过滤事件提供了一种高效的方法。</li><li>事件受其构建基础日志机制的限制。</li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>错误处理使用以下一些重要方法：</p><ul><li><code>assert(bool condition)</code> ：如果不满足条件，此方法调用将导致一个无效的操作码，对状态所做的任何更改将被还原。这个方法是用来处理<strong>内部错误</strong>的。</li><li><code>require(bool condition)</code>：如果不满足条件，此方法调用将恢复到原始状态。此方法用于<strong>检查输入或外部组件的错误</strong>。</li><li><code>require(bool condition, string memory message)</code>:如果不满足条件，此方法调用将恢复到原始状态。此方法用于<strong>检查输入或外部组件的错误</strong>。它提供了一个<strong>提供自定义消息的选项</strong>。</li><li><code>revert()</code>：此方法将中止执行并将所做的更改还原为执行前状态。</li><li><code>revert(string memory reason)</code>：此方法将中止执行并将所做的更改还原为执行前状态。它提供了一个<strong>提供自定义消息的选项</strong>。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.qikegu.com/docs/4811" target="_blank" rel="noopener">Solidity教程-奇客谷</a><br><a href="https://docs.soliditylang.org/en/latest/index.html" target="_blank" rel="noopener">Solidity官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-数据类型&quot;&gt;&lt;a href=&quot;#0x00-数据类型&quot; class=&quot;headerlink&quot; title=&quot;0x00 数据类型&quot;&gt;&lt;/a&gt;0x00 数据类型&lt;/h2&gt;&lt;h3 id=&quot;值类型&quot;&gt;&lt;a href=&quot;#值类型&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Blockchain" scheme="https://blank-vax.github.io/categories/Blockchain/"/>
    
    
      <category term="Programming" scheme="https://blank-vax.github.io/tags/Programming/"/>
    
      <category term="Smart Contract" scheme="https://blank-vax.github.io/tags/Smart-Contract/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习笔记（六）</title>
    <link href="https://blank-vax.github.io/2021/08/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>https://blank-vax.github.io/2021/08/13/汇编语言学习笔记（六）/</id>
    <published>2021-08-13T03:33:00.000Z</published>
    <updated>2021-08-13T03:34:00.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-指令系统总结"><a href="#0x00-指令系统总结" class="headerlink" title="0x00 指令系统总结"></a>0x00 指令系统总结</h2><p>8086CPU提供以下几大类指令。</p><h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>这些指令实现寄存器和内存、寄存器之间的<strong>单个数据传送</strong>。典型指令如mov、push、pop、pushf、popf、xchg等。</p><h3 id="算数运算指令"><a href="#算数运算指令" class="headerlink" title="算数运算指令"></a>算数运算指令</h3><p>这些指令实现寄存器和内存中数据的算术运算，它们的执行结果影响标志寄存器的sf、zf、of、cf、pf、af等位。典型指令如add、sub、adc、sbb、inc、dec、cmp、imul、idiv、aaa等。</p><h3 id="逻辑指令"><a href="#逻辑指令" class="headerlink" title="逻辑指令"></a>逻辑指令</h3><p>除not指令外，其他逻辑指令的执行结果均影响标志寄存器的相关标志位。典型指令如and、or、not、xor、test、shl、shr、sal、sar、rol、ror、rcl、rcr等。</p><h3 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h3><p>可以修改IP或同时修改IP和CS的指令统称为转移指令。转移指令可分为以下几类。</p><ul><li>无条件转移指令，如jmp；</li><li>条件转移指令，如jcxz、je、jb、ja、jnb、jna等；</li><li>循环指令，如loop；</li><li>过程，如call、ret、retf；</li><li>中断，如int、iret。</li></ul><h3 id="处理机控制指令"><a href="#处理机控制指令" class="headerlink" title="处理机控制指令"></a>处理机控制指令</h3><p>这些指令对标志寄存器或其他处理机状态进行设置。典型指令如cld、std、cli、sti、nop、clc、cmc、stc、hlt、wait、esc、lock等。</p><h3 id="串处理指令"><a href="#串处理指令" class="headerlink" title="串处理指令"></a>串处理指令</h3><p>这些指令对内存中的批量数据进行处理，典型指令如movsb、movsw、cmps、scas、lods、stos等。此类指令可以和rep、repe、repne等前缀指令配合使用，以实现批量数据处理。</p><h2 id="0x01-直接定址表"><a href="#0x01-直接定址表" class="headerlink" title="0x01 直接定址表"></a>0x01 直接定址表</h2><h3 id="特殊标号"><a href="#特殊标号" class="headerlink" title="特殊标号"></a>特殊标号</h3><p>可以在代码段中使用标号来标记指令、数据和段地起始地址。同时，引入一种新的特殊标号，不但表示内存单元地地址，还表示内存单元的长度（字节单元/字单元/双字单元）。以如下程序为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment </span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">start:mov si,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:mov al,a[si]</span><br><span class="line">mov ah,0</span><br><span class="line">add b,ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>code段中使用的标号a、b后面没有”:”，它们同时描述内存地址和单元长度的标号。标号a描述了地址<code>code:0</code>，且该地址后的内存单元均为字节单元；标号b描述了地址<code>code:8</code>，且该地址后的内存单元均为字单元。</p><p>在其他段中同样可以使用数据标号来描述存储数据的单元地址和长度。注意，<strong>后面加有”:”的地址标号只能在代码段中使用，不能在其他段中使用</strong>。如果想在代码段中直接使用数据标号访问数据，则需要使用伪指令<code>assume</code>将标号所在的段和一个段寄存器联系起来。</p><p>可以将标号当作数据来定义，此时编译器将标号所表示的地址当作数据的值。</p><h3 id="直接定址表"><a href="#直接定址表" class="headerlink" title="直接定址表"></a>直接定址表</h3><p>通过依据数据，直接计算出所要找的元素位置的表，称为直接定址表。使用根据功能号查找地址表的方法，程序的结构清晰，便于扩充。若加入一个新的功能子程序，则只需在地址表中加入它的入口地址即可。</p><h2 id="0x02-键盘输入-amp-磁盘读写"><a href="#0x02-键盘输入-amp-磁盘读写" class="headerlink" title="0x02 键盘输入&amp;磁盘读写"></a>0x02 键盘输入&amp;磁盘读写</h2><h3 id="int9h中断例程处理键盘输入"><a href="#int9h中断例程处理键盘输入" class="headerlink" title="int9h中断例程处理键盘输入"></a>int9h中断例程处理键盘输入</h3><p>一般的键盘输入，在CPU执行完<code>int 9</code>中断例程后，都放入键盘缓冲区中。键盘缓冲区中有16个字单元，可以存储15个按键的扫描码和对应的ASCII码。缓冲区的字单元中，<strong>高位字节存储扫描码</strong>，<strong>低位字节存储ASCII码</strong>。</p><h3 id="int16h中断例程读取键盘缓冲区"><a href="#int16h中断例程读取键盘缓冲区" class="headerlink" title="int16h中断例程读取键盘缓冲区"></a>int16h中断例程读取键盘缓冲区</h3><p>BIOS提供<code>int 16h</code>中断例程，该例程的0号功能为从键盘缓冲区中读取一个键盘输入。</p><p><code>int 16h</code>中断引发后，若缓冲区中不存在任何数据，则保持循环等待状态，一直等到<code>int 9h</code>中断发生，将数据送入缓冲区即停止等待。该过程执行IF=1的相关设置指令。</p><h3 id="字符串输入"><a href="#字符串输入" class="headerlink" title="字符串输入"></a>字符串输入</h3><p>最基本的字符串输入程序具备以下功能：</p><ul><li>输入的同时产生回显</li><li>输入回车符后，字符串输入结束</li><li>能够删除已经输入的字符</li></ul><p>部分功能函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">charstack:jmp short charstart</span><br><span class="line">tabledw charpush,charpop,charshow;定义输入，删除和回显三个功能</span><br><span class="line">topdw 0;栈顶</span><br><span class="line"></span><br><span class="line">charstart:push bx</span><br><span class="line">push dx</span><br><span class="line">push di</span><br><span class="line">push es</span><br><span class="line"></span><br><span class="line">cmp ah,2;提供0，1，2三号功能，若ah大于2则结束程序</span><br><span class="line">ja sret</span><br><span class="line">mov bl,ah</span><br><span class="line">mov bh,0</span><br><span class="line">add bx,bx;address=func_index*2</span><br><span class="line">jmp word ptr table[bx];采用直接定址表调用函数</span><br><span class="line"></span><br><span class="line">charpush:mov bx,top;字符入栈</span><br><span class="line">mov [si][bx],al</span><br><span class="line">inc top</span><br><span class="line">jmp sret</span><br><span class="line"></span><br><span class="line">charpop:cmp top,0;比较字符栈中是否只剩下结尾标识0</span><br><span class="line">je sret</span><br><span class="line">dec top</span><br><span class="line">mov bx,top</span><br><span class="line">mov al,[si][bx]</span><br><span class="line">jmp sret</span><br><span class="line"></span><br><span class="line">charshow:mov bx,0b800h</span><br><span class="line">mov es,bx</span><br><span class="line">mov al,160</span><br><span class="line">mov ah,0</span><br><span class="line">mul dh</span><br><span class="line">mov di,ax</span><br><span class="line">add dl,dl;设置显示位置等参数</span><br><span class="line">mov dh,0</span><br><span class="line">add di,dx</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">charshows:cmp bx,top;若为结尾，显示&apos;&apos;，进入结束阶段</span><br><span class="line">jne noempty</span><br><span class="line">mov byte ptr es:[di],&apos;&apos;</span><br><span class="line">jmp sret</span><br><span class="line">noempty:mov al,[si][bx]</span><br><span class="line">mov es:[di],al</span><br><span class="line">mov byte ptr es:[di+2],&apos;&apos;</span><br><span class="line">inc bx</span><br><span class="line">add di,2</span><br><span class="line">jmp charshows</span><br><span class="line"></span><br><span class="line">sret:pop es</span><br><span class="line">pop di</span><br><span class="line">pop dx</span><br><span class="line">pop bx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>完整接收字符串输入子程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">getstr:push ax</span><br><span class="line"></span><br><span class="line">getstrs:;输入字符并显示在屏幕上</span><br><span class="line">mov ah,0</span><br><span class="line">int 16h</span><br><span class="line">cmp al,20h</span><br><span class="line">jb nochar;ASCII码小于20h，说明不是字符</span><br><span class="line">mov ah,0</span><br><span class="line">call charstack;字符入栈</span><br><span class="line">mov ah,2</span><br><span class="line">call charstack;显示栈中字符</span><br><span class="line">jmp getstrs</span><br><span class="line"></span><br><span class="line">nochar:;输入非字符，分退格和Enter两种情况处理</span><br><span class="line">cmp ah,0eh;退格的扫描码</span><br><span class="line">je backspace</span><br><span class="line">cmp ah,1ch;Enter键扫描码</span><br><span class="line">je enter</span><br><span class="line">jmp getstrs</span><br><span class="line"></span><br><span class="line">backspace:;删除字符并回显</span><br><span class="line">mov ah,1</span><br><span class="line">call charstack;字符出栈</span><br><span class="line">mov ah,2</span><br><span class="line">call charstack;显示栈中字符</span><br><span class="line">jmp getstrs</span><br><span class="line"></span><br><span class="line">enter:;输入完毕，显示完整字符串</span><br><span class="line">mov al,0</span><br><span class="line">mov ah,0</span><br><span class="line">call charstack;0入栈</span><br><span class="line">mov ah,2</span><br><span class="line">call charstack;显示栈中的字符</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><h3 id="int13h中断例程读写磁盘"><a href="#int13h中断例程读写磁盘" class="headerlink" title="int13h中断例程读写磁盘"></a>int13h中断例程读写磁盘</h3><p>3.5英寸软盘分为上下两面，每面有80个磁道，每个磁道分为18个扇区，每个扇区的大小为512字节，总存储空间约为1.44MB。</p><p>磁盘的实际访问由磁盘控制器进行，只能以扇区为单位对磁盘进行读写。读写扇区时需要给出面号、磁道号和扇区号，面号和磁道号从0开始，扇区号从1开始。</p><p>注意，直接向磁盘扇区写入数据有可能覆盖掉重要信息。若向软盘的0面0道1扇区中写入数据，则要使软盘在现有操作系统下可以使用，则必须重新格式化。</p><p>对位于不同磁道、面上的所有扇区进行统一编号，生成逻辑扇区编号。<strong>逻辑扇区号=(面号*80+磁道号)*18+扇区号-1</strong>。</p><h2 id="0x03-Intel系列微处理器的三种工作模式"><a href="#0x03-Intel系列微处理器的三种工作模式" class="headerlink" title="0x03 Intel系列微处理器的三种工作模式"></a>0x03 Intel系列微处理器的三种工作模式</h2><p>微机中常用的Intel系列微处理器的主要发展过程是：8080，8086、8088，80186，80286，80386，80486，Pentium，Pentium II，Pentium III，Pentium 4。</p><p>8086/8088不具备实现一个完善的多任务操作系统的功能，为此Intel研发了80286，该处理器具备对多任务系统的支持。随后，Intel开发了80386微处理器，在以下三个模式下工作：</p><ul><li>实模式：工作方式相当于一个8086。</li><li>保护模式：提供支持多任务环境的工作方式，建立保护机制。</li><li>虚拟8086模式：可从保护模式切换至其中的一种8086工作方式。该方式的提供使用户可以方便地在保护模式下运行一个或多个原8086程序。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-指令系统总结&quot;&gt;&lt;a href=&quot;#0x00-指令系统总结&quot; class=&quot;headerlink&quot; title=&quot;0x00 指令系统总结&quot;&gt;&lt;/a&gt;0x00 指令系统总结&lt;/h2&gt;&lt;p&gt;8086CPU提供以下几大类指令。&lt;/p&gt;
&lt;h3 id=&quot;数据传送
      
    
    </summary>
    
      <category term="Binary" scheme="https://blank-vax.github.io/categories/Binary/"/>
    
    
      <category term="IoT Foundation" scheme="https://blank-vax.github.io/tags/IoT-Foundation/"/>
    
      <category term="Assembly" scheme="https://blank-vax.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习笔记（五）</title>
    <link href="https://blank-vax.github.io/2021/08/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>https://blank-vax.github.io/2021/08/13/汇编语言学习笔记（五）/</id>
    <published>2021-08-12T16:18:00.000Z</published>
    <updated>2021-08-12T16:18:24.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-内中断"><a href="#0x00-内中断" class="headerlink" title="0x00 内中断"></a>0x00 内中断</h2><p>任何一个通用的CPU都可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。这种特殊的信息称为<strong>中断信息</strong>。中断是指CPU不再接着向下执行，而是转去处理这个特殊信息。</p><p>中断信息来自内部和外部，本节主要讨论内部中断。</p><h3 id="内中断的产生"><a href="#内中断的产生" class="headerlink" title="内中断的产生"></a>内中断的产生</h3><p>8086CPU使用称为中断类型码的数据来标识中断信息的来源，中断类型码为一个字节型数据，可以表示256种中断信息的来源。对于8086CPU，当CPU内部发生以下情况时，将产生相应的中断信息，其对应的中断类型码同样列出。</p><ul><li>除法错误，例如执行div指令产生的除法溢出，中断类型码为0；</li><li>单步执行，中断类型码为1；</li><li>执行into指令，中断类型码为4；</li><li>执行int指令，该指令格式为<code>int n</code>，指令中的n为字节型立即数，是提供给CPU的中断类型码。</li></ul><h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>CPU收到中断信息后，需要对中断信息进行处理。人为编写的可用来处理中断信息的程序被称为中断处理程序。一般来说，需要针对不同的中断信息编写不同的处理程序。根据CPU的涉及，中断类型码的作用就是<strong>定位中断处理程序</strong>。</p><h3 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h3><p>CPU使用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。中断向量表就是<strong>中断处理程序入口地址的列表</strong>。中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口，如下图所示。</p><p><img src="/2021/08/13/汇编语言学习笔记（五）/1.PNG" alt="1"></p><p>中断向量表在内存中存放，对于8086PC机，中断向量表指定放在内存地址0处。从内存<code>0000:0000~0000:03FF</code>的1024个单元中存放着中断向量表。</p><p>在中断向量表中，一个表项存放一个中断向量，也就是一个中断处理程序的入口地址。对于8086CPU，这个入口地址包括段地址和偏移地址，所以一个表项占据两个字，<strong>高地址字存放段地址</strong>，<strong>低地址字存放偏移地址</strong>。</p><h3 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h3><p>通过中断类型码找到中断向量，并用其设置CS和IP的过程称为中断过程，该工作由CPU的硬件自动完成。8086CPU收到中断信息后，引发以下中断过程。</p><ul><li>取得中断类型码N；</li><li>pushf</li><li>TF=0，IF=0</li><li>push CS</li><li>push IP</li><li>(IP)=(N*4)，(CS)=(N*4+2)</li></ul><p>最后一步完成后，CPU开始执行中断处理程序。</p><h3 id="中断处理程序-amp-iret"><a href="#中断处理程序-amp-iret" class="headerlink" title="中断处理程序&amp;iret"></a>中断处理程序&amp;iret</h3><p>中断处理程序编写的常规步骤如下：</p><ul><li>保存用到的寄存器</li><li>处理中断</li><li>恢复用到的寄存器</li><li>使用iret指令返回</li></ul><p>中断过程中，寄存器的入栈顺序是标志寄存器、CS和IP，而iret的出栈顺序是IP、CS和标志寄存器，与前者对应。iret指令的功能使用汇编语法描述为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br><span class="line">popf</span><br></pre></td></tr></table></figure><h3 id="编写0号中断处理程序"><a href="#编写0号中断处理程序" class="headerlink" title="编写0号中断处理程序"></a>编写0号中断处理程序</h3><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>重新编写一个0号中断处理程序，它的功能是在屏幕中间显示”overflow!”，然后返回到操作系统。</p><p>经过对除法溢出错误即0号中断处理程序的分析，我们将题目需求细化为以下几部分：</p><ul><li>编写可以在屏幕中间显示”overflow!”的中断处理程序do0；</li><li>将do0送入内存<code>0000:0200</code>处；</li><li>将do0的入口地址<code>0000:0200</code>存储在中断向量表0号表项中。</li></ul><h4 id="程序框架"><a href="#程序框架" class="headerlink" title="程序框架"></a>程序框架</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:do0安装程序</span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">do0:显示字符串&quot;overflow!&quot;</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>使用<code>rep movsb</code>指令实现中断处理程序的安装需要确定如下信息：</p><ul><li>传送的原始位置，段地址<code>code</code>，偏移地址<code>offset do0</code>；</li><li>传送的目的位置，本例中为<code>0:200</code>；</li><li>传送的长度即do0部分代码的长度；</li><li>传送的方向：正向。</li></ul><p>明确后的安装程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0;设置ds:si指向源地址</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200h;设置es:di指向目的地址</span><br><span class="line"></span><br><span class="line">mov cx,offsetdo0end-offset do0;设置cx为传输长度，&quot;-&quot;是编译器识别的运算符号</span><br><span class="line"></span><br><span class="line">cld;设置传输方向为正</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line">设置中断向量表</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">do0:显示字符串&quot;overflow!&quot;</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">do0end:nop</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h4 id="设置中断向量"><a href="#设置中断向量" class="headerlink" title="设置中断向量"></a>设置中断向量</h4><p>0号表项的地址为<code>0:0</code>，其中<code>0:0</code>字单元存放偏移地址，<code>0:2</code>字单元存放段地址。程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[0*4],200h</span><br><span class="line">mov word ptr es:[0*4+2],0</span><br></pre></td></tr></table></figure><h4 id="最终程序及运行结果"><a href="#最终程序及运行结果" class="headerlink" title="最终程序及运行结果"></a>最终程序及运行结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">; 安装</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200h</span><br><span class="line">mov cx,offset do0end-offset do0</span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line">; 设置中断向量表</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[0*4],200h</span><br><span class="line">mov word ptr es:[0*4+2],0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">; 字符串&quot;overflow!&quot;应存放在一段不会被覆盖的空间中</span><br><span class="line">; 当发生溢出时，jmp指令引导程序直接跳转执行do0start代码段</span><br><span class="line">do0:jmp short do0start</span><br><span class="line">db &quot;overflow!&quot;</span><br><span class="line"></span><br><span class="line">do0start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,202h</span><br><span class="line"></span><br><span class="line">mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,12*160+36*2</span><br><span class="line"></span><br><span class="line">mov cx,9</span><br><span class="line">s:mov al,[si]</span><br><span class="line">mov es:[di],al</span><br><span class="line">inc si</span><br><span class="line">add di,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">do0end:nop</span><br><span class="line">; 溢出例测试</span><br><span class="line">divtest:</span><br><span class="line">        mov ax,1000h</span><br><span class="line">        mov bh,1</span><br><span class="line">        div bh</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/2021/08/13/汇编语言学习笔记（五）/2.PNG" alt="2"></p><h3 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a>单步中断</h3><p>CPU完成指令执行后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。单步中断的中断类型码为1，引发的中断过程如下：</p><ul><li>取得中断类型码1；</li><li>标志寄存器入栈，TF、IF设置为0；</li><li>CS、IP入栈；</li><li>(IP)=(1*4)，(CS)=(1*4+2)。</li></ul><p>CPU提供单步中断，为单步跟踪程序的执行过程提供了实现机制。一般情况下，CPU在执行完当前指令后，若检测到中断信息则立即响应中断，引发中断过程。但是在某系情况下<strong>不立即响应</strong>，如执行完向ss寄存器传送数据的指令后，即便发生中断CPU也不会响应，这是因为<code>ss:sp</code>联合指向栈顶，故对它们的设置应连续完成（<strong>粘连操作</strong>）。</p><h2 id="0x01-int指令"><a href="#0x01-int指令" class="headerlink" title="0x01 int指令"></a>0x01 int指令</h2><p>除前文提到的常见中断信息外，还可以通过int指令引发中断过程。</p><p>int指令格式为<code>int n</code>，n为中断类型码，其功能是引发中断过程。int指令的最终功能和call指令类似，都是调用一段中断例程。</p><h3 id="BIOS-amp-DOS中断例程"><a href="#BIOS-amp-DOS中断例程" class="headerlink" title="BIOS&amp;DOS中断例程"></a>BIOS&amp;DOS中断例程</h3><p>BIOS称为基本输入输出系统，存放于系统板的ROM中，主要包含以下几部分内容。</p><ul><li>硬件系统的检测和初始化程序；</li><li>外部中断和内部中断的中断例程；</li><li>用于对硬件设备进行I/O操作的中断例程；</li><li>其他和硬件系统相关的中断例程。</li></ul><p>和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。BIOS和DOS提供的中断例程都使用寄存器<code>ah</code>来传递内部子程序的编号。</p><h3 id="BIOS-amp-DOS中断例程安装"><a href="#BIOS-amp-DOS中断例程安装" class="headerlink" title="BIOS&amp;DOS中断例程安装"></a>BIOS&amp;DOS中断例程安装</h3><ul><li>开机后，CPU加电，初始化(CS)=0FFFFH，(IP)=0。CPU执行<code>FFFF:0</code>处的指令，转去执行BIOS中的硬件系统检测和初始化程序。</li><li>初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。对于BIOS所提供的中断例程，由于其<strong>固化到ROM</strong>中，故只需将入口地址登记在中断向量表中即可。</li><li>硬件系统检测和初始化完成后，调用<code>int 19h</code>进行操作系统的引导。随后将计算机交由操作系统控制。</li><li>DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。</li></ul><h3 id="BIOS中断例程应用"><a href="#BIOS中断例程应用" class="headerlink" title="BIOS中断例程应用"></a>BIOS中断例程应用</h3><p><code>int 10h</code>中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的子程序。以设置光标位置为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ah,2; 置光标</span><br><span class="line">mov bh,0; 第0页</span><br><span class="line">mov dh,5; dh中放行号</span><br><span class="line">mov dl,12; dl中放列号</span><br><span class="line">int 10h</span><br></pre></td></tr></table></figure><p>(ah)=2表示调用第10h号中断例程的2号子程序，功能为<strong>设置光标位置</strong>，可以提供光标所在的行号、列号，和页号作为参数。</p><p>(bh)=0，(dh)=5，(dl)=12，设置光标的第0页，第5行，第12列。</p><h3 id="DOS中断例程应用"><a href="#DOS中断例程应用" class="headerlink" title="DOS中断例程应用"></a>DOS中断例程应用</h3><p><code>int 21h</code>中断例程是DOS提供的中断例程，其中包含了DOS提供给程序员在编程时调用的子程序。以程序返回功能为例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ah,4ch; 程序返回</span><br><span class="line">mov al,0; 返回值</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure><p>(ah)=4ch表示调用第21h号中断例程的4ch号子程序，功能为程序返回，可以提供返回值作为参数。</p><h2 id="0x02-端口"><a href="#0x02-端口" class="headerlink" title="0x02 端口"></a>0x02 端口</h2><p>各种存储器都和CPU的地址线、数据线、控制线相连。CPU在操控它们的时候，把它们看作一个由若干存储单元组成的逻辑存储器即内存地址空间。</p><p>PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还包含以下三类：</p><ul><li>各种接口卡上的接口芯片，它们控制接口卡进行工作；</li><li>主板上的接口芯片，CPU通过它们对部分外设进行访问；</li><li>其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理。</li></ul><p>从CPU的角度，将这些寄存器都当作端口，对它们进行统一编址，从而建立一个统一的端口地址空间。每个端口在地址空间中都对应一个地址。CPU可以直接从以下三个地方读写数据：</p><ul><li>CPU内部的寄存器；</li><li>内存单元；</li><li>端口。</li></ul><h3 id="端口读写"><a href="#端口读写" class="headerlink" title="端口读写"></a>端口读写</h3><p>CPU通过端口地址来定位端口，端口地址和内存地址一样，通过地址总线来传送。在PC系统中，CPU最多可以定位64KB个不同的端口，端口地址范围为0~65535。</p><p>端口的读写指令有in和out两条，分别用于从端口读取数据和往端口写入数据。</p><p>注意，在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。<strong>访问8位端口时用寄存器al，访问16位端口时用寄存器ax</strong>。</p><h3 id="CMOS-RAM芯片"><a href="#CMOS-RAM芯片" class="headerlink" title="CMOS RAM芯片"></a>CMOS RAM芯片</h3><p>该芯片特征如下：</p><ul><li>包含一个实时钟和一个有128个存储单元的RAM存储器。</li><li>芯片靠电池供电，关机后RAM中的信息不丢失。</li><li>128个字节的RAM中，内部实时钟占用0~0dh单元来保存时间信息，其余大部分单元用于保存<strong>系统配置信息</strong>，供系统启动时BIOS程序读取。</li><li>该芯片内部有两个端口，端口地址分别为70h和71h。CPU通过这两个端口来读写CMOS RAM。</li><li>70h为地址端口，存放要访问CMOS RAM单元的<strong>地址</strong>；71h为数据端口，存放从选定的CMOS RAM单元中读取的或要写入其中的<strong>数据</strong>。</li></ul><p>该芯片中存放着当前时间：年、月、日、时、分、秒。这6个信息的长度均为1字节，存放单元为：<code>秒：0，分：2，时：4，日：7，月：8，年：9</code>，这些数据以<strong>BCD码</strong>的方式存放。高4位BCD码表示十位，低4位的BCD码表示个位。</p><h3 id="shl-amp-shr指令"><a href="#shl-amp-shr指令" class="headerlink" title="shl&amp;shr指令"></a>shl&amp;shr指令</h3><p>shl是逻辑左移指令，功能为：</p><ul><li>将一个寄存器或内存单元中的数据向左移位；</li><li>将最后移出的一位写入CF中；</li><li>最低位用0补充。</li></ul><p>shr是逻辑右移指令，功能于shl相反，最后使用0补充最高位。</p><p>若移动位数大于1，必须将移动位数放在寄存器cl中。</p><h2 id="0x03-外中断"><a href="#0x03-外中断" class="headerlink" title="0x03 外中断"></a>0x03 外中断</h2><p>CPU通过端口和外部设备进行联系。当外设的输入发生时，产生外中断；待CPU执行完当前指令后，可以检测到发送过来的外中断信息，引发中断过程，处理外设的输入。</p><p>PC系统中，外中断源包含可屏蔽中断和不可屏蔽中断两类。</p><h3 id="可屏蔽中断"><a href="#可屏蔽中断" class="headerlink" title="可屏蔽中断"></a>可屏蔽中断</h3><p>可屏蔽中断是CPU可以不响应的外中断。当CPU检测到可屏蔽中断信息时，检查IF标志位信息。若IF=1则引发中断过程，否则不响应可屏蔽中断。中断过程中常将IF置0，该方法可以禁止其他可屏蔽中断。</p><p>可以通过<code>sti</code>指令和<code>cli</code>指令设置IF标志位的值。</p><h3 id="不可屏蔽中断"><a href="#不可屏蔽中断" class="headerlink" title="不可屏蔽中断"></a>不可屏蔽中断</h3><p>不可屏蔽中断是CPU必须响应的外中断。CPU检测到不可屏蔽中断信息时，在执行完当前指令后立即响应，引发中断过程。对于8086CPU，不可屏蔽中断的中断类型码为2。中断过程为：</p><ul><li>标志寄存器入栈，IF=0，TF=0；</li><li>CS、IP入栈；</li><li>(IP)=(8)，(CS)=(0AH)</li></ul><h3 id="CPU处理外设输入"><a href="#CPU处理外设输入" class="headerlink" title="CPU处理外设输入"></a>CPU处理外设输入</h3><ul><li>外设的输入送入端口；</li><li>向CPU发出外中断信息；</li><li>CPU检测到可屏蔽中断信息，若IF=1，CPU在执行完成当前指令后响应中断，执行相应的中断例程。</li><li>可在中断例程中实现对外设输入的处理</li><li>按键和松开按键时都会产生扫描码，随后扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为60h。一般来说，按下按键时产生的扫描码称为通码，松开按键时产生的扫描码为断码。<strong>断码=通码+80h</strong>。</li><li>端口和中断机制是CPU进行I/O的基础。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-内中断&quot;&gt;&lt;a href=&quot;#0x00-内中断&quot; class=&quot;headerlink&quot; title=&quot;0x00 内中断&quot;&gt;&lt;/a&gt;0x00 内中断&lt;/h2&gt;&lt;p&gt;任何一个通用的CPU都可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部
      
    
    </summary>
    
      <category term="Binary" scheme="https://blank-vax.github.io/categories/Binary/"/>
    
    
      <category term="IoT Foundation" scheme="https://blank-vax.github.io/tags/IoT-Foundation/"/>
    
      <category term="Assembly" scheme="https://blank-vax.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习笔记（四）</title>
    <link href="https://blank-vax.github.io/2021/08/10/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>https://blank-vax.github.io/2021/08/10/汇编语言学习笔记（四）/</id>
    <published>2021-08-10T14:10:00.000Z</published>
    <updated>2021-08-10T14:14:43.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-转移指令"><a href="#0x00-转移指令" class="headerlink" title="0x00 转移指令"></a>0x00 转移指令</h2><p>可以<strong>修改IP</strong>，或<strong>同时修改CS和IP</strong>的指令统称为转移指令。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。</p><p>8086CPU转移行为包括以下几类：</p><ul><li>只修改IP时，称为<strong>段内转移</strong>，比如<code>jmp ax</code>。</li><li>同时修改CS和IP时，称为<strong>段间转移</strong>，比如<code>jmp 1000:0</code>。</li></ul><p>由于转移指令对IP的修改范围不同，段内转移分为<strong>短转移</strong>和<strong>近转移</strong>。</p><ul><li>短转移IP的修改范围为-128~127。</li><li>近转移IP的修改范围为-32768~32767。</li></ul><p>8086CPU的转移指令分为以下几类：</p><ul><li>无条件转移指令（如<code>jmp</code>）</li><li>条件转移指令</li><li>循环指令（如<code>loop</code>）</li><li>过程</li><li>中断</li></ul><p>操作符offset在汇编语言中是由编译器处理的符号，它的功能是<strong>取得标号的偏移地址</strong>。</p><h2 id="0x01-jmp指令"><a href="#0x01-jmp指令" class="headerlink" title="0x01 jmp指令"></a>0x01 jmp指令</h2><p>jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP。jmp指令给出<strong>转移目的地址</strong>和<strong>转移的距离（段内转移、段内短转移、段内近转移）</strong>。不同的给出目的地址的方法和不同的转移位置，对应不同格式的jmp指令。</p><h3 id="依据位移转移"><a href="#依据位移转移" class="headerlink" title="依据位移转移"></a>依据位移转移</h3><p>CPU在执行jmp指令的时候并不需要<strong>转移的目的地址</strong>，而是向CPU传递<strong>要转移的位移</strong>，这种设计方便程序段在内存中的<strong>浮动装配</strong>。根据位移进行转移的指令受到<strong>转移位移</strong>的限制。如果在源程序中出现转移范围越界的问题，则编译器报错。</p><p><img src="/2021/08/10/汇编语言学习笔记（四）/1.png" alt="1"></p><ul><li><p><code>jmp short 标号(转到标号处执行指令)</code></p><p>该指令中的<code>short</code>符号说明其实现段内短转移，它对IP的修改范围是-128~127。jmp指令中的标号是代码段中的标号，指明了指令要转移的目的地，转移指令结束后，CS:IP应指向标号处的指令。实际上该指令的功能为<code>(IP)=(IP)+8位位移</code>。</p><ul><li>8位位移=标号处地址-jmp指令后的第一个字节的地址；</li><li>short指明此处的位移为8位位移；</li><li>8位位移的范围是-128~127，使用补码表示；</li><li>8位位移由编译程序在编译时算出。</li></ul></li><li><p><code>jmp near ptr 标号</code></p><p>该指令实现段内近转移，功能为<code>(IP)=(IP)+16位位移</code>。</p><ul><li>16位位移=标号处的地址-jmp指令后的第一个字节的地址；</li><li>near ptr指明此处的位移为16位位移，进行的是段内近转移；</li><li>16位位移的范围是-32768~32767，使用补码表示；</li><li>16位位移由编译程序在编译时算出。</li></ul></li></ul><h3 id="转移地址在指令中"><a href="#转移地址在指令中" class="headerlink" title="转移地址在指令中"></a>转移地址在指令中</h3><p><code>jmp far ptr 标号</code></p><p>该指令实现段间转移，又称为远转移。功能如下：(CS)=标号所在段的地址，(IP)=标号在段中的偏移地址。far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。</p><h3 id="转移地址在寄存器中"><a href="#转移地址在寄存器中" class="headerlink" title="转移地址在寄存器中"></a>转移地址在寄存器中</h3><p><code>jmp 16位reg</code></p><p>该指令功能为：<code>(IP)=(16位reg)</code></p><h3 id="转移地址在内存中"><a href="#转移地址在内存中" class="headerlink" title="转移地址在内存中"></a>转移地址在内存中</h3><p>转移地址在内存中的jmp指令有两种格式：</p><ul><li><p><code>jmp word ptr 内存单元地址(段内地址)</code></p><p>功能：从内存单元地址处开始存放的字是转移的目的偏移地址。</p></li><li><p><code>jmp dword ptr 内存单元地址(段间转移)</code></p><p>功能：从内存单元地址处开始存放的两个字，<strong>高地址处</strong>的字是转移的<strong>目的段地址</strong>，<strong>低地址处</strong>是转移的<strong>目的偏移地址</strong>。即(CS)=(内存单元地址+2)，(IP)=(内存单元地址)。</p></li></ul><h2 id="0x02-jcxz-amp-loop-amp-ret"><a href="#0x02-jcxz-amp-loop-amp-ret" class="headerlink" title="0x02 jcxz&amp;loop&amp;ret"></a>0x02 jcxz&amp;loop&amp;ret</h2><h3 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h3><p>jcxz指令为有条件<strong>短转移</strong>指令，在对应的机器码中包含转移的位移，而不是目的地址，对IP的修改范围均为-128~127。</p><ul><li><p>指令格式</p><p><code>jcxz 标号</code>(若(cx)=0，则转移到标号处执行)</p></li><li><p>操作</p><ul><li><p>当(cx)=0时，(IP)=(IP)+8位位移；</p><p>8位位移=标号处地址-jcxz指令后的第一个字节的地址，使用补码表示，由编译程序在编译时加以计算。</p></li><li><p>当$(cx) /neq 0$时，程序向下执行。</p></li></ul></li></ul><p>综上，jcxz的功能相当于<code>if((cx)==0) jmp short 标号</code>。</p><h3 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h3><p>loop指令为循环<strong>短转移</strong>指令，在对应的机器码中包含转移的位移而非目的地址，对IP的修改范围为-128~127。</p><ul><li><p>指令格式</p><p><code>loop 标号</code>((cx)=(cx)-1，若$(cx) \neq 0$，转移到标号处执行)</p></li><li><p>操作</p><ul><li>(cx)=(cx)-1；</li><li>若$(cx) \neq 0$，<code>(IP)=(IP)+8位位移</code>；</li><li>若(cx)=0，则程序向下执行。</li></ul></li></ul><p>综上，loop的功能相当于<code>cx-- if((cx)≠0 jmp short 标号)</code></p><h3 id="ret-amp-retf"><a href="#ret-amp-retf" class="headerlink" title="ret&amp;retf"></a>ret&amp;retf</h3><p>ret指令修改IP，retf指令修改CS和IP。</p><ul><li>ret指令用栈中的数据修改IP的内容，从而实现近转移。汇编语法表示为<code>pop IP</code>。</li><li>retf指令用栈中的数据修改CS和IP的内容，从而实现远转移。汇编语法表示为<code>pop IP pop CS</code>。</li></ul><h2 id="0x03-CALL"><a href="#0x03-CALL" class="headerlink" title="0x03 CALL"></a>0x03 CALL</h2><p>CPU执行call指令时，进行两步操作：</p><ul><li>将当前的IP或CS和IP压入栈中；</li><li>转移。</li></ul><p>call指令不能实现短转移，除此之外其实现转移的方法和jmp指令的原理相同。</p><h3 id="依据位移转移-1"><a href="#依据位移转移-1" class="headerlink" title="依据位移转移"></a>依据位移转移</h3><p><code>call 标号</code>(将当前的IP压栈后，转到标号处执行指令)</p><p>该指令操作如下：</p><ul><li><p>(sp)=(sp)-2</p><p>((ss)*16+(sp))=(IP)</p></li><li><p>(IP)=(IP)+16位位移</p></li></ul><p>CPU执行该指令时，相当于进行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure><h3 id="转移地址在指令中-1"><a href="#转移地址在指令中-1" class="headerlink" title="转移地址在指令中"></a>转移地址在指令中</h3><p><code>call far ptr 标号</code>实现段间转移。</p><p>该指令操作如下：</p><ul><li><p>(sp)=(sp)-2</p><p>((ss)*16+(sp))=(CS)</p><p>(sp)=(sp)-2</p><p>((ss)*16+(sp))=(IP)</p></li><li><p>(CS)=标号所在段的段地址</p><p>(IP)=标号在段中的偏移地址</p></li></ul><p>CPU执行该指令时，相当于进行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure><h3 id="转移地址在寄存器中-1"><a href="#转移地址在寄存器中-1" class="headerlink" title="转移地址在寄存器中"></a>转移地址在寄存器中</h3><p><code>call 16位reg</code></p><p>该指令操作如下：</p><ul><li><p>(sp)=(sp)-2</p></li><li><p>((ss)*16+(sp))=(IP)</p><p>(IP)=(16位reg)</p></li></ul><p>CPU执行该指令时，相当于进行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp 16位reg</span><br></pre></td></tr></table></figure><h3 id="转移地址在内存中-1"><a href="#转移地址在内存中-1" class="headerlink" title="转移地址在内存中"></a>转移地址在内存中</h3><p>转移地址在内存中的call指令同样存在两种格式。</p><ul><li><p><code>call word ptr 内存单元地址</code></p><p>CPU执行该指令时，相当于进行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure></li><li><p><code>call dword ptr 内存单元地址</code></p><p>CPU执行该指令时，相当于进行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x04-模块化程序设计"><a href="#0x04-模块化程序设计" class="headerlink" title="0x04 模块化程序设计"></a>0x04 模块化程序设计</h2><h3 id="call-amp-ret"><a href="#call-amp-ret" class="headerlink" title="call&amp;ret"></a>call&amp;ret</h3><p>call指令可以与ret指令组合使用以实现子程序机制。call指令跳转之前，其后面的指令的地址将存储在栈中，所以可在子程序的尾部使用ret指令，用栈中的数据设置IP的值，从而转到call指令后面的代码处继续执行。</p><p>具有子程序的源程序框架如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">main::</span><br><span class="line">:</span><br><span class="line">call sub1;调用子程序sub1</span><br><span class="line">:</span><br><span class="line">:</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">sub1::;子程序sub1开始</span><br><span class="line">:</span><br><span class="line">call sub2;调用子程序sub2</span><br><span class="line">:</span><br><span class="line">:</span><br><span class="line">ret;子程序sub1返回</span><br><span class="line">sub2::;子程序sub2开始</span><br><span class="line">:</span><br><span class="line">ret;子程序sub2返回</span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure><h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><ul><li><p>参数&amp;结果传递问题</p><p>调用者将参数送入参数寄存器，从结果寄存器中取到返回值；子程序从参数寄存器中取到参数，将返回值送入结果寄存器。</p></li><li><p>批量数据传递</p><p>可以将批量数据放到内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给需要的子程序。对于具有批量返回结果的程序也可以使用以上方法。当然也可以通过数据栈的方法批量传递数据。</p></li><li><p>寄存器冲突问题</p><p>在子程序的开始将子程序中所有用到的寄存器中的内容都保存至栈中，当子程序返回前再予以恢复，需要注意寄存器<strong>入栈和出栈的顺序</strong>。</p><p>从而编写子程序的标准框架如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">子程序开始：子程序中使用的寄存器入栈</span><br><span class="line">子程序内容</span><br><span class="line">子程序使用的寄存器出栈</span><br><span class="line">返回(ret,retf)</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x05-标志寄存器"><a href="#0x05-标志寄存器" class="headerlink" title="0x05 标志寄存器"></a>0x05 标志寄存器</h2><p>8086CPU中，标志寄存器具有以下三种作用：存储相关指令的某些执行结果、为CPU执行相关指令提供行为依据、控制CPU的相关工作方式。8086CPU的标志寄存器有16位，简称为flag，其中存储的信息通常被称为程序状态字(PSW)。</p><p>flag寄存器按位起作用，即每一位都记录特定的信息，结构如图：</p><p><img src="/2021/08/10/汇编语言学习笔记（四）/2.png" alt="2"></p><p>如图所示，flag的第0、2、4、6、7、8、9、10、11位都具有特殊的含义。</p><h3 id="重要标志位"><a href="#重要标志位" class="headerlink" title="重要标志位"></a>重要标志位</h3><h4 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h4><p>flag的第6位是ZF即零标志位。若相关指令执行后，结果为0，则zf=1；若结果不为0，则zf=0。</p><p>注意，在8086CPU指令集中，进行逻辑运算或算术运算的<strong>运算指令</strong>的执行影响标志寄存器，而传送指令的执行对标志寄存器没有影响。</p><h4 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h4><p>flag的第2位是PF即奇偶标志位。若相关指令执行后，其结果的所有bit位中1的个数为偶数，则pf=1；若1的个数为奇数，则pf=0。</p><h4 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h4><p>flag的第7位是SF即符号标志位。若相关指令执行后，其结果为负数，则sf=1；若非负，则sf=0。</p><p>显然，SF标志就是CPU对有符号数运算结果的一种记录，即它可以记录数据的正负，对于无符号数运算则没有任何意义。</p><h4 id="CF标志"><a href="#CF标志" class="headerlink" title="CF标志"></a>CF标志</h4><p>flag的第0位是CF即进位标志位。一般情况下，在进行<strong>无符号数运算</strong>时，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的错位值。</p><h4 id="OF标志"><a href="#OF标志" class="headerlink" title="OF标志"></a>OF标志</h4><p>进行有符号数运算的时候，若结果超过了机器所能表示的范围称为溢出。</p><p>flag的第11位是OF即溢出标志位。一般情况下，若<strong>有符号数运算</strong>的结果发生溢出，则OF=1；若没有发生溢出，则OF=0。</p><h4 id="TF标志"><a href="#TF标志" class="headerlink" title="TF标志"></a>TF标志</h4><p>flag的第8位是TF，该标志位与单步中断有关。CPU在执行完成一条指令之后，若检测到TF=1，则产生单步中断，引发中断过程；若检测到TF=0，则继续执行，不产生任何中断。</p><h4 id="IF标志"><a href="#IF标志" class="headerlink" title="IF标志"></a>IF标志</h4><p>flag的第9位是IF，该标志位决定CPU是否响应可屏蔽中断。若CPU检测到IF=1，则其在执行完成当前指令后响应中断，引发中断过程；若IF=0，则不响应可屏蔽中断。中断过程中常将IF置为0，是为了在进入中断处理程序后，禁止其他的可屏蔽中断。当然，如果在中断处理程序中需要处理可屏蔽中断，可利用指令将IF置1。8086CPU提供设置IF的指令如下：</p><ul><li>sti，设置IF=1；</li><li>cli，设置IF=0。</li></ul><h4 id="DF标志"><a href="#DF标志" class="headerlink" title="DF标志"></a>DF标志</h4><p>flag的第10位是DF即方向标志位。在串处理指令中，控制每次操作后si、di的增减。</p><ul><li>df=0，每次操作后si、di递增</li><li>df=1，每次操作后si、di递减</li></ul><p>8086CPU提供下面两条指令对df位进行设置：</p><ul><li>cld指令：将标志寄存器的df位置0</li><li>std指令：将标志寄存器的df位置1</li></ul><h3 id="重要指令"><a href="#重要指令" class="headerlink" title="重要指令"></a>重要指令</h3><h4 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h4><p>adc是带进位加法指令，它利用了CF位上记录的进位值。</p><ul><li><p>指令格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc 操作对象1, 操作对象2</span><br></pre></td></tr></table></figure></li><li><p>功能</p><p>操作对象1=操作对象1+操作对象2+CF</p></li><li><p>由于adc指令执行后，也可能产生进位值，所以也会对CF位进行设置。因此该指令可对任意大的数据进行加法运算。</p></li></ul><h4 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h4><p>sbb是带错位减法指令，它利用了CF位上记录的错位值。</p><ul><li><p>指令格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbb 操作对象1, 操作对象2</span><br></pre></td></tr></table></figure></li><li><p>功能</p><p>操作对象1=操作对象1-操作对象2-CF</p></li><li><p>sbb指令执行后，将对CF进行设置，故利用sbb指令可以对任意大的数据进行减法运算。</p></li></ul><h4 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h4><p>cmp是比较指令，其执行后将对标志寄存器产生影响，但不保存结果。其他相关指令通过识别这些被影响的标志寄存器来得知比较结果。该指令通过做减法运算，影响标志寄存器，标志寄存器的相关位记录了比较结果。CPU在执行cmp指令的时候，也包含<strong>无符号数比较</strong>和<strong>有符号数比较</strong>两种情况。</p><ul><li><p>指令格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp 操作对象1, 操作对象2</span><br></pre></td></tr></table></figure></li><li><p>功能</p><p>计算操作对象1-操作对象2但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。</p></li><li><p>溢出</p><p>由于有符号数在进行减法操作时会产生溢出现象，而sf标志位只记录实际结果的正负，从而cmp指令的比较结果与sf标志位的结果并不完全等同，需要结合of标志位的情况进行判断。</p><ul><li><p>of=0</p><p>of=0说明没有溢出，逻辑上真正结果的正负=实际结果的正负。</p></li><li><p>of=1</p><p>of=1说明存在溢出，逻辑上真正结果的正负$\neq$实际结果的正负。同时，若因溢出导致实际结果为负，则逻辑上结果必然为正；若因溢出导致实际结果为正，则逻辑上结果必然为负。</p></li></ul></li></ul><h4 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a>检测比较结果的条件转移指令</h4><p>根据cmp指令的比较结果进行转移的指令也分为两种，即根据无符号数的比较结果进行转移的条件转移指令（检测zf和cf的值）和根据有符号数的比较结果进行转移的条件转移指令（检测sf、of和zf的值）。</p><p>常用根据无符号数的比较结果进行转移的条件转移指令如下：</p><p><img src="/2021/08/10/汇编语言学习笔记（四）/3.png" alt="3"></p><h4 id="串传送指令"><a href="#串传送指令" class="headerlink" title="串传送指令"></a>串传送指令</h4><ul><li><p>格式</p><p>movsb&amp;movsw</p></li><li><p>功能</p><p>该指令的功能是将<code>ds:si</code>指向的内存单元中的字节（字）送入<code>es:di</code>中，然后根据标志寄存器df位的值，将si和di递增(2)或递减(2)。采用汇编语法描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov es:[di],byte/word ptr ds:[si]</span><br><span class="line">if df=0:</span><br><span class="line">inc si/add si,2</span><br><span class="line">inc di/add di,2 </span><br><span class="line">if df=1:</span><br><span class="line">dec si/sub si,2</span><br><span class="line">dec di/sub di,2</span><br></pre></td></tr></table></figure></li><li><p>movsb和movsw都可以和rep配合使用，从而循环实现(cx)个字节（字）的传送。</p></li></ul><h4 id="pushf-amp-popf"><a href="#pushf-amp-popf" class="headerlink" title="pushf&amp;popf"></a>pushf&amp;popf</h4><p>pushf的功能是将标志寄存器的值压栈，而popf是从栈中弹出数据，送入标志寄存器中。pushf和popf为直接访问标志寄存器提供了一种方法。</p><h3 id="Debug中的标志寄存器"><a href="#Debug中的标志寄存器" class="headerlink" title="Debug中的标志寄存器"></a>Debug中的标志寄存器</h3><p><img src="/2021/08/10/汇编语言学习笔记（四）/4.PNG" alt="4"></p><p>在Debug中，标志寄存器按照有意义的各个标志位单独表示。如上图所示，其中NV、UP、PL、NZ、PO和NC分别对应OF、DF、SF、ZF、PF和CF标志位。下面列出Debug对已知标志位的表示。</p><p><img src="/2021/08/10/汇编语言学习笔记（四）/5.png" alt="5"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-转移指令&quot;&gt;&lt;a href=&quot;#0x00-转移指令&quot; class=&quot;headerlink&quot; title=&quot;0x00 转移指令&quot;&gt;&lt;/a&gt;0x00 转移指令&lt;/h2&gt;&lt;p&gt;可以&lt;strong&gt;修改IP&lt;/strong&gt;，或&lt;strong&gt;同时修改CS和IP
      
    
    </summary>
    
      <category term="Binary" scheme="https://blank-vax.github.io/categories/Binary/"/>
    
    
      <category term="IoT Foundation" scheme="https://blank-vax.github.io/tags/IoT-Foundation/"/>
    
      <category term="Assembly" scheme="https://blank-vax.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习笔记（三）</title>
    <link href="https://blank-vax.github.io/2021/08/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://blank-vax.github.io/2021/08/06/汇编语言学习笔记（三）/</id>
    <published>2021-08-06T03:34:00.000Z</published>
    <updated>2021-08-09T15:46:16.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-内存定址方法"><a href="#0x00-内存定址方法" class="headerlink" title="0x00 内存定址方法"></a>0x00 内存定址方法</h2><h3 id="and-amp-or指令"><a href="#and-amp-or指令" class="headerlink" title="and&amp;or指令"></a>and&amp;or指令</h3><ul><li><p><code>and</code>指令</p><p>逻辑与指令，按位进行与运算。通过该指令可将操作对象的<strong>相应位设置为0</strong>，其他位不变。</p></li><li><p><code>or</code>指令</p><p>逻辑或指令，按位进行或运算。通过该指令可将操作对象的<strong>相应位设置为1</strong>，其他位不变。</p></li></ul><h3 id="以字符形式给出数据"><a href="#以字符形式给出数据" class="headerlink" title="以字符形式给出数据"></a>以字符形式给出数据</h3><p>用’……’的方式指明数据是以字符的形式给出的，编译器将把它们转化为相对应的ASCII码。对于用户输入或预先定义的字符，计算机采用ASCII码对其进行编码，将其转化为对应的十六进制信息存储在内存的指定空间中。文本编辑软件从内存中取出该十六进制信息，将其送到显卡的显存中。工作在文本模式下的显卡，用ASCII码的规则解释显存中的内容，显卡驱动显示器将对应字符显示在屏幕上。</p><h3 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h3><p>一个字母，无论原来是大写还是小写，将其第5位置0，它将变为大写字母；将其第5位置1，它将变为小写字母。从而大小写转换对应的汇编语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and al, 11011111B ;将al中的ASCII码的第5位置为0，变为大写字母</span><br><span class="line">or al, 00100000B  ;将al中的ASCII码的第5位置为1，变为小写字母</span><br></pre></td></tr></table></figure><h3 id="SI-amp-DI"><a href="#SI-amp-DI" class="headerlink" title="SI&amp;DI"></a>SI&amp;DI</h3><p>si和di是8086CPU中和bx功能相近的寄存器，si和di<strong>不能够分成两个8位寄存器来使用</strong>。</p><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><ul><li><p>[bx+idata]</p><p>[bx+idata]表示一个内存单元，它的偏移地址为<code>(bx)+idata</code>。指令<code>mov ax,[bx+200]</code>的数字化描述为<code>(ax) = ((ds)*16+(bx)+200)</code>。该指令也常用以下格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[200+bx]</span><br><span class="line">mov ax,200[bx]</span><br><span class="line">mov ax,[bx].200</span><br></pre></td></tr></table></figure></li><li><p>[bx+si]&amp;[bx+di]</p><p>[bx+si]和[bx+di]含义相似，以前者为例进行说明。[bx+si]表示一个内存单元，它的偏移地址为<code>(bx)+(si)</code>。指令<code>mov ax,[bx+si]</code>的数字化描述为<code>(ax) = ((ds)*16+(bx)+(si))</code>。指令常用格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx][si]</span><br></pre></td></tr></table></figure></li><li><p>[bx+si+idata]&amp;[bx+di+idata]</p><p>[bx+si+idata]和[bx+di+idata]含义相似，以前者为例进行说明。[bx+si+idata]表示一个内存单元，它的偏移地址为<code>(bx)+(si)+idata</code>。指令<code>mov ax,[bx+si+idata]</code>的数字化描述为<code>(ax) = ((ds)*16+(bx)+(si)+idata)</code>。指令常用格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx+200+si]</span><br><span class="line">mov ax,[200+bx+si]</span><br><span class="line">mov ax,200[bx][si]</span><br><span class="line">mov ax,[bx].200[si]</span><br><span class="line">mov ax,[bx][si].200</span><br></pre></td></tr></table></figure></li></ul><p>经过对比我们可以得出以下结论：</p><ul><li>[idata]用一个常量来表示地址，可用于直接定位一个内存单元；</li><li>[bx]用一个变量来表示内存地址，可用于间接定位一个内存单元；</li><li>[bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；</li><li>[bx+si]用两个变量表示地址；</li><li>[bx+si+idata]用两个变量和一个常量表示地址。</li></ul><p><img src="/2021/08/06/汇编语言学习笔记（三）/1.png" alt="1"></p><h3 id="汇编语言循环嵌套"><a href="#汇编语言循环嵌套" class="headerlink" title="汇编语言循环嵌套"></a>汇编语言循环嵌套</h3><p>以下面的编程题目为例简要说明在汇编语言中如何处理循环嵌套功能。</p><p>现要求编写汇编程序，实现将datasg段中每个单词的前4个字母改为大写字母。</p><p>汇编语言中循环功能的实现需要<code>cx</code>寄存器的配合，因为该寄存器存放单层循环的循环次数。在多层循环这一情景下，我们可以使用<strong>寄存器或内存栈来保存<code>cx</code>中存放的外层循环次数</strong>，以便内层循环对该寄存器的重复利用。</p><p>完整程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ss:stacksg,ds:datasg</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">        dw 0,0,0,0,0,0,0,0</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">        db &apos;1. display      &apos;</span><br><span class="line">        db &apos;2. brows        &apos;</span><br><span class="line">        db &apos;3. replace      &apos;</span><br><span class="line">        db &apos;4. modify       &apos;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:  mov ax,stacksg ; 初始化栈相关指针</span><br><span class="line">        mov ss,ax</span><br><span class="line">        mov sp,16</span><br><span class="line"></span><br><span class="line">        mov ax,datasg ; 初始化数据段，方便寻址</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov bx,0</span><br><span class="line">        mov cx,4 ; 由于外层循环需要对4行字符串进行操作，故设置cx为4</span><br><span class="line">   s0:  push cx ; 将外层循环次数压栈</span><br><span class="line">        mov si,0</span><br><span class="line">        mov cx,4 ; 由于内层循环需要对每行前4个字母实现大小写转换，故设置cx为4</span><br><span class="line"></span><br><span class="line">    s:  mov al,[bx+3+si]</span><br><span class="line">        and al,11011111b ; 完成大小写转换</span><br><span class="line">        mov [bx+3+si],al</span><br><span class="line"></span><br><span class="line">        inc si</span><br><span class="line">        loop s ; 重复调用内层循环</span><br><span class="line"></span><br><span class="line">        add bx,16 </span><br><span class="line">        pop cx ; 将外层循环次数弹栈</span><br><span class="line">        loop s0 ; 重复调用外层循环</span><br><span class="line">        </span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="0x01-数据处理的两个基本问题"><a href="#0x01-数据处理的两个基本问题" class="headerlink" title="0x01 数据处理的两个基本问题"></a>0x01 数据处理的两个基本问题</h2><p>数据处理的两个基本问题为<strong>处理数据位置</strong>和<strong>处理数据长度</strong>。机器指令必须给出这两个问题明确或隐含的说明，否则计算机无法工作。</p><p>我们定义描述性符号<code>reg</code>和<code>sreg</code>，前者表示一个寄存器，后者表示一个段寄存器。</p><ul><li>reg集合包括：<code>ax</code>、<code>bx</code>、<code>cx</code>、<code>dx</code>、<code>ah</code>、<code>al</code>、<code>bh</code>、<code>bl</code>、<code>ch</code>、<code>cl</code>、<code>dh</code>、<code>dl</code>、<code>sp</code>、<code>bp</code>、<code>si</code>、<code>di</code>；</li><li>sreg集合包括：<code>ds</code>、<code>ss</code>、<code>cs</code>、<code>es</code>。</li></ul><h3 id="bx-amp-si-amp-di-amp-bp"><a href="#bx-amp-si-amp-di-amp-bp" class="headerlink" title="bx&amp;si&amp;di&amp;bp"></a>bx&amp;si&amp;di&amp;bp</h3><ul><li><p>在8086CPU中，只有这4个寄存器可以用在<code>[...]</code>中来进行内存单元的寻址，其他的reg例如<code>ax</code>,<code>bx</code>,<code>cx</code>等出现在<code>[...]</code>中均会报错。</p></li><li><p>在<code>[...]</code>中，这4个寄存器可以单独出现，或只能以<strong>4种组合</strong>出现：<code>bx&amp;si</code>、<code>bx&amp;di</code>、<code>bp&amp;si</code>、<code>bp&amp;di</code>。</p></li><li><p>只要在<code>[...]</code>中使用寄存器bp，而指令中没有显性地给出段地址，段地址就默认在ss中。比如下面的指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bp]          ;含义：(ax) = ((ss)*16+(bp))</span><br><span class="line">mov ax,[bp+si+idata] ;含义: (ax) = ((ss*16)+(bp)+(si)+idata)</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据位置"><a href="#数据位置" class="headerlink" title="数据位置"></a>数据位置</h3><h4 id="机器指令处理数据位置"><a href="#机器指令处理数据位置" class="headerlink" title="机器指令处理数据位置"></a>机器指令处理数据位置</h4><p>绝大部分机器指令都是数据处理指令，处理大致可分为3类：读取、写入、运算。机器指令层不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令执行前所要处理的数据可以在3个地方：<strong>CPU内部</strong>、<strong>内存</strong>和<strong>端口</strong>。</p><h4 id="汇编语言中数据位置表达"><a href="#汇编语言中数据位置表达" class="headerlink" title="汇编语言中数据位置表达"></a>汇编语言中数据位置表达</h4><p>汇编语言中使用3个概念来表达数据的位置。</p><ul><li><p>立即数(idata)</p><p>对于直接包含在机器指令中的数据，在汇编语言中称为立即数，在汇编指令中直接给出。</p></li><li><p>寄存器</p><p>指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。</p></li><li><p>段地址(SA)&amp;偏移地址(EA)</p><p>指令要处理的数据在内存中，在汇编指令中可用<code>[X]</code>的格式给出EA，SA在某个段寄存器中。</p></li></ul><h3 id="数据长度"><a href="#数据长度" class="headerlink" title="数据长度"></a>数据长度</h3><p>8086CPU的指令，可以处理两种尺寸的数据，即byte和word。所以在机器指令中要指明，指令进行的是<strong>字操作</strong>还是<strong>字节操作</strong>。汇编语言采用以下方法处理这一问题：</p><ul><li><p>通过寄存器名指明要处理的数据尺寸。如对<code>ax</code>等16位寄存器执行的指令均为字操作，而对<code>al</code>等8位寄存器执行的指令为字节操作。</p></li><li><p>在没有寄存器名存在的情况下，用操作符<code>X ptr</code>指明<strong>内存单元的长度</strong>，X在汇编指令中可以为word或byte。用法举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1 ;word ptr指明指令访问的内存单元是一个字单元</span><br><span class="line">mov byte ptr ds:[0],1 ;byte ptr指明指令访问的内存单元是一个字节单元</span><br></pre></td></tr></table></figure><p>在没有寄存器参与的内存单元访问指令中，用<code>word ptr</code>或<code>byte ptr</code>显性地指明所要访问的内存单元的长度是很必要的。否则，CPU无法得知所要访问的单元是字单元还是字节单元。</p></li><li><p>有些指令默认了访问的是字单元还是字节单元，例如<code>push</code>指令只进行字操作。</p></li></ul><h3 id="div指令"><a href="#div指令" class="headerlink" title="div指令"></a>div指令</h3><ul><li><p>除数：有8位和16位两种，在一个reg或内存单元中。</p></li><li><p>被除数：默认放在AX或DX和AX中。</p><ul><li>若除数为8位，被除数则为16位，默认在AX中存放。</li><li>若除数为16位，被除数则为32位，在DX中存放其高16位，AX中存放其低16位。</li></ul></li><li><p>结果：默认存放在AX或AX和DX中。</p><ul><li>若除数为8位，则AL存储除法操作的商，AH存放除法操作的余数。</li><li>若除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</li></ul></li><li><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div reg</span><br><span class="line">div 内存单元</span><br></pre></td></tr></table></figure></li><li><p>应用举例</p><p>利用除法指令计算100001/100</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dx,1</span><br><span class="line">mov ax,86A1H ; (dx)*10000H+(ax)=100001</span><br><span class="line">mov bx,100</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure><p>利用除法指令计算1001/100</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1001</span><br><span class="line">mov bl,100</span><br><span class="line">div bl</span><br></pre></td></tr></table></figure></li><li><p>除法溢出</p><p>当CPU执行div等除法指令的时候，如果结果的商过大，超出了寄存器所能存储的范围，将引发CPU的一个内部错误即<strong>除法溢出</strong>，我们可以通过以下计算方式排除溢出的情况。</p><p>给出公式$ X/N = int(H/N)<em>65536+[rem(H/N)</em>65536+L]/N $，其中</p><ul><li>X：被除数，范围：[0,FFFFFFFF]</li><li>N：除数，范围：[0,FFFF]</li><li>H：X高16位，范围：[0,FFFF]</li><li>L：X低16位，范围：[0,FFFF]</li><li>int()：描述性运算符，取商。</li><li>rem()：描述性运算符，取余数。</li></ul><p>这个公式将可能产生溢出的除法运算X/N转变为多个不会产生溢出的除法运算。公式中等号右边的所有除法运算都可以用div指令进行，肯定不会导致除法溢出。</p></li></ul><h3 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a>mul指令</h3><ul><li><p>两个相乘的数必须均为8位或16位。若均为8位，则一个默认放在AL中，另一个放在8位reg或内存字节单元中；若均为16位，则一个默认放在AX中，另一个放在16位reg或内存字单元中。</p></li><li><p>若进行8位乘法，结果默认放在AX中；若进行16位乘法，结果高位放在DX中，低位放在AX中。</p></li><li><p>格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mul reg</span><br><span class="line">mul 内存单元</span><br></pre></td></tr></table></figure></li></ul><h3 id="伪指令dd"><a href="#伪指令dd" class="headerlink" title="伪指令dd"></a>伪指令dd</h3><p>dd用来定义dword(double word，双字)类型的数据，该关键字定义的数据占两个字的大小。</p><h3 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h3><p>dup是一个操作符，在汇编语言中和db、dw、dd等数据定义伪指令配合使用，用来进行数据的重复。dup的使用格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db 重复的次数 dup (重复的字节型数据)</span><br><span class="line">dw 重复的次数 dup (重复的字型数据)</span><br><span class="line">dd 重复的次数 dup (重复的双字型)</span><br></pre></td></tr></table></figure><h2 id="0x02-实验7：寻址方式在结构化数据访问中的应用"><a href="#0x02-实验7：寻址方式在结构化数据访问中的应用" class="headerlink" title="0x02 实验7：寻址方式在结构化数据访问中的应用"></a>0x02 实验7：寻址方式在结构化数据访问中的应用</h2><p>汇编源程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">data segment</span><br><span class="line">        db &apos;1975&apos;,&apos;1976&apos;,&apos;1977&apos;,&apos;1978&apos;,&apos;1979&apos;,&apos;1980&apos;,&apos;1981&apos;,&apos;1982&apos;,&apos;1983&apos;</span><br><span class="line">        db &apos;1984&apos;,&apos;1985&apos;,&apos;1986&apos;,&apos;1987&apos;,&apos;1988&apos;,&apos;1989&apos;,&apos;1990&apos;,&apos;1991&apos;,&apos;1992&apos;</span><br><span class="line">        db &apos;1993&apos;,&apos;1994&apos;,&apos;1995&apos;</span><br><span class="line"></span><br><span class="line">        dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514</span><br><span class="line">        dd 345980,590827,803530,118300,1843000,2759000,3753000,4649000,5937000</span><br><span class="line"></span><br><span class="line">        dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226</span><br><span class="line">        dw 11542,14430,15257,17800</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">table segment</span><br><span class="line">        db 21 dup(&apos;year summ ne ?? &apos;)</span><br><span class="line">table ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:  mov ax,data</span><br><span class="line">        mov es,ax</span><br><span class="line"></span><br><span class="line">        mov ax,table</span><br><span class="line">        mov ds,ax</span><br><span class="line"></span><br><span class="line">        mov cx,21</span><br><span class="line">        mov bx,0   ;locate struct data, add 16 per time</span><br><span class="line">        mov si,0   ;locate employee number, add 2 per time</span><br><span class="line">        mov bp,0   ;locate year and wage, add 4 per time</span><br><span class="line">    s:</span><br><span class="line">        ; input year data</span><br><span class="line">        mov ax,es:[bp+0]</span><br><span class="line">        mov ds:[bx],ax</span><br><span class="line">        mov ax,es:[bp+2]</span><br><span class="line">        mov ds:[bx+2],ax</span><br><span class="line"></span><br><span class="line">        ; input wage data</span><br><span class="line">        mov ax,es:54H[bp+0]</span><br><span class="line">        mov ds:[bx+5],ax</span><br><span class="line">        mov ax,es:54H[bp+2]</span><br><span class="line">        mov ds:[bx+7],ax</span><br><span class="line"></span><br><span class="line">        ; input employee data</span><br><span class="line">        mov ax,es:0A8H[si]</span><br><span class="line">        mov ds:[bx+10],ax</span><br><span class="line"></span><br><span class="line">        ; calculate average wages</span><br><span class="line">        mov ax,ds:[bx+5]</span><br><span class="line">        mov dx,ds:[bx+7]</span><br><span class="line">        div word ptr ds:[bx+10]</span><br><span class="line">        mov ds:[bx+13],ax</span><br><span class="line"></span><br><span class="line">        add bx,16</span><br><span class="line">        add si,2</span><br><span class="line">        add bp,4</span><br><span class="line"></span><br><span class="line">        loop s</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">                                </span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2021/08/06/汇编语言学习笔记（三）/2.PNG" alt="2"></p><h2 id="0x03-相关资料"><a href="#0x03-相关资料" class="headerlink" title="0x03 相关资料"></a>0x03 相关资料</h2><h3 id="屏幕显示相关"><a href="#屏幕显示相关" class="headerlink" title="屏幕显示相关"></a>屏幕显示相关</h3><ul><li><p>内存地址空间中，<strong>B8000H~BFFFFH</strong>共32KB的空间，为$80 \times 25$彩色字符模式的显示缓冲区。向这个地址空间写入数据，写入的内容讲立即出现在显示器上。彩色字符模式下，显示器可以显示25行，每行80个字符，每个字符包含256种属性。</p></li><li><p>每一行种，一个字符占两个字节的存储空间，低位字节存储字符的ASCII码，高位字节存储字符的属性。</p></li><li><p>显示缓冲区中，偶地址存放字符，奇地址存放字符的颜色属性。</p></li><li><p>属性字节的格式如下：</p><p><img src="/2021/08/06/汇编语言学习笔记（三）/3.png" alt="4"></p></li></ul><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>补码思想适用于有符号数的表示。首先使用00000000b~01111111b表示0~127，然后将它们按位取反加1后的数据表示负数。补码方案具有以下特点：</p><ul><li>最高位为1，表示负数；</li><li>正数的补码取反加1后，为其对应的负数的补码；负数的补码取反加1后，为其绝对值；</li><li>8位补码所表示的数的范围是-128~127。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-内存定址方法&quot;&gt;&lt;a href=&quot;#0x00-内存定址方法&quot; class=&quot;headerlink&quot; title=&quot;0x00 内存定址方法&quot;&gt;&lt;/a&gt;0x00 内存定址方法&lt;/h2&gt;&lt;h3 id=&quot;and-amp-or指令&quot;&gt;&lt;a href=&quot;#and-a
      
    
    </summary>
    
      <category term="Binary" scheme="https://blank-vax.github.io/categories/Binary/"/>
    
    
      <category term="IoT Foundation" scheme="https://blank-vax.github.io/tags/IoT-Foundation/"/>
    
      <category term="Assembly" scheme="https://blank-vax.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习笔记（二）</title>
    <link href="https://blank-vax.github.io/2021/07/16/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://blank-vax.github.io/2021/07/16/汇编语言学习笔记（二）/</id>
    <published>2021-07-16T10:31:00.000Z</published>
    <updated>2021-07-16T10:41:18.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-源程序"><a href="#0x00-源程序" class="headerlink" title="0x00 源程序"></a>0x00 源程序</h2><h3 id="程序周期"><a href="#程序周期" class="headerlink" title="程序周期"></a>程序周期</h3><p>一个汇编语言程序从写出到最终执行的过程包括如下内容：</p><ul><li><p>编写汇编程序</p><p>这一步工作的结果产生存储源程序的文本文件，常以<code>.asm</code>结尾。</p></li><li><p>对源程序进行编译连接</p><p>使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件（以<code>.obj</code>结尾）。再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件（以<code>.exe</code>结尾）。这一步工作的结果产生可在操作系统中运行的可执行文件。</p><p>可执行文件包括<strong>程序</strong>、<strong>数据</strong>和<strong>相关描述信息</strong>三部分。</p></li><li><p>执行可执行文件中的程序。</p></li><li><p>程序返回</p></li></ul><p>以上过程可概括如下：</p><script type="math/tex; mode=display">编程 \rightarrow test.asm \rightarrow 编译 \rightarrow test.obj \rightarrow 连接 \rightarrow test.exe \rightarrow 加载 \rightarrow 内存中的程序 \rightarrow 运行</script><h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><p>汇编语言源程序中的指令包括汇编指令和伪指令。汇编指令有对应的机器码指令，可被编译为机器指令，最终被CPU执行。而伪指令没有对应的机器码指令，由编译器执行，编译器根据伪指令进行相关的编译工作。</p><ul><li><code>segment&amp;ends</code>：成对使用，功能为定义一个段。其中<code>segment</code>说明段的开始，<code>ends</code>说明段的结束。</li><li><code>end</code>：是一个汇编程序的结束标记，编译器碰到伪指令<code>end</code>则结束对源程序的编译。</li><li><code>assume</code>：将有特定用途的段和相关的段寄存器关联起来。</li></ul><h3 id="源程序与程序"><a href="#源程序与程序" class="headerlink" title="源程序与程序"></a>源程序与程序</h3><p>将源程序文件中的所有内容称为源程序，将源程序中最终由计算机执行、处理的指令或数据成为程序。程序最先以汇编指令的形式存在源程序中，经编译、连接后转变为机器码，存储在可执行文件中。</p><h3 id="程序加载-amp-返回"><a href="#程序加载-amp-返回" class="headerlink" title="程序加载&amp;返回"></a>程序加载&amp;返回</h3><p>一个程序结束后，将CPU的控制权交还给使它得以运行的程序，这个过程称为程序返回。可以通过在程序的末尾添加如下返回程序段实现程序返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure><p>任何通用的操作系统，都需要提供一个称为shell的程序，用户使用这个程序来操作计算机系统进行工作。DOS系统中有一个程序<code>command.com</code>，这个程序称为命令解释器，也就是DOS系统的shell。</p><p>故可执行文件在DOS中加载执行的过程可概括如下：</p><ul><li>可执行文件执行时，正在运行的command程序将该可执行文件中的程序加载入内存。</li><li>command设置CPU的<code>CS:IP</code>指向程序的第一条指令（即程序的入口），从而使程序得以运行。</li><li>程序运行结束后，返回到command中，CPU继续运行command。</li></ul><p><img src="/2021/07/16/汇编语言学习笔记（二）/1.png" alt="1"></p><p>由上图可知，程序加载后，<code>ds</code>中存放着程序所在内存区的段地址，对应的偏移地址为0.则程序所在的内存区地址为<code>ds:0</code>。这个内存区的前256个字节中存放的是PSP，DOS用来和程序进行通信。从256字节处向后的空间存放程序。故程序的物理地址为<code>SA+10H:0</code>。</p><h3 id="语法错误和逻辑错误"><a href="#语法错误和逻辑错误" class="headerlink" title="语法错误和逻辑错误"></a>语法错误和逻辑错误</h3><p>一般来说，程序在编译时被编译器发现的错误是语法错误。源程序经过编译，在运行时发生的错误是逻辑错误。</p><h2 id="0x01-编辑-amp-编译-amp-连接"><a href="#0x01-编辑-amp-编译-amp-连接" class="headerlink" title="0x01 编辑&amp;编译&amp;连接"></a>0x01 编辑&amp;编译&amp;连接</h2><p>DOS下汇编源程序的编辑、编译及连接需要的工具分别为编辑器<code>edit</code>、编译器<code>masm</code>和连接器<code>link</code>。通常来说，DOSBox中不自带这些软件，下载链接如下：<a href="https://pan.baidu.com/s/1BxI4qu-3wjPmNOB5ADYFxw" target="_blank" rel="noopener">https://pan.baidu.com/s/1BxI4qu-3wjPmNOB5ADYFxw</a> ，提取码：yxg5 。</p><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><p>在DOS命令行中输入<code>edit 文件名.asm</code>指令，进行汇编源程序编辑，界面如下：</p><p><img src="/2021/07/16/汇编语言学习笔记（二）/2.PNG" alt="2"></p><p>完成编辑后保存即可。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>在DOS命令行中输入<code>masm</code>指令进入编译模式。编译过程中，输入为源程序文件，最多可以得到三个输出即目标文件、列表文件和交叉引用文件。</p><p><img src="/2021/07/16/汇编语言学习笔记（二）/3.PNG" alt="3"></p><ul><li>Source filename：源程序名称，默认为<code>[.ASM]</code>。若待编译文件为masm所在路径下的<code>.asm</code>文件，则直接输入文件名；否则需要输入完整的路径名称及文件后缀。</li><li>Object filename：生成<code>OBJ</code>文件名称，默认为<code>[.OBJ]</code>。直接键入Enter则在当前目录下生成<code>.obj</code>文件。当然也可以指定目录。</li><li>Source listing：列表文件名称，为编译过程的中间结果，键入Enter键取消生成。</li><li>Cross-reference：交叉引用文件名称，键入Enter键取消生成。</li></ul><p>常见编译错误包含两类：</p><ul><li>程序中存在<code>Severe Errors</code>。</li><li>找不到所给出的源程序文件。</li></ul><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>连接的作用包括以下内容：</p><ul><li>分割较大的源程序，分别编译子源程序后连接在一起，形成一个可执行文件。</li><li>将库文件和目标文件连接在一起，实现对库文件中子程序的调用。</li><li>连接程序将目标文件中的内容处理为最终的可执行信息。</li></ul><p>在DOS中输入<code>link</code>指令进入连接模式。</p><p><img src="/2021/07/16/汇编语言学习笔记（二）/4.PNG" alt="4"></p><ul><li>Object Modules：待连接<code>OBJ</code>文件名称，默认为<code>[.OBJ]</code>。如果文件不以<code>.obj</code>为扩展名，则需要输入全名。</li><li>Run File：生成的可执行文件名称。</li><li>List File：映像文件的名称，为可忽略的中间结果。</li><li>Libraries：库文件名称。若程序中调用了某一个库文件中的子程序，则在连接时需要将这个库文件和目标文件连接到一起生成可执行文件。</li></ul><h3 id="简化版的编译连接"><a href="#简化版的编译连接" class="headerlink" title="简化版的编译连接"></a>简化版的编译连接</h3><ul><li>简化编译：<code>masm 文件路径+文件名;</code>，自动忽略中间文件。</li><li>简化连接：<code>link 文件路径+文件名;</code>，自动忽略中间文件。</li></ul><h2 id="0x02-BX-amp-LOOP"><a href="#0x02-BX-amp-LOOP" class="headerlink" title="0x02 [BX]&amp;LOOP"></a>0x02 [BX]&amp;LOOP</h2><p>定义描述性符号()，其中的元素包括三种类型：寄存器名、段寄存器名和内存单元的物理地址（一个20位数据）。</p><p>约定Idata表示常量。</p><h3 id="BX"><a href="#BX" class="headerlink" title="[BX]"></a>[BX]</h3><p>[bx]表示一个内存单元，偏移地址在<code>bx</code>寄存器中，段地址在<code>ds</code>寄存器中。</p><h3 id="LOOP"><a href="#LOOP" class="headerlink" title="LOOP"></a>LOOP</h3><p>使用loop指令实现循环功能，寄存器<code>cx</code>中存放循环次数。该指令的格式是：<code>loop 标号</code>，CPU执行loop指令时，首先执行<code>(cx) = (cx)-1</code>，随后判断<code>cx</code>中的值，若不为零则跳转至标号处执行程序；若为零则向下执行。</p><p>使用<code>cx</code>和LOOP指令配合实现循环功能的框架如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov cx, 循环次数</span><br><span class="line">s:</span><br><span class="line">循环执行的程序段</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><p>编写汇编程序并使用debug命令进行跟踪执行，验证loop语句的操作流程。</p><p>可以使用debug命令的g命令进行持续执行。如<code>g 0012</code>表示从当前的<code>CS:IP</code>指向的指令执行，一直到<code>(IP)=0012h</code>为止。若希望将循环一次执行完，可在遇到loop指令时，使用p命令执行。</p><p>值得注意的是，在汇编源程序中，数据不能以<strong>字母</strong>开头。</p><h3 id="Debug与masm对指令的不同处理"><a href="#Debug与masm对指令的不同处理" class="headerlink" title="Debug与masm对指令的不同处理"></a>Debug与masm对指令的不同处理</h3><p>在debug中的指令<code>mov ax,[0]</code>表示将<code>ds:0</code>处的数据送入<code>ax</code>中。但在汇编源程序中，指令<code>mov ax,[0]</code>被编译器当作指令<code>mov ax,0</code>进行处理。Debug将<code>[idata]</code>解释为一个内存单元，idata是内存单元的偏移地址；而编译器将<code>[idata]</code>解释为idata。</p><p>若希望在源程序中实现将内存单元中的数据送入寄存器中，则可以使用<code>bx</code>寄存器存储偏移地址，使用<code>[bx]</code>的方式访问内存单元。若希望直接使用idata表示偏移地址，则需要显式地给出段地址所在的段寄存器，例如<code>ds:[idata]</code>。</p><p>出现在访问内存单元的指令中，用于显式地指明内存单元的段地址的<code>ds:</code>，<code>cs:</code>，<code>ss:</code>，<code>es:</code>，在汇编语言中称为<strong>段前缀</strong>。</p><h3 id="安全段空间"><a href="#安全段空间" class="headerlink" title="安全段空间"></a>安全段空间</h3><p>在8086模式中，随意向一段内存空间写入内容是危险的，因为这段空间中可能存放着重要的系统数据或代码。故向内存空间写入数据时，需要使用操作系统分配的内存空间，而不应直接用地址任意指定内存单元，向里面写入。</p><p>DOS和其他合法的程序一般都不会使用<code>0:200~0:2ff</code>的256个字节的地址空间，故可以直接向该段空间内写入内容。</p><h2 id="0x03-多程序段程序"><a href="#0x03-多程序段程序" class="headerlink" title="0x03 多程序段程序"></a>0x03 多程序段程序</h2><p>前面内容中讨论的程序均只包含一个代码段，称为单程序段程序，下面讨论多程序段程序。</p><p>操作系统环境中，合法地通过操作系统取得的空间都是安全地，因为操作系统不会让一个程序所用的空间和其他程序以及系统自己的空间冲突。故在操作系统允许的情况下，程序可以取得<strong>任意容量的空间</strong>。</p><p>程序可以通过两种方法获取所需空间，本文重点讨论<strong>在加载程序的时候为程序分配</strong>这种方法，即通过在源程序中定义段来获取内存空间。</p><h3 id="在代码段中使用数据"><a href="#在代码段中使用数据" class="headerlink" title="在代码段中使用数据"></a>在代码段中使用数据</h3><p>考虑以下场景，我们需实现多个常数的相加，并将结果存储在特定寄存器中。这种情况下，我们可以在程序中定义希望处理的数据，这些数据就会被编译、连接程序作为程序的一部分写入可执行文件中。以下面的程序为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,8</span><br><span class="line">  s:add ax,cs:[bx]</span><br><span class="line">    add bx,2</span><br><span class="line">    loop s</span><br><span class="line">    </span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="dw-amp-db"><a href="#dw-amp-db" class="headerlink" title="dw&amp;db"></a>dw&amp;db</h4><p><code>dw</code>：即<code>define word</code>，用于定义字型数据。该语句后跟随N个字型数据，其所占空间大小为2N字节。同时，<code>dw</code>定义的数据处于代码段的头部，故偏移地址为0。</p><p><code>db</code>：即<code>define byte</code>，用于定义字节型数据。该语句后跟随N个字节型数据，其所占空间大小为N字节。</p><h4 id="start"><a href="#start" class="headerlink" title="start"></a>start</h4><p><img src="/2021/07/16/汇编语言学习笔记（二）/5.PNG" alt="5"></p><p>通过debug查看上述程序的可执行文件，可以发现代码段的前16个字节是用<code>dw</code>指令定义的数据，从第16个字节开始才是汇编指令对应的机器码。故我们需要<strong>显式地表明程序第一条指令的位置</strong>。</p><p>可以通过调试器修改<code>CS:IP</code>指向的指令单元从而标记程序的第一条指令，但更方便的做法是利用<code>start</code>标号来表明程序首条指令的位置。这个标号在伪指令end后面出现，于是end除通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。修改后的程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line"></span><br><span class="line">start:mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,8</span><br><span class="line">  s:add ax,cs:[bx]</span><br><span class="line">    add bx,2</span><br><span class="line">    loop s</span><br><span class="line">    </span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>在代码段中使用数据的程序框架如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">  :</span><br><span class="line">  :</span><br><span class="line">  数据</span><br><span class="line">  :</span><br><span class="line">  :</span><br><span class="line">start: </span><br><span class="line">:</span><br><span class="line">代码</span><br><span class="line">:</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h3 id="在代码段中使用栈"><a href="#在代码段中使用栈" class="headerlink" title="在代码段中使用栈"></a>在代码段中使用栈</h3><p>考虑以下场景，我们需要逆序输出数据段中的内容，最佳的解决办法就是在代码段中引入栈。即在程序中通过定义数据来取得一段空间，然后将这段空间当作栈来使用。以下面程序为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">; 用dw定义16个字型数据，在程序加载后，将取得16个字的内存空间，存放这16个数</span><br><span class="line">; 据。在后面的程序中将这段空间当作栈来使用。</span><br><span class="line">start:mov ax,cs</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,30h</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:  push cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s0: pop cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>将<code>CS:10~CS:2F</code>的内存空间当作栈使用，初始状态下栈为空，所以<code>SS:SP</code>要指向栈底<code>CS:30</code>。</p><h3 id="将数据、代码、栈放入不同的段"><a href="#将数据、代码、栈放入不同的段" class="headerlink" title="将数据、代码、栈放入不同的段"></a>将数据、代码、栈放入不同的段</h3><p>为避免程序结构混乱，考虑将数据、代码和栈放入不同的段，并在程序头部进行寄存器关联。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">data segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">data ends</span><br><span class="line">stack segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,20h</span><br><span class="line"></span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:push [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s0:pop [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><ul><li><p>定义一个段的方法和定义代码段方法相同，只是不同的段要求不同的段名。</p></li><li><p>CPU如何处理定义的段中的内容完全依靠程序中具体的汇编指令，和汇编指令对<code>CS:IP</code>、<code>SS:SP</code>、<code>DS</code>等寄存器的设置来决定。以上三个寄存器分别掌管代码段、栈段和数据段。</p></li><li><p>对于如下定义的段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name segment</span><br><span class="line">...</span><br><span class="line">name ends</span><br></pre></td></tr></table></figure><p>如果段中的数据占N个字节，则程序加载后，该段实际占有的空间为<code>(N/16+1)*16</code>个字节。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-源程序&quot;&gt;&lt;a href=&quot;#0x00-源程序&quot; class=&quot;headerlink&quot; title=&quot;0x00 源程序&quot;&gt;&lt;/a&gt;0x00 源程序&lt;/h2&gt;&lt;h3 id=&quot;程序周期&quot;&gt;&lt;a href=&quot;#程序周期&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Binary" scheme="https://blank-vax.github.io/categories/Binary/"/>
    
    
      <category term="IoT Foundation" scheme="https://blank-vax.github.io/tags/IoT-Foundation/"/>
    
      <category term="Assembly" scheme="https://blank-vax.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习笔记（一）</title>
    <link href="https://blank-vax.github.io/2021/07/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://blank-vax.github.io/2021/07/12/汇编语言学习笔记（一）/</id>
    <published>2021-07-12T08:00:00.000Z</published>
    <updated>2021-07-16T10:32:37.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-基础知识"><a href="#0x00-基础知识" class="headerlink" title="0x00 基础知识"></a>0x00 基础知识</h2><ul><li>Central Processing Unit为中央处理单元，简称CPU。CPU是一种微处理器，计算机是指由CPU和其他受CPU直接或间接控制的芯片、器件、设备组成的计算机系统，比如常见的PC机。每一种CPU都有自己的汇编指令集。</li><li>汇编指令通过编译器翻译为机器码，供计算机直接使用。</li><li>汇编语言由汇编指令、伪指令和其他符号组成。</li><li>指令和数据在存储器中存放，也就是平时所说的内存。在内存或磁盘上，指令和数据没有任何区别，都是<strong>二进制信息</strong>。</li><li>存储器被划分成若干个存储单元，每个存储单元从0开始顺序编号，微机存储器的容量以<strong>字节</strong>为最小单位计算。</li><li>CPU通过地址总线指定存储器单元，地址总线的宽度决定了CPU的寻址能力。</li><li>CPU通过数据总线实现自身与内存或其他器件之间的数据传送，数据总线的宽度决定了CPU与其他器件进行数据传送时的一次数据传送量。8088CPU数据总线宽度为8，8086CPU数据总线宽度为16。</li><li>CPU通过控制总线实现对外部器件的控制，控制总线的宽度决定了CPU对系统中其他器件的控制能力。</li><li>每台PC机都拥有一个主板，主板上有核心器件和一些主要器件，包括CPU、存储器、外围芯片组、扩展插槽等，这些器件通过总线相连。</li><li>存储器从功能和连接上可分为三类：随机存储器RAM、装有BIOS(Basic Input/Output System，基本输入输出系统)的只读存储器ROM、接口卡上的RAM（如显存）。</li><li>PC机在实际运作过程中，所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。</li></ul><h2 id="0x01-寄存器"><a href="#0x01-寄存器" class="headerlink" title="0x01 寄存器"></a>0x01 寄存器</h2><p>一个典型的CPU由运算器、控制器、寄存器等器件构成。各器件功能如下：</p><ul><li>运算器进行信息处理。</li><li>寄存器进行信息存储。</li><li>控制器控制各种器件进行工作。</li><li>内部总线连接各种器件，在它们之间进行数据的传送。</li></ul><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>8086CPU的所有寄存器都是16位的，可存放两个字节。AX、BX、CX、DX这四个寄存器通常用来存放一般性数据，称为通用寄存器。同时，这四个寄存器可分为两个可独立使用的8位寄存器来使用。</p><p>以寄存器AX为例，AX的低8位构成AL寄存器，高8位构成AH寄存器。AH和AL寄存器是可以独立使用的8位寄存器。注意，诸如<code>mov ax,bl</code>这类的汇编语句是错误的，因为其尝试将一个8位寄存器中的值赋值至16位寄存器中。</p><p>8086CPU可以一次性处理以下两种尺寸的数据：</p><ul><li>字节：记为byte，一个字节由8个bit组成，可存在8位寄存器中。</li><li>字：记为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节（H）和低位字节（L）。</li></ul><h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><ul><li><p>在写一条汇编指令或一个寄存器的名称时，不区分大小写。</p></li><li><p>8位寄存器只能存放两位十六进制的数字，若溢出则丢弃最高位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, C5H</span><br><span class="line">add al, 93H</span><br></pre></td></tr></table></figure><p>以上代码执行结果为：<code>158H</code>，而寄存器<code>al</code>是8位寄存器，故舍弃最高位1，保存结果<code>58H</code>。</p></li></ul><h3 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h3><p>所有的内存单元构成的存储空间是一个一维的线性空间，每个内存单元在这个空间中都有唯一的地址，将该地址称为物理地址。在CPU向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址。</p><p>8086CPU是16位结构的CPU，具有以下特性：</p><ul><li>运算器一次最多可以处理16位的数据。</li><li>寄存器的最大宽度为16位。</li><li>寄存器和运算器之间的通路为16位。</li></ul><p>8086CPU有20位地址总线，可以传送20位地址。然而，该CPU又是16位结构，在内部一次性处理、传输、暂时存储的地址均为16位。故8086CPU采用一种<strong>在内部用两个16位地址合成的方法来形成一个20位物理地址</strong>。</p><p>具体来讲，地址加法器采用<strong>物理地址=段地址*16+偏移地址</strong>的方法使用段地址和偏移地址合成物理地址。该方法的本质含义是：CPU在访问内存时，用一个基础地址（段地址<em>16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。一般来说，这种寻址功能是”<em>*基础地址+偏移地址=物理地址</em></em>“寻址模式的一种具体实现方案。</p><p>以上寻址方式有以下几个关键点：</p><ul><li>CPU可以用不同的段地址和偏移地址形成同一个物理地址。</li><li>偏移地址16位，变化范围为<code>0~FFFFH</code>，仅用偏移地址来寻址最多可寻64KB个内存单元。</li></ul><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>可以根据需要，将地址连续、起始地址为16的倍数的一组内存单元定义为一个段。8086CPU有4个段寄存器：CS、DS、SS、ES。当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。</p><p>CS和IP是8086CPU中两个最关键的寄存器，指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令指针寄存器。任意时刻，CPU将<code>CS:IP</code>指向的内容当作指令执行。</p><p>8086CPU工作过程如下：</p><ul><li>从<code>CS:IP</code>指向的内存单元读取指令，读取的指令进入<strong>指令缓冲器</strong>。</li><li><code>IP = IP + 所读取指令的长度</code>，指向下一条指令。</li><li>执行指令，转到第一步并重复。</li></ul><p>能够改变CS、IP内容的指令被统称为<strong>转移指令</strong>，最简单的转移指令是<code>jmp</code>指令。可以使用形如<code>jmp 段地址:偏移地址</code>的指令实现对CS、IP内容的同时修改。若只想修改IP的内容，可以使用形如<code>jmp 某一合法寄存器</code>的指令完成，该指令表示使用寄存器中的值修改IP。</p><h2 id="0x02-Debug的使用及相关指令"><a href="#0x02-Debug的使用及相关指令" class="headerlink" title="0x02 Debug的使用及相关指令"></a>0x02 Debug的使用及相关指令</h2><p>Windows10系统中已经剔除Debug相关的插件，需要下载DOSBox并手动安装debug.exe才可以使用Debug程序。安装指南链接如下：<a href="https://blog.csdn.net/mengjizhiyou/article/details/102458118" target="_blank" rel="noopener">win10环境下如何安装和运行DOSBox和debug_mengjizhiyou的博客-CSDN博客</a>。</p><p>Debug程序中重要指令如下：</p><ul><li><p>R命令</p><p>查看、修改CPU中寄存器的内容。r命令可以直接查看所有寄存器的值，使用<code>r+寄存器名称</code>语句以修改寄存器的值。</p><p><img src="/2021/07/12/汇编语言学习笔记（一）/1.PNG" alt="1"></p></li><li><p>D命令</p><p>查看内存中的内容。</p><p>直接使用d命令将列出Debug预设的地址处的内容。使用命令<code>d 段地址:偏移地址</code>的格式来指定查看内存的起始地址，随后接着使用d命令可列出后续内容。采用<code>d 段地址:起始偏移地址 结尾偏移地址</code>来规定d命令的查看范围。</p><p>Debug将输出的内容分为三部分：中间是从指定地址开始的128个内存单元的内容，以十六进制的格式输出，每行的输出从16的整数倍地址开始，最多输出16个单元的内容。左边是每行的起始地址。右边是每个内存单元中的数据对应的可显示的ASCII码字符。</p><p><img src="/2021/07/12/汇编语言学习笔记（一）/2.PNG" alt="2"></p><p>同时，D命令支持<code>d 段寄存器:偏移地址</code>指令格式。</p><p><img src="/2021/07/12/汇编语言学习笔记（一）/6.PNG" alt="6"></p></li><li><p>E命令</p><p>修改内存中的内容，可以写入数据和指令，在内存中它们实际上没有区别。</p><p>可以使用<code>e 起始地址 数据 数据 数据 ...</code>的格式修改指定内存范围中的内容。也可以直接输入<code>e 起始地址</code>，随后以询问的方式逐个修改内存单元中的内容，空格键表示指定内存单元修改完成，Enter键表示e命令执行结束。</p><p><img src="/2021/07/12/汇编语言学习笔记（一）/3.PNG" alt="3"></p></li><li><p>U命令</p><p>将内存中的内容解释为机器指令和对应的汇编指令。</p><p><img src="/2021/07/12/汇编语言学习笔记（一）/4.PNG" alt="4"></p></li><li><p>T命令</p><p>执行<code>CS:IP</code>指向的内存单元处的指令。若需要执行指定内存处存放的指令，则需要利用r命令修改寄存器CS和IP的值，随后才可使用t命令完成指令执行。</p><p>值得注意的是，T命令在修改寄存器SS的指令时，下一条指令也紧接着被执行，这涉及中断机制。</p><p><img src="/2021/07/12/汇编语言学习笔记（一）/7.PNG" alt="7"></p></li><li><p>A命令</p><p>以汇编指令的形式向内存中写入指令。</p><p><img src="/2021/07/12/汇编语言学习笔记（一）/5.PNG" alt="5"></p></li></ul><h2 id="0x03-寄存器内存访问"><a href="#0x03-寄存器内存访问" class="headerlink" title="0x03 寄存器内存访问"></a>0x03 寄存器内存访问</h2><h3 id="字的存储"><a href="#字的存储" class="headerlink" title="字的存储"></a>字的存储</h3><p>在内存中存储时，由于内存单元是字节单元，则一个字需要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。我们将起始地址为N的字单元简称为N地址字单元。</p><p>任何两个地址连续的内存单元既可被看作两个内存单元，也可 被看作一个地址为N的字单元中的高位字节单元和低位字节单元。</p><h3 id="DS-amp-address"><a href="#DS-amp-address" class="headerlink" title="DS&amp;[address]"></a>DS&amp;[address]</h3><p>8086CPU中有一个DS寄存器，通常用来存放要访问数据的段地址。</p><p>可以利用<code>mov</code>指令将一个内存单元中的内容送入一个寄存器中。寄存器通过寄存器名标识，而内存单元需要用内存单元地址指明。<code>[address]</code>表示一个内存单元，address表示内存单元的偏移地址。指令执行时，CPU自动区ds寄存器中的数字作为内存单元的段地址。</p><p>值得注意的是，8086CPU不支持将数据直接送入段寄存器的操作，故需要使用一般寄存器完成中转。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ds,1000H ;错误语句</span><br><span class="line"></span><br><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax ;正确语句</span><br></pre></td></tr></table></figure><h3 id="mov-amp-add-amp-sub"><a href="#mov-amp-add-amp-sub" class="headerlink" title="mov&amp;add&amp;sub"></a>mov&amp;add&amp;sub</h3><p>以上三个指令均支持以下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 寄存器，数据</span><br><span class="line">* 寄存器，寄存器</span><br><span class="line">* 寄存器，内存单元</span><br><span class="line">* 内存单元，寄存器</span><br></pre></td></tr></table></figure><p>其中*代表mov，add和sub三类运算。</p><h2 id="0x04-栈"><a href="#0x04-栈" class="headerlink" title="0x04 栈"></a>0x04 栈</h2><h3 id="基本概念及特性"><a href="#基本概念及特性" class="headerlink" title="基本概念及特性"></a>基本概念及特性</h3><p>栈是一种具有特殊访问方式的存储空间，具有后进先出（Last In First Out, LIFO）的特性。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>8086CPU提供入栈和出栈指令，分别为PUSH和POP，前者将一个新的元素放到栈顶，后者从栈顶去除一个元素。8086CPU的入栈出栈操作都是以字为单位进行的。</p><p>入栈时，栈顶从高地址向低地址方向增长，出栈则相反。栈顶元素出栈后，内存对应单元的元素依然存在，但已不在栈中，当再次执行PUSH指令时，写入的新数据会将其覆盖。</p><h3 id="SS-amp-SP"><a href="#SS-amp-SP" class="headerlink" title="SS&amp;SP"></a>SS&amp;SP</h3><p>8086CPU中存在段寄存器SS和栈指针 寄存器SP。栈顶的段地址存放在SS中，偏移地址存放在SP中。<strong>任意时刻，<code>SS:SP</code>指向栈顶元素</strong>。在对栈进行操作前，首先需要初始化寄存器SS和SP。</p><p>例如，若对范围为22000H~2200FH范围的栈进行操作，需首先初始化 SS指向2200H，初始化SP指向000FH+1=0100H。</p><h3 id="PUSH-amp-POP"><a href="#PUSH-amp-POP" class="headerlink" title="PUSH&amp;POP"></a>PUSH&amp;POP</h3><p>PUSH指令执行过程分为两步：首先执行<code>SP = SP-2</code>，使SP指向新的栈顶元素；随后向<code>SS:SP</code>指向的字单元中送入数据。POP指令执行过程同样分为两步：首先从<code>SS:SP</code>指向的字单元中读取数据；随后执行<code>SP = SP-2</code>移动SP指针。</p><p>可以看出，PUSH和POP等栈操作指令修改的只是SP寄存器，也就是说栈顶的变化范围最大为0~FFFFH。</p><p><strong>当栈满的时候再次使用PUSH指令入栈，或栈空的时候再次使用POP指令出栈，都将发生栈顶越界问题</strong>。</p><h2 id="0x05-段的综述"><a href="#0x05-段的综述" class="headerlink" title="0x05 段的综述"></a>0x05 段的综述</h2><p>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。根据使用者的初始化情况，一段内存可以作为代码的存储空间、数据的存储空间和栈空间，并支持这三类空间类型的组合。</p><ul><li><p>数据段</p><p>数据段的地址放在DS中，使用mov、add、sub等访问内存单元的指令时，CPU就将指定内存单元中的内容作为数据来处理。</p></li><li><p>代码段</p><p>代码段的段地址放在CS中，段中第一条指令的偏移地址放在IP中，CPU将执行指定内存单元中的指令。</p></li><li><p>栈段</p><p>栈段的段地址 放在SS中，栈顶单元的偏移地址放在SP中，CPU在执行PUSH、POP等栈操作时就将指定内存单元作为栈空间使用。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-基础知识&quot;&gt;&lt;a href=&quot;#0x00-基础知识&quot; class=&quot;headerlink&quot; title=&quot;0x00 基础知识&quot;&gt;&lt;/a&gt;0x00 基础知识&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Central Processing Unit为中央处理单元，简称CPU
      
    
    </summary>
    
      <category term="Binary" scheme="https://blank-vax.github.io/categories/Binary/"/>
    
    
      <category term="IoT Foundation" scheme="https://blank-vax.github.io/tags/IoT-Foundation/"/>
    
      <category term="Assembly" scheme="https://blank-vax.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>基于配对的密码学——基础知识及JPBC库</title>
    <link href="https://blank-vax.github.io/2021/07/05/%E5%9F%BA%E4%BA%8E%E9%85%8D%E5%AF%B9%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8AJPBC%E5%BA%93/"/>
    <id>https://blank-vax.github.io/2021/07/05/基于配对的密码学——基础知识及JPBC库/</id>
    <published>2021-07-05T03:46:00.000Z</published>
    <updated>2021-07-06T15:53:21.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本科毕业设计过程中需要使用JPBC库实现Java语言下双线性配对运算的仿真，摸索过程中遇到一些问题及特性，记录如下。本文参考李发根等编著的《基于配对的密码学》一书，首先简要介绍基于配对密码学的相关性质，随后结合JPBC文档介绍该库中部分函数的特殊性质及用法。</p><p>参考链接：</p><ul><li><p>《基于配对的密码学》</p><p>链接：<a href="https://pan.baidu.com/s/1bocycprbAUtNzCopkF1v-A" target="_blank" rel="noopener">https://pan.baidu.com/s/1bocycprbAUtNzCopkF1v-A</a>  提取码：oe09 </p></li><li><p>JPBC jar包</p><p>链接：<a href="https://pan.baidu.com/s/1MOZCaplESGF0gVk5dNeLGQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1MOZCaplESGF0gVk5dNeLGQ</a>  提取码：sa5m </p></li><li><p>JPBC DOCS</p><p>链接：<a href="http://gas.dia.unisa.it/projects/jpbc" target="_blank" rel="noopener">http://gas.dia.unisa.it/projects/jpbc</a></p></li></ul><h2 id="0x01-椭圆曲线密码体制"><a href="#0x01-椭圆曲线密码体制" class="headerlink" title="0x01 椭圆曲线密码体制"></a>0x01 椭圆曲线密码体制</h2><p>椭圆曲线密码体制（elliptic curve cryptosystem, ECC）是公钥密码体制的一个重要分支，其安全性基于椭圆曲线离散对数问题的困难性。该问题比大整数因子分解问题和有限域上的离散对数问题难得多。由于还没有找到求解椭圆曲线离散对数的亚指数算法，因此椭圆曲线密码体制可使用更短的密钥以保证相同的安全性。</p><h3 id="有限域上的椭圆曲线"><a href="#有限域上的椭圆曲线" class="headerlink" title="有限域上的椭圆曲线"></a>有限域上的椭圆曲线</h3><p>有限域上的椭圆曲线是指变量和系数均为有限域中元素的椭圆曲线。有限域$GF(p)$上的椭圆曲线是指满足方程</p><script type="math/tex; mode=display">y^2 \equiv x^3+ax+b(mod  p)</script><p>的所有点$(x,y)$及一个无穷远点O构成的集合，其中a,b,x和y均在有限域$GF(p)$上取值，p是素数。这里将该椭圆曲线记为$E_p(a,b)$，曲线上只有有限个点，其个数N由Hasse定理确定。</p><p><strong>Hasse定理</strong> 设E是有限域$GF(p)$上的椭圆曲线，N是E上点的个数，则满足</p><script type="math/tex; mode=display">p+1-2\sqrt(p) \leq N \leq p+1+2\sqrt(p)</script><p>当$4a^3+27b^2(mod p) \neq 0$时，基于集合$E_p(a,b)$可以定义一个Abel群，其加法规则与实数域上描述的代数方法一致。设$P,Q \in E_p(a,b)$，则</p><script type="math/tex; mode=display">P+O=P</script><ul><li><p>如果$P = (x,y)$，那么$(x,y) + (x,-y) = O$，即点(x,-y)是P的加法逆元，表示为-P。</p></li><li><p>设$P=(x_1,y_1)$和$Q=(x_2,y_2)$,$P \neq -Q$，则$S = P+Q = (x_3,y_3)$由以下规则确定：</p><script type="math/tex; mode=display">x_3 \equiv \lambda^2 - x_1 - x_2 (mod p)</script><script type="math/tex; mode=display">y_3 \equiv \lambda(x_1-x_3) - y_1 (mod p)</script><p>式中</p><script type="math/tex; mode=display">\lambda \equiv (y_2-y_1)/(x_2-x_1) (mod p), if P \neq Q</script><script type="math/tex; mode=display">\lambda \equiv (3x_1^2+a)/2y_1 (mod p), if P = Q</script></li><li><p>倍点运算定义为重复加法，即$3P = P+P+P$。</p></li></ul><h3 id="椭圆曲线上的ElGamal加密体制"><a href="#椭圆曲线上的ElGamal加密体制" class="headerlink" title="椭圆曲线上的ElGamal加密体制"></a>椭圆曲线上的ElGamal加密体制</h3><ul><li><p>定义1 椭圆曲线的阶</p><p>椭圆曲线$E_p(a,b)$上点P的阶是指满足</p><script type="math/tex; mode=display">nP = \sum^{n}P = O</script><p>的最小正整数，记为$ord(P)$，其中O是无穷远点。</p></li><li><p>定义2 椭圆曲线上离散对数问题</p><p>设G是椭圆曲线$E_p(a,b)$上的一个循环子群，P是G的一个生成元，$Q \in G$。已知P和Q，求满足</p><script type="math/tex; mode=display">mP = Q</script><p>的整数m，$0 \leq m \leq ord(P)-1$，称为椭圆曲线上的离散对数问题（elliptic curve discrete logarithm problem, ECDLP）。计算$mP$的过程称为点乘运算。</p></li></ul><p>EC-ElGamal密码体制包含以下四个元操作：</p><ul><li><p>编码与解码</p><p>将待发送的明文m<strong>编码</strong>为椭圆曲线上的点$P_m = (x_m, y_m)$，随后执行的加解密操作均针对点$P_m$，解密后的点$P_m$需执行<strong>逆向解码</strong>操作才可以获得明文。</p></li><li><p>密钥生成</p><p>在椭圆曲线$E_p(a,b)$上选取一个阶为大素数n的生成元P。随机选取整数x满足$1 &lt; x &lt; n$，计算$Q = xP$，将x作为私钥，Q作为公钥。</p></li><li><p>加密</p><p>为加密$P_m$，随机选取一个整数k满足$1 &lt; k &lt; n$，计算</p><script type="math/tex; mode=display">C_1 = kP, C_2 = P_m+kQ</script><p>则密文$c =(C_1, C_2)$。</p></li><li><p>解密</p><p>为解密密文$c = (C_1, C_2)$，计算</p><script type="math/tex; mode=display">C_2 - xC_1 = P_m+kQ-xkP = P_m+kxP-xkP = P_m</script><p>攻击者若妄图通过$c = (C_1,C_2)$计算出$P_m$，则必须获得k。攻击者需要通过P和kP推算出k的值，这一过程面临求解椭圆曲线上的离散对数问题。</p></li></ul><h2 id="0x02-双线性配对理论"><a href="#0x02-双线性配对理论" class="headerlink" title="0x02 双线性配对理论"></a>0x02 双线性配对理论</h2><h3 id="抽象双线性配对"><a href="#抽象双线性配对" class="headerlink" title="抽象双线性配对"></a>抽象双线性配对</h3><p>设k为安全参数，p为k比特长的素数。令$G_1$为由P生成的循环加法群，阶为p，$G_T$为具有相同阶p的循环乘法群，a，b是$Z_p^*$中的元素。0表示$G_1$中的单位元，1表示$G_T$中的单位元。假设$G_1$和$G_T$这两个群中的离散对数问题都是困难问题。双线性配对是指满足下列性质的映射$e: G_1 \times G_1 \rightarrow G_T$。</p><ul><li>双线性性（bilinearity）：对于任意的$P,Q \in G_1$和$a, b \in Z_p^*$，$e(aP, bQ) = e(P, Q)^{ab}$成立。</li><li>非退化性（non-degeneracy）：存在$P, Q \in G_1$，使得$e(P, Q) \neq 1$。同时，满足$e(0, Q) = e(Q, 0) = 1$。</li><li>可计算性（computability）：对于所有$P, Q \in G_1$，存在有效的算法计算$e(P, Q)$。</li></ul><p>双线性映射可以通过有限域上的超奇异椭圆曲线或超奇异超椭圆曲线中的Weil配对或Tate配对推导出来。</p><h3 id="非对称双线性配对"><a href="#非对称双线性配对" class="headerlink" title="非对称双线性配对"></a>非对称双线性配对</h3><p>设计密码体制时，有时会遇到非对称的配对。</p><p>令$G_1, G_2, G_T$为具有相同阶p的群，P为$G_1$的生成元，Q为$G_2$的生成元。非对称双线性配对指满足下列性质的一个映射：$e: G_1 \times G_2 \rightarrow G_T$。</p><ul><li>双线性性：对于任意$(S, T) \in G_1 \times G_2$和$a, b \in Z_p^*$，$e(aS, bT) = e(S, T)^{ab}$成立。</li><li>非退化性：存在$(S, T) \in G_1 \times G_2$，使得$e(S, T) \neq 1$。</li><li>可计算性：对于所有的$(S, T) \in G_1 \times G_2$，存在有效算法计算$e(S, T)$。</li><li>存在一个有效的、可公开计算的同构映射$\phi:G_2 \rightarrow G_1$，满足$\phi(Q) = P$。这个映射必须是不可逆的。</li></ul><p>若令$G_2 = G_1$且映射$\phi$为恒等映射，此时非对称配对就变成了对称配对。尽管对称配对比较简单且应用方便，但只能从超奇异超椭圆曲线中的Weil配对或Tate配对推导出来。非对称配对比较复杂，但不仅可以从超奇异超椭圆曲线中推导出来，还可以从普通椭圆曲线中的Weil配对或Tate配对推导出来。</p><h2 id="0x03-困难问题"><a href="#0x03-困难问题" class="headerlink" title="0x03 困难问题"></a>0x03 困难问题</h2><h3 id="计算Diffie-Hellman问题"><a href="#计算Diffie-Hellman问题" class="headerlink" title="计算Diffie-Hellman问题"></a>计算Diffie-Hellman问题</h3><p>给定一个阶为p的循环加法群$G_1$和一个生成元P，$G_1$中的计算Diffie-Hellman（computational Diffie-Hellman，CDH）问题是给定$(P, aP, bP)$，计算$abP \in G_1$。这里$a, b \in Z_p^*$是未知整数。</p><h3 id="判定Diffie-Hellman问题"><a href="#判定Diffie-Hellman问题" class="headerlink" title="判定Diffie-Hellman问题"></a>判定Diffie-Hellman问题</h3><p>给定一个阶为p的循环加法群$G_1$和一个生成元P，$G_1$中的判定Diffie-Hellman（decisional Diffie-Hellman，DDH）问题是给定$(P, aP, bP, cP)$，判断$c \equiv ab mod p$是否成立。这里$a, b, c \in Z_p^*$是未知整数。若$(P, aP, bP, cP)$满足上述条件，则称其为一个”Diffie-Hellman元组”，可采用记号$cP = DH_p(aP, bP)$来表示。</p><h3 id="间隙Diffie-Hellman问题"><a href="#间隙Diffie-Hellman问题" class="headerlink" title="间隙Diffie-Hellman问题"></a>间隙Diffie-Hellman问题</h3><p>给定一个阶为p的循环加法群$G_1$和一个生成元P，$G_1$中的间隙Diffie-Hellman（gap Diffie-Hellman，GDH）问题是在DDH预言机的帮助下，求解一个给定元组$(P, aP, bP)$的CDH问题。DDH预言机可以判断$(P, aP, bP, cP)$是否满足$c \equiv ab mod p$。</p><h3 id="q-强Diffie-Hellman问题"><a href="#q-强Diffie-Hellman问题" class="headerlink" title="q-强Diffie-Hellman问题"></a>q-强Diffie-Hellman问题</h3><p>给定一个阶为p的循环加法群$G_1$和一个生成元P，$G_1$中的q-强Diffie-Hellman（q-strong Diffie-Hellman，q-SDH）问题是给定$(P, xP, x^2P, … , x^qP)$，计算</p><script type="math/tex; mode=display">(c, P/(x+c)) \in Z_p \times G_1</script><h3 id="双线性Diffie-Hellman问题"><a href="#双线性Diffie-Hellman问题" class="headerlink" title="双线性Diffie-Hellman问题"></a>双线性Diffie-Hellman问题</h3><p>给定两个阶都为p的循环加法群$G_1$和循环乘法群$G_T$，一个双线性映射$e:G_1 \times G_1 \rightarrow G_T$和一个群$G_1$的生成元P，双线性Diffie-Hellman（bilinear Diffie-Hellman，BDH）问题是给定$(P, aP, bP, cP)$，计算$e(P, P)^{abc} \in G_T$。这里的$a, b, c \in Z_p^*$是未知整数。</p><h3 id="判定双线性Diffie-Hellman问题"><a href="#判定双线性Diffie-Hellman问题" class="headerlink" title="判定双线性Diffie-Hellman问题"></a>判定双线性Diffie-Hellman问题</h3><p>给定两个阶都为p的循环加法群$G_1$和循环乘法群$G_T$，一个双线性映射$e:G_1 \times G_1 \rightarrow G_T$和一个群$G_1$的生成元P，判定双线性Diffie-Hellman（decisional bilinear Diffie-Hellman，DBDH）问题是给定$(P, aP, bP, cP)$和$z \in G_T$，判断</p><script type="math/tex; mode=display">z = e(P, P)^{abc}</script><p>是否成立。这里的$a, b, c \in Z_p^*$是未知整数。</p><h3 id="间隙双线性Diffie-Hellman问题"><a href="#间隙双线性Diffie-Hellman问题" class="headerlink" title="间隙双线性Diffie-Hellman问题"></a>间隙双线性Diffie-Hellman问题</h3><p>给定两个阶都为p的循环加法群$G_1$和循环乘法群$G_T$，一个双线性映射$e:G_1 \times G_1 \rightarrow G_T$和一个群$G_1$的生成元P，间隙双线性Diffie-Hellman（gap bilinear Diffie-Hellman，GBDH）问题是在DBDH预言机的帮助下，求解一个给定元组$(P, aP, bP, cP)$的BDH问题。DBDH预言机可以判断一个元组$(P, aP, bP, cP, z)$是否满足</p><script type="math/tex; mode=display">z = e(P, P)^{abc}</script><p>上述问题通常被视为困难问题，但其困难程度不尽相同。显然，判定问题不比计算问题更难，即如果能够求解CDH问题，那么DDH问题就容易解决；同样如果能够求解BDH问题，那么DBDH问题就容易解决。</p><h2 id="0x04-JPBC库"><a href="#0x04-JPBC库" class="headerlink" title="0x04 JPBC库"></a>0x04 JPBC库</h2><p>PBC库（pairing-based cryptography library）是斯坦福大学研究人员开发的一个免费可移植C语言库。它通过提供一个抽象的接口，使程序设计人员可以不必考虑具体的数学细节，甚至不必考虑椭圆曲线和数论的相关知识就可以实现基于配对的密码体制。JPBC库（Java Pairing-Based Cryptography Library）是对PBC库的Java封装，常用于基于配对的密码学算法仿真程序编写中。</p><p>该库提供的各类API结构如下。</p><p><img src="/2021/07/05/基于配对的密码学——基础知识及JPBC库/5.PNG" alt="API Structure"></p><h3 id="入门教程"><a href="#入门教程" class="headerlink" title="入门教程"></a>入门教程</h3><p>除JPBC文档外，整理一些优秀视频及技术博客，链接如下：</p><p><a href="https://www.bilibili.com/video/av456320837/" target="_blank" rel="noopener">JPBC库（基于配对的密码学）入门和避坑指南</a></p><p><a href="https://www.bilibili.com/video/BV1jA41147vt" target="_blank" rel="noopener">JPBC库应用之BLS签名</a></p><p><a href="https://blog.csdn.net/qq_41359358/category_10659429.html" target="_blank" rel="noopener">CSDN JPBC Library 专栏</a></p><p><a href="https://blog.csdn.net/liuweiran900217" target="_blank" rel="noopener">刘巍然大佬的博客</a></p><h3 id="群上点的特性"><a href="#群上点的特性" class="headerlink" title="群上点的特性"></a>群上点的特性</h3><p>JPBC库共提供四个循环群，其中$G_1,G_2,G_T$均为阶为p的乘法循环群，而$Z_p$为整数域上的加法循环群。乘法循环群上的点是z值为0的椭圆曲线上的点，而整数循环群上的点是数，二者均可抽象为<code>Element</code>数据类型并用于仿真中。生成测试元素并打印，结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成测试元素</span></span><br><span class="line">Element g1 = G1.newRandomElement();</span><br><span class="line">System.out.println(g1);</span><br><span class="line">Element g2 = G2.newRandomElement();</span><br><span class="line">System.out.println(g2);</span><br><span class="line">Element gt = Gt.newRandomElement();</span><br><span class="line">System.out.println(gt);</span><br><span class="line">Element zp = Zr.newRandomElement();</span><br><span class="line">System.out.println(zp);</span><br></pre></td></tr></table></figure><p><img src="/2021/07/05/基于配对的密码学——基础知识及JPBC库/1.PNG" alt="Characteristic of point in group"></p><h3 id="群运算"><a href="#群运算" class="headerlink" title="群运算"></a>群运算</h3><p>JPBC库支持的运算如下：</p><ul><li>$G_1,G_2,G_T$中元素的模幂运算、倍乘运算以及互相之间的加法运算，运算结果均为对应群上的元素。</li><li>$Z_p$中元素的加减乘除运算及乘方运算，运算结果为整数循环群上的元素。</li></ul><p>测试相关运算，并打印对应结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相关运算</span></span><br><span class="line">Element a = Zr.newRandomElement();</span><br><span class="line">Element b = Zr.newRandomElement();</span><br><span class="line"><span class="comment">// 1. g1^a</span></span><br><span class="line">Element g1_pow_a = g1.duplicate().powZn(a);</span><br><span class="line">System.out.println(<span class="string">"g1^a"</span>);</span><br><span class="line">System.out.println(g1_pow_a);</span><br><span class="line"><span class="comment">// 2. a*g1</span></span><br><span class="line">Element g1_mul_a = g1.duplicate().mulZn(a);</span><br><span class="line">System.out.println(<span class="string">"a*g1"</span>);</span><br><span class="line">System.out.println(g1_mul_a);</span><br><span class="line"><span class="comment">// 3. g1+g2</span></span><br><span class="line">Element g1_add_g2 = g1.duplicate().add(g2);</span><br><span class="line">System.out.println(<span class="string">"g1+g2"</span>);</span><br><span class="line">System.out.println(g1_add_g2);</span><br><span class="line"><span class="comment">// 4. gt^b</span></span><br><span class="line">Element gt_pow_b = gt.duplicate().powZn(b);</span><br><span class="line">System.out.println(<span class="string">"gt^b"</span>);</span><br><span class="line">System.out.println(gt_pow_b);</span><br><span class="line"><span class="comment">// 5. b*gt</span></span><br><span class="line">Element gt_mul_b = gt.duplicate().mulZn(b);</span><br><span class="line">System.out.println(<span class="string">"b*gt"</span>);</span><br><span class="line">System.out.println(gt_mul_b);</span><br><span class="line"><span class="comment">// 6. gt+gt</span></span><br><span class="line">Element gt_add_gt = gt.duplicate().add(gt);</span><br><span class="line">System.out.println(<span class="string">"gt+gt"</span>);</span><br><span class="line">System.out.println(gt_add_gt);</span><br><span class="line"><span class="comment">// 7. a+b</span></span><br><span class="line">Element a_add_b = a.duplicate().add(b);</span><br><span class="line">System.out.println(<span class="string">"a+b"</span>);</span><br><span class="line">System.out.println(a_add_b);</span><br><span class="line"><span class="comment">// 8. a*b</span></span><br><span class="line">Element a_mul_b = a.duplicate().mulZn(b);</span><br><span class="line">System.out.println(<span class="string">"a*b"</span>);</span><br><span class="line">System.out.println(a_mul_b);</span><br></pre></td></tr></table></figure><p><img src="/2021/07/05/基于配对的密码学——基础知识及JPBC库/2.PNG" alt="2.PNG-77.4kB"></p><p><strong>值得注意的是</strong>，现在的密码学相关论文中，习惯将$G_1, G_2$设置为乘法循环群。但是基于椭圆曲线的双线性群构造中，$G_1, G_2$是加法循环群。所以在2005年以前的论文中，双线性群一般写成加法群的形式。JPBC库中将$G_1, G_2$表示成了乘法循环群，因此在加法循环群形式方案的仿真过程中，应特别注意将加法群改写为乘法群的写法再完成进一步仿真。由于加法群中的加法运算对应乘法群中的乘法运算，减法运算对应除法运算（即求逆元），乘法运算对应幂指数运算，而除法运算对应对数运算。故改写过程需要结合以上运算法则。</p><h3 id="初始化双线性群"><a href="#初始化双线性群" class="headerlink" title="初始化双线性群"></a>初始化双线性群</h3><p>双线性群（即椭圆曲线）的初始化在JPBC中表现为对Pairing对象的初始化。JPBC库支持A、A1、D、E、F、G六种椭圆曲线，对比如下。我们可以通过代码动态产生和从文件中读取相关参数这两种方法完成上述初始化过程。</p><p><img src="/2021/07/05/基于配对的密码学——基础知识及JPBC库/4.PNG" alt="4.PNG-38.7kB"></p><h4 id="代码动态产生"><a href="#代码动态产生" class="headerlink" title="代码动态产生"></a>代码动态产生</h4><p>动态产生的方法大概包括以下几个步骤：</p><ul><li>指定椭圆曲线的种类</li><li>产生椭圆曲线参数</li><li>初始化Pairing对象</li></ul><p>Type A曲线初始化过程中需要提供两个参数：<code>rBit</code>代表$Z_p$中阶数p的比特长度，<code>qBit</code>代表$G$中阶数的比特长度，生成代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TypeACurveGenerator pg = <span class="keyword">new</span> TypeACurveGenerator(rBit, qBit);</span><br><span class="line">PairingParameters typeAParams = pg.generate();</span><br><span class="line">Pairing bp = PairingFactory.getPairing(typeAParams);</span><br></pre></td></tr></table></figure><p>Type A1曲线需要提供两个参数：<code>numPrime</code>是阶数N中包含质数因子的数量，<code>qBit</code>是每个质数因子的比特长度。由于Type A1曲线涉及到的阶数较大，故参数产生的时间较长，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TypeA1CurveGenerator pg = <span class="keyword">new</span> TypeA1CurveGenerator(numPrime, qBit);</span><br><span class="line">PairingParameters typeA1Params = pg.generate();</span><br><span class="line">Pairing pairing = PairingFactory.getPairing(typeA1Params);</span><br></pre></td></tr></table></figure><h4 id="文件读取产生"><a href="#文件读取产生" class="headerlink" title="文件读取产生"></a>文件读取产生</h4><p>当然我们可以选择事先生成参数并存放至文件中。在后续初始化过程中直接从文件中读取参数，就可以快速地完成双线性群的初始化过程。</p><p>可以利用Princeton大学封装的文件输出库将初始化后的椭圆曲线对象<code>PairingParameters</code>封装至<code>x.properties</code>文件中。后续使用过程中直接从对应配置文件中读取即可还原。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type A曲线</span></span><br><span class="line">TypeACurveGenerator pg = <span class="keyword">new</span> TypeACurveGenerator(rBit, qBit);</span><br><span class="line"><span class="comment">// Type A1曲线</span></span><br><span class="line">TypeA1CurveGenerator pg = <span class="keyword">new</span> TypeA1CurveGenerator(numPrimes, qBit);</span><br><span class="line">PairingParameters typeAParams = pg.generate();</span><br><span class="line"><span class="comment">//将参数写入文件a.properties中，使用Princeton大学封装的文件输出库</span></span><br><span class="line">Out out = <span class="keyword">new</span> Out(<span class="string">"a.properties"</span>);</span><br><span class="line">out.println(typeAParams);</span><br><span class="line"><span class="comment">//从文件a.properties中读取参数初始化双线性群</span></span><br><span class="line">Pairing pairing = PairingFactory.getPairing(<span class="string">"a.properties"</span>);</span><br></pre></td></tr></table></figure><h3 id="随机数内部机制"><a href="#随机数内部机制" class="headerlink" title="随机数内部机制"></a>随机数内部机制</h3><p>重点关注椭圆曲线循环群初始化过程中的相关事项。当确定椭圆曲线参数后重复调用<code>getG1()</code>，<code>newElement()</code>和<code>newRandomElement()</code>方法，验证生成结果是否相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Group_Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Pairing bp = PairingFactory.getPairing(<span class="string">"a.properties"</span>);</span><br><span class="line">        Field G1 = bp.getG1();</span><br><span class="line">        Field G3 = bp.getG1();</span><br><span class="line"></span><br><span class="line">        Element g_1 = G1.newElement();</span><br><span class="line">        Element g_2 = G1.newElement();</span><br><span class="line"></span><br><span class="line">        Element g_3 = G1.newRandomElement();</span><br><span class="line">        Element g_4 = G1.newRandomElement();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(G1.equals(G3))&#123;</span><br><span class="line">            System.out.println(<span class="string">"YES1!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"Nope!!!"</span>);</span><br><span class="line">        <span class="keyword">if</span>(g_1.equals(g_2))&#123;</span><br><span class="line">            System.out.println(<span class="string">"YES2!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"Nope!!!"</span>);</span><br><span class="line">        <span class="keyword">if</span>(g_3.equals(g_4))&#123;</span><br><span class="line">            System.out.println(<span class="string">"YES3!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"Nope!!!"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行以上程序，结果如下：</p><p><img src="/2021/07/05/基于配对的密码学——基础知识及JPBC库/3.PNG" alt="3.PNG-14kB"></p><p>可以看出，使用<code>PairingFactory.getPairing(filename)</code>函数导入特定参数的椭圆曲线后，每次调用<code>getG1()</code>函数生成的循环群都是相同的，故可以通过保存椭圆曲线参数至<code>xxx.properties</code>文件并导入这一操作实现循环群的保存。</p><p>对于群$G_1$，每次调用<code>G1.newElement()</code>函数生成的生成元g都是相同的。然而调用<code>G1.newRandomElement()</code>函数随机获取的群上元素则是不同的。</p><h3 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h3><p>该部分总结利用JPBC库编写算法仿真程序过程中需要用到的工具函数。代码如下：</p><h4 id="String-amp-Byte"><a href="#String-amp-Byte" class="headerlink" title="String&amp;Byte"></a>String&amp;Byte</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//16进制的byte[]数组转换为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hexBytesToString</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] hexChars = <span class="keyword">new</span> <span class="keyword">char</span>[bytes.length * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bytes.length; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = bytes[j] &amp; <span class="number">0xFF</span>;</span><br><span class="line">        hexChars[j * <span class="number">2</span>] = HEX_ARRAY[v &gt;&gt;&gt; <span class="number">4</span>];</span><br><span class="line">        hexChars[j * <span class="number">2</span> + <span class="number">1</span>] = HEX_ARRAY[v &amp; <span class="number">0x0F</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(hexChars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//16进制的字符串转换为byte[]数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] hexStringToBytes(String s) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[len / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span>) &#123;</span><br><span class="line">        data[i / <span class="number">2</span>] = (<span class="keyword">byte</span>) ((Character.digit(s.charAt(i), <span class="number">16</span>) &lt;&lt; <span class="number">4</span>)                             + Character.digit(s.charAt(i+<span class="number">1</span>), <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取特定元素"><a href="#获取特定元素" class="headerlink" title="获取特定元素"></a>获取特定元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//G1中获取随机元素，获取1，获取0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">getRandomFromG1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pairing.getG1().newRandomElement().getImmutable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">getOneFromG1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pairing.getG1().newOneElement().getImmutable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">getZeroFromG1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pairing.getG1().newZeroElement().getImmutable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Zr中获取随机元素，获取1，获取0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">getRandomFromZp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pairing.getZr().newRandomElement().getImmutable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">getOneFromZp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pairing.getZr().newOneElement().getImmutable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">getZeroFromZp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pairing.getZr().newZeroElement().getImmutable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="哈希映射"><a href="#哈希映射" class="headerlink" title="哈希映射"></a>哈希映射</h4><ul><li><p>$H_0: {0, 1}^* \rightarrow Z_p $</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">hashFromStringToZp</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pairing.getZr().newElement().setFromHash(str.getBytes(), <span class="number">0</span>, str.length()).getImmutable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">hashFromBytesToZp</span><span class="params">( <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pairing.getZr().newElement().setFromHash(bytes, <span class="number">0</span>, bytes.length).getImmutable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>$H_1: {0, 1}^* \rightarrow G_1$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">hashFromStringToG1</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pairing.getG1().newElement().setFromHash(str.getBytes(), <span class="number">0</span>, str.length()).getImmutable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">hashFromBytesToG1</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pairing.getG1().newElement().setFromHash(bytes, <span class="number">0</span>, bytes.length).getImmutable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>$H_2: G_1 \rightarrow Z_p$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">hashFromG1ToZp</span><span class="params">( Element g1_element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// h(y) : G1 -&gt; Zp</span></span><br><span class="line">    <span class="keyword">byte</span>[] g1_bytes = g1_element.getImmutable().toCanonicalRepresentation();       <span class="keyword">byte</span>[] zp_bytes = g1_bytes;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MessageDigest hasher = MessageDigest.getInstance(<span class="string">"SHA-512"</span>);</span><br><span class="line">        zp_bytes = hasher.digest(g1_bytes);   <span class="comment">//先把G1元素hash成512bits</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再把hash后的bits映射到Zp</span></span><br><span class="line">    Element hash_result = pairing.getZr().newElementFromHash(zp_bytes, <span class="number">0</span>, zp_bytes.length).getImmutable();</span><br><span class="line">    <span class="keyword">return</span> hash_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>$H_{ch}: G_T \rightarrow Z_p$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">transformFromGtToZp</span><span class="params">(Element pairing_result)</span></span>&#123;  </span><br><span class="line">    BigInteger pairing_params = pairing_result.toBigInteger();</span><br><span class="line">    <span class="keyword">return</span> pairing.getZr().newElement().set(pairing_params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Element-I-O"><a href="#Element-I-O" class="headerlink" title="Element I/O"></a>Element I/O</h4><ul><li><p>定义<code>writeElement(Element elem, String filename, Pairing pairing)</code>函数，实现将<code>Element</code>对象写入文件。该函数的三个参数分别为待写入的<code>Element</code>对象，写入文件路径以及对象所在椭圆曲线。返回结果为<code>void</code>类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeElement</span><span class="params">(Element elem, String filename, Pairing pairing)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DataOutputStream dOut = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"Parameters_file/"</span>+filename+<span class="string">".dat"</span>));  </span><br><span class="line">    dOut.writeBoolean(elem == <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (elem == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dOut.writeInt(pairing.getFieldIndex(elem.getField()));</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = elem.toBytes();</span><br><span class="line">    dOut.writeInt(bytes.length);</span><br><span class="line">    dOut.write(bytes);</span><br><span class="line">    <span class="comment">// this is a workaround because it.unisa.dia.gas.plaf.jpbc.field.curve.CurveElement does not serialize the infFlag</span></span><br><span class="line">    dOut.writeBoolean(elem <span class="keyword">instanceof</span> CurveElement &amp;&amp; elem.isZero());</span><br><span class="line">    <span class="keyword">if</span> (elem <span class="keyword">instanceof</span> CurveElement &amp;&amp; elem.isZero()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Infinite element detected. They should not happen."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义<code>readElement(String filename, Pairing pairing)</code>函数，实现从文件中读取<code>Element</code>对象。该函数的两个参数为读取文件路径和对象所在椭圆曲线，返回结果为<code>Element</code>类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">readElement</span><span class="params">(String filename, Pairing pairing)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DataInputStream dIn = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"Parameters_file/"</span>+filename+<span class="string">".dat"</span>));</span><br><span class="line">    <span class="keyword">if</span> (dIn.readBoolean()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> fieldIndex = dIn.readInt(); <span class="comment">// <span class="doctag">TODO:</span> check if this is in a sensible range</span></span><br><span class="line">    <span class="keyword">int</span> length = dIn.readInt(); <span class="comment">// <span class="doctag">TODO:</span> check if this is in a sensible range</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">    dIn.readFully(bytes); <span class="comment">// throws an exception if there is a premature EOF </span></span><br><span class="line">    Element e = pairing.getFieldAt(fieldIndex).newElementFromBytes(bytes);        <span class="comment">// this is a workaround because it.unisa.dia.gas.plaf.jpbc.field.curve.CurveElement does not serialize the infFlag</span></span><br><span class="line">    <span class="keyword">boolean</span> instOfCurveElementAndInf = dIn.readBoolean();</span><br><span class="line">    <span class="keyword">if</span> (instOfCurveElementAndInf) &#123;</span><br><span class="line">        <span class="comment">//e.setToZero(); // according to the code this simply sets the infFlag to 1</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"The point is infinite. This shouldn't happen."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="函数运行效率"><a href="#函数运行效率" class="headerlink" title="函数运行效率"></a>函数运行效率</h3><p>结合文章《jPBC: java Pairing Based Cryptography》，比较jPBC和PBC之间的运算效率。用于比较效率的计算机配置为Intel@R CoreTM2 Quad CPU Q6600，2.40GHz，3 GB 内存，Ubuntu 10.04系统。JDK版本是Oracle jdk1.6.0 20。结果如下。</p><p><img src="/2021/07/05/基于配对的密码学——基础知识及JPBC库/6.PNG" alt="6.PNG-72.8kB"></p><p>可以看出，由于Java语言特性的限制，JPBC库在处理乘法循环群上运算及配对运算方面效率远低于PBC库，但在处理整数循环群上运算方面效率高于PBC库。显然，可以通过预处理的方法提高JPBC库对应函数的运行效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;本科毕业设计过程中需要使用JPBC库实现Java语言下双线性配对运算的仿真，摸索过程中遇到一些问题及
      
    
    </summary>
    
      <category term="Crypto_Knowledge" scheme="https://blank-vax.github.io/categories/Crypto-Knowledge/"/>
    
    
      <category term="JPBC" scheme="https://blank-vax.github.io/tags/JPBC/"/>
    
      <category term="Pairing Based Cryptography" scheme="https://blank-vax.github.io/tags/Pairing-Based-Cryptography/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer刷题记录（一）</title>
    <link href="https://blank-vax.github.io/2021/02/04/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://blank-vax.github.io/2021/02/04/剑指offer刷题记录（一）/</id>
    <published>2021-02-03T16:39:00.000Z</published>
    <updated>2021-07-07T12:45:55.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>寒假赋闲在家，搞科研的同时希望提升一下自己的代码水平，于是回到阔别已久的LeetCode平台开始刷题。这次选择了剑指offer系列题目，编程语言采用Java。话不多说，直接开刷。</p><h2 id="0x01-数组中重复的数字"><a href="#0x01-数组中重复的数字" class="headerlink" title="0x01 数组中重复的数字"></a>0x01 数组中重复的数字</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3</span><br></pre></td></tr></table></figure><p>限制：</p><p><code>2 &lt;= n &lt;= 100000</code></p><h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><p>题目仅要求输出一个多次出现的数字，故自然联想到使用哈希表。完成建表之后对题目提供的数组进行一次遍历即可。该方法时间复杂度为O(N)，空间复杂度为哈希表所占的额外空间O(N)。</p><p>注意题目给出的特殊条件：<strong>长度为n的数组里所有数字在0—n-1范围内</strong>。该条件说明若数组中不包含重复元素，则数组下标与元素值是一一对应的关系，即<code>nums[i]==i</code>成立。于是引入原地置换的算法，提升程序运行效率，具体算法如下：</p><p>遍历数组nums，设置初始索引为i=0：</p><ul><li>若<code>nums[i] == i</code>，说明数字与索引位置正确对应，无需交换，跳过该索引；</li><li>若<code>nums[nums[i]] == nums[i]</code>，说明索引nums[i]及索引i处元素值相同，返回该重复值即可；</li><li>否则交换索引为i和nums[i]的元素值，将此数字交换至对应索引的位置。</li></ul><p>若遍历完毕尚未返回任何值，则返回-1表示元素与索引一一对应。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] != i)&#123;</span><br><span class="line">                <span class="keyword">int</span> m = nums[i];</span><br><span class="line">                <span class="keyword">if</span>(nums[m] == m)&#123;</span><br><span class="line">                    <span class="keyword">return</span> m;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    temp = nums[m];</span><br><span class="line">                    nums[m] = nums[i];</span><br><span class="line">                    nums[i] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度$O(N)$。</li><li>空间复杂度$O(1)$：该算法提供原地置换，无需开辟新的存储空间。</li></ul><h2 id="0x02-二维数组中的查找"><a href="#0x02-二维数组中的查找" class="headerlink" title="0x02 二维数组中的查找"></a>0x02 二维数组中的查找</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>示例:</p><p>现有矩阵 matrix 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>给定 target = 5，返回<code>true</code>。</p><p>给定 target = 20，返回<code>false</code>。</p><p>限制：</p><p><code>0 &lt;= n &lt;= 1000</code></p><p><code>0 &lt;= m &lt;= 1000</code></p><h3 id="算法详解-1"><a href="#算法详解-1" class="headerlink" title="算法详解"></a>算法详解</h3><p>该题目将普通元素查找扩展至二维数组，最简单的方法为两次循环遍历，时间复杂度为O(N*M)，其中N，M分别为二维数组的行数与列数。显然该解法没有用到矩阵<strong>从上至下递增，从左至右递增</strong>的特点，故不是最优解。</p><p>我们将矩阵逆时针旋转45°，可以发现其结构类似二叉搜索树，对每个元素来说，左分支元素更小而右分支元素更大。因此我们从根节点开始搜索，遇到大于目标元素的元素则向左继续搜索，反之则向右继续搜索，最终获得目标元素。</p><p><img src="/2021/02/04/剑指offer刷题记录（一）/1.PNG" alt="剑指offer-04.PNG-107.2kB"></p><p>结合以上思想，我们进行合理转化：<strong>根节点</strong>对应矩阵<strong>右上角的元素</strong>。具体算法如下：</p><ul><li>从矩阵右上角元素开始遍历，同时与目标值target进行对比；</li><li>若<code>matrix[row_index][column_index] &gt; target</code>，消去第<code>column_index</code>列元素；</li><li>若<code>matrix[row_index][column_index] &lt; target</code>，消去第<code>row_index</code>行元素；</li><li>若<code>matrix[row_index][column_index] == target</code>，找到目标。</li></ul><p>该算法选择从右上角开始遍历，需要注意下标范围及二维数组空判断问题。</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> column_index = matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row_index&gt;=<span class="number">0</span>&amp;&amp;row_index&lt;matrix.length&amp;&amp;column_index&gt;=<span class="number">0</span>&amp;&amp;column_index&lt;matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row_index][column_index]== target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[row_index][column_index] &gt; target)&#123;</span><br><span class="line">                column_index--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[row_index][column_index] &lt; target)&#123;</span><br><span class="line">                row_index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度$O(M+N)$：其中N和M分别代表矩阵的行数和列数，算法最多循环N+M次；</li><li>空间复杂度$O(1)$：i，j指针使用常数大小的额外空间。</li></ul><h2 id="0x03-替换空格"><a href="#0x03-替换空格" class="headerlink" title="0x03 替换空格"></a>0x03 替换空格</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure><p>限制：</p><p><code>0 &lt;= s 的长度 &lt;= 10000</code></p><h3 id="算法详解-2"><a href="#算法详解-2" class="headerlink" title="算法详解"></a>算法详解</h3><p>根据题目要求，最简单的方法是采用String类自带的替换函数<code>replaceAll()</code>，当然面试官肯定不会允许。于是就需要自己研究替换函数。注意到Java中String类型使用final关键词修饰，即String对象是不可修改的，从而考虑两种方法：</p><ul><li>方法一：引入可修改的数据类型StringBuilder，最后使用<code>toString()</code>函数转换成String类型输出即可。</li><li>方法二：引入静态数组<code>char[]</code>，首先确定数组的长度为原始字符串的三倍（假设原始字符串全部由空格组成），随后采用双指针法循环遍历原始字符串和新的字符串，完成比较与添加字符的操作。</li></ul><h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="Method-1"><a href="#Method-1" class="headerlink" title="Method 1"></a>Method 1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">' '</span>) sb.append(<span class="string">"%20"</span>);</span><br><span class="line">            <span class="keyword">else</span> sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method-2"><a href="#Method-2" class="headerlink" title="Method 2"></a>Method 2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] final_result = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">3</span>*length];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">' '</span>)&#123;</span><br><span class="line">                final_result[j++] = <span class="string">'%'</span>;</span><br><span class="line">                final_result[j++] = <span class="string">'2'</span>;</span><br><span class="line">                final_result[j++] = <span class="string">'0'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                final_result[j++] = s.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(final_result, <span class="number">0</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>Method1</p><ul><li>时间复杂度$O(N)$。</li><li>空间复杂度$O(N)$：Java新建StringBuilder使用了线性大小的额外空间。</li></ul></li><li><p>Method2</p><ul><li>时间复杂度$O(N)$。</li><li>空间复杂度$O(1)$：由于是原地扩展字符串s的长度，因此使用$O(1)$的额外空间。</li></ul></li></ul><h2 id="0x04-从尾到头打印链表"><a href="#0x04-从尾到头打印链表" class="headerlink" title="0x04 从尾到头打印链表"></a>0x04 从尾到头打印链表</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure><p>限制：</p><p><code>0 &lt;= 链表长度 &lt;= 10000</code></p><h3 id="算法详解-3"><a href="#算法详解-3" class="headerlink" title="算法详解"></a>算法详解</h3><p>本题目为最基础的链表逆序问题，可采用两种不同的数据结构辅助完成：</p><ul><li>方法一：不引入栈而仅使用定长数组。由于Java中数组具有长度固定的特点，故首先需要遍历链表以获得结果数组的长度。建立对应长度数组后，采用从后向前逐位填充的方法完成逆序输出。</li><li>方法二：引入栈这一数据结构。由于栈具有LIFO的特点，只需通过进出操作就能实现链表逆序输出，将输出结果按序存入结果数组即可。</li></ul><h3 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="Method-1-1"><a href="#Method-1-1" class="headerlink" title="Method 1"></a>Method 1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="comment">// First get the length of the list</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="keyword">null</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Then create a result array with fixed length</span></span><br><span class="line">        <span class="keyword">int</span>[] result_array = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        <span class="comment">// Lastly reverse the linkedlist</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = count-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            result_array[j] = head.val;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result_array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method-2-1"><a href="#Method-2-1" class="headerlink" title="Method 2"></a>Method 2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="comment">// First create stack needed</span></span><br><span class="line">        Stack&lt;Integer&gt; tmp_stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            tmp_stack.push(temp.val);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Then create result array with fixed length</span></span><br><span class="line">        <span class="keyword">int</span>[] result_array = <span class="keyword">new</span> <span class="keyword">int</span>[tmp_stack.size()];</span><br><span class="line">        <span class="comment">// Lastly pop all the elements in this stack</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; result_array.length;j++)&#123;</span><br><span class="line">            result_array[j] = tmp_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result_array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>两种方法的时间复杂度与空间复杂度均为$O(N)$。</p><h2 id="0x05-重建二叉树"><a href="#0x05-重建二叉树" class="headerlink" title="0x05 重建二叉树"></a>0x05 重建二叉树</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>例如，给出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder = [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>限制：</p><p><code>0 &lt;= 节点个数 &lt;= 5000</code></p><h3 id="算法详解-4"><a href="#算法详解-4" class="headerlink" title="算法详解"></a>算法详解</h3><p>题目中给出前序遍历和中序遍历的结果数组。树结构中前序遍历遵循<code>根节点—&gt;左节点—&gt;右节点</code>的遍历顺序，中序遍历遵循<code>左节点—&gt;根节点—&gt;右节点</code>的遍历顺序，我们需要结合两次遍历的结果数组完成二叉树重构。基本方法如下：</p><p>递归函数将前序遍历结果数组<code>preorder[]</code>和中序遍历结果数组<code>inorder[]</code>作为输入参数，显然<code>preorder[0]</code>必为根节点。随后获取根节点对应元素在<code>inorder[]</code>数组中的位置（可通过构造函数和采用哈希表存储的方法），设为<code>target_index</code>。则在中序遍历数组中，<code>inorder[:target_index]</code>即为左子树，<code>inorder[target_inex:]</code>即为右子树；在前序遍历数组中，<code>preorder[1: 1+target_index-0]</code>为左子树（其中<code>target_index-0</code>表示从<code>inorder[]</code>数组中获取的左子树的长度），<code>preorder[target_index+1:]</code>为右子树。通过以上方法可以确定更新后的<code>preorder[]</code>数组和<code>inorder[]</code>数组，随后递归调用即可。</p><p>结合基本方法的分析，我们引入分治算法，通过递归对所有子树进行划分：</p><ul><li><p>递推参数：根节点在前序遍历的索引<code>root_index</code>，子树在中序遍历的左边界<code>left_bound</code>，子树在中序遍历的右边界<code>right_bound</code>；</p></li><li><p>终止条件：当<code>left_bound &gt; right_bound</code>，代表已经越过叶节点，此时返回null；</p></li><li><p>递推流程</p><ul><li><p>建立根节点<code>node</code>，节点值为<code>preorder[root_index]</code>；</p></li><li><p>划分左右子树：查找根节点在中序遍历结果数组<code>inorder[]</code>中的索引<code>target_index_in_inorder</code>；</p></li><li><p>开启左右子树递归，关键参数如下表所示：<br><img src="/2021/02/04/剑指offer刷题记录（一）/2.PNG" alt="剑指offer-子树重构.png-45.2kB"></p></li></ul></li><li><p>返回值：回溯返回<code>node</code>，作为上一层递归中根节点的左/右子节点</p></li></ul><p>值得注意的是，参数列表中<code>target_index_in_inorder - left_bound + root_index + 1</code>含义为：<code>根节点索引+左子树长度+1</code>，在中序遍历中该位置表示右子树的根节点。</p><h3 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="Method1-Fundational-Solution"><a href="#Method1-Fundational-Solution" class="headerlink" title="Method1 Fundational Solution"></a>Method1 Fundational Solution</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function is defined to get the index of root node in inorder-list</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findIndex</span><span class="params">(<span class="keyword">int</span>[] orderlist, <span class="keyword">int</span> target_value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;orderlist.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(orderlist[i] == target_value)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((preorder.length != inorder.length)||(preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>)||(preorder == <span class="keyword">null</span> || inorder == <span class="keyword">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> root_value = preorder[<span class="number">0</span>];</span><br><span class="line">        TreeNode root_node = <span class="keyword">new</span> TreeNode(root_value);</span><br><span class="line">        <span class="keyword">int</span> position = findIndex(inorder, root_value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get new preorder-list</span></span><br><span class="line">        <span class="keyword">int</span>[] preorder_left = Arrays.copyOfRange(preorder, <span class="number">1</span>, <span class="number">1</span>+position);</span><br><span class="line">        <span class="keyword">int</span>[] preorder_right = Arrays.copyOfRange(preorder, <span class="number">1</span>+position, preorder.length);</span><br><span class="line"><span class="comment">// Get new inorder-list</span></span><br><span class="line">        <span class="keyword">int</span>[] inorder_left = Arrays.copyOfRange(inorder, <span class="number">0</span>, position);</span><br><span class="line">        <span class="keyword">int</span>[] inorder_right = Arrays.copyOfRange(inorder, position+<span class="number">1</span>, inorder.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recurrsion starts</span></span><br><span class="line">        TreeNode node_left = buildTree(preorder_left, inorder_left);</span><br><span class="line">        TreeNode node_right = buildTree(preorder_right, inorder_right);</span><br><span class="line"></span><br><span class="line">        root_node.left = node_left;</span><br><span class="line">        root_node.right = node_right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method2-Solution-With-Hashmap"><a href="#Method2-Solution-With-Hashmap" class="headerlink" title="Method2 Solution With Hashmap"></a>Method2 Solution With Hashmap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This method can only be used in the construction of binary tree without duplicate nodes</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记中序遍历</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 保留先序遍历</span></span><br><span class="line">    <span class="keyword">int</span>[] preorder;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将索引结果对应填入哈希表map中，方便后续查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preorder = preorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;preorder.length;i++)&#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recurrsion(<span class="number">0</span>, <span class="number">0</span>, inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">recurrsion</span><span class="params">(<span class="keyword">int</span> root_index, <span class="keyword">int</span> left_bound, <span class="keyword">int</span> right_bound)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left_bound &gt; right_bound) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[root_index]);</span><br><span class="line">        <span class="keyword">int</span> target_index_in_inorder = map.get(preorder[root_index]);</span><br><span class="line">        root.left = recurrsion(root_index+<span class="number">1</span>, left_bound, target_index_in_inorder-<span class="number">1</span>);</span><br><span class="line">        root.right = recurrsion(root_index+<span class="number">1</span>+(target_index_in_inorder-left_bound), target_index_in_inorder+<span class="number">1</span>, right_bound);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>两种方法的时间复杂度与空间复杂度均为$O(N)$。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-di-gui-fa-qin/" target="_blank" rel="noopener">重建二叉树精选题解</a></p><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/" target="_blank" rel="noopener">重建二叉树官方题解</a></p><h2 id="0x06-用两个栈实现队列"><a href="#0x06-用两个栈实现队列" class="headerlink" title="0x06 用两个栈实现队列"></a>0x06 用两个栈实现队列</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数<code>appendTail</code>和<code>deleteHead</code>，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code>操作返回 -1 )</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= values &lt;= 10000</code></li><li>最多会对<code>appendTail</code>，<code>deleteHead</code>进行 10000 次调用</li></ul><h3 id="算法详解-5"><a href="#算法详解-5" class="headerlink" title="算法详解"></a>算法详解</h3><p>题目主要考察栈和队列这两种存储结构的功能区别。栈具有LIFO的特点，即入栈与出栈都是对栈顶位置的元素进行操作。而队列可以理解为普通数组，可同时实现头部与尾部两向的操作。</p><p>结合以上特性，我们采用下面的思路解决问题：</p><ul><li>使用栈结构存储队列数据，此时栈底元素对应队首元素，其无法直接删除，需要将上方所有元素出栈；</li><li>使用双栈可以实现列表倒序。假设非空栈A与空栈B，只需要将栈A弹出的元素依次压入栈B即可实现A列表倒序；</li><li>倒序后B执行出栈操作即相当于删除了A的栈底元素，即对应的队首元素。</li></ul><p>本题中要求实现构造函数<code>CQueue()</code>，加入队尾函数<code>appendTail()</code>与删除队首函数<code>deleteHead()</code>。</p><ul><li><code>CQueue()</code>：初始化两链表结构，分别代表栈A、B，用来实现加入队尾操作与元素倒序；</li><li><code>appendTail()</code>：将新元素加入栈A即可；</li><li><code>deleteHead()</code>：删除过程中存在以下三种情况：<ul><li>当栈B不为空，此时B中仍存在已完成倒序的元素，直接返回B的栈顶元素即可；</li><li>当栈A、B均为空，无元素，返回-1；</li><li>当栈A不为空，栈B为空，代表未进行倒序操作，此时需要将A中元素全部转移至B中，实现元素倒序并返回栈B栈顶元素即可。</li></ul></li></ul><h3 id="解题代码-5"><a href="#解题代码-5" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    LinkedList &lt;Integer&gt; A, B;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Stack A is used to store the elements by the order of pushment;</span></span><br><span class="line">        <span class="comment">// Stack B is used for reversing stack A.</span></span><br><span class="line">        A = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        A.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!B.isEmpty()) <span class="keyword">return</span> B.removeLast();</span><br><span class="line">        <span class="keyword">if</span>(A.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!A.isEmpty())&#123;</span><br><span class="line">            B.addLast(A.removeLast());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：<code>appendTail()</code>函数为$O(1)$；<code>deleteHead()</code>函数在N次队首元素删除操作中共需完成N个元素的倒序；</li><li>空间复杂度$O(N)$：最差情况下，栈A和B共保存N个元素。</li></ul><h2 id="0x07-斐波那契数列"><a href="#0x07-斐波那契数列" class="headerlink" title="0x07 斐波那契数列"></a>0x07 斐波那契数列</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p>提示：</p><p><code>0 &lt;= n &lt;= 100</code></p><h3 id="算法详解-6"><a href="#算法详解-6" class="headerlink" title="算法详解"></a>算法详解</h3><p>题目给出斐波那契数列的递推公式，说明其具有递推关系，选择<code>f(n+1) = f(n) + f(n-1)</code>为转移方程，采用动态规划完成问题求解：</p><ul><li>状态定义：设dp为一维数组，其中<code>dp[i]</code>的值代表斐波那契数列第i个数字；</li><li>转移方程：<code>dp[i+1] = dp[i] + dp[i-1]</code>；</li><li>初始状态：<code>dp[0] = 0, dp[1] = 1</code>；</li><li>返回值：<code>dp[n]</code>，即返回斐波那契数列的第n个数字。</li></ul><p>这里采用循环求余法简化运算过程。随着n的增大，<code>f(n)</code>会超过<code>Int32</code>甚至<code>Int64</code>的取值范围，从而导致结果溢出，故需要采用求余运算，规则如下：</p><p>设正整数x，y，p，求余符号为<code>mod</code>，则有<code>(x+y) mod p = (x mod p + y mod p) mod p</code>，从而<code>f(n) mod p = [f(n-1) mod p + f(n-2) mod p] mod p</code>。故只需在循环中每次计算sum = (a+b) mod 1000000007即可。</p><h3 id="解题代码-6"><a href="#解题代码-6" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (a+b) % <span class="number">1000000007</span>;</span><br><span class="line">            b = a;</span><br><span class="line">            a = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度$O(N)$：计算f(n)需要循环n次，每轮循环内计算操作使用$O(1)$;</li><li>空间复杂度$O(1)$：几个标志变量使用常数大小的额外空间。</li></ul><h2 id="0x08-青蛙跳台阶问题"><a href="#0x08-青蛙跳台阶问题" class="headerlink" title="0x08 青蛙跳台阶问题"></a>0x08 青蛙跳台阶问题</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>提示：</p><p><code>0 &lt;= n &lt;= 100</code></p><h3 id="算法详解-7"><a href="#算法详解-7" class="headerlink" title="算法详解"></a>算法详解</h3><p>本题目与斐波那契数列解题方法类似，只不过初始参数不同，可以通过普通动态规划和简化版动态规划解决问题，后者占用更少的空间资源。</p><h3 id="解题代码-7"><a href="#解题代码-7" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="Method1-General-DP"><a href="#Method1-General-DP" class="headerlink" title="Method1 General DP"></a>Method1 General DP</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[i] = (dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method2-Simple-Version"><a href="#Method2-Simple-Version" class="headerlink" title="Method2 Simple Version"></a>Method2 Simple Version</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (a+b) % <span class="number">1000000007</span>;</span><br><span class="line">            b = a;</span><br><span class="line">            a = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-7"><a href="#复杂度分析-7" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>Method1</p><p>时间与空间复杂度均为$O(N)$。</p></li><li><p>Method2</p><p>时间复杂度为$O(N)$，空间复杂度为$O(1)$。</p></li></ul><h2 id="0x09-旋转数组的最小数字"><a href="#0x09-旋转数组的最小数字" class="headerlink" title="0x09 旋转数组的最小数字"></a>0x09 旋转数组的最小数字</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h3 id="算法详解-8"><a href="#算法详解-8" class="headerlink" title="算法详解"></a>算法详解</h3><p>本题显然需要使用二分法，目标元素为旋转点元素，一般情况下满足以下条件：<strong>该元素值小于右侧元素，大于左侧元素</strong>。算法设计过程中需要考虑以下两个特殊情况：</p><ul><li>输入数组部分元素相同；</li><li>输入数组旋转后的结果与初始结果相同，均为全升序序列。</li></ul><p>二分法本身分以下三种情况讨论：</p><ul><li><code>nums[mid] &gt; nums[right]</code></li><li><code>nums[mid] &lt; nums[right]</code></li><li><code>nums[mid] == nums[right]</code></li></ul><p>具体题解参考如下链接：</p><p><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/" target="_blank" rel="noopener">旋转数组的最小数字（二分法，清晰图解）</a></p><p>需要注意的是，二分法过程中经常使用<code>mid = left + (left-right) / 2</code>来防止溢出。</p><h3 id="解题代码-8"><a href="#解题代码-8" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers.length == <span class="number">1</span>) <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right-left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid] &gt; numbers[right])&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &lt; numbers[right])&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-8"><a href="#复杂度分析-8" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度$O(log_{2}N)$：特例情况下会退化到$ O(N) $。</li><li>空间复杂度$O(1)$：i，j等变量使用常数大小的额外空间。</li></ul><h2 id="0x0a-矩阵中的路径"><a href="#0x0a-矩阵中的路径" class="headerlink" title="0x0a 矩阵中的路径"></a>0x0a 矩阵中的路径</h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><p>示例1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= board.length &lt;= 200</span><br><span class="line">1 &lt;= board[i].length &lt;= 200</span><br></pre></td></tr></table></figure><h3 id="算法详解-9"><a href="#算法详解-9" class="headerlink" title="算法详解"></a>算法详解</h3><p>题目为典型的矩阵搜索问题，可使用<code>深度优先搜索+剪枝</code>来解决。首先介绍下这两个概念：</p><ul><li>深度优先搜索（DFS）：该算法通过递归，先朝一个方向搜索至底部，再回溯到上个节点，沿另一个方向搜索，以此类推；</li><li>剪枝：在搜索过程中，遇到<code>此路无法和目标字符串匹配成功</code>的情况（例如，此矩阵元素和目标字符不同，此元素已被访问等），则应立即返回，此种方法成为<code>可行性剪枝</code>。</li></ul><p><img src="/2021/02/04/剑指offer刷题记录（一）/3.PNG" alt="剑指offer-12.png-31.1kB"></p><p>DFS过程如下：</p><ul><li>递归参数：当前元素在矩阵<code>board</code>中的行列索引<code>i</code>和<code>j</code>，当前目标字符在字符串<code>word</code>中的索引<code>k</code>。</li><li>终止条件：<ul><li>返回<code>false</code>：1）行或列索引出现越界<strong>或</strong>(2）当前矩阵元素与目标字符不同<strong>或</strong>(3）当前矩阵元素已被访问；</li><li>返回<code>true</code>：<code>k=len(word)-1</code>，代表字符串<code>word</code>已全部完成匹配。</li></ul></li><li>递推工作<ul><li>标记当前矩阵元素：将<code>board[i][j]</code>修改为 空字符<code>&#39;\0&#39;</code> ，代表此元素已访问过，防止之后搜索时重复访问。</li><li>搜索下一单元格：朝当前元素的 上、下、左、右 四个方向开启下层递归，使用<strong>或</strong>连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至<code>res</code> 。</li><li>还原当前矩阵元素： 将<code>board[i][j]</code>元素还原至初始值，即<code>word[k]</code>。</li></ul></li><li>返回值： 返回布尔量<code>res</code>，代表是否搜索到目标字符串。</li></ul><h3 id="解题代码-9"><a href="#解题代码-9" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key parameters: i represents row index, j represents column index, and k represents wordlist index.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, words, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] words, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((i &lt; <span class="number">0</span> || i &gt;= board.length) || (j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length) || board[i][j] != words[k]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == words.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        board[i][j] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">boolean</span> result = dfs(board, words, i, j+<span class="number">1</span>, k+<span class="number">1</span>) || dfs(board, words, i, j-<span class="number">1</span>, k+<span class="number">1</span>) || dfs(board, words, i+<span class="number">1</span>, j, k+<span class="number">1</span>)|| dfs(board, words, i-<span class="number">1</span>, j, k+<span class="number">1</span>);</span><br><span class="line">        board[i][j] = words[k];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-9"><a href="#复杂度分析-9" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假设M，N分别为矩阵的行列大小，K为字符串<code>word</code>的长度。</p><ul><li>时间复杂度$O(3^{K}MN)$：设字符串长度为K，搜索中每个字符有上、下、左、右四个方向可供选择，舍弃回头的方向，剩下三种选择，因此方案数的复杂度为$O(3^{K})$。矩阵共有MN个 起点，时间复杂度为$O(MN)$，故最差情况为二者乘积。</li><li>空间复杂度$O(K)$：搜索过程中递归深度不超过K，因此系统因函数调用累计使用的栈空间占用$O(K)$。</li></ul><h2 id="0x0b-机器人的运动范围"><a href="#0x0b-机器人的运动范围" class="headerlink" title="0x0b 机器人的运动范围"></a>0x0b 机器人的运动范围</h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 2, n = 3, k = 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 1, k = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= n,m &lt;= 100</span><br><span class="line">0 &lt;= k &lt;= 20</span><br></pre></td></tr></table></figure><h3 id="算法详解-10"><a href="#算法详解-10" class="headerlink" title="算法详解"></a>算法详解</h3><p>本题与上题类似，均为典型的搜索&amp;回溯问题。与上题不同的是，本题目的起点为<code>(0,0)</code>而非任意点，同时每次机器人运动方向只有<strong>向右</strong>和<strong>向下</strong>两个方向。可以采用广度优先搜索与深度优先搜索两种方法解题。可参考题解如下：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/mian-shi-ti-13-ji-qi-ren-de-yun-dong-fan-wei-dfs-b/" target="_blank" rel="noopener">机器人的运动范围（回溯算法，DFS/BFS）</a></p><h3 id="解题代码-10"><a href="#解题代码-10" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="Method1-DFS"><a href="#Method1-DFS" class="headerlink" title="Method1 DFS"></a>Method1 DFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> visited_position[][] = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(visited_position, m, n, <span class="number">0</span>, <span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[][] visited_position, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((i &gt;= m) || (j &gt;= n) || visited_position[i][j] || (sumCount(i) + sumCount(j) &gt; k))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        visited_position[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(visited_position, m, n, i+<span class="number">1</span>, j, k) + dfs(visited_position, m, n, i, j+<span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumCount</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index != <span class="number">0</span>)&#123;</span><br><span class="line">            sum += index % <span class="number">10</span>;</span><br><span class="line">            index /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method2-BFS"><a href="#Method2-BFS" class="headerlink" title="Method2 BFS"></a>Method2 BFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] tmp_list = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> i = tmp_list[<span class="number">0</span>], j = tmp_list[<span class="number">1</span>], s_i = tmp_list[<span class="number">2</span>], s_j = tmp_list[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span>((i &gt;= m) || (j &gt;= n) || visited[i][j] || (s_i + s_j &gt; k)) <span class="keyword">continue</span>;</span><br><span class="line">            visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            result += <span class="number">1</span>;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j+<span class="number">1</span>, s_i, sumCount(j+<span class="number">1</span>)&#125;);</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i+<span class="number">1</span>, j, sumCount(i+<span class="number">1</span>), s_j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumCount</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum_result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index != <span class="number">0</span>)&#123;</span><br><span class="line">            sum_result += index % <span class="number">10</span>;</span><br><span class="line">            index /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum_result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-10"><a href="#复杂度分析-10" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度$O(MN)$：最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为$O(MN)$；</li><li>空间复杂度$O(MN)$：最差情况下，布尔数组<code>visited</code>内存储矩阵所有单元格的索引，使用$O(MN)$的额外空间。</li></ul><h2 id="0x0c-剪绳子I"><a href="#0x0c-剪绳子I" class="headerlink" title="0x0c 剪绳子I"></a>0x0c 剪绳子I</h2><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m-1]</code> 。请问 <code>k[0]*k[1]*...*k[m-1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 &lt;= n &lt;= 58</span><br></pre></td></tr></table></figure><h3 id="算法详解-11"><a href="#算法详解-11" class="headerlink" title="算法详解"></a>算法详解</h3><h4 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h4><p>设将长度为n的绳子切为a段，满足：$n = n_{1} + n_{2} +… + n_{a}$，则本题等价于求解$max(n_{1}*n_{2}*…*n_{a})$。提出两个假设：1）当所有绳段长度相等时，乘积最大；2）最优的绳段长度为3。进行推导如下：</p><p>根据算术几何均值不等式：</p><script type="math/tex; mode=display">\frac{(n_{1}+n_{2}+...+n_{a})}{a} \ge \sqrt[a]{n_{1}*n_{2}*...*n_{a}}</script><p>当且仅当$n_{1} = n_{2} = … = n_{a}$时成立。故<strong>将绳子以相等的长度等分为多段，得到的乘积最大</strong>。</p><p>设将绳子按照x长度等分为a段，即n=a*x，则乘积为$x^{a}$。由于n为常数，满足$x^{a} = x^{\frac{n}{x}} = (x^{\frac{1}{x}})^{n}$。</p><p>构造函数$y = x^{\frac{1}{x}}$，对x求导得：</p><script type="math/tex; mode=display">y' = \frac{1-lnx}{x^{2}}*x^{\frac{1}{x}}</script><p>令y’=0，则1-lnx=0，得驻点$x_{0} = 2.7$且该点为极大值点。由于切分长度x必须为整数，分别带入最接近e的整数2或3，比较可知x=3时乘积达到最大。故<strong>尽可能将绳子以长度3等分为多段时，乘积最大</strong>。</p><p>结合以上分析，本算法流程如下：</p><ul><li>当<code>n &lt;= 3</code>时，按照数学推导不应切分，但由于题目要求必须剪成两段及以上，故此时返回<code>n-1</code>；</li><li>当<code>n &gt; 3</code>时，n可表示为<code>n = 3*a + b</code>，分别求出整数部分a和余数部分b。<ul><li>当<code>b == 0</code>时，返回<code>pow(3, a)</code>；</li><li>当<code>b == 1</code>时，需将一个<code>3+1</code>转换成<code>2+2</code>，因此返回<code>pow(3, a-1)*4</code>；</li><li>当<code>b === 2</code>时，返回<code>pow(3, a)*2</code>。</li></ul></li></ul><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul><li>状态定义：dp[i]表示长度为i的绳子剪短后的最大乘积；</li><li>初始状态：<code>dp[0]=1</code>，<code>dp[1]=1</code>；</li><li>状态转移方程：<code>dp[i] = Math.max(dp[i], Math.max(j*dp[i-j], j*(i-j)))</code>。对于循环到的长度i，假设将其剪成两段，一段长度为j，另一段为i-j。此时需要比较<code>j*(i-j)</code>与<code>j*(dp[i-j])</code>的大小，根据比较结果决定是否继续剪下去：若<code>j*(i-j) &gt; j*(dp[i-j])</code>，说明将长度为i的绳子剪成两段得到最大结果；否则说明需要继续分段，此时将切割长度从i转化为<code>i-j</code>。</li><li>返回值：<code>dp[n]</code>。</li></ul><h3 id="解题代码-11"><a href="#解题代码-11" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="Method1-Mathematical-Solution"><a href="#Method1-Mathematical-Solution" class="headerlink" title="Method1 Mathematical Solution"></a>Method1 Mathematical Solution</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = n / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a-<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method2-DP"><a href="#Method2-DP" class="headerlink" title="Method2 DP"></a>Method2 DP</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; i;j++)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-11"><a href="#复杂度分析-11" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>Method1<ul><li>时间复杂度$O(1)$：方法一仅包含求整、求余和次方运算。</li><li>空间复杂度$O(1)$：变量均使用常数大小的额外空间。</li></ul></li><li>Method2<ul><li>时间复杂度$O(N^{2})$：该方法需要进行两层嵌套循环，故时间复杂度为平方级别。</li><li>空间复杂度$O(N)$：开辟长度为n的数组。</li></ul></li></ul><h2 id="0x0d-剪绳子II"><a href="#0x0d-剪绳子II" class="headerlink" title="0x0d 剪绳子II"></a>0x0d 剪绳子II</h2><h3 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h3><p>本题目与剪绳子I的操作过程完全相同，唯一不同的是n的范围扩展至<code>2 &lt;= n &lt;= 1000</code>。结合上题分析可知，最终乘积呈现指数式增长，故考虑部分编程语言中<code>int32</code>甚至<code>int64</code>类型数据出现溢出的情况，要求最终结果需要进行模<code>1e9+7</code>的处理。</p><h3 id="算法详解-12"><a href="#算法详解-12" class="headerlink" title="算法详解"></a>算法详解</h3><p>本题目与上题基本思路相同，唯一区别为<code>需要进行模运算</code>。故引入快速幂乘法实现该运算。然而，由于模运算的存在无法进行动态规划，于是采用贪心算法解题。</p><h3 id="解题代码-12"><a href="#解题代码-12" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="Method1-Mathematical-Solution-1"><a href="#Method1-Mathematical-Solution-1" class="headerlink" title="Method1 Mathematical Solution"></a>Method1 Mathematical Solution</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> modular = (<span class="keyword">int</span>)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = n / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)fast_power(<span class="number">3</span>, a);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)(fast_power(<span class="number">3</span>, a-<span class="number">1</span>)*<span class="number">4</span> % modular);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (<span class="keyword">int</span>)(fast_power(<span class="number">3</span>, a)*<span class="number">2</span> % modular);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function is used to calculate pow(x, a)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">fast_power</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(a &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a%<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                result = (result * x) % <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            x %= <span class="number">1000000007</span>;</span><br><span class="line">            a /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method2-Greedy-Algorithm"><a href="#Method2-Greedy-Algorithm" class="headerlink" title="Method2 Greedy Algorithm"></a>Method2 Greedy Algorithm</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">4</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">4</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">long</span> final_result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mod_number = (<span class="keyword">int</span>)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            final_result *= <span class="number">3</span>;</span><br><span class="line">            final_result %= mod_number;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(final_result*n % mod_number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-12"><a href="#复杂度分析-12" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>Method1<ul><li>时间复杂度$O(log_{2}N)$：使用快速幂算法降低时间复杂度。</li><li>空间复杂度$O(1)$：变量使用常数大小的空间。</li></ul></li><li>Method2<ul><li>时间复杂度$O(N)$；</li><li>空间复杂度$O(1)$。</li></ul></li></ul><h2 id="0x0e-二进制中1的个数"><a href="#0x0e-二进制中1的个数" class="headerlink" title="0x0e 二进制中1的个数"></a>0x0e 二进制中1的个数</h2><h3 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &apos;1&apos;。</span><br></pre></td></tr></table></figure><p>提示：</p><p>输入必须是长度为 32 的 二进制串 。</p><h3 id="算法详解-13"><a href="#算法详解-13" class="headerlink" title="算法详解"></a>算法详解</h3><p>结合题目需求，可以采用<code>逐位判断</code>与<code>n&amp;(n-1)</code>两种方法。</p><h4 id="逐位判断"><a href="#逐位判断" class="headerlink" title="逐位判断"></a>逐位判断</h4><p>根据与运算定义，二进制数字n存在以下性质：</p><ul><li>若<code>n&amp;1 == 0</code>，则n<strong>最右一位</strong>为0；</li><li>若<code>n&amp;1 == 1</code>，则n<strong>最右一位</strong>为1。</li></ul><p>根据以上特点，考虑以下循环算法：</p><ul><li>若n最右一位是否为1，若为1则<code>count_result</code>自加1，否则<code>continue</code>；</li><li>本题要求把数字n看作无符号数，使用<strong>无符号右移一位</strong>（Java中为<code>&gt;&gt;&gt;</code>）。</li></ul><h4 id="运用n-amp-n-1"><a href="#运用n-amp-n-1" class="headerlink" title="运用n&amp;(n-1)"></a>运用n&amp;(n-1)</h4><p><code>(n-1)</code>运算：二进制数字n最右边的1变成0，随后此1右边的0都变成1;</p><p><code>n&amp;(n-1)</code>运算：二进制数字n最右边的1变成0，其余不变。</p><p>根据以上特点，考虑循环算法：</p><ul><li>循环消去最右边的1，当<code>n == 0</code>时跳出循环；</li><li>循环内部持续增加<code>count_result</code>，同时采用<code>n&amp;(n-1)</code>持续消去数字n最右边的1。</li></ul><h3 id="解题代码-13"><a href="#解题代码-13" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="Method1-Rotation-Count"><a href="#Method1-Rotation-Count" class="headerlink" title="Method1 Rotation Count"></a>Method1 Rotation Count</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count_result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">1</span>) count_result += <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count_result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method2-‘1’-Elimination"><a href="#Method2-‘1’-Elimination" class="headerlink" title="Method2 ‘1’ Elimination"></a>Method2 ‘1’ Elimination</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count_result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            count_result += <span class="number">1</span>;</span><br><span class="line">            n &amp;= (n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count_result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-13"><a href="#复杂度分析-13" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>Method1<ul><li>时间复杂度$O(log_{2}N)$：此算法循环内部仅有移位、与、加等基本运算，占用$O(1)$；逐位判断需循环$log_{2}n$次，其中$log_{2}n$代表数字n最高位1所在的位数。</li><li>空间复杂度$O(1)$。</li></ul></li><li>Method2<ul><li>时间复杂度$O(M)$：<code>n&amp;(n-1)</code>操作仅有减法和与运算，占用$O(1)$；设M为二进制数字n中1的个数，则需要循环M次，每轮消去一个1。</li><li>空间复杂度$O(1)$。</li></ul></li></ul><h2 id="0x0f-数值的整数次方"><a href="#0x0f-数值的整数次方" class="headerlink" title="0x0f 数值的整数次方"></a>0x0f 数值的整数次方</h2><h3 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>-100.0 &lt; x &lt; 100.0</li><li>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</li></ul><h3 id="算法详解-14"><a href="#算法详解-14" class="headerlink" title="算法详解"></a>算法详解</h3><p>针对幂运算问题都可以通过快速幂算法提高运算效率。快速幂实际上是二分思想的一种应用，现推导如下：</p><p>$x^{n} = x^{n/2}*x^{n/2}=(x^{2})^{n/2}$，令n/2为整数，则分奇偶两种情况讨论，设向下取整符号为<code>//</code>：</p><ul><li>当n为偶数时，$x^{n} = (x^{2})^{n//2}$；</li><li>当n为奇数时，$x^{n} = (x^{2})^{n//2}*x$。</li></ul><p>结合以上推导，通过下述方法获取幂结果：</p><ul><li>通过循环$x = x^{2}$操作，每次把幂从n降至n//2，直至将幂降为0；</li><li>设count=1，则初始状态为$x^{n} = x^{n}*count$。循环二分过程中，每当n为奇数，将多出的一项x乘入count，最终可化至$x^{n} = x^{0}*count = count$，返回count即可。</li></ul><p>为加快运算速率，将不同运算转化为位运算：</p><ul><li>向下整除<code>n//2</code>等价于有符号数右移一位<code>n&gt;&gt;1</code>；</li><li>取余数<code>n%2</code>等价于判断二进制最后一位数值<code>n&amp;1</code>。</li></ul><h3 id="解题代码-14"><a href="#解题代码-14" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> b = n;</span><br><span class="line">        <span class="keyword">double</span> final_result = <span class="number">1.0000</span>;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            final_result = fast_power(x, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            final_result = <span class="number">1.00000</span>/fast_power(x, -b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> final_result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">fast_power</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1.00000</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n&amp;<span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                result *= x;</span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-14"><a href="#复杂度分析-14" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度$O(log_{2}N)$：二分法的时间复杂度为对数级别；</li><li>空间复杂度$O(1)$：结果变量及临时变量等占用常数大小的额外空间。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;寒假赋闲在家，搞科研的同时希望提升一下自己的代码水平，于是回到阔别已久的LeetCode平台开始刷题
      
    
    </summary>
    
      <category term="Data Structure and Algorithm" scheme="https://blank-vax.github.io/categories/Data-Structure-and-Algorithm/"/>
    
    
      <category term="LeetCode" scheme="https://blank-vax.github.io/tags/LeetCode/"/>
    
      <category term="Java" scheme="https://blank-vax.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Euler-Project(V)</title>
    <link href="https://blank-vax.github.io/2020/11/22/Euler-Project(V)/"/>
    <id>https://blank-vax.github.io/2020/11/22/Euler-Project(V)/</id>
    <published>2020-11-22T03:36:00.000Z</published>
    <updated>2020-12-03T14:44:43.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="41-Pandigital-prime"><a href="#41-Pandigital-prime" class="headerlink" title="41. Pandigital prime"></a>41. Pandigital prime</h2><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>We shall say that an <em>n</em>-digit number is pandigital if it makes use of all the digits 1 to <em>n</em> exactly once. For example, 2143 is a 4-digit pandigital and is also prime.</p><p>What is the largest <em>n</em>-digit pandigital prime that exists?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># What is the largest n-digit pandigital prime that exists?</span></span><br><span class="line"><span class="comment"># The maximum pandigital prime may be located in range 123456789 to 987654321</span></span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllPermutations</span><span class="params">(n)</span>:</span></span><br><span class="line">    original_list = list(permutations(range(<span class="number">1</span>, n+<span class="number">1</span>)))</span><br><span class="line">    final_list = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> original_list:</span><br><span class="line">        tmp_result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> tuple_object <span class="keyword">in</span> item:</span><br><span class="line">            tmp_result += str(tuple_object)</span><br><span class="line">        final_list.append(tmp_result)</span><br><span class="line">    <span class="keyword">return</span> final_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPrime</span><span class="params">(combinations_result)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> reversed(combinations_result):</span><br><span class="line">        <span class="keyword">if</span> sympy.isprime(int(item)):</span><br><span class="line">            <span class="keyword">return</span> int(item)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    max_result = <span class="number">0</span></span><br><span class="line">    <span class="comment"># After some computation, we can find the aiming number is located in 7654321 to 1234567, which is a 7-digit pandigital prime</span></span><br><span class="line">    combinations_result = getAllPermutations(<span class="number">7</span>)</span><br><span class="line">    final_result = findPrime(combinations_result)</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h2 id="42-Coded-triangle-numbers"><a href="#42-Coded-triangle-numbers" class="headerlink" title="42. Coded triangle numbers"></a>42. Coded triangle numbers</h2><h3 id="Problem-Description-1"><a href="#Problem-Description-1" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The $ n^{th} $ term of the sequence of triangle numbers is given by, $ t_{n} = 1/2*n*(n+1)$; so the first ten triangle numbers are:</p><p>1, 3, 6, 10, 15, 21, 28, 36, 45, 55, …</p><p>By converting each letter in a word to a number corresponding to its alphabetical position and adding these values we form a word value. For example, the word value for SKY is $ 19 + 11 + 25 = 55 = t_{10} $. If the word value is a triangle number then we shall call the word a triangle word.</p><p>Using <a href="https://projecteuler.net/project/resources/p042_words.txt" target="_blank" rel="noopener">words.txt</a> (right click and ‘Save Link/Target As…’), a 16K text file containing nearly two-thousand common English words, how many are triangle words?</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How many are triangle words?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateTriangleNumbers</span><span class="params">(upper_bound)</span>:</span></span><br><span class="line">    triangle_number_set = [<span class="number">1</span>]</span><br><span class="line">    generator_element = <span class="number">1</span></span><br><span class="line">    generatedNumber = triangle_number_set[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> generatedNumber &lt; upper_bound:</span><br><span class="line">        generatedNumber = generator_element * (generator_element+<span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        triangle_number_set.append(generatedNumber)</span><br><span class="line">        generator_element += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> triangle_number_set</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countWordValue</span><span class="params">(word_string)</span>:</span></span><br><span class="line">    count_result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> word_string:</span><br><span class="line">        count_result += ord(item) - <span class="number">64</span></span><br><span class="line">    <span class="keyword">return</span> count_result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    triangle_word_count = <span class="number">0</span></span><br><span class="line">    triangle_number_set = generateTriangleNumbers(<span class="number">520</span>)</span><br><span class="line">    file_pointer = p042_word_path</span><br><span class="line">    word_list = file_pointer.read().replace(<span class="string">"\""</span>, <span class="string">""</span>).split(<span class="string">","</span>)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> word_list:</span><br><span class="line">        <span class="keyword">if</span> countWordValue(word) <span class="keyword">in</span> triangle_number_set:</span><br><span class="line">            triangle_word_count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> triangle_word_count</span><br></pre></td></tr></table></figure><h2 id="43-Sub-string-divisibility"><a href="#43-Sub-string-divisibility" class="headerlink" title="43. Sub-string divisibility"></a>43. Sub-string divisibility</h2><h3 id="Problem-Description-2"><a href="#Problem-Description-2" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The number, 1406357289, is a 0 to 9 pandigital number because it is made up of each of the digits 0 to 9 in some order, but it also has a rather interesting sub-string divisibility property.</p><p>Let $ d_{1} $ be the $ 1^{st} $ digit,$ d_{2} $ be the $ 2^{nd} $ digit, and so on. In this way, we note the following:</p><ul><li>$ d_{2}*d_{3}*d_{4} = 406 $ is divisible by 2</li><li>$ d_{3}*d_{4}*d_{5} = 063 $ is divisible by 3</li><li>$ d_{4}*d_{5}*d_{6}=635 $ is divisible by 5</li><li>$ d_{5}*d_{6}*d_{7}=357 $ is divisible by 7</li><li>$ d_{6}*d_{7}*d_{8}=572 $ is divisible by 11</li><li>$ d_{7}*d_{8}*d_{9} = 728 $ is divisible by 13</li><li>$ d_{8}*d_{9}*d_{10} = 289 $ is divisible by 17</li></ul><p>Find the sum of all 0 to 9 pandigital numbers with this property.</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>题解引入<code>sympy.nextprime(n)</code>函数以持续不断地获取素数，从而用于性质判断。该函数返回大于参数n的第一个素数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of all 0 to 9 pandigital numbers with this property</span></span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasProperty</span><span class="params">(input_string)</span>:</span></span><br><span class="line">    generated_prime = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> index_number <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">8</span>):</span><br><span class="line">        generated_prime = sympy.nextprime(generated_prime)</span><br><span class="line">        <span class="keyword">if</span> int(input_string[index_number: index_number+<span class="number">3</span>]) % generated_prime != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllPermutations</span><span class="params">(n)</span>:</span></span><br><span class="line">    original_list = list(permutations(range(n)))</span><br><span class="line">    final_list = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> original_list:</span><br><span class="line">        tmp_result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> tuple_object <span class="keyword">in</span> item:</span><br><span class="line">            tmp_result += str(tuple_object)</span><br><span class="line">        final_list.append(tmp_result)</span><br><span class="line">    <span class="keyword">return</span> final_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sum_result = <span class="number">0</span></span><br><span class="line">    combination_result = getAllPermutations(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> combination_result:</span><br><span class="line">        <span class="keyword">if</span> hasProperty(item):</span><br><span class="line">            sum_result += int(item)</span><br><span class="line">    <span class="keyword">print</span> sum_result</span><br></pre></td></tr></table></figure><h2 id="44-Pentagon-numbers"><a href="#44-Pentagon-numbers" class="headerlink" title="44. Pentagon numbers"></a>44. Pentagon numbers</h2><h3 id="Problem-Description-3"><a href="#Problem-Description-3" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Pentagonal numbers are generated by the formula,$ P_{n} = n(3n−1)/2 $. The first ten pentagonal numbers are:</p><p>1, 5, 12, 22, 35, 51, 70, 92, 117, 145, …</p><p>It can be seen that $ P_{4} + P_{7} = 22 + 70 = 92 = P_{8} $. However, their difference, 70 − 22 = 48, is not pentagonal.</p><p>Find the pair of pentagonal numbers, $ P_{j} $ and$ P_{k} $, for which their sum and difference are pentagonal and $ D = |P_{k} − P_{j}| $ is minimised; what is the value of D?</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>题解引入operator函数库，运用其中的底层函数提高运算效率，该库内函数说明如下：</p><p>operator库函数说明：<a href="https://docs.python.org/zh-cn/3/library/operator.html。" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/operator.html。</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the pair of pentagonal numbers, Pj and Pk</span></span><br><span class="line"><span class="comment"># The sum of these two number and the difference of these are both pentagonal</span></span><br><span class="line"><span class="comment"># Output the minimum D = |Pk - Pj|</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPentagonalNumbers</span><span class="params">(upper_bound)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> set(n*(<span class="number">3</span>*n<span class="number">-1</span>)//<span class="number">2</span> <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>, upper_bound+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    result_list = []</span><br><span class="line">    pentagonal_number_set = getPentagonalNumbers(<span class="number">3000</span>)</span><br><span class="line">    combination_result = combinations(pentagonal_number_set, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> combination_result:</span><br><span class="line">        <span class="keyword">if</span> add(item[<span class="number">0</span>], item[<span class="number">1</span>]) <span class="keyword">in</span> pentagonal_number_set <span class="keyword">and</span> abs(sub(item[<span class="number">0</span>], item[<span class="number">1</span>])) <span class="keyword">in</span> pentagonal_number_set:</span><br><span class="line">            result_list.append(abs(item[<span class="number">0</span>]-item[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">print</span> min(result_list)</span><br></pre></td></tr></table></figure><h2 id="45-Triangular-pentagonal-and-hexagonal"><a href="#45-Triangular-pentagonal-and-hexagonal" class="headerlink" title="45. Triangular, pentagonal, and hexagonal"></a>45. Triangular, pentagonal, and hexagonal</h2><h3 id="Problem-Description-4"><a href="#Problem-Description-4" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:</p><div class="table-container"><table><thead><tr><th>NumberType</th><th>Formulae</th><th>Example</th></tr></thead><tbody><tr><td>Triangle</td><td>$ T_{n} = n*(n+1) / 2 $</td><td>1, 3, 6, 10, 15, …</td></tr><tr><td>Pentagonal</td><td>$ P_{n} = n*(3*n-1) / 2 $</td><td>1, 5, 12, 22, 35, …</td></tr><tr><td>Hexagonal</td><td>$ H_{n} = n*(2*n-1) $</td><td>1, 6, 15, 28, 45</td></tr></tbody></table></div><p>It can be verified that $ T_{285} = P_{165} = H_{143} = 40755 $.</p><p>Find the next triangle number that is also pentagonal and hexagonal.</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><p>根据题意，以1—60000为生成元构造三角形数、五边形数和六边形数对应的集合，随后求交集并输出大于40755的第一个数字即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the next triangle number bigger than 40755 that is also pentagonal and hexagonal</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTriangleNumber</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> set(generator*(generator+<span class="number">1</span>)//<span class="number">2</span> <span class="keyword">for</span> generator <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPentagonalNumber</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(generator*(<span class="number">3</span>*generator<span class="number">-1</span>)//<span class="number">2</span> <span class="keyword">for</span> generator <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHexagonalNumber</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(generator*(<span class="number">2</span>*generator<span class="number">-1</span>) <span class="keyword">for</span> generator <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    triangle_set = getTriangleNumber(<span class="number">60000</span>)</span><br><span class="line">    pentagonal_set = getPentagonalNumber(<span class="number">60000</span>)</span><br><span class="line">    hexagonal_set = getHexagonalNumber(<span class="number">60000</span>)</span><br><span class="line">    result = set(triangle_set) &amp; set(pentagonal_set) &amp; set(hexagonal_set)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> result:</span><br><span class="line">        <span class="keyword">if</span> item &gt; <span class="number">40755</span>:</span><br><span class="line">            <span class="keyword">print</span> item</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h3><p>通过观察这三类数字的生成表达式可以获得三角形数、五边形数和六边形数的判断方法：</p><ul><li>若数字x是一个三角形数，则$ (\sqrt{(8*x+1)}-1) / 2 $必为一个整数；</li><li>若数字x是一个五边形数，则$ (\sqrt{(24*x+1)}+1) / 6 $必为一个整数；</li><li>若数字x是一个六边形数，则$ (\sqrt{(8*x+1)}+1) / 4 $必为一个整数 </li></ul><p>同时，这三类数的生成过程满足性质：$ H(n) = T(2n-1) $，即生成元n得到的六边形数一定对应更大生成元得到的三角形数。于是可以从第144个六边形数开始逐个验证其是否可表示为五边形数即可。暴力代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the next triangle number bigger than 40755 that is also pentagonal and hexagonal</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPentagonalNumber</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    integer_n = (math.sqrt(<span class="number">24</span>*input_number+<span class="number">1</span>)+<span class="number">1</span>) / <span class="number">6</span></span><br><span class="line">    <span class="keyword">if</span> integer_n % <span class="number">1</span> &gt; <span class="number">0</span> <span class="keyword">and</span> integer_n % <span class="number">1</span> &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHexagonalNumber</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n*(<span class="number">2</span>*n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    origin_generator = <span class="number">144</span></span><br><span class="line">    hexagonal_number = getHexagonalNumber(origin_generator)</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">print</span> origin_generator</span><br><span class="line">        <span class="keyword">if</span> isPentagonalNumber(hexagonal_number):</span><br><span class="line">            <span class="keyword">print</span> hexagonal_number</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        origin_generator += <span class="number">1</span></span><br><span class="line">        hexagonal_number = getHexagonalNumber(origin_generator)</span><br></pre></td></tr></table></figure><h2 id="46-Goldbach’s-other-conjecture"><a href="#46-Goldbach’s-other-conjecture" class="headerlink" title="46. Goldbach’s other conjecture"></a>46. Goldbach’s other conjecture</h2><h3 id="Problem-Description-5"><a href="#Problem-Description-5" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>It was proposed by Christian Goldbach that every odd composite number can be written as the sum of a prime and twice a square.</p><script type="math/tex; mode=display">9 = 7 + 2×1^{2}</script><script type="math/tex; mode=display">15 = 7 + 2×2^{2}</script><script type="math/tex; mode=display">21 = 3 + 2×3^{2}</script><script type="math/tex; mode=display">25 = 7 + 2×3^{2}</script><script type="math/tex; mode=display">27 = 19 + 2×2^{2}</script><script type="math/tex; mode=display">33 = 31 + 2×1^{2}</script><p>It turns out that the conjecture was false.</p><p>What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?</span></span><br><span class="line"><span class="comment"># odd_composite = odd_prime + 2 * square_number</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPrimes</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sorted(list(sympy.primerange(<span class="number">3</span>, n+<span class="number">1</span>)))</span><br><span class="line"><span class="comment"># Get the odd composites</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getOddComposite</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sorted(list(set(list(i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n+<span class="number">1</span>, <span class="number">2</span>))) - set(getPrimes(n))))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSquare</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    possible_square = math.sqrt(input_number / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> possible_square % <span class="number">1</span> &gt; <span class="number">0</span> <span class="keyword">and</span> possible_square % <span class="number">1</span> &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    odd_composite = getOddComposite(<span class="number">6000</span>)</span><br><span class="line">    prime_set = getPrimes(<span class="number">6000</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> odd_composite:</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> prime <span class="keyword">in</span> prime_set:</span><br><span class="line">            <span class="keyword">if</span> prime &gt;= item:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> isSquare(item - prime):</span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">print</span> item</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="47-Distinct-primes-factors"><a href="#47-Distinct-primes-factors" class="headerlink" title="47. Distinct primes factors"></a>47. Distinct primes factors</h2><h3 id="Problem-Description-6"><a href="#Problem-Description-6" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The first two consecutive numbers to have two distinct prime factors are:</p><script type="math/tex; mode=display">14 = 2 × 7</script><script type="math/tex; mode=display">15 = 3 × 5</script><p>The first three consecutive numbers to have three distinct prime factors are:</p><script type="math/tex; mode=display">644 = 2^{2} × 7 × 23</script><script type="math/tex; mode=display">645 = 3 × 5 × 43</script><script type="math/tex; mode=display">646 = 2 × 17 × 19</script><p>Find the first four consecutive integers to have four distinct prime factors each. What is the first of these numbers?</p><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the first four consecutive integers to have four distinct prime factors each.</span></span><br><span class="line"><span class="comment"># What is the first of these numbers?</span></span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPrimeFactorSet</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> set(sympy.primerange(a, b+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countPrimeFactors</span><span class="params">(n, factor_set, prime_set)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> prime_set:</span><br><span class="line">        <span class="keyword">if</span> n % item == <span class="number">0</span>:</span><br><span class="line">            factor_set.add(item)</span><br><span class="line">            <span class="keyword">return</span> countPrimeFactors(n/item, factor_set, prime_set)</span><br><span class="line">    <span class="keyword">return</span> factor_set</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    prime_set = getPrimeFactorSet(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">for</span> item_object <span class="keyword">in</span> range(<span class="number">100000</span>, <span class="number">150000</span>):</span><br><span class="line">        <span class="keyword">if</span> len(countPrimeFactors(item_object, set(), prime_set)) == <span class="number">4</span> <span class="keyword">and</span> len(countPrimeFactors(item_object+<span class="number">1</span>, set(), prime_set)) == <span class="number">4</span> <span class="keyword">and</span> len(countPrimeFactors(item_object+<span class="number">2</span>, set(), prime_set)) == <span class="number">4</span> <span class="keyword">and</span> len(countPrimeFactors(item_object+<span class="number">3</span>, set(), prime_set)) == <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">print</span> item_object</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="comment"># Program running time: The function run time is : 0.384 seconds.</span></span><br></pre></td></tr></table></figure><h2 id="48-Self-powers"><a href="#48-Self-powers" class="headerlink" title="48. Self powers"></a>48. Self powers</h2><h3 id="Problem-Description-7"><a href="#Problem-Description-7" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The series, $ 1^{1} + 2^{2} + 3^{3} + … + 10^{10} = 10405071317 $.</p><p>Find the last ten digits of the series, $ 1^{1} + 2^{2} + 3^{3} + … + 1000^{1000} $.</p><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the last ten digits of the series, sum(pow(n, n) for n in range(1, 1000))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    result_digits = str(sum(list(pow(i, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">1000</span>))))[<span class="number">-10</span>:]</span><br><span class="line">    <span class="keyword">print</span> result_digits</span><br></pre></td></tr></table></figure><h2 id="49-Prime-permutations"><a href="#49-Prime-permutations" class="headerlink" title="49. Prime permutations"></a>49. Prime permutations</h2><h3 id="Problem-Description-8"><a href="#Problem-Description-8" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The arithmetic sequence, 1487, 4817, 8147, in which each of the terms increases by 3330, is unusual in two ways: (i) each of the three terms are prime, and, (ii) each of the 4-digit numbers are permutations of one another.</p><p>There are no arithmetic sequences made up of three 1-, 2-, or 3-digit primes, exhibiting this property, but there is one other 4-digit increasing sequence.</p><p>What 12-digit number do you form by concatenating the three terms in this sequence?</p><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># What 12-digit number do you form by concatenating the three terms in this sequence?</span></span><br><span class="line"><span class="comment"># Brute force in Python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPrimeSet</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(sympy.primerange(a, b+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPermutations</span><span class="params">(input_list)</span>:</span></span><br><span class="line">    result_list = []</span><br><span class="line">    permutation_list = list(permutations(input_list, <span class="number">4</span>))</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> permutation_list:</span><br><span class="line">        result_list.append(item[<span class="number">0</span>]*<span class="number">1000</span>+item[<span class="number">1</span>]*<span class="number">100</span>+item[<span class="number">2</span>]*<span class="number">10</span>+item[<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">return</span> set(permutations(result_list, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrimePermutations</span><span class="params">(input_item, prime_set)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> input_item[<span class="number">0</span>] == input_item[<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> input_item[<span class="number">2</span>] + input_item[<span class="number">0</span>] != <span class="number">2</span>*input_item[<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> input_item[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> prime_set <span class="keyword">or</span> input_item[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> prime_set <span class="keyword">or</span> input_item[<span class="number">2</span>] <span class="keyword">not</span> <span class="keyword">in</span> prime_set:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getEachDigitList</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    result_list = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> str(input_number):</span><br><span class="line">        result_list.append(eval(item))</span><br><span class="line">    <span class="keyword">return</span> result_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    prime_set = getPrimeSet(<span class="number">1000</span>, <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">for</span> possible_number <span class="keyword">in</span> prime_set:</span><br><span class="line">        possible_number_list = getEachDigitList(possible_number)</span><br><span class="line">        final_result_list = getPermutations(possible_number_list)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> final_result_list:</span><br><span class="line">            item = sorted(item)</span><br><span class="line">            <span class="keyword">if</span> isPrimePermutations(item, prime_set):</span><br><span class="line">                <span class="keyword">print</span> str(item[<span class="number">0</span>]) + str(item[<span class="number">1</span>]) + str(item[<span class="number">2</span>])</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="50-Consecutive-prime-sum"><a href="#50-Consecutive-prime-sum" class="headerlink" title="50. Consecutive prime sum"></a>50. Consecutive prime sum</h2><h3 id="Problem-Description-9"><a href="#Problem-Description-9" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The prime 41, can be written as the sum of six consecutive primes:</p><p>41 = 2 + 3 + 5 + 7 + 11 + 13</p><p>This is the longest sum of consecutive primes that adds to a prime below one-hundred.</p><p>The longest sum of consecutive primes below one-thousand that adds to a prime, contains 21 terms, and is equal to 953.</p><p>Which prime, below one-million, can be written as the sum of the most consecutive primes?</p><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Which prime, below one-million, can be written as the sum of the most consecutive primes?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPrimeSet</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(sympy.primerange(a, b+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllSumResult</span><span class="params">(upper_bound, prime_set)</span>:</span></span><br><span class="line">    result_list = []</span><br><span class="line">    <span class="keyword">for</span> index_number <span class="keyword">in</span> range(len(prime_set)):</span><br><span class="line">        sum_result = sum(prime_set[:index_number])</span><br><span class="line">        <span class="keyword">if</span> sum_result &lt; upper_bound:</span><br><span class="line">            result_list.append(sum_result)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> result_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">originalSumResultJudge</span><span class="params">(stored_dict, prime_set, sum_result)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index_number <span class="keyword">in</span> range(len(sum_result)<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> sum_result[index_number] <span class="keyword">in</span> prime_set:</span><br><span class="line">            stored_dict[index_number] = sum_result[index_number]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> stored_dict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getConsecutivePrimeRange</span><span class="params">(prime_set, sum_result)</span>:</span></span><br><span class="line">    stored_dict = &#123;&#125;</span><br><span class="line">    first_processed_dict = originalSumResultJudge(stored_dict, prime_set, sum_result)</span><br><span class="line">    <span class="keyword">for</span> index_number1 <span class="keyword">in</span> range(len(sum_result)<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> index_number2 <span class="keyword">in</span> range(len(sum_result)):</span><br><span class="line">            <span class="keyword">if</span> sum_result[index_number1] - sum_result[index_number2] <span class="keyword">in</span> prime_set:</span><br><span class="line">                first_processed_dict[index_number1-index_number2] = sum_result[index_number1] - sum_result[index_number2]</span><br><span class="line">                <span class="keyword">return</span> first_processed_dict</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    prime_set = getPrimeSet(<span class="number">2</span>, <span class="number">1000000</span>)</span><br><span class="line">    result_list = getAllSumResult(<span class="number">1000000</span>, prime_set)</span><br><span class="line">    final_result = getConsecutivePrimeRange(prime_set, result_list)</span><br><span class="line">    sorted_dict = sorted(final_result.iteritems(), key=<span class="keyword">lambda</span> d: d[<span class="number">0</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">print</span> sorted_dict[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;41-Pandigital-prime&quot;&gt;&lt;a href=&quot;#41-Pandigital-prime&quot; class=&quot;headerlink&quot; title=&quot;41. Pandigital prime&quot;&gt;&lt;/a&gt;41. Pandigital prime&lt;/h2&gt;&lt;h3
      
    
    </summary>
    
      <category term="Mathematics" scheme="https://blank-vax.github.io/categories/Mathematics/"/>
    
    
      <category term="Euler-Project" scheme="https://blank-vax.github.io/tags/Euler-Project/"/>
    
  </entry>
  
  <entry>
    <title>Euler-Project(IV)</title>
    <link href="https://blank-vax.github.io/2020/11/17/Euler-Project(IV)/"/>
    <id>https://blank-vax.github.io/2020/11/17/Euler-Project(IV)/</id>
    <published>2020-11-17T06:40:00.000Z</published>
    <updated>2021-07-07T04:11:36.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="31-Coin-sums"><a href="#31-Coin-sums" class="headerlink" title="31. Coin sums"></a>31. Coin sums</h2><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>In the United Kingdom the currency is made up of pound (£) and pence (p). There are eight coins in general circulation:</p><blockquote><p>1p, 2p, 5p, 10p, 20p, 50p, £1 (100p), and £2 (200p).</p></blockquote><p>It is possible to make £2 in the following way:</p><blockquote><p>1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p</p></blockquote><p>How many different ways can £2 be made using any number of coins?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>题目本质为经典的找零问题，可以通过动态规划的方法解决。</p><p>以本题给出的条件为例进行详细说明。题目给出1，2，5，10，20，50，100，200这八种面额的便士类型，要求通过组合获得200便士并求出所有组合的数量。首先将问题进行分解，结果为200便士的组合可分为以下三种：</p><ul><li>不引入100便士而是使用其他便士进行组合（单体最多为200便士）</li><li>引入一个100便士，剩余的100便士由其他便士组合（单体最多为100便士）</li><li>引入两个100便士完成组合</li></ul><p>故可得以下递推公式：</p><p><img src="/2020/11/17/Euler-Project(IV)/Euler-Project(IV" alt="31_problem1.PNG-20.5kB">\1.PNG)</p><p>各字符含义如下：</p><ul><li>t表示目标量；</li><li>c表示最大可用的硬币面值；</li><li>s(c)表示除c外更小的硬币面值；</li><li>w(t, c)表示使用面值为c或更小的硬币组成目标量的所有方法数。</li></ul><p>根据以上递推公式采用动态规划的方法，将大问题分割成多个小问题并进行分类讨论处理，该方法为第一类动态规划，遵循自顶向下的问题划分原则。同时引入二维数组记录不同(t, c)组对应的方法数，以提高程序运行效率。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How many different ways can 2 pound be made using any number of coins?</span></span><br><span class="line"><span class="comment"># 2 pound equals to 200p</span></span><br><span class="line"><span class="comment"># There are eight coins in general circulation: 1p, 2p, 5p, 10p, 20p, 50p, 100p, 200p</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countWays</span><span class="params">(target, avc)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> avc &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    t = target</span><br><span class="line">    <span class="keyword">if</span> memoset[t<span class="number">-1</span>][avc<span class="number">-1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> memoset[t<span class="number">-1</span>][avc<span class="number">-1</span>]</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> target &gt;= <span class="number">0</span>:</span><br><span class="line">        result += countWays(target, avc<span class="number">-1</span>)</span><br><span class="line">        target = target - coins[avc<span class="number">-1</span>]</span><br><span class="line">    memoset[t<span class="number">-1</span>][avc<span class="number">-1</span>] = result</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span>]</span><br><span class="line">    amount_result = <span class="number">200</span></span><br><span class="line">    memoset = [[<span class="number">0</span> <span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">9</span>)] <span class="keyword">for</span> row <span class="keyword">in</span> range(amount_result+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">print</span> countWays(amount_result, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>以上算法还可以进一步优化。首先我们观察(t, c)取值不同时w(t, c)的运算结果，对应如下表：</p><p><img src="/2020/11/17/Euler-Project(IV)/Euler-Project(IV" alt="31_solution1.PNG-44.5kB">\2.PNG)</p><p>根据以上对应关系归纳递推公式如下：</p><p><img src="/2020/11/17/Euler-Project(IV)/Euler-Project(IV" alt="31_formula.PNG-25.2kB">\3.PNG)</p><p>经过深入分析，我们可以得出w’(t, c)函数不同参数对应结果之间的关系图如下所示：</p><p><img src="/2020/11/17/Euler-Project(IV)/Euler-Project(IV" alt="31_solution2.PNG-44kB">\4.PNG)</p><p>可以看出第一行和第一列的数值1达到最终目的地需要较长的加和路径。除此之外其他所有元素都可由最多另外两个元素相加得到。从而每个w’(t, c)的值最多决定于另外两个数值，即：</p><ul><li>同列c的前一个元素；</li><li>同行t，前一列c-1对应的元素；</li></ul><p>该方法为第二种动态规划方法，遵循自底向上的问题划分原则，从较小的问题开始解决，逐步解决更大的子问题。此类方法在处理以下问题时具有更高的效率：</p><ul><li>每个元素可以通过至多两个其他元素相加获得；</li><li>要求较低的时间复杂度及空间复杂度；</li><li>使用循环而非函数调用解决问题；</li></ul><p>结合以上分析，对应代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How many different ways can 2 pound be made using any number of coins?</span></span><br><span class="line"><span class="comment"># 2 pound equals to 200p</span></span><br><span class="line"><span class="comment"># There are eight coins in general circulation: 1p, 2p, 5p, 10p, 20p, 50p, 100p, 200p</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countWays</span><span class="params">(upper_bound, coins, aim_amount, final_ways)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(upper_bound):</span><br><span class="line">        j = coins[i]</span><br><span class="line">        <span class="keyword">print</span> final_ways</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(j, aim_amount+<span class="number">1</span>):</span><br><span class="line">            final_ways[k] += final_ways[k-j]</span><br><span class="line">    <span class="keyword">return</span> final_ways</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span>]</span><br><span class="line">    amount_result = <span class="number">200</span></span><br><span class="line">    answer = [<span class="number">1</span>] + [<span class="number">0</span>]*amount_result</span><br><span class="line">    final_result = countWays(<span class="number">8</span>, coins, amount_result, answer)</span><br><span class="line">    <span class="keyword">print</span> final_result[amount_result]</span><br></pre></td></tr></table></figure><h3 id="找零问题参考资料"><a href="#找零问题参考资料" class="headerlink" title="找零问题参考资料"></a>找零问题参考资料</h3><p>Euler-Project-Problem31-Overview：<a href="https://projecteuler.net/overview=031" target="_blank" rel="noopener">https://projecteuler.net/overview=031</a></p><p>动态规划2：<a href="https://www.jianshu.com/p/e515efee2310" target="_blank" rel="noopener">https://www.jianshu.com/p/e515efee2310</a></p><p>硬币找零问题：<a href="https://www.cnblogs.com/anzhengyu/p/11176134.html" target="_blank" rel="noopener">https://www.cnblogs.com/anzhengyu/p/11176134.html</a></p><h2 id="32-Pandigital-products"><a href="#32-Pandigital-products" class="headerlink" title="32. Pandigital products"></a>32. Pandigital products</h2><h3 id="Problem-Description-1"><a href="#Problem-Description-1" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once; for example, the 5-digit number, 15234, is 1 through 5 pandigital.</p><p>The product 7254 is unusual, as the identity, 39 × 186 = 7254, containing multiplicand, multiplier, and product is 1 through 9 pandigital.</p><p>Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.</p><p>HINT: Some products can be obtained in more than one way so be sure to only include it once in your sum.</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.</span></span><br><span class="line"><span class="comment"># Example: 39 x 186 = 7254,</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPandigital</span><span class="params">(result_string)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(result_string) == <span class="number">9</span> <span class="keyword">and</span> <span class="string">"123456789"</span>.strip(result_string) == <span class="string">""</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    result_set = set()</span><br><span class="line">    <span class="keyword">for</span> multiplicand <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">        <span class="keyword">for</span> multiplier <span class="keyword">in</span> range(<span class="number">123</span>, <span class="number">9880</span>):</span><br><span class="line">            <span class="keyword">if</span> isPandigital(str(multiplicand)+str(multiplier)+str(multiplicand*multiplier)):</span><br><span class="line">                result_set.add(multiplicand*multiplier)</span><br><span class="line">    <span class="keyword">print</span> sum(result_set)</span><br></pre></td></tr></table></figure><h2 id="33-Digit-cancelling-fractions"><a href="#33-Digit-cancelling-fractions" class="headerlink" title="33. Digit cancelling fractions"></a>33. Digit cancelling fractions</h2><h3 id="Problem-Description-2"><a href="#Problem-Description-2" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The fraction 49/98 is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe that 49/98 = 4/8, which is correct, is obtained by cancelling the 9s.</p><p>We shall consider fractions like, 30/50 = 3/5, to be trivial examples.</p><p>There are exactly four non-trivial examples of this type of fraction, less than one in value, and containing two digits in the numerator and denominator.</p><p>If the product of these four fractions is given in its lowest common terms, find the value of the denominator.</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If the product of these four fractions is given in its lowest common terms, find the value of the denominator.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The mean of sign '/' equals to '//' in Python2, so if we wanna get the deimal, we could import such sentence:</span></span><br><span class="line"><span class="comment"># from __future__ import division</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isCuriousFraction</span><span class="params">(numerator, denominator)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> numerator%<span class="number">10</span> == denominator//<span class="number">10</span> <span class="keyword">and</span> (numerator//<span class="number">10</span>)/(denominator%<span class="number">10</span>) == numerator/denominator:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reductionFraction</span><span class="params">(numerator, denominator)</span>:</span></span><br><span class="line">    certain_range = denominator</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">2</span>, certain_range):</span><br><span class="line">        <span class="keyword">if</span> numerator == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> numerator % item == <span class="number">0</span> <span class="keyword">and</span> denominator % item == <span class="number">0</span>:</span><br><span class="line">            numerator /= item</span><br><span class="line">            denominator /= item</span><br><span class="line">    <span class="keyword">return</span> denominator</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    final_numerator = <span class="number">1</span></span><br><span class="line">    final_denominator = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> numerator <span class="keyword">in</span> range(<span class="number">10</span>, <span class="number">100</span>):</span><br><span class="line">        <span class="keyword">if</span> numerator % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> denominator <span class="keyword">in</span> range(numerator+<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">            <span class="keyword">if</span> denominator % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> isCuriousFraction(numerator, denominator):</span><br><span class="line">                final_numerator *= numerator//<span class="number">10</span></span><br><span class="line">                final_denominator *= denominator%<span class="number">10</span></span><br><span class="line">    final_result = reductionFraction(final_numerator, final_denominator)</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h2 id="34-Digit-factorials"><a href="#34-Digit-factorials" class="headerlink" title="34. Digit factorials"></a>34. Digit factorials</h2><h3 id="Problem-Description-3"><a href="#Problem-Description-3" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.</p><p>Find the sum of all numbers which are equal to the sum of the factorial of their digits.</p><p>Note: As 1! = 1 and 2! = 2 are not sums they are not included.</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of all numbers which are equal to the sum of the factorial of their digits</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFactorial</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> input_number == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y: x*y, range(<span class="number">1</span>, input_number+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSum</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    sum_result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> input_number != <span class="number">0</span>:</span><br><span class="line">        sum_result += getFactorial(input_number%<span class="number">10</span>)</span><br><span class="line">        input_number /= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> sum_result</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    final_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">100000</span>):</span><br><span class="line">        <span class="keyword">if</span> getSum(item) == item:</span><br><span class="line">            final_sum += item</span><br><span class="line">    <span class="keyword">print</span> final_sum</span><br></pre></td></tr></table></figure><h2 id="35-Circular-primes"><a href="#35-Circular-primes" class="headerlink" title="35. Circular primes"></a>35. Circular primes</h2><h3 id="Problem-Description-4"><a href="#Problem-Description-4" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The number, 197, is called a circular prime because all rotations of the digits: 197, 971, and 719, are themselves prime.</p><p>There are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97.</p><p>How many circular primes are there below one million?</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>首先引入python的sympy库筛选出10到1000000之间的所有素数，随后对其进行第二次筛选操作。由于需要对每个素数进行顺序位移，故第一批剔除任意数位为偶数的素数。第三次筛选题目要求进行顺序位移并判断结果是否在第一步获得的素数池内。最后计算长度并作差即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How many circular primes are there below one million</span></span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="comment"># First we should get all the prime numbers</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllPrimes</span><span class="params">(lower_bound ,upper_bound)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(sympy.sieve.primerange(lower_bound, upper_bound))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sieveEvenElements</span><span class="params">(prime_set)</span>:</span></span><br><span class="line">    PossiblePrime_set = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> prime_set:</span><br><span class="line">        item_string = str(item)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'0'</span> <span class="keyword">not</span> <span class="keyword">in</span> item_string <span class="keyword">and</span> <span class="string">'2'</span> <span class="keyword">not</span> <span class="keyword">in</span> item_string <span class="keyword">and</span> <span class="string">'4'</span> <span class="keyword">not</span> <span class="keyword">in</span> item_string <span class="keyword">and</span> <span class="string">'6'</span> <span class="keyword">not</span> <span class="keyword">in</span> item_string <span class="keyword">and</span> <span class="string">'8'</span> <span class="keyword">not</span> <span class="keyword">in</span> item_string:</span><br><span class="line">            PossiblePrime_set.append(item)</span><br><span class="line">    <span class="keyword">return</span> PossiblePrime_set</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testRotationResult</span><span class="params">(SetAfterSieve)</span>:</span></span><br><span class="line">    SetAfterSecondSieve = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> SetAfterSieve:</span><br><span class="line">        item_string = str(item)</span><br><span class="line">        <span class="keyword">for</span> index_number <span class="keyword">in</span> range(len(item_string)):</span><br><span class="line">            <span class="keyword">if</span> int(item_string[index_number:] + item_string[:index_number]) <span class="keyword">not</span> <span class="keyword">in</span>  SetAfterSieve:</span><br><span class="line">                SetAfterSecondSieve.append(item)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> SetAfterSecondSieve</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    original_primeset = getAllPrimes(<span class="number">10</span>, <span class="number">1000000</span>)</span><br><span class="line">    FirstSieveSet = sieveEvenElements(original_primeset)</span><br><span class="line">    SecondSieveSet = testRotationResult(FirstSieveSet)</span><br><span class="line">    final_circular_prime_number = <span class="number">4</span> + len(FirstSieveSet) - len(SecondSieveSet)</span><br><span class="line">    <span class="keyword">print</span> final_circular_prime_number</span><br></pre></td></tr></table></figure><h2 id="36-Double-base-palindromes"><a href="#36-Double-base-palindromes" class="headerlink" title="36. Double-base palindromes"></a>36. Double-base palindromes</h2><h3 id="Problem-Description-5"><a href="#Problem-Description-5" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The decimal number, $ 585 = 1001001001_{2}$ (binary), is palindromic in both bases.</p><p>Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2.</p><p>(Please note that the palindromic number, in either base, may not include leading zeros.)</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindromes</span><span class="params">(input_string)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> input_string == input_string[::<span class="number">-1</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sum_result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">1000000</span>):</span><br><span class="line">        <span class="keyword">if</span> isPalindromes(str(item)) <span class="keyword">and</span> isPalindromes(bin(item)[<span class="number">2</span>:]):</span><br><span class="line">            <span class="keyword">print</span> item</span><br><span class="line">            sum_result += item</span><br><span class="line">    <span class="keyword">print</span> sum_result</span><br></pre></td></tr></table></figure><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h3><p>除借助python特有的字符串逆序特性方便地解决问题外，我们设计任意进制下判定某个数字是否为回文数字的函数<code>isPalindromes()</code>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(input_number, base)</span>:</span></span><br><span class="line">    reverse_result = <span class="number">0</span></span><br><span class="line">    k = input_number</span><br><span class="line">    <span class="keyword">while</span> k != <span class="number">0</span>:</span><br><span class="line">        reverse_result = base*reverse_result + k % base</span><br><span class="line">        k /= base</span><br><span class="line">    <span class="keyword">return</span> input_number == reverse_result</span><br></pre></td></tr></table></figure><p>注意在二进制运算中，可以使用<code>&amp;1</code>代替模运算，使用<code>&lt;&lt;1</code>代替乘法运算。</p><p>由于题目需要在二进制下保持回文状态且不考虑前导零的存在，故排除所有的偶数，即循环过程中以奇数起始，步长选择为2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sum_result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">1000000</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> isPalindrome(item, <span class="number">10</span>) <span class="keyword">and</span> isPalindrome(item, <span class="number">2</span>):</span><br><span class="line">            sum_result += item</span><br><span class="line">    <span class="keyword">print</span> sum_result</span><br></pre></td></tr></table></figure><h3 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h3><p>在题目给出的限制范围内，解法二可保持较高的效率，但随着数字上限的扩大，程序运行时间会大大增长。故考虑”生成+判定”的方法：假设在b进制下存在回文数字xyzzyx，取前三个数字xyz为回文结，则该六位数字由三位回文结xyz定义。同时xyz亦可定义五位回文数字xyzyx。故我们可得出如下结论：</p><p><strong>对于任意b进制，任意小于$b^{n}$的整数可作为回文结生成两个小于$b^{2n}$的回文数字，这两个回文数字的位数一奇一偶。</strong></p><p>应用以上结论，我们选择在二进制下生成两个回文数字并检验十进制下该数字是否为回文数字。如果需要得到奇数位数的回文数字，则设置标志位为true，并进行运算<code>生成元n/进制b</code>，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(input_number, base)</span>:</span></span><br><span class="line">    reverse_result = <span class="number">0</span></span><br><span class="line">    k = input_number</span><br><span class="line">    <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">        reverse_result = base*reverse_result + k % base</span><br><span class="line">        k /= base</span><br><span class="line">    <span class="keyword">return</span> input_number == reverse_result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makePalindromeBase2</span><span class="params">(n, oddflag)</span>:</span></span><br><span class="line">    result = n</span><br><span class="line">    <span class="keyword">if</span> oddflag:</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        result = (result &lt;&lt; <span class="number">1</span>) + (n &amp; <span class="number">1</span>)</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    upper_bound = <span class="number">1000000</span></span><br><span class="line">    sum_result = <span class="number">0</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    generated_result = makePalindromeBase2(i, <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">while</span> generated_result &lt; upper_bound:</span><br><span class="line">        <span class="keyword">if</span> isPalindrome(generated_result, <span class="number">10</span>):</span><br><span class="line">            sum_result += generated_result</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        generated_result = makePalindromeBase2(i, <span class="literal">True</span>)</span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    generated_result2 = makePalindromeBase2(j, <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">while</span> generated_result2 &lt; upper_bound:</span><br><span class="line">        <span class="keyword">if</span> isPalindrome(generated_result2, <span class="number">10</span>):</span><br><span class="line">            sum_result += generated_result2</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        generated_result2 = makePalindromeBase2(j, <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">print</span> sum_result</span><br></pre></td></tr></table></figure><h2 id="37-Truncatable-primes"><a href="#37-Truncatable-primes" class="headerlink" title="37. Truncatable primes"></a>37. Truncatable primes</h2><h3 id="Problem-Description-6"><a href="#Problem-Description-6" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The number 3797 has an interesting property. Being prime itself, it is possible to continuously remove digits from left to right, and remain prime at each stage: 3797, 797, 97, and 7. Similarly we can work from right to left: 3797, 379, 37, and 3.</p><p>Find the sum of the only eleven primes that are both truncatable from left to right and right to left.</p><p>NOTE: 2, 3, 5, and 7 are not considered to be truncatable primes.</p><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of the only eleven primes that are both truncatable from left to right and right to left</span></span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rightToLeft</span><span class="params">(given_prime, primeSet)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> given_prime != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> given_prime <span class="keyword">not</span> <span class="keyword">in</span> primeSet:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        given_prime /= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leftToRight</span><span class="params">(given_prime, primeSet)</span>:</span></span><br><span class="line">    given_prime_string = str(given_prime)</span><br><span class="line">    <span class="keyword">for</span> index_number <span class="keyword">in</span> range(len(given_prime_string)):</span><br><span class="line">        <span class="keyword">if</span> int(given_prime_string[index_number:]) <span class="keyword">not</span> <span class="keyword">in</span> primeSet:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isTruncatablePrimes</span><span class="params">(given_prime, primeSet)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> given_prime == <span class="number">2</span> <span class="keyword">or</span> given_prime == <span class="number">3</span> <span class="keyword">or</span> given_prime == <span class="number">5</span> <span class="keyword">or</span> given_prime == <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> rightToLeft(given_prime, primeSet) <span class="keyword">and</span> leftToRight(given_prime, primeSet)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sum_result = <span class="number">0</span></span><br><span class="line">    final_result = []</span><br><span class="line">    primeSet = list(sympy.sieve.primerange(<span class="number">2</span>, <span class="number">1000000</span>))</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> primeSet:</span><br><span class="line">        <span class="keyword">if</span> isTruncatablePrimes(item, primeSet):</span><br><span class="line">            final_result.append(item)</span><br><span class="line">            sum_result += item</span><br><span class="line">    <span class="keyword">print</span> sum_result</span><br></pre></td></tr></table></figure><h2 id="38-Pandigital-multiples"><a href="#38-Pandigital-multiples" class="headerlink" title="38. Pandigital multiples"></a>38. Pandigital multiples</h2><h3 id="Problem-Description-7"><a href="#Problem-Description-7" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Take the number 192 and multiply it by each of 1, 2, and 3:</p><blockquote><p>192 × 1 = 192<br>192 × 2 = 384<br>192 × 3 = 576</p></blockquote><p>By concatenating each product we get the 1 to 9 pandigital, 192384576. We will call 192384576 the concatenated product of 192 and (1,2,3)</p><p>The same can be achieved by starting with 9 and multiplying by 1, 2, 3, 4, and 5, giving the pandigital, 918273645, which is the concatenated product of 9 and (1,2,3,4,5).</p><p>What is the largest 1 to 9 pandigital 9-digit number that can be formed as the concatenated product of an integer with (1,2, … , n) where n &gt; 1?</p><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># What is the largest 1 to 9 pandigital 9-digit number that can be formed as the concatenated product of an integer with (1,2, ... , n) where n &gt; 1?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getConcatenatedResult</span><span class="params">(multiple_time, max_result, final_item)</span>:</span></span><br><span class="line">    upper_bound = <span class="number">6</span> - multiple_time</span><br><span class="line">    lower_bound = <span class="number">5</span> - multiple_time</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">10</span>**lower_bound, <span class="number">10</span>**upper_bound):</span><br><span class="line">        concatenated_result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> time <span class="keyword">in</span> range(<span class="number">1</span>, multiple_time+<span class="number">1</span>):</span><br><span class="line">            concatenated_result += str(item*time)</span><br><span class="line">        tmp_result = comparisonFunction(concatenated_result, max_result, item)</span><br><span class="line">        max_result = tmp_result[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> tmp_result[<span class="number">1</span>] != <span class="number">0</span>:</span><br><span class="line">            final_item = tmp_result[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> (max_result, final_item)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">comparisonFunction</span><span class="params">(concatenated_result, max_result, item)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> judgePandigitalNumber(concatenated_result) <span class="keyword">and</span> int(concatenated_result) &gt; max_result:</span><br><span class="line">        <span class="keyword">return</span> (int(concatenated_result), item)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> (max_result, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judgePandigitalNumber</span><span class="params">(input_number_string)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(input_number_string) == <span class="number">9</span> <span class="keyword">and</span> len(set(input_number_string)) == <span class="number">9</span> <span class="keyword">and</span> <span class="string">'0'</span> <span class="keyword">not</span> <span class="keyword">in</span> input_number_string:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    final_item, max_result = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> multiply_factor <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">6</span>):</span><br><span class="line">        concatenated_result = getConcatenatedResult(multiply_factor, max_result, final_item)</span><br><span class="line">        max_result = concatenated_result[<span class="number">0</span>]</span><br><span class="line">        final_item = concatenated_result[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">print</span> max_result</span><br></pre></td></tr></table></figure><h2 id="39-Integer-right-triangles"><a href="#39-Integer-right-triangles" class="headerlink" title="39. Integer right triangles"></a>39. Integer right triangles</h2><h3 id="Problem-Description-8"><a href="#Problem-Description-8" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>If <em>p</em> is the perimeter of a right angle triangle with integral length sides, {<em>a</em>,<em>b</em>,<em>c</em>}, there are exactly three solutions for <em>p</em> = 120.</p><p>{20,48,52}, {24,45,51}, {30,40,50}</p><p>For which value of <em>p</em> ≤ 1000, is the number of solutions maximised?</p><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For which value of p &lt;= 1000, is the numnber of solutions maximised?</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judgeTriangle</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> a**<span class="number">2</span> + b**<span class="number">2</span> == c**<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSolutions</span><span class="params">(p)</span>:</span></span><br><span class="line">    solution_number = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">2</span>, int(p/<span class="number">2</span>)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> range(<span class="number">1</span>, a+<span class="number">1</span>):</span><br><span class="line">            c = p - a - b</span><br><span class="line">            <span class="keyword">if</span> judgeTriangle(a, b, c):</span><br><span class="line">                solution_number += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> solution_number</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    maximum_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> range(<span class="number">12</span>, <span class="number">1001</span>):</span><br><span class="line">        count_result = getSolutions(p)</span><br><span class="line">        <span class="keyword">if</span> count_result &gt; maximum_count:</span><br><span class="line">            maximum_count = count_result</span><br><span class="line">            maximum_count_p = p</span><br><span class="line">    <span class="keyword">print</span> maximum_count_p</span><br></pre></td></tr></table></figure><h2 id="40-Champernowne’s-constant"><a href="#40-Champernowne’s-constant" class="headerlink" title="40. Champernowne’s constant"></a>40. Champernowne’s constant</h2><h3 id="Probelm-Description"><a href="#Probelm-Description" class="headerlink" title="Probelm Description"></a>Probelm Description</h3><p>An irrational decimal fraction is created by concatenating the positive integers:</p><p>0.12345678910<strong>1</strong>112131415161718192021…</p><p>It can be seen that the $12^{th}$ digit of the fractional part is 1.</p><p>If $d_{n}$ represents the $n^{th}$ digit of the fractional part, find the value of the following expression.</p><script type="math/tex; mode=display">d_{1} × d_{10} × d_{100} × d_{1000} × d_{10000} × d_{100000} × d_{1000000}</script><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the value of the following expression</span></span><br><span class="line"><span class="comment"># d1 x d10 x d100 x d1000 x d10000 x d100000 x d1000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDecimalFraction</span><span class="params">()</span>:</span></span><br><span class="line">    positive_integer = <span class="number">1</span></span><br><span class="line">    decimalfraction_string = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> len(decimalfraction_string) &lt; <span class="number">1000000</span>:</span><br><span class="line">        decimalfraction_string += str(positive_integer)</span><br><span class="line">        positive_integer += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> decimalfraction_string</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    final_fraction = getDecimalFraction()</span><br><span class="line">    result = int(final_fraction[<span class="number">0</span>])*int(final_fraction[<span class="number">9</span>])*int(final_fraction[<span class="number">99</span>])*int(final_fraction[<span class="number">999</span>])*int(final_fraction[<span class="number">9999</span>])*int(final_fraction[<span class="number">99999</span>])*int(final_fraction[<span class="number">999999</span>])</span><br><span class="line">    <span class="keyword">print</span> result</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;31-Coin-sums&quot;&gt;&lt;a href=&quot;#31-Coin-sums&quot; class=&quot;headerlink&quot; title=&quot;31. Coin sums&quot;&gt;&lt;/a&gt;31. Coin sums&lt;/h2&gt;&lt;h3 id=&quot;Problem-Description&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="Mathematics" scheme="https://blank-vax.github.io/categories/Mathematics/"/>
    
    
      <category term="Euler-Project" scheme="https://blank-vax.github.io/tags/Euler-Project/"/>
    
  </entry>
  
  <entry>
    <title>Euler-Project(III)</title>
    <link href="https://blank-vax.github.io/2020/11/10/Euler-Project(III)/"/>
    <id>https://blank-vax.github.io/2020/11/10/Euler-Project(III)/</id>
    <published>2020-11-09T16:20:00.000Z</published>
    <updated>2021-07-07T04:08:23.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="21-Amicable-numbers"><a href="#21-Amicable-numbers" class="headerlink" title="21. Amicable numbers"></a>21. Amicable numbers</h2><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Let d(<em>n</em>) be defined as the sum of proper divisors of <em>n</em> (numbers less than <em>n</em> which divide evenly into <em>n</em>).<br>If d(<em>a</em>) = <em>b</em> and d(<em>b</em>) = <em>a</em>, where <em>a</em> ≠ <em>b</em>, then <em>a</em> and <em>b</em> are an amicable pair and each of <em>a</em> and <em>b</em> are called amicable numbers.</p><p>For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220.</p><p>Evaluate the sum of all the amicable numbers under 10000.</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><p>根据题目抓住关键点：</p><ul><li>本题需要统计满足<code>d(a) == b and d(b) == a, while a != b</code>条件的数字对(a, b) ，故需要关注<code>d(a) == a</code>的情况；</li><li>统计因子之和的函数中，引入set数据结构，在结果中排除重复添加的情况，最后加上1。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSumOfDivisors</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> input_number == <span class="number">1</span> <span class="keyword">or</span> input_number == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    important_set = set()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">2</span>, int(input_number/<span class="number">2</span>)):</span><br><span class="line">        <span class="keyword">if</span> input_number % item == <span class="number">0</span>:</span><br><span class="line">            important_set.add(item)</span><br><span class="line">            important_set.add(input_number/item)</span><br><span class="line">    <span class="keyword">return</span> sum(important_set)+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    blank_list = []</span><br><span class="line">    <span class="keyword">for</span> index_number <span class="keyword">in</span> xrange(<span class="number">10000</span>):</span><br><span class="line">        <span class="keyword">if</span> index_number <span class="keyword">in</span> blank_list:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        tmp_result = getSumOfDivisors(index_number)</span><br><span class="line">        <span class="keyword">if</span> tmp_result == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> (index_number == getSumOfDivisors(tmp_result)) <span class="keyword">and</span> (index_number != tmp_result) :</span><br><span class="line">            blank_list.append(tmp_result)</span><br><span class="line">            blank_list.append(index_number)</span><br><span class="line">    <span class="keyword">print</span> sum(blank_list)</span><br></pre></td></tr></table></figure><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h3><p>从第十题的分析可以看出，任何一个数字都可以表示成素数幂乘积的形式。下面对素数幂的因子之和进行推导分析：</p><p>设p为任意素数，由于素数只包含1和其本身两个因子，则：$\sigma(p) = p + 1$；</p><p>考虑p的a次幂，$\sigma(p^{a}) = 1 + p + p^{2} + p^{3} + … + p^{a}$ (1)；</p><p>式子(1)两侧同乘p，有$p*\sigma(p^{a}) = p + p^{2} + p^{3} + p^{4} + … + p^{a+1} (2)$;</p><p>(2) - (1)得，$p<em>\sigma(p^{a}) - \sigma(p^{a}) = (p-1) </em> \sigma(p^{a}) = p^{a+1} - 1$；</p><p>因此$\sigma(p^{a}) = (p^{a+1} - 1) / (p - 1)$</p><p>使用该公式并结合数字的素数幂分解即可较快求出因子之和，代码实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SumOfDivisors</span><span class="params">(n)</span>:</span></span><br><span class="line">    sum_result = <span class="number">1</span></span><br><span class="line">    p = <span class="number">2</span></span><br><span class="line">    <span class="comment"># Prevents from checking prime factors greater than sqrt(n).</span></span><br><span class="line">    <span class="keyword">while</span> p**<span class="number">2</span> &lt;= n <span class="keyword">and</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> n % p == <span class="number">0</span>:</span><br><span class="line">            j = p**<span class="number">2</span></span><br><span class="line">            n /= p</span><br><span class="line">            <span class="keyword">while</span> n % p == <span class="number">0</span>:</span><br><span class="line">                j *= p</span><br><span class="line">                n /= p</span><br><span class="line">            sum_result *= (j<span class="number">-1</span>)</span><br><span class="line">            sum_result /= (p<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> p == <span class="number">2</span>:</span><br><span class="line">            p = <span class="number">3</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p += <span class="number">2</span></span><br><span class="line">    <span class="comment"># Covers the case that one prime factor greater than sqrt(n) remains.</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        sum_result *= (n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> sum_result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SumOfProperDivisors</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> SumOfDivisors(input_number) - input_number</span><br></pre></td></tr></table></figure><p>与解法一对比，该方法将运算时间 从3s降低到0.3s。</p><h2 id="22-Names-score"><a href="#22-Names-score" class="headerlink" title="22. Names score"></a>22. Names score</h2><h3 id="Problem-Description-1"><a href="#Problem-Description-1" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Using <a href="https://projecteuler.net/project/resources/p022_names.txt" target="_blank" rel="noopener">names.txt</a> (right click and ‘Save Link/Target As…’), a 46K text file containing over five-thousand first names, begin by sorting it into alphabetical order. Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list to obtain a name score.</p><p>For example, when the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. So, COLIN would obtain a score of 938 × 53 = 49714.</p><p>What is the total of all the name scores in the file?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Count the total scores of names</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SortContentAsAlphabeticalPosition</span><span class="params">(txtlocation)</span>:</span></span><br><span class="line">    file = open(txtlocation, <span class="string">"r"</span>)</span><br><span class="line">    content_string = file.read()</span><br><span class="line">    content_list = content_string.replace(<span class="string">"\""</span>, <span class="string">""</span>).split(<span class="string">","</span>)</span><br><span class="line">    <span class="keyword">return</span> sorted(content_list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetWordScore</span><span class="params">(input_word)</span>:</span></span><br><span class="line">    word_Score = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> input_word:</span><br><span class="line">        word_Score += ord(item) - <span class="number">65</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> word_Score</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CountTotalScore</span><span class="params">(content_list)</span>:</span></span><br><span class="line">    total_score = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> xrange(len(content_list)):</span><br><span class="line">        total_score += GetWordScore(content_list[index]) * (index+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> total_score</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    txt_location = given_txt_path</span><br><span class="line">    Sorted_list = SortContentAsAlphabeticalPosition(txt_location)</span><br><span class="line">    total_score = CountTotalScore(Sorted_list)</span><br><span class="line">    <span class="keyword">print</span> total_score</span><br></pre></td></tr></table></figure><h2 id="23-Non-abundant-sums"><a href="#23-Non-abundant-sums" class="headerlink" title="23. Non-abundant sums"></a>23. Non-abundant sums</h2><h3 id="Problem-Description-2"><a href="#Problem-Description-2" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>A perfect number is a number for which the sum of its proper divisors is exactly equal to the number. For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.</p><p>A number n is called deficient if the sum of its proper divisors is less than n and it is called abundant if this sum exceeds n.</p><p>As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be written as the sum of two abundant numbers is 24. By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers. However, this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit.</p><p>Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SumOfDivisors</span><span class="params">(n)</span>:</span></span><br><span class="line">    sum_result = <span class="number">1</span></span><br><span class="line">    p = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> p**<span class="number">2</span> &lt;= n <span class="keyword">and</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> n % p == <span class="number">0</span>:</span><br><span class="line">            j = p**<span class="number">2</span></span><br><span class="line">            n /= p</span><br><span class="line">            <span class="keyword">while</span> n % p == <span class="number">0</span>:</span><br><span class="line">                j *= p</span><br><span class="line">                n /= p</span><br><span class="line">            sum_result *= (j<span class="number">-1</span>)</span><br><span class="line">            sum_result /= (p<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> p == <span class="number">2</span>:</span><br><span class="line">            p = <span class="number">3</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p += <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        sum_result *= (n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> sum_result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SumOfProperDivisors</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> SumOfDivisors(input_number) - input_number</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    final_sum = <span class="number">28123</span>*<span class="number">28124</span>/<span class="number">2</span></span><br><span class="line">    least_abundant_number = <span class="number">12</span></span><br><span class="line">    possible_abundant_number_list = []</span><br><span class="line">    <span class="keyword">while</span> least_abundant_number &lt;= <span class="number">28123</span>:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> possible_abundant_number_list:</span><br><span class="line">            <span class="keyword">if</span> least_abundant_number - item <span class="keyword">in</span> possible_abundant_number_list:</span><br><span class="line">                final_sum -= least_abundant_number</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> SumOfProperDivisors(least_abundant_number) &gt; least_abundant_number:</span><br><span class="line">            possible_abundant_number_list.append(least_abundant_number)</span><br><span class="line">        least_abundant_number += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> final_sum</span><br></pre></td></tr></table></figure><p>使用上述暴力遍历的方法统计结果需要的时间较长，大概为160-180s左右。</p><h2 id="24-Lexicographic-permutations"><a href="#24-Lexicographic-permutations" class="headerlink" title="24. Lexicographic permutations"></a>24. Lexicographic permutations</h2><h3 id="Problem-Description-3"><a href="#Problem-Description-3" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>A permutation is an ordered arrangement of objects. For example, 3124 is one possible permutation of the digits 1, 2, 3 and 4. If all of the permutations are listed numerically or alphabetically, we call it lexicographic order. The lexicographic permutations of 0, 1 and 2 are:</p><p>012  021  102  120  201  210</p><p>What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>偷懒调用了python的itertools库，其中包含<code>permutations()</code>即排列函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    result_string = <span class="string">""</span></span><br><span class="line">    result_list = list(permutations(<span class="string">'0123456789'</span>))</span><br><span class="line">    final_result = sorted(result_list)[<span class="number">999999</span>]</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> final_result:</span><br><span class="line">        result_string += item</span><br><span class="line">    <span class="keyword">print</span> eval(result_string)</span><br></pre></td></tr></table></figure><h2 id="25-1000-digit-Fibonacci-number"><a href="#25-1000-digit-Fibonacci-number" class="headerlink" title="25. 1000-digit Fibonacci number"></a>25. 1000-digit Fibonacci number</h2><h3 id="Problem-Description-4"><a href="#Problem-Description-4" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The Fibonacci sequence is defined by the recurrence relation:</p><script type="math/tex; mode=display">F_{n} = F_{n−1} + F_{n−2}, where F_{1} = 1 and F_{2} = 1</script><p>Hence the first 12 terms will be:</p><script type="math/tex; mode=display">F_{1} = 1</script><script type="math/tex; mode=display">F_{2} = 1</script><script type="math/tex; mode=display">F_{3} = 2</script><script type="math/tex; mode=display">F_{4} = 3</script><script type="math/tex; mode=display">F_{5} = 5</script><script type="math/tex; mode=display">F_{6} = 8</script><script type="math/tex; mode=display">F_{7} = 13</script><script type="math/tex; mode=display">F_{8} = 21</script><script type="math/tex; mode=display">F_{9} = 34</script><script type="math/tex; mode=display">F_{10} = 55</script><script type="math/tex; mode=display">F_{11} = 89</script><script type="math/tex; mode=display">F_{12} = 144</script><p>The 12th term, $F_{12}$, is the first term to contain three digits.</p><p>What is the index of the first term in the Fibonacci sequence to contain 1000 digits?</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># What is the index of the first term in the Fibonacci sequence to contain 1000 digits</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetIndexOfFibonacci</span><span class="params">()</span>:</span></span><br><span class="line">    f = <span class="number">1</span></span><br><span class="line">    g = <span class="number">1</span></span><br><span class="line">    g_count = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> len(str(g)) &lt; <span class="number">1000</span>:</span><br><span class="line">        f, g = g, f+g</span><br><span class="line">        g_count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> g_count</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    final_result = GetIndexOfFibonacci()</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h2 id="26-Reciprocal-cycles"><a href="#26-Reciprocal-cycles" class="headerlink" title="26. Reciprocal cycles"></a>26. Reciprocal cycles</h2><h3 id="Problem-Description-5"><a href="#Problem-Description-5" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>A unit fraction contains 1 in the numerator. The decimal representation of the unit fractions with denominators 2 to 10 are given:</p><blockquote><div class="table-container"><table><thead><tr><th>1/2</th><th>=</th><th>0.5</th></tr></thead><tbody><tr><td>1/3</td><td>=</td><td>0.(3)</td></tr><tr><td>1/4</td><td>=</td><td>0.25</td></tr><tr><td>1/5</td><td>=</td><td>0.2</td></tr><tr><td>1/6</td><td>=</td><td>0.1(6)</td></tr><tr><td>1/7</td><td>=</td><td>0.(142857)</td></tr><tr><td>1/8</td><td>=</td><td>0.125</td></tr><tr><td>1/9</td><td>=</td><td>0.(1)</td></tr><tr><td>1/10</td><td>=</td><td>0.1</td></tr></tbody></table></div></blockquote><p>Where 0.1(6) means 0.166666…, and has a 1-digit recurring cycle. It can be seen that 1/7 has a 6-digit recurring cycle.</p><p>Find the value of <em>d</em> &lt; 1000 for which 1/<em>d</em> contains the longest recurring cycle in its decimal fraction part.</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>本题为经典的循环节计算问题。</p><p>设分母为n，若n为合数，则必可以表示成多个素数的乘积，其循环节与这些分解素数中最大的循环节保持一致。故只需要讨论所给范围内所有素数分母其倒数的循环节即可。值得注意的是，1/2与1/5都是有限小数，故2和5这两个素数需要排除。</p><p>确定循环的范围后下面进行循环节计算：通过查阅资料可知，循环节问题可以等价为大整数分解问题。给定大整数n，求使得$10^{k} \equiv 1 (mod n)$成立的最小的k，该数值即为1/n循环节的长度。根据以上分析采取<code>10**k-1 % n == 0</code>作为限制条件求解。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the value of d &lt; 1000 for which 1/d contains the longest recurring cycle in its decimal fraction part</span></span><br><span class="line"><span class="comment"># Brute force to find the longest recurring cycle</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># Judge whether n is prime</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(math.sqrt(n))+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetRecurringCycle</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    L = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">10</span>**L<span class="number">-1</span>) % input_number == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        L += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    max_recurring_length = <span class="number">1</span></span><br><span class="line">    result_n = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">1001</span>):</span><br><span class="line">        <span class="keyword">if</span> isPrime(i) <span class="keyword">and</span> i != <span class="number">2</span> <span class="keyword">and</span> i != <span class="number">5</span>:</span><br><span class="line">            recurring_length = GetRecurringCycle(i)</span><br><span class="line">            <span class="keyword">if</span> recurring_length &gt; max_recurring_length:</span><br><span class="line">                max_recurring_length = recurring_length</span><br><span class="line">                result_n = i</span><br><span class="line">    <span class="keyword">print</span> (result_n, max_recurring_length)</span><br></pre></td></tr></table></figure><h3 id="Mathematical-Analysis"><a href="#Mathematical-Analysis" class="headerlink" title="Mathematical Analysis"></a>Mathematical Analysis</h3><p>考虑上面提到的一般化问题：求最小的k使得$a^{k} \equiv 1(mod n)$，若n与a互素，求出分母n的欧拉函数值$\Phi(n)$，则循环节长度k必为其约数；若n与a存在公因子则无解。由此可见通过暴力遍历的方法可以求出约数k，从而得出循环节。</p><p>在RSA加密中，给定n=p<em>q，则p，q均为大质数，此时1/n循环节的长度length为gcd(p-1, q-1)的约数。假定已知length的因数分解$length = l<em>{1}^{c</em>{1}}</em>l<em>{2}^{c</em>{2}}<em>l<em>{3}^{c</em>{3}}</em>……*l<em>{k}^{c</em>{k}}$，则length共有$\prod[c_{i}+1]$个约数。将这些约数分别加上1，若某个约数y(j)加1后是质数，则y(j)+1可能是大整数n的约数。对所有小于$\sqrt{n}-1$的y(j)进行检验，必能找到一个恰好满足y(j)+1 = min(p, q)的数字。通过此种方法可以将大整数分解问题转换为求循环节的问题。在最坏的情况下，一个300位的大整数只需通过小于500次转换完成分解。</p><p>关于循环节长度计算公式存在如下改进：</p><p><img src="/2020/11/10/Euler-Project(III)/Euler-Project(III" alt="26_recurring_cycle.PNG-34.7kB">\1.PNG)</p><p>该公式的应用如下：</p><p><img src="/2020/11/10/Euler-Project(III)/Euler-Project(III" alt="26_recurring_cycle2.PNG-47.8kB">\2.PNG)</p><p>参考论文：关于循环节长度计算公式的改进：<a href="https://www.ixueshu.com/document/6d924626ac37b4ee318947a18e7f9386.html" target="_blank" rel="noopener">https://www.ixueshu.com/document/6d924626ac37b4ee318947a18e7f9386.html</a></p><h2 id="27-Quadratic-primes"><a href="#27-Quadratic-primes" class="headerlink" title="27. Quadratic primes"></a>27. Quadratic primes</h2><h3 id="Problem-Description-6"><a href="#Problem-Description-6" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Euler discovered the remarkable quadratic formula:</p><script type="math/tex; mode=display">n^{2} + n + 41</script><p>It turns out that the formula will produce 40 primes for the consecutive integer values 0≤n≤39. However, when$ n=40, 40^{2}+40+41=40*(40+1)+41$ is divisible by 41, and certainly when $ n=41,41^{2}+41+41 $is clearly divisible by 41.</p><p>The incredible formula $n^{2}−79*n+1601$ was discovered, which produces 80 primes for the consecutive values 0≤n≤79. The product of the coefficients, −79 and 1601, is −126479.</p><p>Considering quadratics of the form:</p><script type="math/tex; mode=display">n^{2}+a*n+b , where|a|<1000 , |b|≤1000</script><p>where |n| is the modulus/absolute value of n<br>e.g. |11|=11 and |−4|=4</p><p>Find the product of the coefficients, a and b, for the quadratic expression that produces the maximum number of primes for consecutive values of n, starting with n=0.</p><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>根据题目，可以仅通过数学推导的方法求解（条件极值问题+二次图像平移），参考链接如下：<a href="https://zhuanlan.zhihu.com/p/62137330。除此之外，还可以按照题意暴力求解，由于本题提供的a" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/62137330。除此之外，还可以按照题意暴力求解，由于本题提供的a</a>, b范围较小，故可以在较短时间内完成计算。根据题目给出的二次多项式$f(n) = n^{2} + a*n + b$可得出以下性质：</p><ul><li>由f(0) = b可知参数b必为素数，故将b的遍历范围缩小为2—999；</li><li>由f(1) = a+b+1且该多项式为素数，可得结论a &gt; -b-1，据此适当缩小a的遍历范围；</li><li>当gcd(a, b) = d且d != 1时，一定存在一个数n’ = minP(d)使得f(n’)为合数，其中minP(d)表示d的最小素因子。从而若a, b不互素，最多生成minP(d)个连续素数，从而在遍历过程中排除a, b不互素的情况即可。（需要用到math.gcd()函数且偷懒不想自己构造，故以下代码需选择Python3.5+版本运行）</li></ul><p>遍历代码具有两个版本，记录如下：</p><h4 id="Version1"><a href="#Version1" class="headerlink" title="Version1"></a>Version1</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the product of the coefficients,a and b, for the quadratic expression that produces the maximum number of primes for consecutive values of n, starting with n = 0</span></span><br><span class="line"><span class="comment"># Some properties:</span></span><br><span class="line">    <span class="comment"># f(0) = b, so b must be a prime</span></span><br><span class="line">    <span class="comment"># a &gt; -b-1</span></span><br><span class="line">    <span class="comment"># if gcd(a, b) = d and d != 1, we could only get as many as the least prime factor of d continuous primes</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(math.sqrt(n))+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    prime_counter = <span class="number">0</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> isPrime(n*n+a*n+b):</span><br><span class="line">            prime_counter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> prime_counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    result_set = []</span><br><span class="line">    max_result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">-995</span>, <span class="number">999</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">1000</span>):</span><br><span class="line">            <span class="keyword">if</span> isPrime(b) <span class="keyword">and</span> math.gcd(a, b) == <span class="number">1</span>:</span><br><span class="line">                count = countPrimes(a, b)</span><br><span class="line">                <span class="keyword">if</span> count &gt; max_result:</span><br><span class="line">                    max_result = count</span><br><span class="line">                    result_set.append(a*b)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">    print(result_set[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h4 id="Version2"><a href="#Version2" class="headerlink" title="Version2"></a>Version2</h4><p>引入python中的数学运算库sympy，该库继承多种数学运算，包括大量素数操作的接口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">isprime(n)              <span class="comment"># Test if n is a prime number (True) or not (False).</span></span><br><span class="line"> </span><br><span class="line">primerange(a, b)        <span class="comment"># Generate a list of all prime numbers in the range [a, b).</span></span><br><span class="line">randprime(a, b)         <span class="comment"># Return a random prime number in the range [a, b).</span></span><br><span class="line">primepi(n)              <span class="comment"># Return the number of prime numbers less than or equal to n.</span></span><br><span class="line"> </span><br><span class="line">prime(nth)              <span class="comment"># Return the nth prime, with the primes indexed as prime(1) = 2. The nth prime is approximately n*log(n) and can never be larger than 2**n.</span></span><br><span class="line">prevprime(n, ith=<span class="number">1</span>)     <span class="comment"># Return the largest prime smaller than n</span></span><br><span class="line">nextprime(n)            <span class="comment"># Return the ith prime greater than n</span></span><br><span class="line"> </span><br><span class="line">sieve.primerange(a, b)  <span class="comment"># Generate all prime numbers in the range [a, b), implemented as a dynamically growing sieve of Eratosthenes.</span></span><br></pre></td></tr></table></figure><p>代码如下，其中应用到<code>sympy.isprime()</code>函数进行素数判断，应用<code>sieve.primerange(a, b)</code>函数生成1—1000内的所有素数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"></span><br><span class="line"><span class="comment"># This function is used to collect all the primes between 1 and 1000</span></span><br><span class="line">Prime = list(sympy.sieve.primerange(<span class="number">1</span>, <span class="number">1000</span>))</span><br><span class="line">dic = &#123;&#125;</span><br><span class="line">dic[<span class="string">'n'</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">-995</span>, <span class="number">999</span>, <span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> Prime:</span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        c = n*n + a*n + b</span><br><span class="line">        <span class="keyword">while</span> sympy.isprime(c):</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            c = n*n + a*n + b</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; dic[<span class="string">'n'</span>]:</span><br><span class="line">            dic[<span class="string">'n'</span>] = n</span><br><span class="line">            dic[<span class="string">'a*b'</span>] = a*b</span><br><span class="line"><span class="keyword">print</span> dic[<span class="string">'a*b'</span>]</span><br></pre></td></tr></table></figure><p>sympy库函数文档：<a href="http://docs.sympy.org/latest/modules/ntheory.html?highlight=prime#ntheory-functions-reference" target="_blank" rel="noopener">http://docs.sympy.org/latest/modules/ntheory.html?highlight=prime#ntheory-functions-reference</a></p><h2 id="28-Number-spiral-diagonals"><a href="#28-Number-spiral-diagonals" class="headerlink" title="28. Number spiral diagonals"></a>28. Number spiral diagonals</h2><h3 id="Problem-Description-7"><a href="#Problem-Description-7" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Starting with the number 1 and moving to the right in a clockwise direction a 5 by 5 spiral is formed as follows:</p><p><img src="/2020/11/10/Euler-Project(III)/Euler-Project(III" alt="28_problem.PNG-10.2kB">\3.PNG)</p><p>It can be verified that the sum of the numbers on the diagonals is 101.</p><p>What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way?</p><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gridA: 5*5 there are 3 circles</span></span><br><span class="line"><span class="comment"># gridB: 7*7 there are 4 circles</span></span><br><span class="line"><span class="comment"># gridN: N*N there must be (N+1)/2 circles</span></span><br><span class="line"><span class="comment"># Arithmetic progression</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCircles</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (n+<span class="number">1</span>) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSum</span><span class="params">(circle_number)</span>:</span></span><br><span class="line">    final_sum = <span class="number">0</span></span><br><span class="line">    step = <span class="number">2</span></span><br><span class="line">    origin_number = <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(circle_number<span class="number">-1</span>):</span><br><span class="line">        final_sum += <span class="number">4</span>*origin_number + <span class="number">6</span>*step</span><br><span class="line">        origin_number += <span class="number">4</span>*step + <span class="number">2</span></span><br><span class="line">        step += <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> final_sum</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    final_result = countSum(getCircles(<span class="number">1001</span>))</span><br><span class="line">    <span class="keyword">print</span> final_result+<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="29-Distinct-powers"><a href="#29-Distinct-powers" class="headerlink" title="29. Distinct powers"></a>29. Distinct powers</h2><h3 id="Problem-Description-8"><a href="#Problem-Description-8" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Consider all integer combinations of $a^{b}$ for 2 ≤ <em>a</em> ≤ 5 and 2 ≤ <em>b</em> ≤ 5:</p><script type="math/tex; mode=display">2^{2}=4, 2^{3}=8, 2^{4}=16, 2^{5}=32</script><script type="math/tex; mode=display">3^{2}=9, 3^{3}=27, 3^{4}=81, 3^{5}=243</script><script type="math/tex; mode=display">4^{2}=16, 4^{3}=64, 4^{4}=256, 4^{5}=1024</script><script type="math/tex; mode=display">5^{2}=25, 5^{3}=125, 5^{4}=625, 5^{5}=3125</script><p>If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:</p><p>4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125</p><p>How many distinct terms are in the sequence generated by $a^{b}$ for 2 ≤ <em>a</em> ≤ 100 and 2 ≤ <em>b</em> ≤ 100?</p><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final_set = set()</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">101</span>):</span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">101</span>):</span><br><span class="line">tmp_a_b = a**b</span><br><span class="line">        tmp_b_a = b**a</span><br><span class="line">        <span class="keyword">if</span> tmp_a_b <span class="keyword">not</span> <span class="keyword">in</span> final_set:</span><br><span class="line">            final_set.add(tmp_a_b)</span><br><span class="line">        <span class="keyword">if</span> tmp_b_a <span class="keyword">not</span> <span class="keyword">in</span> final_set:</span><br><span class="line">            final_set.add(tmp_b_a)</span><br><span class="line"><span class="keyword">print</span> len(final_set)</span><br></pre></td></tr></table></figure><h2 id="30-Digit-fifth-powers"><a href="#30-Digit-fifth-powers" class="headerlink" title="30. Digit fifth powers"></a>30. Digit fifth powers</h2><h3 id="Problem-Description-9"><a href="#Problem-Description-9" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Surprisingly there are only three numbers that can be written as the sum of fourth powers of their digits:</p><script type="math/tex; mode=display">1634 = 1^{4} + 6^{4} + 3^{4} + 4^{4}</script><script type="math/tex; mode=display">8208 = 8^{4} + 2^{4} + 0^{4} + 8^{4}</script><script type="math/tex; mode=display">9474 = 9^{4} + 4^{4} + 7^{4} + 4^{4}</script><p>As$ 1 = 1^{4} $is not a sum it is not included.</p><p>The sum of these numbers is 1634 + 8208 + 9474 = 19316.</p><p>Find the sum of all the numbers that can be written as the sum of fifth powers of their digits.</p><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><p>该问题的关键为确定枚举的上界：设满足题设条件的数字为n位数，取其每位都为9的情况，构造不等式$ 10^{n} &lt;= 9^{5}*n $，计算满足条件n的最小值即可找出上界。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of all the numbers that can be written as the sum of fifth powers of their powers</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSum</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    sum_result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> input_number != <span class="number">0</span>:</span><br><span class="line">        sum_result += (input_number % <span class="number">10</span>)**<span class="number">5</span></span><br><span class="line">        input_number /= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> sum_result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    final_result = <span class="number">0</span></span><br><span class="line">    <span class="comment"># Work out the upper bound of the enumeration range</span></span><br><span class="line">    <span class="comment"># 10^n &lt;= 9^5*n =&gt; we can get the minimum value of n is 5</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">9</span>**<span class="number">5</span>*<span class="number">6</span>):</span><br><span class="line">        <span class="keyword">if</span> item == getSum(item):</span><br><span class="line">            final_result += item</span><br><span class="line">            <span class="keyword">print</span> item</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;21-Amicable-numbers&quot;&gt;&lt;a href=&quot;#21-Amicable-numbers&quot; class=&quot;headerlink&quot; title=&quot;21. Amicable numbers&quot;&gt;&lt;/a&gt;21. Amicable numbers&lt;/h2&gt;&lt;h3
      
    
    </summary>
    
      <category term="Mathematics" scheme="https://blank-vax.github.io/categories/Mathematics/"/>
    
    
      <category term="Euler-Project" scheme="https://blank-vax.github.io/tags/Euler-Project/"/>
    
  </entry>
  
  <entry>
    <title>Euler-Project(II)</title>
    <link href="https://blank-vax.github.io/2020/10/25/Euler-Project(II)/"/>
    <id>https://blank-vax.github.io/2020/10/25/Euler-Project(II)/</id>
    <published>2020-10-25T04:16:00.000Z</published>
    <updated>2021-07-07T04:04:38.306Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11-Largest-product-in-a-grid"><a href="#11-Largest-product-in-a-grid" class="headerlink" title="11. Largest product in a grid"></a>11. Largest product in a grid</h2><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>In the 20×20 grid below, four numbers along a diagonal line have been marked in bold.</p><p>08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08<br>49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00<br>81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65<br>52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91<br>22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80<br>24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50<br>32 98 81 28 64 23 67 10 <strong>26</strong> 38 40 67 59 54 70 66 18 38 64 70<br>67 26 20 68 02 62 12 20 95 <strong>63</strong> 94 39 63 08 40 91 66 49 94 21<br>24 55 58 05 66 73 99 26 97 17 <strong>78</strong> 78 96 83 14 88 34 89 63 72<br>21 36 23 09 75 00 76 44 20 45 35 <strong>14</strong> 00 61 33 97 34 31 33 95<br>78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92<br>16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57<br>86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58<br>19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40<br>04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66<br>88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69<br>04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36<br>20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16<br>20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54<br>01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48</p><p>The product of these numbers is 26 × 63 × 78 × 14 = 1788696.</p><p>What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Simply rotation and comparison in four types of direction</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">grid_given =<span class="string">'''08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08</span></span><br><span class="line"><span class="string">49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00</span></span><br><span class="line"><span class="string">81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65</span></span><br><span class="line"><span class="string">52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91</span></span><br><span class="line"><span class="string">22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80</span></span><br><span class="line"><span class="string">24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50</span></span><br><span class="line"><span class="string">32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70</span></span><br><span class="line"><span class="string">67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21</span></span><br><span class="line"><span class="string">24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72</span></span><br><span class="line"><span class="string">21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95</span></span><br><span class="line"><span class="string">78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92</span></span><br><span class="line"><span class="string">16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57</span></span><br><span class="line"><span class="string">86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58</span></span><br><span class="line"><span class="string">19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40</span></span><br><span class="line"><span class="string">04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66</span></span><br><span class="line"><span class="string">88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69</span></span><br><span class="line"><span class="string">04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36</span></span><br><span class="line"><span class="string">20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16</span></span><br><span class="line"><span class="string">20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54</span></span><br><span class="line"><span class="string">01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48'''</span></span><br><span class="line"><span class="comment"># Alist variable is used to slice the given grid</span></span><br><span class="line">alist = [re.split(<span class="string">' '</span>, everyrow) <span class="keyword">for</span> everyrow <span class="keyword">in</span> re.split(<span class="string">'\n'</span>, grid_given)]</span><br><span class="line">result_list = []</span><br><span class="line"><span class="comment"># rows</span></span><br><span class="line"><span class="keyword">for</span> row_index <span class="keyword">in</span> range(len(alist)):</span><br><span class="line">    <span class="keyword">for</span> columns_index <span class="keyword">in</span> xrange(len(alist[row_index])<span class="number">-3</span>):</span><br><span class="line">        result_list.append(int(alist[row_index][columns_index])*int(alist[row_index][columns_index+<span class="number">1</span>])*int(alist[row_index][columns_index+<span class="number">2</span>])*int(alist[row_index][columns_index+<span class="number">3</span>]))</span><br><span class="line"><span class="comment"># columns</span></span><br><span class="line"><span class="keyword">for</span> columns_index <span class="keyword">in</span> range(len(alist[<span class="number">0</span>])):</span><br><span class="line">    <span class="keyword">for</span> row_index <span class="keyword">in</span> xrange(len(alist)<span class="number">-3</span>):</span><br><span class="line">        result_list.append(int(alist[row_index][columns_index])*int(alist[row_index+<span class="number">1</span>][columns_index])*int(alist[row_index+<span class="number">2</span>][columns_index])*int(alist[row_index+<span class="number">3</span>][columns_index]))</span><br><span class="line"><span class="comment"># diagonal</span></span><br><span class="line"><span class="keyword">for</span> row_index <span class="keyword">in</span> range(len(alist)<span class="number">-3</span>):</span><br><span class="line">    <span class="keyword">for</span> columns_index <span class="keyword">in</span> range(len(alist[row_index])<span class="number">-3</span>):</span><br><span class="line">        <span class="comment"># main diagonal</span></span><br><span class="line">        result_list.append(int(alist[row_index][columns_index])*int(alist[row_index+<span class="number">1</span>][columns_index+<span class="number">1</span>])*int(alist[row_index+<span class="number">2</span>][columns_index+<span class="number">2</span>])*int(alist[row_index+<span class="number">3</span>][columns_index+<span class="number">3</span>]))</span><br><span class="line">        <span class="comment"># vice diagonal</span></span><br><span class="line">        result_list.append(int(alist[row_index+<span class="number">3</span>][columns_index])*int(alist[row_index+<span class="number">2</span>][columns_index+<span class="number">1</span>])*int(alist[row_index+<span class="number">1</span>][columns_index+<span class="number">2</span>])*int(alist[row_index][columns_index+<span class="number">3</span>]))</span><br><span class="line"><span class="keyword">print</span> max(result_list)</span><br></pre></td></tr></table></figure><h2 id="12-Highly-divisible-triangular-number"><a href="#12-Highly-divisible-triangular-number" class="headerlink" title="12. Highly divisible triangular number"></a>12. Highly divisible triangular number</h2><h3 id="Problem-Description-1"><a href="#Problem-Description-1" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:</p><p>1, 3, 6, 10, 15, 21, 28, 36, 45, 55, …</p><p>Let us list the factors of the first seven triangle numbers:</p><blockquote><p> <strong>1</strong>: 1<br> <strong>3</strong>: 1,3<br> <strong>6</strong>: 1,2,3,6<br><strong>10</strong>: 1,2,5,10<br><strong>15</strong>: 1,3,5,15<br><strong>21</strong>: 1,3,7,21<br><strong>28</strong>: 1,2,4,7,14,28</p></blockquote><p>We can see that 28 is the first triangle number to have over five divisors.</p><p>What is the value of the first triangle number to have over five hundred divisors?</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><p>通过观察可以发现，数字N的全部因子可分为大于$\sqrt{N}$和小于$\sqrt{N}$两部分，且这两部分的因子数量相等。故以$\sqrt{N}$为界限，统计前半部分因子数量，当大于250时跳出循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Triangular number</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">basic = <span class="number">1</span></span><br><span class="line">step = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    basic += step</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= int(math.sqrt(basic)):</span><br><span class="line">        <span class="keyword">if</span> basic % i == <span class="number">0</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> count &gt;= <span class="number">250</span>:</span><br><span class="line">        <span class="keyword">print</span> basic</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        step += <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h3><p>每个整数N可以分解为如下模式：</p><script type="math/tex; mode=display">N = p_{1}^{a1} * p_{2}^{a2} * p_{3}^{a3} * ...</script><p>此处$p<em>{n}$必为素数，$a</em>{n}$是其对应的幂指数。例如$28 = 2^{2} * 7^{1}$。继续推广下去，对于任意正整数N，其因子的数量D(N)可用如下式子表示：</p><script type="math/tex; mode=display">D(N) = (a_{1}+1) * (a_{2}+1) * (a_{3}+1) * ...</script><p>故首先采用埃氏筛法构造大素数表，随后对循环内每个数字进行分解以获得$a<em>{1}，a</em>{2}，a_{3}$等参数，连乘可得D(N)。对该常规方法进行改进，首先对三角形数进行等差数列求和，结果为$t = n * (n+1) / 2$，此处n和n+1必互素。随后采用如下公式分解D(t)：</p><p>$D(t) = D(n/2) * D(n+1)$, if n is even</p><p>$D(t) = D(n) * D((n+1)/2)$, if n is odd</p><p>实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Highly divisible triangular number</span></span><br><span class="line"><span class="comment"># First get the possible prime facotrs below 1000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPossiblePrimeFactors</span><span class="params">(upper_bound)</span>:</span></span><br><span class="line">    L = range(<span class="number">2</span>, upper_bound)</span><br><span class="line">    primes_list = findPrime(L)</span><br><span class="line">    <span class="keyword">return</span> primes_list</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPrime</span><span class="params">(L)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> L[i]**<span class="number">2</span> &lt; L[<span class="number">-1</span>]:</span><br><span class="line">        <span class="comment"># Eratosthenes algorithm</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(L)):</span><br><span class="line">            <span class="keyword">if</span> L[j] % L[i] == <span class="number">0</span>:</span><br><span class="line">                L[j] = <span class="number">0</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        L.sort()</span><br><span class="line">        L = L[count:]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countD</span><span class="params">(n, Dn, count_range, primes_list)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count &lt;= count_range:</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        n1 = n</span><br><span class="line">        <span class="keyword">if</span> n1 % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            n1 /= <span class="number">2</span></span><br><span class="line">        Dn1 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, primes_list[<span class="number">-1</span>]):</span><br><span class="line">            <span class="keyword">if</span> primes_list[i]**<span class="number">2</span> &gt; n1:</span><br><span class="line">                <span class="string">'''</span></span><br><span class="line"><span class="string">                When the prime divisor would be greater than the residual n1, that residual n1 is the last prime factor with an exponent = 1</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">                Dn1 = <span class="number">2</span>*Dn1</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># ause D(n) = (a1+1)*(a2+1)*(a3+1)*...., so initialize the exponent to 1</span></span><br><span class="line">            exponent = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> n1 % primes_list[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># resolve n1 to the form of multiplication, count a1, a2, a3, ...</span></span><br><span class="line">                exponent += <span class="number">1</span></span><br><span class="line">                n1 = n1 // primes_list[i]</span><br><span class="line">            <span class="keyword">if</span> exponent &gt; <span class="number">1</span>:</span><br><span class="line">                Dn1 = Dn1*exponent</span><br><span class="line">            <span class="keyword">if</span> n1 == <span class="number">1</span>: <span class="keyword">break</span></span><br><span class="line">        count = Dn*Dn1</span><br><span class="line">        Dn = Dn1</span><br><span class="line">    <span class="keyword">return</span> n*(n<span class="number">-1</span>) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">Dn = <span class="number">2</span></span><br><span class="line">primes_list = getPossiblePrimeFactors(<span class="number">1000</span>)</span><br><span class="line">final_result = countD(n, Dn, <span class="number">500</span>, primes_list)</span><br><span class="line"><span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><p>理解上述代码过程中，值得注意的是countD()函数的返回结果为n*(n-1) / 2而非n*(n+1) / 2，从而代码每次迭代计算的D(t)由传入while循环之前的n值表示，与上面提到的性质对应。</p><h2 id="13-Large-sum"><a href="#13-Large-sum" class="headerlink" title="13. Large sum"></a>13. Large sum</h2><h3 id="Problem-Description-2"><a href="#Problem-Description-2" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.</p><p>37107287533902102798797998220837590246510135740250<br>46376937677490009712648124896970078050417018260538<br>74324986199524741059474233309513058123726617309629<br>91942213363574161572522430563301811072406154908250<br>23067588207539346171171980310421047513778063246676<br>89261670696623633820136378418383684178734361726757<br>28112879812849979408065481931592621691275889832738<br>44274228917432520321923589422876796487670272189318<br>47451445736001306439091167216856844588711603153276<br>70386486105843025439939619828917593665686757934951<br>62176457141856560629502157223196586755079324193331<br>64906352462741904929101432445813822663347944758178<br>92575867718337217661963751590579239728245598838407<br>58203565325359399008402633568948830189458628227828<br>80181199384826282014278194139940567587151170094390<br>35398664372827112653829987240784473053190104293586<br>86515506006295864861532075273371959191420517255829<br>71693888707715466499115593487603532921714970056938<br>54370070576826684624621495650076471787294438377604<br>53282654108756828443191190634694037855217779295145<br>36123272525000296071075082563815656710885258350721<br>45876576172410976447339110607218265236877223636045<br>17423706905851860660448207621209813287860733969412<br>81142660418086830619328460811191061556940512689692<br>51934325451728388641918047049293215058642563049483<br>62467221648435076201727918039944693004732956340691<br>15732444386908125794514089057706229429197107928209<br>55037687525678773091862540744969844508330393682126<br>18336384825330154686196124348767681297534375946515<br>80386287592878490201521685554828717201219257766954<br>78182833757993103614740356856449095527097864797581<br>16726320100436897842553539920931837441497806860984<br>48403098129077791799088218795327364475675590848030<br>87086987551392711854517078544161852424320693150332<br>59959406895756536782107074926966537676326235447210<br>69793950679652694742597709739166693763042633987085<br>41052684708299085211399427365734116182760315001271<br>65378607361501080857009149939512557028198746004375<br>35829035317434717326932123578154982629742552737307<br>94953759765105305946966067683156574377167401875275<br>88902802571733229619176668713819931811048770190271<br>25267680276078003013678680992525463401061632866526<br>36270218540497705585629946580636237993140746255962<br>24074486908231174977792365466257246923322810917141<br>91430288197103288597806669760892938638285025333403<br>34413065578016127815921815005561868836468420090470<br>23053081172816430487623791969842487255036638784583<br>11487696932154902810424020138335124462181441773470<br>63783299490636259666498587618221225225512486764533<br>67720186971698544312419572409913959008952310058822<br>95548255300263520781532296796249481641953868218774<br>76085327132285723110424803456124867697064507995236<br>37774242535411291684276865538926205024910326572967<br>23701913275725675285653248258265463092207058596522<br>29798860272258331913126375147341994889534765745501<br>18495701454879288984856827726077713721403798879715<br>38298203783031473527721580348144513491373226651381<br>34829543829199918180278916522431027392251122869539<br>40957953066405232632538044100059654939159879593635<br>29746152185502371307642255121183693803580388584903<br>41698116222072977186158236678424689157993532961922<br>62467957194401269043877107275048102390895523597457<br>23189706772547915061505504953922979530901129967519<br>86188088225875314529584099251203829009407770775672<br>11306739708304724483816533873502340845647058077308<br>82959174767140363198008187129011875491310547126581<br>97623331044818386269515456334926366572897563400500<br>42846280183517070527831839425882145521227251250327<br>55121603546981200581762165212827652751691296897789<br>32238195734329339946437501907836945765883352399886<br>75506164965184775180738168837861091527357929701337<br>62177842752192623401942399639168044983993173312731<br>32924185707147349566916674687634660915035914677504<br>99518671430235219628894890102423325116913619626622<br>73267460800591547471830798392868535206946944540724<br>76841822524674417161514036427982273348055556214818<br>97142617910342598647204516893989422179826088076852<br>87783646182799346313767754307809363333018982642090<br>10848802521674670883215120185883543223812876952786<br>71329612474782464538636993009049310363619763878039<br>62184073572399794223406235393808339651327408011116<br>66627891981488087797941876876144230030984490851411<br>60661826293682836764744779239180335110989069790714<br>85786944089552990653640447425576083659976645795096<br>66024396409905389607120198219976047599490197230297<br>64913982680032973156037120041377903785566085089252<br>16730939319872750275468906903707539413042652315011<br>94809377245048795150954100921645863754710598436791<br>78639167021187492431995700641917969777599028300699<br>15368713711936614952811305876380278410754449733078<br>40789923115535562561142322423255033685442488917353<br>44889911501440648020369068063960672322193204149535<br>41503128880339536053299340368006977710650566631954<br>81234880673210146739058568557934581403627822703280<br>82616570773948327592232845941706525094512325230608<br>22918802058777319719839450180888072429661980811197<br>77158542502016545090413245809786882778948721859617<br>72107838435069186155435662884062257473692284509516<br>20849603980134001723930671666823555245252804609722<br>53503534226472524250874054075591789781264330331690</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">all_numbers = given_50_digit_numbers</span><br><span class="line">sum_result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> all_numbers.split(<span class="string">'\n'</span>):</span><br><span class="line">    <span class="keyword">if</span> item == <span class="string">''</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sum_result += int(item)</span><br><span class="line"><span class="keyword">print</span> str(sum_result)[<span class="number">0</span>:<span class="number">10</span>]</span><br></pre></td></tr></table></figure><h2 id="14-Longest-Collatz-sequence"><a href="#14-Longest-Collatz-sequence" class="headerlink" title="14. Longest Collatz sequence"></a>14. Longest Collatz sequence</h2><h3 id="Problem-Description-3"><a href="#Problem-Description-3" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The following iterative sequence is defined for the set of positive integers:</p><p>n → n/2 (n is even)<br>n → 3n + 1 (n is odd)</p><p>Using the rule above and starting with 13, we generate the following sequence:</p><p>13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1</p><p>It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.</p><p>Which starting number, under one million, produces the longest chain?</p><p><strong>NOTE:</strong> Once the chain starts the terms are allowed to go above one million.</p><h3 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1"></a>Solution1</h3><p>按照题意直接进行暴力遍历，可以采用递归和迭代的方法。采用靠近计算机底层的位运算代替普通运算可以适当提高效率：n &amp; 1 代替 n % 2，n &gt;&gt; 1代替 n / 2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Iteration</span></span><br><span class="line"><span class="comment"># Longest Collatz Sequence</span></span><br><span class="line"><span class="comment"># Which starting number, under one million, produces the longest chain</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCollatzSquence</span><span class="params">(n)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> n &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            n = <span class="number">3</span>*n+<span class="number">1</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    maxlength = <span class="number">1</span></span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>, <span class="number">1000000</span>):</span><br><span class="line">        count_number = getCollatzSquence(i)</span><br><span class="line">        <span class="keyword">if</span> count_number &gt; maxlength:</span><br><span class="line">            maxlength = count_number</span><br><span class="line">            flag = i</span><br><span class="line">    <span class="keyword">print</span> (maxlength, flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Recursion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countCollatzChain</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + countCollatzChain(n &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + countCollatzChain(<span class="number">3</span> * n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    longest_chain = <span class="number">0</span></span><br><span class="line">    result = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> range(<span class="number">100</span>, <span class="number">10</span>**<span class="number">6</span><span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> countCollatzChain(number) &gt; longest_chain:</span><br><span class="line">            longest_chain = countCollatzChain(number)</span><br><span class="line">            result = number</span><br><span class="line">    <span class="keyword">print</span> result</span><br></pre></td></tr></table></figure><p>二者效率对比如下，可以看出迭代调用所需时间明显小于递归调用。</p><p><img src="/2020/10/25/Euler-Project(II)/Euler-Project(II" alt="14_sufficiency.PNG-10.6kB">\1.PNG)</p><h3 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2"></a>Solution2</h3><p>无论采用递归或是迭代的方法进行暴力遍历，我们都可以明确看出有部分数值经过重复计算，导致运算时间过长。于是进行以下优化：</p><ul><li>引入字典存储已经计算过的考拉兹链长度；</li><li>根据考拉兹猜想提出的运算规则，我们可以得到Collatz(n) = Collatz(n/2) + 1。因此对于所有整数k，Collatz(2k) &gt; Collatz(k)必定成立，所以我们不必计算小于LIMIT/2的所有k值，本例中即无需计算低于500000的k的考拉兹链长度；</li><li>若n是奇数，则3*n+1必定为偶数，从而n经过考拉兹变换后最终得到(3*n+1) / 2。故当n是奇数时，采用以下公式简化运算过程：Collatz(n) = Collatz((3*n+1) / 2) + 2。</li></ul><p>代码复现如下，但效率无法达到相关题解中提及的1.5s。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the longest Collatz sequence chain</span></span><br><span class="line"><span class="comment"># Which starting number, under one million, produces the longest chain</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countCollatzChain</span><span class="params">(n, values)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> values.keys():</span><br><span class="line">        <span class="keyword">return</span> values[n]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> n &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">        values[n] = <span class="number">1</span> + countCollatzChain(n &gt;&gt; <span class="number">1</span>, values)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        values[n] = <span class="number">2</span> + countCollatzChain((<span class="number">3</span> * n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, values)</span><br><span class="line">    <span class="keyword">return</span> values[n] </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    longest_chain = <span class="number">0</span></span><br><span class="line">    final_result = <span class="number">-1</span></span><br><span class="line">    values = &#123;<span class="number">1</span>: <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> range(<span class="number">500000</span>, <span class="number">10</span>**<span class="number">6</span> - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> countCollatzChain(number, values) &gt; longest_chain:</span><br><span class="line">            longest_chain = countCollatzChain(number, values)</span><br><span class="line">            final_result = number</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h2 id="15-Lattice-paths"><a href="#15-Lattice-paths" class="headerlink" title="15. Lattice paths"></a>15. Lattice paths</h2><h3 id="Problem-Description-4"><a href="#Problem-Description-4" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner.</p><p><img src="/2020/10/25/Euler-Project(II)/Euler-Project(II" alt="4.png-9.7kB">\2.PNG)</p><p>How many such routes are there through a 20×20 grid?</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>本题目为简单格子路径问题，可以采用迭代、递归与组合数三种方法求解。</p><h4 id="Recursive-Solution"><a href="#Recursive-Solution" class="headerlink" title="Recursive Solution"></a>Recursive Solution</h4><p>将题目所给信息转换为一般问题，即求从(0, 0)点运动到(m, n)点的所有路径数量，该数量等于(0, 0)点到点(m-1, n)和(0, 0)点到点(m, n-1)的路径数量之和。以此类推，当m或n等于0时，(0, 0)点到达该点只存在一直向右或向下两条道路，此时递归算法返回1。值得注意的是，该方法存在重复计算问题，故可引入大容量数组存储可能需要的计算结果。</p><h4 id="Iterative-Solution"><a href="#Iterative-Solution" class="headerlink" title="Iterative Solution"></a>Iterative Solution</h4><p>递归法较易编写，但需要消耗较多计算资源，故考虑结合动态规划进行迭代求解。如果说递归法是”执果索因”，动态规划就是”由因导果”。首先建立20x20数组，由于第一行和第一列所有元素到达点(0, 0)只有一条路径，故数组中对应位置全部设置为1。随后从第二行第二列开始按照<code>grid[i][j] = grid[i][j-1] + grid[i-1][j]</code>进行数组赋值，目标位置<code>grid[m][n]</code>即为待求结果。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Lattice paths problem</span></span><br><span class="line"><span class="comment"># Simple dynamic programming</span></span><br><span class="line"><span class="comment"># Solution1 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllPaths</span><span class="params">(m, n)</span>:</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp[k][l] = dp[k<span class="number">-1</span>][l] + dp[k][l<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">print</span> dp</span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># Get all possible paths of 20 x 20 grids</span></span><br><span class="line">    final_result = getAllPaths(<span class="number">21</span>, <span class="number">21</span>)</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h4 id="Combinatorial-Solution"><a href="#Combinatorial-Solution" class="headerlink" title="Combinatorial Solution"></a>Combinatorial Solution</h4><p>以上两种方法时间复杂度均为O(mn)，我们可以使用组合数学以提高效率。</p><p>首先分析一般问题的本质，即从点(0, 0)到点(m, n)共需要走m+n步，其中需要向下走m步，向右走n步。于是引出简单无顺序组合问题即$\binom{m+n}{m}$。然而本题给出m=n=20，从而得到如下公式：</p><p><img src="/2020/10/25/Euler-Project(II)/Euler-Project(II" alt="15_formula.PNG-20.8kB">\3.PNG)</p><p>至此我们得到复杂度为O(n)的算法，实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Solution2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllPaths2</span><span class="params">(n)</span>:</span></span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        result = result * (n+i) / i</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># Get all possible paths of 20 x 20 grids</span></span><br><span class="line">    final_result2 = getAllPaths2(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">print</span> final_result2</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>方格问题升级之路（详细讨论格子路径问题）：<a href="https://blog.csdn.net/cookieZZ/article/details/70306757" target="_blank" rel="noopener">https://blog.csdn.net/cookieZZ/article/details/70306757</a></p><p>格子路径问题+组合数学：<a href="https://www.cnblogs.com/yhm138/p/13610626.html#102-lattice-paths-without-restrictions-无限制格子路径" target="_blank" rel="noopener">https://www.cnblogs.com/yhm138/p/13610626.html#102-lattice-paths-without-restrictions-无限制格子路径</a></p><h2 id="16-Power-digit-sum"><a href="#16-Power-digit-sum" class="headerlink" title="16. Power digit sum"></a>16. Power digit sum</h2><h3 id="Problem-Description-5"><a href="#Problem-Description-5" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>$2^{15} = 32768$ and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.</p><p>What is the sum of the digits of the number $2^{1000}$?</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Power digit sum</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDigitSum</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    digitsum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> input_number != <span class="number">0</span>:</span><br><span class="line">        digitsum += input_number % <span class="number">10</span></span><br><span class="line">        input_number /= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> digitsum</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    final_result = getDigitSum(<span class="number">2</span>**<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h2 id="17-Number-letter-counts"><a href="#17-Number-letter-counts" class="headerlink" title="17. Number letter counts"></a>17. Number letter counts</h2><h3 id="Problem-Description-6"><a href="#Problem-Description-6" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.</p><p>If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?</p><p><strong>NOTE:</strong> Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. The use of “and” when writing out numbers is in compliance with British usage.</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>最简单的方法为建立三个字典，分别存储个位数字1-9，十位数字1-9（即10-90）以及11-19，然后判断输入数字的位数并进行相关处理。该方法需要讨论的情况较多，例如三位数字便需要讨论100，1X0，10X，11X，1XX五种情况，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Count the letters of numbers 1 to 1000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countLetters</span><span class="params">(input_number, length, dict1, dict2, dict3)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> length == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> dict1[input_number]</span><br><span class="line">    <span class="keyword">elif</span> length == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> input_number / <span class="number">10</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> dict2[input_number]</span><br><span class="line">        <span class="keyword">elif</span> input_number % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> dict3[input_number/<span class="number">10</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> dict3[input_number/<span class="number">10</span>] + dict1[input_number%<span class="number">10</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> input_number % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> dict1[input_number/<span class="number">100</span>] + <span class="number">7</span></span><br><span class="line">        <span class="keyword">elif</span> input_number % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> dict1[input_number/<span class="number">100</span>] + dict3[input_number%<span class="number">100</span>/<span class="number">10</span>] + <span class="number">10</span></span><br><span class="line">        <span class="keyword">elif</span> input_number / <span class="number">10</span> % <span class="number">10</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> dict1[input_number/<span class="number">100</span>] + <span class="number">10</span> + dict2[input_number%<span class="number">100</span>]</span><br><span class="line">        <span class="keyword">elif</span> input_number / <span class="number">10</span> % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> dict1[input_number/<span class="number">100</span>] + <span class="number">10</span> + dict1[input_number%<span class="number">10</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> dict1[input_number/<span class="number">100</span>] + dict3[input_number%<span class="number">100</span>/<span class="number">10</span>] + dict1[input_number%<span class="number">10</span>] + <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># digits</span></span><br><span class="line">    dict1 = &#123;<span class="number">1</span>:<span class="number">3</span>, <span class="number">2</span>:<span class="number">3</span>, <span class="number">3</span>:<span class="number">5</span>, <span class="number">4</span>:<span class="number">4</span>, <span class="number">5</span>:<span class="number">4</span>, <span class="number">6</span>:<span class="number">3</span>, <span class="number">7</span>:<span class="number">5</span>, <span class="number">8</span>:<span class="number">5</span>, <span class="number">9</span>:<span class="number">4</span>&#125;</span><br><span class="line">    <span class="comment"># 10-tens</span></span><br><span class="line">    dict2 = &#123;<span class="number">10</span>:<span class="number">3</span>, <span class="number">11</span>:<span class="number">6</span>, <span class="number">12</span>:<span class="number">6</span>, <span class="number">13</span>:<span class="number">8</span>, <span class="number">14</span>:<span class="number">8</span>, <span class="number">15</span>:<span class="number">7</span>, <span class="number">16</span>:<span class="number">7</span>, <span class="number">17</span>:<span class="number">9</span>, <span class="number">18</span>:<span class="number">8</span>, <span class="number">19</span>:<span class="number">8</span>&#125;</span><br><span class="line">    <span class="comment"># tens</span></span><br><span class="line">    dict3 = &#123;<span class="number">1</span>:<span class="number">3</span>, <span class="number">2</span>:<span class="number">6</span>, <span class="number">3</span>:<span class="number">6</span>, <span class="number">4</span>:<span class="number">5</span>, <span class="number">5</span>:<span class="number">5</span>, <span class="number">6</span>:<span class="number">5</span>, <span class="number">7</span>:<span class="number">7</span>, <span class="number">8</span>:<span class="number">6</span>, <span class="number">9</span>:<span class="number">6</span>&#125;</span><br><span class="line">    total_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">1000</span>):</span><br><span class="line">        <span class="keyword">print</span> item</span><br><span class="line">        item_length = len(str(item))</span><br><span class="line">        <span class="comment"># print item_length</span></span><br><span class="line">        total_sum += countLetters(item, item_length, dict1, dict2, dict3)</span><br><span class="line">    </span><br><span class="line">    total_sum += <span class="number">11</span></span><br><span class="line">    <span class="keyword">print</span> total_sum</span><br></pre></td></tr></table></figure><p>由于三位数字与两位数字相比仅增加了对百位数字的讨论，本质为增加<code>X hundred and</code>这几个字符。故可以1-99为基础进行适当求和，从而省略了三位数字包含字符数量的判断，节约了运算时间，关键代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">        item_length = len(str(item))</span><br><span class="line">        total_sum += countLetters(item, item_length, dict1, dict2, dict3)</span><br><span class="line">    block_sum = total_sum</span><br><span class="line">    <span class="keyword">for</span> hundredstype <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        total_sum += dict1[hundredstype] + <span class="number">7</span> + (dict1[hundredstype] + <span class="number">10</span>) * <span class="number">99</span> + block_sum</span><br><span class="line">    total_sum += <span class="number">11</span></span><br><span class="line">    <span class="keyword">print</span> total_sum</span><br></pre></td></tr></table></figure><h2 id="18-Maximum-path-sum-I"><a href="#18-Maximum-path-sum-I" class="headerlink" title="18. Maximum path sum I"></a>18. Maximum path sum I</h2><h3 id="Problem-Description-7"><a href="#Problem-Description-7" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.</p><p><img src="/2020/10/25/Euler-Project(II)/Euler-Project(II" alt="18_problem_1.PNG-2.4kB">\4.PNG)</p><p>That is, 3 + 7 + 4 + 9 = 23.</p><p>Find the maximum total from top to bottom of the triangle below:</p><p><img src="/2020/10/25/Euler-Project(II)/Euler-Project(II" alt="18_problem_2.PNG-29.6kB">\5.PNG)</p><p><strong>NOTE:</strong> As there are only 16384 routes, it is possible to solve this problem by trying every route. However, <a href="https://projecteuler.net/problem=67" target="_blank" rel="noopener">Problem 67</a>, is the same challenge with a triangle containing one-hundred rows; it cannot be solved by brute force, and requires a clever method! ;o)</p><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>根据题目说明采用动态规划进行逐级递归。</p><p>首先将所给的字符串类型转换为二维数组，随后进行分析，核心思想为<strong>将上一行的数字更新为其本身与下一行相邻两数字中较大数字之和</strong>：以倒数第二行元素为例，63可更新为63+max(04, 62)即125，66可更新为66+max(62, 98)即164…以此类推，更新结束后二维数组第一个元素即为所求最长路径。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the maximum total from top to bottom of the triangle below:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transformToList</span><span class="params">(grid_string)</span>:</span></span><br><span class="line">    <span class="comment"># First transform the string to list</span></span><br><span class="line">    tmp_list = [item.split(<span class="string">' '</span>) <span class="keyword">for</span> item <span class="keyword">in</span> grid_string.split(<span class="string">'\n'</span>)]</span><br><span class="line">    <span class="comment"># print tmp_list</span></span><br><span class="line">    list_length = len(tmp_list)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(list_length):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>):</span><br><span class="line">            tmp_list[i][j] = int(tmp_list[i][j])</span><br><span class="line">    <span class="keyword">return</span> tmp_list</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dynamicProgramming</span><span class="params">(grid_list)</span>:</span></span><br><span class="line">    list_length = len(grid_list)</span><br><span class="line">    <span class="comment"># Start from the last but one line</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(list_length<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>):</span><br><span class="line">            grid_list[i][j] = grid_list[i][j] + max(grid_list[i+<span class="number">1</span>][j], grid_list[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> grid_list[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    grid = <span class="string">'''75</span></span><br><span class="line"><span class="string">95 64</span></span><br><span class="line"><span class="string">17 47 82</span></span><br><span class="line"><span class="string">18 35 87 10</span></span><br><span class="line"><span class="string">20 04 82 47 65</span></span><br><span class="line"><span class="string">19 01 23 75 03 34</span></span><br><span class="line"><span class="string">88 02 77 73 07 63 67</span></span><br><span class="line"><span class="string">99 65 04 28 06 16 70 92</span></span><br><span class="line"><span class="string">41 41 26 56 83 40 80 70 33</span></span><br><span class="line"><span class="string">41 48 72 33 47 32 37 16 94 29</span></span><br><span class="line"><span class="string">53 71 44 65 25 43 91 52 97 51 14</span></span><br><span class="line"><span class="string">70 11 33 28 77 73 17 78 39 68 17 57</span></span><br><span class="line"><span class="string">91 71 52 38 17 14 91 43 58 50 27 29 48</span></span><br><span class="line"><span class="string">63 66 04 68 89 53 67 30 73 16 69 87 40 31</span></span><br><span class="line"><span class="string">04 62 98 27 23 09 70 98 73 93 38 53 60 04 23'''</span></span><br><span class="line">    result_list = transformToList(grid)</span><br><span class="line">    final_result = dynamicProgramming(result_list)</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h2 id="19-Counting-Sundays"><a href="#19-Counting-Sundays" class="headerlink" title="19. Counting Sundays"></a>19. Counting Sundays</h2><h3 id="Problem-Description-8"><a href="#Problem-Description-8" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>You are given the following information, but you may prefer to do some research for yourself.</p><ul><li>1 Jan 1900 was a Monday.</li><li>Thirty days has September,<br>April, June and November.<br>All the rest have thirty-one,<br>Saving February alone,<br>Which has twenty-eight, rain or shine.<br>And on leap years, twenty-nine.</li><li>A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.</li></ul><p>How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?</p><h3 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1"></a>Solution1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?</span></span><br><span class="line"><span class="comment"># First we need to find the sum of the days from Febrary to December every year from 1901 to 2000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSundaysPerYear</span><span class="params">(input_year, first_day)</span>:</span></span><br><span class="line">    <span class="comment"># 31 days per month</span></span><br><span class="line">    month_list1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br><span class="line">    <span class="comment"># 30 days per month</span></span><br><span class="line">    month_list2 = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">11</span>]</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    month = <span class="number">1</span></span><br><span class="line">    <span class="comment"># input the location of the first day in this year as variable first_day</span></span><br><span class="line">    <span class="keyword">while</span> month &lt;= <span class="number">12</span>:</span><br><span class="line">        <span class="keyword">if</span> first_day % <span class="number">7</span> == <span class="number">0</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> month <span class="keyword">in</span> month_list1:</span><br><span class="line">            first_day += <span class="number">31</span></span><br><span class="line">        <span class="keyword">elif</span> month <span class="keyword">in</span> month_list2:</span><br><span class="line">            first_day += <span class="number">30</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> (input_year % <span class="number">4</span> == <span class="number">0</span> <span class="keyword">and</span> input_year % <span class="number">100</span> != <span class="number">0</span>) <span class="keyword">or</span> (input_year % <span class="number">400</span> == <span class="number">0</span>):</span><br><span class="line">                first_day += <span class="number">29</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                first_day += <span class="number">28</span></span><br><span class="line">        month += <span class="number">1</span></span><br><span class="line">    <span class="comment"># print count</span></span><br><span class="line">    <span class="keyword">return</span> (first_day % <span class="number">7</span>, count)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_day = <span class="number">2</span></span><br><span class="line">    final_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> year <span class="keyword">in</span> xrange(<span class="number">1901</span>, <span class="number">2001</span>):</span><br><span class="line">        <span class="comment"># print (year, start_day)</span></span><br><span class="line">        <span class="comment"># print "-------"</span></span><br><span class="line">        result_tuple = countSundaysPerYear(year, start_day)</span><br><span class="line">        start_day = result_tuple[<span class="number">0</span>]</span><br><span class="line">        final_count += result_tuple[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">print</span> final_count</span><br></pre></td></tr></table></figure><h3 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2"></a>Solution2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line">result_list = [calendar.weekday(year,month,<span class="number">1</span>) <span class="keyword">for</span> year <span class="keyword">in</span> range(<span class="number">1901</span>, <span class="number">2001</span>) <span class="keyword">for</span> month <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">13</span>)]</span><br><span class="line"><span class="keyword">print</span> result_list.count(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>python提供<code>calendar</code>模块实现日历功能，提供对日期的操作函数，常用函数说明如下：<a href="https://www.cnblogs.com/liuxiaowei/p/7263888.html。" target="_blank" rel="noopener">https://www.cnblogs.com/liuxiaowei/p/7263888.html。</a></p><h2 id="20-Factorial-digit-sum"><a href="#20-Factorial-digit-sum" class="headerlink" title="20. Factorial digit sum"></a>20. Factorial digit sum</h2><h3 id="Problem-Description-9"><a href="#Problem-Description-9" class="headerlink" title="Problem Description"></a>Problem Description</h3><p><em>n</em>! means <em>n</em> × (<em>n</em> − 1) × … × 3 × 2 × 1</p><p>For example, 10! = 10 × 9 × … × 3 × 2 × 1 = 3628800,<br>and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.</p><p>Find the sum of the digits in the number 100!</p><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Count the sum of digits of 100!</span></span><br><span class="line"><span class="keyword">import</span> math </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countDigitSum</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    sum_number = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> input_number != <span class="number">0</span>:</span><br><span class="line">        sum_number += input_number % <span class="number">10</span></span><br><span class="line">        input_number /= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> sum_number</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    final_result = countDigitSum(math.factorial(<span class="number">100</span>))</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;11-Largest-product-in-a-grid&quot;&gt;&lt;a href=&quot;#11-Largest-product-in-a-grid&quot; class=&quot;headerlink&quot; title=&quot;11. Largest product in a grid&quot;&gt;&lt;/a&gt;1
      
    
    </summary>
    
      <category term="Mathematics" scheme="https://blank-vax.github.io/categories/Mathematics/"/>
    
    
      <category term="Euler-Project" scheme="https://blank-vax.github.io/tags/Euler-Project/"/>
    
  </entry>
  
  <entry>
    <title>Euler-Project(I)</title>
    <link href="https://blank-vax.github.io/2020/10/13/Euler-Project(I)/"/>
    <id>https://blank-vax.github.io/2020/10/13/Euler-Project(I)/</id>
    <published>2020-10-13T13:40:00.000Z</published>
    <updated>2021-07-07T03:59:28.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Multiples-of-3-and-5"><a href="#1-Multiples-of-3-and-5" class="headerlink" title="1. Multiples of 3 and 5"></a>1. Multiples of 3 and 5</h2><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p><p>Find the sum of all the multiples of 3 or 5 below 1000.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># below 1000 </span></span><br><span class="line"><span class="comment"># multiples of 3 and 5</span></span><br><span class="line"><span class="comment"># 3*(1+2+3+...+999/3) + 5*(1+2+3+...+999/5) - 15*(1+2+3+...+999/15)</span></span><br><span class="line"><span class="comment"># Note that 1+2+3+...+p = 1/2*p*(p+1)</span></span><br><span class="line"></span><br><span class="line">count_result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">1000</span>, <span class="number">3</span>):</span><br><span class="line">    count_result += item</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item2 <span class="keyword">in</span> range(<span class="number">5</span>, <span class="number">1000</span>, <span class="number">5</span>):</span><br><span class="line">    <span class="keyword">if</span> item2 % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        count_result += item2</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> count_result</span><br></pre></td></tr></table></figure><h2 id="2-Even-Fibonacci-numbers"><a href="#2-Even-Fibonacci-numbers" class="headerlink" title="2. Even Fibonacci numbers"></a>2. Even Fibonacci numbers</h2><h3 id="Problem-Description-1"><a href="#Problem-Description-1" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:</p><p>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …</p><p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</span></span><br><span class="line"><span class="comment"># odd even odd odd even odd odd even odd odd even</span></span><br><span class="line"><span class="comment"># Find the total number of the Fibonacci numbers below four million</span></span><br><span class="line">origin1 = <span class="number">1</span></span><br><span class="line">origin2 = <span class="number">2</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">final_result = <span class="number">2</span></span><br><span class="line">origin_new = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> origin_new &lt; <span class="number">4000000</span>:</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    origin_new = origin1 + origin2</span><br><span class="line">    <span class="keyword">if</span> count % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        final_result += origin_new</span><br><span class="line">    origin1, origin2 = origin2, origin_new</span><br><span class="line"><span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><p><img src="/2020/10/13/Euler-Project(I)/Euler-Project(I" alt="image-20200905003907639.png-85.4kB">\1.png)</p><p><img src="/2020/10/13/Euler-Project(I)/Euler-Project(I" alt="image-20200905003924792.png-79.6kB">\2.png)</p><h2 id="3-Largest-prime-factor"><a href="#3-Largest-prime-factor" class="headerlink" title="3. Largest prime factor"></a>3. Largest prime factor</h2><h3 id="Problem-Description-2"><a href="#Problem-Description-2" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The prime factors of 13195 are 5, 7, 13 and 29.</p><p>What is the largest prime factor of the number 600851475143 ?</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Largest prime factor of designated number 600851475143</span></span><br><span class="line"><span class="comment"># Note the key word: prime factor</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Those numbers who are some times of evens or some odd must be composite numbers</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">3</span>, int(math.sqrt(n))+<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> n % item == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime2</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    All numbers can be shown as such numbers:6n, 6n+1, 6n+2, 6n+3, 6n+4, 6n+5</span></span><br><span class="line"><span class="string">    In these numbers, besides 2 and 3, only 6n+1 and 6n+5 may be primes.</span></span><br><span class="line"><span class="string">    For those who can be shown by 6n+1 and 6n+5 but aren't primes, they can be some times of 6n+1 or 6n+5</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span> <span class="keyword">or</span> n == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">6</span> != <span class="number">1</span> <span class="keyword">and</span> n % <span class="number">6</span> != <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(math.sqrt(n))+<span class="number">1</span>):</span><br><span class="line">        division = <span class="number">5</span> + (i+<span class="number">1</span>)*<span class="number">6</span> </span><br><span class="line">        <span class="keyword">if</span> (n // division &gt; <span class="number">1</span>) <span class="keyword">or</span> (n // (division+<span class="number">2</span>) &gt; <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># division == 6n+5, division+2 == 6n+1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">possible_result = []</span><br><span class="line">final_number = <span class="number">600851475143</span></span><br><span class="line">item = int(math.sqrt(final_number))+<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> item &gt;= <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> final_number % item == <span class="number">0</span>:</span><br><span class="line">        possible_result.append(item)</span><br><span class="line">    item -= <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> possible_result:</span><br><span class="line">    <span class="keyword">if</span> isPrime(result):</span><br><span class="line">        <span class="keyword">print</span> result</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h3><p>本题也可以使用厄拉多塞筛法寻找输入数字范围内所有的素数。因为素数的倍数一定不是素数，所以我们找到一个素数时可以将其倍数从所给范围内排除。这种方法称为素数筛。例如求100以内的素数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">100</span></span><br><span class="line">L = list(range(<span class="number">2</span>, n))</span><br><span class="line">ans = set()</span><br><span class="line"><span class="keyword">while</span> L:</span><br><span class="line">    x = L.pop(<span class="number">0</span>)</span><br><span class="line">    ans.add(x)</span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> i*x &lt; n:</span><br><span class="line">        <span class="keyword">if</span> i*x <span class="keyword">in</span> L:</span><br><span class="line">            L.remove(i*x)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">print(ans)</span><br><span class="line"><span class="comment"># ans = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97&#125;</span></span><br></pre></td></tr></table></figure><p>基于以上思想，在找输入数字因数时可以将合数筛出，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ans = []</span><br><span class="line">n = <span class="number">600851475143</span></span><br><span class="line">iter_max = int(n ** <span class="number">0.5</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">2</span>,iter_max):</span><br><span class="line">    <span class="keyword">if</span> n%num == <span class="number">0</span>:</span><br><span class="line">        ans.append(num)</span><br><span class="line">        n/=num</span><br><span class="line">        <span class="keyword">while</span> n%num == <span class="number">0</span>:</span><br><span class="line">            n/=num <span class="comment"># 保证n已被num除尽，此时n不会再有num*i的因数</span></span><br><span class="line">print(ans)</span><br><span class="line">ans = [<span class="number">71</span>, <span class="number">839</span>, <span class="number">1471</span>, <span class="number">6857</span>]</span><br></pre></td></tr></table></figure><h3 id="素数判别法"><a href="#素数判别法" class="headerlink" title="素数判别法"></a>素数判别法</h3><h4 id="根号判别法"><a href="#根号判别法" class="headerlink" title="根号判别法"></a>根号判别法</h4><p>设输入的数字为n，则可以通过遍历方法暴力搜索其素因子，若出现非1及其本身的素因子，则可断定该数字为素数。常见的遍历范围为1—n-1，其实将遍历范围调节至1—$\sqrt{n}$亦可实现素数判定的目的。</p><h4 id="奇偶判别法"><a href="#奇偶判别法" class="headerlink" title="奇偶判别法"></a>奇偶判别法</h4><p>对于所有可能成为数字x素因子的n-1个数字，偶数中除了2均不是质数，且奇数的因数没有偶数，因此可以继续优化。首先将n与2进行比较，其次判断2是否为n的素因子，最后从3开始以2为增幅逐次判断数字n是否包含奇数因子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Those numbers who are some times of evens or some odd must be composite numbers</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">3</span>, int(math.sqrt(n))+<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> n % item == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="6n系判别"><a href="#6n系判别" class="headerlink" title="6n系判别"></a>6n系判别</h4><p>所有数字均可表示为6n，6n+1，6n+2，6n+3，6n+4，6n+5的形式，除2和3以外，所有的素数都可以表示为6n+1和6n+5的形式，如果输入数字x是6n+1和6n+5的整数倍，则必为合数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime2</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    All numbers can be shown as such numbers:6n, 6n+1, 6n+2, 6n+3, 6n+4, 6n+5</span></span><br><span class="line"><span class="string">    In these numbers, besides 2 and 3, only 6n+1 and 6n+5 may be primes.</span></span><br><span class="line"><span class="string">    For those who can be shown by 6n+1 and 6n+5 but aren't primes, they can be some times of 6n+1 or 6n+5</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span> <span class="keyword">or</span> n == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">6</span> != <span class="number">1</span> <span class="keyword">and</span> n % <span class="number">6</span> != <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(math.sqrt(n))+<span class="number">1</span>):</span><br><span class="line">        division = <span class="number">5</span> + (i+<span class="number">1</span>)*<span class="number">6</span> </span><br><span class="line">        <span class="keyword">if</span> (n // division &gt; <span class="number">1</span>) <span class="keyword">or</span> (n // (division+<span class="number">2</span>) &gt; <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># division == 6n+5, division+2 == 6n+1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="Miller-Rabin素数判别法"><a href="#Miller-Rabin素数判别法" class="headerlink" title="Miller-Rabin素数判别法"></a>Miller-Rabin素数判别法</h4><p>该素数判别方法应用费马小定理对素数进行概率判定，若输入数字N通过t次测试，则N不是素数的概率仅为$(1/4)^{t}$，随着通过测试次数的增加，N是素数的概率无穷逼近于1。在实际运用中，可首先用300—500个小素数对N进行测试，以提高测试通过的概率与算法的速度。</p><p>具体步骤如下：</p><ul><li>计算奇数M，使得N=$2^{r}*M+1$；</li><li>选择随机数A&lt;N；</li><li>对于任意i&lt;r，若$A^{(2^{i}*M)}mod N=N-1$，则N通过随机数A的测试；</li><li>或者若$A^{M}modN=1$，则N通过随机数A的测试；</li><li>改变随机数A的值对N进行多次测试（一般为5—10次，较高需求的情况下可进行20—30次），若全部通过则判定N为素数。</li></ul><p>相关代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fast_power</span><span class="params">(base, power, n)</span>:</span></span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    tmp = base</span><br><span class="line">    <span class="keyword">while</span> power &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> power&amp;<span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">            result = (result * tmp) % n</span><br><span class="line">        tmp = (tmp * tmp) % n </span><br><span class="line">        power = power&gt;&gt;<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Miller_Rabin</span><span class="params">(n, iter_num)</span>:</span></span><br><span class="line">    <span class="comment"># 2 is prime</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="comment"># if n is even or less than 2, then n is not a prime</span></span><br><span class="line">    <span class="keyword">if</span> n&amp;<span class="number">1</span> == <span class="number">0</span> <span class="keyword">or</span> n&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># n-1 = (2^s)m</span></span><br><span class="line">    <span class="comment"># get random odd m</span></span><br><span class="line">    m,s = n - <span class="number">1</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> m&amp;<span class="number">1</span>==<span class="number">0</span>:</span><br><span class="line">        m = m&gt;&gt;<span class="number">1</span></span><br><span class="line">        s += <span class="number">1</span></span><br><span class="line">    <span class="comment"># M-R </span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(iter_num):</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        key algorithm</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        b = fast_power(random.randint(<span class="number">2</span>,n<span class="number">-1</span>), m, n)</span><br><span class="line">        <span class="keyword">if</span> b==<span class="number">1</span> <span class="keyword">or</span> b== n<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> __ <span class="keyword">in</span> range(s<span class="number">-1</span>):</span><br><span class="line">            b = fast_power(b, <span class="number">2</span>, n)</span><br><span class="line">            <span class="keyword">if</span> b == n<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># example</span></span><br><span class="line">    print(Miller_Rabin(<span class="number">49139</span>, <span class="number">10</span>))</span><br><span class="line">    print(Miller_Rabin(<span class="number">561</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><h4 id="素数筛查"><a href="#素数筛查" class="headerlink" title="素数筛查"></a>素数筛查</h4><p>除了上述的高级试除法外，还可以使用素数筛查的方法。常见的素数筛查包括埃拉托斯特尼筛法和欧拉筛法。</p><p>埃氏筛法由希腊数学家埃拉托斯特尼提出，用以简单鉴定素数，方法如下：要获取自然数n（上界）内的全部素数，必须剔除所有小于等于sqrt(n)的素数的倍数，经过此种筛查后，剩下的就是素数。</p><p>欧拉筛法是埃氏筛法的改进。采用欧拉筛法进行筛选过程中，对于含多个因子的数字需要进行多次筛选，耗费部分运行时间。例如，对于合数20，可分解为2*10，4*5，故至少需要筛选两次。欧拉筛过程中引入语句<code>if i%prime[j] == 0: break</code>，保证每个合数只被这个合数最小的质因子筛除，而且不出现重复筛除。</p><p>代码实现可参考：<a href="https://blog.csdn.net/FeilingGong/article/details/83660779?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">素数筛法详解（欧拉筛&amp;埃氏筛）</a>。</p><h2 id="4-Largest-palindrome-product"><a href="#4-Largest-palindrome-product" class="headerlink" title="4. Largest palindrome product"></a>4. Largest palindrome product</h2><h3 id="Problem-Description-3"><a href="#Problem-Description-3" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.</p><p>Find the largest palindrome made from the product of two 3-digit numbers.</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    Suppose that P = a*b = 100000*x+10000*y+1000*z+100*z+10*y+x = 11*(9091*x+910*y+100*z)</span></span><br><span class="line"><span class="string">    The range of a and b are both 100 to 999</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    reversed = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> input_number &gt; <span class="number">0</span>:</span><br><span class="line">        reversed = reversed*<span class="number">10</span> + input_number % <span class="number">10</span></span><br><span class="line">        input_number /= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> reversed</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> input_number == reverse(input_number)</span><br><span class="line"></span><br><span class="line">largest_number = <span class="number">0</span></span><br><span class="line">a = <span class="number">999</span></span><br><span class="line"><span class="keyword">while</span> a &gt;= <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">if</span> a % <span class="number">11</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># Then b doesn't need to contain prime factor 11</span></span><br><span class="line">        b = <span class="number">999</span></span><br><span class="line">        b_down = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># b needs to contain prime factor 11</span></span><br><span class="line">        b = <span class="number">990</span></span><br><span class="line">        b_down = <span class="number">11</span></span><br><span class="line">    <span class="keyword">while</span> b &gt;= <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">if</span> a*b &lt;= largest_number:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> isPalindrome(a*b):</span><br><span class="line">            largest_number = a*b</span><br><span class="line">        b = b - b_down</span><br><span class="line">    a = a - <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> largest_number</span><br></pre></td></tr></table></figure><h2 id="5-Smallest-multiple"><a href="#5-Smallest-multiple" class="headerlink" title="5. Smallest multiple"></a>5. Smallest multiple</h2><h3 id="Problem-Description-4"><a href="#Problem-Description-4" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.</p><p>What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    The factors are 20 numbers from 1 to 20</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    All numbers can be shown as such numbers:6n, 6n+1, 6n+2, 6n+3, 6n+4, 6n+5</span></span><br><span class="line"><span class="string">    In these numbers, besides 2 and 3, only 6n+1 and 6n+5 may be primes.</span></span><br><span class="line"><span class="string">    For those who can be shown by 6n+1 and 6n+5 but aren't primes, they can be some times of 6n+1 or 6n+5</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span> <span class="keyword">or</span> n == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">6</span> != <span class="number">1</span> <span class="keyword">and</span> n % <span class="number">6</span> != <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(math.sqrt(n))+<span class="number">1</span>):</span><br><span class="line">        division = <span class="number">5</span> + (i+<span class="number">1</span>)*<span class="number">6</span> </span><br><span class="line">        <span class="keyword">if</span> (n // division &gt; <span class="number">1</span>) <span class="keyword">or</span> (n // (division+<span class="number">2</span>) &gt; <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># division == 6n+5, division+2 == 6n+1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">factors_list = []</span><br><span class="line">original_list = [x+<span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">20</span>)]</span><br><span class="line"><span class="keyword">print</span> original_list</span><br><span class="line"><span class="comment"># Get all primes</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> original_list:</span><br><span class="line">    <span class="keyword">if</span> isPrime(item):</span><br><span class="line">        factors_list.append(item)</span><br><span class="line"></span><br><span class="line">k = <span class="number">20</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">N = <span class="number">1</span></span><br><span class="line">edge_number = math.sqrt(k)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> i == len(factors_list):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> factors_list[i] &lt;= edge_number:</span><br><span class="line">        N = N*pow(factors_list[i], math.floor(math.log(k)/math.log(factors_list[i])))</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> N</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        N = N*factors_list[i]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> N</span><br><span class="line"><span class="keyword">print</span> N</span><br></pre></td></tr></table></figure><p>分析题目，首先以1—10之间的数字为例，我们进行以下操作：</p><ul><li>Step1：寻找2—10内所有素数，即2、3、5、7，则剩余合数均可以素数的幂乘积的形式表示；待求的最小倍数可以表示为$min_multiply = 2^a<em>3^b</em>5^c*7^d$。</li><li>Step2：分解剩余合数，均表示为min_multiply所示形式。</li><li>Step3：取最大指数作为待求参数a，b，c，d的值。</li></ul><p>现令N为可被2—k间所有数字整除的最小数字，分析求解N的过程。参考上述k=10时的分析，首先确定所有小于k的素数，存入列表P。随后确定列表中每个元素的次数，令$P[i]^{a[i]} = k$，两侧同时进行对数运算并向下取整，得$a[i] = floor(log(k) / log(P[i]))$。值得注意的是，当$P[i]^{2} &gt; k$时，a[i]==1，故只需要计算满足$P[i] &lt;= \sqrt(k)$对应素数的次数a[i]。最终$N=P[0]^{a[0]}<em>P[1]^{a[1]}</em>P[2]^{a[2]}*……..$</p><h2 id="6-Sum-square-difference"><a href="#6-Sum-square-difference" class="headerlink" title="6. Sum square difference"></a>6. Sum square difference</h2><h3 id="Problem-Description-5"><a href="#Problem-Description-5" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The sum of the squares of the first ten natural numbers is,</p><script type="math/tex; mode=display">1^2 + 2^2 + ... + 10^2 = 385</script><p>The square of the sum of the first ten natural numbers is,</p><script type="math/tex; mode=display">(1 + 2 + ... + 10)^2 = 55^2 = 3025</script><p>Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is $3025 - 385 = 2640$.</p><p>Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    sum1 = 1+2+3+..+n = n*(n+1)/2</span></span><br><span class="line"><span class="string">    sum2 = 1**2 + 2**2 + 3**2 +...+ n**2 = n*(n+1)*(2*n+1)/6</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">sum1 = <span class="number">100</span>*<span class="number">101</span>/<span class="number">2</span></span><br><span class="line">sum2 = <span class="number">100</span>*<span class="number">101</span>*<span class="number">201</span>/<span class="number">6</span></span><br><span class="line"><span class="keyword">print</span> sum2-sum1</span><br></pre></td></tr></table></figure><h2 id="7-10001st-prime"><a href="#7-10001st-prime" class="headerlink" title="7. 10001st prime"></a>7. 10001st prime</h2><h3 id="Problem-Description-6"><a href="#Problem-Description-6" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.</p><p>What is the 10 001st prime number?</p><h3 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1"></a>Solution1</h3><p>题目只给出素数的个数，最简单的思路就是循环计数与素数判断相结合。素数判断过程中，现补充事实如下：</p><ul><li>1不是素数</li><li>除2以外的所有素数均为奇数</li><li>所有比3大的素数均可以写成6k+/-1的形式，k为整数</li><li>如果我们无法找到小于等于sqrt(n)并能够整除n的数字f，则可以判定n为素数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Method1: Round and prime judgement</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> input_number == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> input_number &lt; <span class="number">4</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">    <span class="keyword">elif</span> input_number % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> input_number &lt; <span class="number">9</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> input_number % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        limit = math.floor(math.sqrt(input_number))</span><br><span class="line">        f = <span class="number">5</span></span><br><span class="line">        <span class="keyword">while</span> f &lt;= limit:</span><br><span class="line">            <span class="comment"># Which means 6n-1</span></span><br><span class="line">            <span class="keyword">if</span> input_number % f == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># We must plus 2 to get 6n+1</span></span><br><span class="line">            <span class="keyword">if</span> input_number % (f+<span class="number">2</span>) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            f += <span class="number">6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">final_number = <span class="number">3</span></span><br><span class="line">count = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">10001</span>:</span><br><span class="line">    final_number += <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> isPrime(final_number):</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">print</span> final_number</span><br></pre></td></tr></table></figure><h3 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2"></a>Solution2</h3><p>本题也可以采用埃拉托斯特尼筛法进行求解，求解的关键是确定第10001个素数的上界。为确保一定会出现第10001个素数，取较大的上界为1000000。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Method2: a sieve of Eratosthenes</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPrime</span><span class="params">(L)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> L[i]**<span class="number">2</span> &lt; L[<span class="number">-1</span>]:</span><br><span class="line">        <span class="comment"># Eratosthenes algorithm</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(L)):</span><br><span class="line">            <span class="keyword">if</span> L[j] % L[i] == <span class="number">0</span>:</span><br><span class="line">                L[j] = <span class="number">0</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        L.sort()</span><br><span class="line">        L = L[count:]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"><span class="comment"># L = (2,3,4,...,1000000)</span></span><br><span class="line">L = range(<span class="number">2</span>, <span class="number">1000000</span>)</span><br><span class="line">primes_list = findPrime(L)</span><br><span class="line">print(primes_list[<span class="number">10000</span>])</span><br></pre></td></tr></table></figure><h2 id="8-Largest-product-in-a-series"><a href="#8-Largest-product-in-a-series" class="headerlink" title="8. Largest product in a series"></a>8. Largest product in a series</h2><h3 id="Problem-Description-7"><a href="#Problem-Description-7" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.</p><p>73167176531330624919225119674426574742355349194934<br>96983520312774506326239578318016984801869478851843<br>85861560789112949495459501737958331952853208805511<br>12540698747158523863050715693290963295227443043557<br>66896648950445244523161731856403098711121722383113<br>62229893423380308135336276614282806444486645238749<br>30358907296290491560440772390713810515859307960866<br>70172427121883998797908792274921901699720888093776<br>65727333001053367881220235421809751254540594752243<br>52584907711670556013604839586446706324415722155397<br>53697817977846174064955149290862569321978468622482<br>83972241375657056057490261407972968652414535100474<br>82166370484403199890008895243450658541227588666881<br>16427171479924442928230863465674813919123162824586<br>17866458359124566529476545682848912883142607690042<br>24219022671055626321111109370544217506941658960408<br>07198403850962455444362981230987879927244284909188<br>84580156166097919133875499200524063689912560717606<br>05886116467109405077541002256983155200055935729725<br>71636269561882670428252483600823257530420752963450</p><p>Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?</p><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    Find the thirteen adjacent digits in the 1000-digits number</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">input_number = given_string</span><br><span class="line"><span class="comment"># Transform the 1000-digits number to number list in order to get each number seperately</span></span><br><span class="line">input_number_list = [eval(input_number[i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(input_number))]</span><br><span class="line">maximum_number = <span class="number">0</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt;= len(input_number) - <span class="number">13</span>:</span><br><span class="line">    <span class="comment"># Combination of function reduce() and lambda function</span></span><br><span class="line">    result_number = reduce(<span class="keyword">lambda</span> x, y: x*y, input_number_list[count:count+<span class="number">13</span>])</span><br><span class="line">    <span class="keyword">if</span> result_number &gt; maximum_number:</span><br><span class="line">        maximum_number = result_number</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> maximum_number</span><br></pre></td></tr></table></figure><h2 id="9-Special-Pythagorean-triplet"><a href="#9-Special-Pythagorean-triplet" class="headerlink" title="9. Special Pythagorean triplet"></a>9. Special Pythagorean triplet</h2><h3 id="Problem-Description-8"><a href="#Problem-Description-8" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>A Pythagorean triplet is a set of three natural numbers, a &lt; b &lt; c, for which,</p><script type="math/tex; mode=display">a^{2} + b^{2} = c^{2}</script><p>For example, $3^{2} + 4^{2} = 9 + 16 = 25 = 5^{2}$.</p><p>There exists exactly one Pythagorean triplet for which a + b + c = 1000.<br>Find the product abc.</p><h3 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1"></a>Solution1</h3><p>可以采用放缩的方法，以题目所给的1000为例，设$ a=m1<em>k，b=m2</em>k，c=m3*k$，这里m1，m2，m3为小于50的勾股数。故只需要寻找满足1000 % (m1+m2+m3) == 0的勾股数并相应扩大k倍，使其满足a+b+c == 1000即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    1. a+b+c = 1000</span></span><br><span class="line"><span class="string">    2. Suppose a&lt;b&lt;c,then we get a^2 + b^2 = c^2</span></span><br><span class="line"><span class="string">    3. Find a,b,c and calculate abc</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># First find all the Pythagorean triplet number under 50</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">50</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">50</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">50</span>):</span><br><span class="line">            <span class="keyword">if</span> i**<span class="number">2</span>+j**<span class="number">2</span> == k**<span class="number">2</span> <span class="keyword">and</span> <span class="number">1000</span>%(i+j+k) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">print</span> i*j*k*(<span class="number">1000</span>/(i+j+k))**<span class="number">3</span></span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2"></a>Solution2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the only Pythagorean triplet(a, b, c), for which a+b+c = 1000</span></span><br><span class="line"><span class="comment"># a^2+b^2=(s-a-b)^2, cause a&lt;b&lt;c, then a&lt;=(s-3)/3 and b &lt;(s-a)/2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPythagorean</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">3</span>, (s<span class="number">-3</span>)//<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> range(a+<span class="number">1</span>, (s<span class="number">-1</span>-a)//<span class="number">2</span>):</span><br><span class="line">            c = s-a-b</span><br><span class="line">            <span class="keyword">if</span> c*c == a*a + b*b:</span><br><span class="line">                <span class="keyword">print</span> (a,b,c)</span><br><span class="line">                <span class="keyword">return</span> a*b*c</span><br><span class="line"></span><br><span class="line">final_multiply = getPythagorean(<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">print</span> final_multiply</span><br></pre></td></tr></table></figure><h3 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h3><p>下面通过勾股数的一些性质简化解法二中的代码，提高程序运行效率。</p><p>如果勾股数(a, b, c)满足gcd(a, b, c) = 1，定义该类勾股数具有素数性质。同时，任意组勾股数(a, b, c)可表示为：</p><script type="math/tex; mode=display">a = m^{2}-n^{2}，b = 2*m*n，c = m^{2}+n^{2}，m>n>0 (9.1)</script><p>由于勾股数可通过倍乘进行放缩，故可对(a, b, c)进行运算，得到以下结果：</p><script type="math/tex; mode=display">a = (m^{2}-n^{2})*d，b = 2*m*n*d，c = (m^{2}+n^{2})*d, m>n>0 (9.2)</script><p>使用以上性质，我们可得：</p><script type="math/tex; mode=display">a+b+c = 2*m*(m+n)*d (9.3)</script><p>所以想要找到勾股数组合(a, b, c)满足a+b+c = s，我们需要在1—s/2之间寻找除数m，并寻找s/2m的奇除数k（此处k=m+n，k满足m &lt; k &lt; 2m，并且m，k互素）。随后令n = k - m，d = s/2mk，将该结果插入式(9.2)中，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">euclid_gcd</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> a &lt; b:</span><br><span class="line">        a, b = b, a</span><br><span class="line">    <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">        a, b = b, a%b</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPythagorean</span><span class="params">(s2, mlimit)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">2</span>, mlimit):</span><br><span class="line">        <span class="keyword">if</span> s2 % m == <span class="number">0</span>:</span><br><span class="line">            sm = s2 // m</span><br><span class="line">            <span class="keyword">while</span> sm % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                sm = sm // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> m % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                k = m+<span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                k = m+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> k &lt; <span class="number">2</span>*m <span class="keyword">and</span> k &lt;= sm:</span><br><span class="line">                <span class="keyword">if</span> sm % k == <span class="number">0</span> <span class="keyword">and</span> euclid_gcd(k, m) == <span class="number">1</span>:</span><br><span class="line">                    d = s2 // (k*m)</span><br><span class="line">                    n = k - m</span><br><span class="line">                    a = d*(m*m-n*n)</span><br><span class="line">                    b = <span class="number">2</span>*d*m*n</span><br><span class="line">                    c = d*(m*m+n*n)</span><br><span class="line">                    <span class="keyword">print</span> (a, b, c)</span><br><span class="line">                    <span class="keyword">return</span> a*b*c</span><br><span class="line">                k += <span class="number">2</span></span><br><span class="line">s = <span class="number">1000</span></span><br><span class="line">s2 = s // <span class="number">2</span></span><br><span class="line">mlimit = int(math.ceil(math.sqrt(s2))) - <span class="number">1</span></span><br><span class="line">final_result = getPythagorean(s2, mlimit)</span><br><span class="line"><span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h2 id="10-Sum-all-primes-below-N-million"><a href="#10-Sum-all-primes-below-N-million" class="headerlink" title="10. Sum all primes below N million"></a>10. Sum all primes below N million</h2><h3 id="Problem-Description-9"><a href="#Problem-Description-9" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.</p><p>Find the sum of all the primes below two million.</p><h3 id="Solution1-3"><a href="#Solution1-3" class="headerlink" title="Solution1"></a>Solution1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sum after the sieve of Eratosthenes</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPrime</span><span class="params">(L)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> L[i]**<span class="number">2</span> &lt; L[<span class="number">-1</span>]:</span><br><span class="line">        <span class="comment"># Eratosthenes algorithm</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(L)):</span><br><span class="line">            <span class="keyword">if</span> L[j] % L[i] == <span class="number">0</span>:</span><br><span class="line">                L[j] = <span class="number">0</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        L.sort()</span><br><span class="line">        L = L[count:]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line">L = range(<span class="number">2</span>, <span class="number">2000000</span>)</span><br><span class="line">primes_list = findPrime(L)</span><br><span class="line"><span class="keyword">print</span> reduce(<span class="keyword">lambda</span> x,y:x+y, primes_list)</span><br></pre></td></tr></table></figure><h3 id="Solution2-3"><a href="#Solution2-3" class="headerlink" title="Solution2"></a>Solution2</h3><p>除2以外的所有偶数均为合数，故只需要对所给范围2—N内的奇数进行素性判断。我们建立下标i与奇数2*i+1的对应关系。首先建立布尔类型数组，其长度为(N-1)/2，初始值均为False，表示全为素数。设p=2*i+1，则$p^{2}=4<em>i^{2}+4</em>i+1$，其对应的数组下标为2*i+1；设m=k*p，则m+2*p对应的下标为j+p。</p><p>同样参考埃氏筛的思路，下一步需要找外部循环的下标范围、内部循环的初始值以及步进参数。结合以上分析进行讨论。由$2<em>i_max+1&lt;= \sqrt(N)$可得i的范围为$(\lfloor N\rfloor -1) / 2$，该范围是外部循环的下标范围。对于奇数p，所有小于p^2的数字中若为合数则必可被小于p的素数整除，故内部循环的初始值设定为p^2，对应下标为2\</em>i*(i+1)。又$p^{2}+p = 4<em>i^{2}+4</em>i+1+2<em>i+1 = 4</em>i^{2}+6<em>i+2 = 2</em>(2<em>i^{2}+3</em>i+1)$，可知若以p为步进，则得到的结果必为合数，无需进行判断。同时$p^{2}+2<em>p = 2</em>(2<em>i+1)+1 = 4</em>i^{2}+8*i+3 $，可以看出该结果必为合数，同时该结果为p的倍数，将数组对应下标位置标记为True。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Some imporvement of the sieve of Eratosthenes</span></span><br><span class="line"><span class="comment"># Only consider the odd numbers, do some index-arithmetics</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPrimes</span><span class="params">(sievebound, sieve_set, input_number)</span>:</span></span><br><span class="line">    crosslimit = int(math.floor(math.sqrt(input_number)<span class="number">-1</span> // <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, crosslimit):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sieve_set[i]:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>*i*(i+<span class="number">1</span>), sievebound, <span class="number">2</span>*i+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 2*j+1 is compositive</span></span><br><span class="line">                sieve_set[j] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> sieve_set</span><br><span class="line">input_number = <span class="number">2000000</span></span><br><span class="line">sievebound = int(math.floor((input_number<span class="number">-1</span>) // <span class="number">2</span>))</span><br><span class="line">sieve_set = [<span class="literal">False</span>]*input_number</span><br><span class="line">sieve_set_after_deal = findPrimes(sievebound, sieve_set, input_number)</span><br><span class="line">sum_result = <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, sievebound):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sieve_set[k]:</span><br><span class="line">        sum_result += <span class="number">2</span>*k+<span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> sum_result</span><br></pre></td></tr></table></figure><p>以题中所给的2000000为例，解法一运行速度为8s左右，解法二运行速度大大提升，只需要0.417s。</p><p><img src="/2020/10/13/Euler-Project(I)/Euler-Project(I" alt="10_sufficiency.PNG-11.2kB">\3.png)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Multiples-of-3-and-5&quot;&gt;&lt;a href=&quot;#1-Multiples-of-3-and-5&quot; class=&quot;headerlink&quot; title=&quot;1. Multiples of 3 and 5&quot;&gt;&lt;/a&gt;1. Multiples of 3 a
      
    
    </summary>
    
      <category term="Mathematics" scheme="https://blank-vax.github.io/categories/Mathematics/"/>
    
    
      <category term="Euler-Project" scheme="https://blank-vax.github.io/tags/Euler-Project/"/>
    
  </entry>
  
  <entry>
    <title>21深信服秋招面试</title>
    <link href="https://blank-vax.github.io/2020/09/26/21%E7%A7%8B%E6%8B%9B%E6%B7%B1%E4%BF%A1%E6%9C%8D%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/"/>
    <id>https://blank-vax.github.io/2020/09/26/21秋招深信服秋招面经/</id>
    <published>2020-09-25T16:27:00.000Z</published>
    <updated>2020-11-09T03:40:59.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近日考研期间，适逢深信服”翔鹰计划”线上实习结束，公司给了秋招提前批的面试机会，准备了大概两天就去面试了，岗位是<strong>技服工程师</strong>。由于前期通过笔试，故直接进入技术面、业务面和HR面。</p><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><ul><li>7.19 2020年”翔鹰计划”结束，成绩考核通过，简历转入公司秋招简历池；</li><li>7.23 技服工程师线上技术（一面）面试</li><li>7.30 技服工程师线上业务（二面）面试</li><li>8.4 技服工程师线上HR面试</li><li>9.18 offer沟通</li><li>9.22 签订三方协定（虽然最后没签</li></ul><h2 id="技术面（一面）"><a href="#技术面（一面）" class="headerlink" title="技术面（一面）"></a>技术面（一面）</h2><p>邮件中面试官约定的事件是上午11：00，大概提前两分钟左右进入房间调试设备，不过不知道是牛客网平台原因还是公司网络原因，面试官声音一直断断续续，中间还出现突然静音的情况，于是后期换了腾讯会议。</p><p>面试时间为45分钟，首先进行自我介绍，然后面试官进行提问。问题包括技术问题和非技术问题合计共十个左右，具体如下。</p><h3 id="技术问题"><a href="#技术问题" class="headerlink" title="技术问题"></a>技术问题</h3><ul><li><p>简要介绍VLAN</p><p>回答了VLAN的定义，虚拟局域网。主要作用为将同一网段根据功能划分成不同的虚拟子网。以公司为例，为保证主管、业务、销售、技术等各个部门之间网络的专有通信，引入VLAN技术，实现各部门人员之间在对应虚拟子网内部的高效安全通信，不会产生业务互相影响的情况。</p></li><li><p>简要介绍交换机</p><p>交换机是二层设备，位于数据链路层，主要作用为端口数据帧转发。提到了ARP协议，提出每个交换机维护一个ARP表，以保证不同主机之间的正常通信。顺便讲了一下ARP广播单播，以及相同网段之间主机如何进行通信。</p></li><li><p>针对ARP协议的攻击</p><p>简单讲了ARP欺骗和ARP洪泛攻击，重点介绍了攻击手法及危害。</p></li><li><p>ARP欺骗的防御方法</p><p>由于对ARP欺骗的防御掌握不深入，所以当时简单提到了修改帧结构及增加校验部分，以及进行相关检测。面试官追问哪个设备进行相关检测，然后就没有答上来。面试结束后，参考FreeBuf上的一篇文章：<a href="https://www.freebuf.com/articles/network/210852.html" target="_blank" rel="noopener">浅谈ARP欺骗的实现与防御</a>，归纳两个防御手段：</p><ul><li>主机欺骗：在本机添加一条静态的ARP映射，这样就无需询问网关MAC地址；</li><li>网关欺骗：在网关中也添加一条到主机的静态ARP映射。</li></ul></li><li><p>对路由选择协议的认识</p><p>回答了路由优先级顺序：<strong>直连路由&gt;静态路由&gt;动态路由&gt;默认路由</strong>。静态路由部分只提到需要在路由器上手动配置。动态路由部分提到了内部网关协议与外部网关协议。外部网关协议包括BGP，内部网关协议又分为基于距离矢量的协议和基于链路状态的协议。详细介绍了RIP协议和OSPF协议的工作原理，重点介绍<strong>衡量路径优劣</strong>的标准。</p></li><li><p>网络排查问题：公司中一楼无法正常连网，二楼可正常连网但网速较慢，三楼可正常上网，针对此种情况如何排查解决。</p><p>由于公司和个人网络的排查有所差别，同时我也没有了解过公司的网络排查标准，于是按照个人网络问题进行排查。首先讲了个人PC无法正常联网的排查步骤：</p><ul><li>ping 127.0.0.1，检查TCP/IP协议是否正常配置；</li><li>ping 本机地址，检查网络适配器是否正常配置；</li><li>ping 网关地址，检查网关是否正常配置；</li><li>ping 外网地址，排查重点放在hosts文件中DNS解析是否正常。</li></ul><p>网速较慢这个问题没怎么关注过，简单提到了猜想——公司访问流量限速，当然这是在胡说八道，但是可以用来缓解尴尬，委婉地告诉面试官不怎么会。</p></li><li><p>攻击网站的常见手段</p><p>回答了SQL注入、XSS、CSRF、一句话木马，然后追问一句话木马的工作原理，笼统地回答了一下。</p></li><li><p>了解磁盘冗余阵列RAID吗？</p><p>由于昨天准备的时候刚看到RAID的相关知识，简要回答了RAID 0，RAID 1，RAID 3，RAID 5，RAID p+q等组合方式的特点及优缺点。RAID p+q以RAID 10为例进行详细介绍。</p></li><li><p>了解虚拟化技术吗？</p><p>将虚拟化与云计算技术结合起来回答，大致提到了SaaS，PaaS，IaaS，公有云，私有云，混合云等名词并进行解释。面试官让说出自己对虚拟化的理解，结合aDesk云桌面产品进行了相关说明（感觉自己讲的语无伦次）。本来还想加上虚拟现实技术，后来面试官话锋转到下个问题，只好作罢。</p></li><li><p>常见的加密算法</p><p>终于问到密码学了！（不是）分成对称加密和非对称加密两部分进行回答。对称加密主要介绍了DES，AES，RC4，RC5。非对称加密介绍了三大困难问题及对应的RSA，DH交换和ECC密码体制。顺带提到了消息摘要算法和数字签名算法。</p></li><li><p>以上提到的算法的实际应用</p><p>刚开始想回答数字证书等知识，后来确定回答主题为<strong>非对称加密+对称加密</strong>：对称加密具有加密效率高的特点，相应地安全性较低；非对称加密无法处理大量数据，但安全性较高。故流行的通信方式为通信双方使用非对称加密算法对对称加密密钥进行加解密，从而实现密钥共享，随后使用该密钥结合对称加解密算法进行消息传输。围绕该主题并结合HTTPS加密过程客户端与服务器的相应操作进行作答。</p></li></ul><h3 id="非技术问题"><a href="#非技术问题" class="headerlink" title="非技术问题"></a>非技术问题</h3><ul><li><p>有没有考过网络认证证书+计算机网络知识学习途径</p><p>没考过证书，计网知识除”翔鹰计划”培训外，还上过学校的对应课程，进行过系统学习。</p></li><li><p>经历的压力较大的事情</p><p>聊了聊”美亚杯”比赛的事情（现在感觉当时的回答驴唇不对马嘴）</p></li><li><p>“基于数字水印与神经网络的图像攻击检测系统”项目相关</p><ul><li><p>这个项目中负责的部分</p><p>水印的提取与嵌入算法的实现，水印置乱算法实现，信噪比检验。</p></li><li><p>项目中遇到哪些难题，如何解决？</p><p>只提到当时嵌入提取算法matlab转python实现过程中出现的问题，即无论怎么调整参数，使用python语言实现的算法嵌入水印后的图像都具有明显的水印标记，无法通过信噪比测试。解决方法就是python调matlab脚本（说出来我自己都觉得low，但是当时这个bug调了大概一晚上，所以印象很深刻）。</p></li><li><p>项目中学到了什么？</p><p>从技术和团队合作两方面进行回答。结合自己负责的技术部分简单讲了一下这些算法，同时提到了matlab和python编程。团队合作方面，首先提到了模块化即各司其职，相互配合，以写代码为例提出即使补充注释，方便后期代码整合；然后提到积极讨论，制定多个方案并进行测试。</p></li><li><p>合作过程中，如果发生冲突或受到质疑如何解决？</p><p>这种问题就非常简单了，首先强调团队精神即荣辱与共，大家为共同目标奋斗；然后回答鼓励大家积极讨论，针对同一解决方案各抒己见；最后就是提出质疑需要有理有据。</p></li></ul></li><li><p>热爱读书吗？读过印象最深刻的书是什么？</p><p>这个问题就俨然成为一股清流。先问了问是技术书还是其他书，得到回答是都可以。后来好像也没怎么介绍看的书，这个问题就奇奇怪怪地一扫而过了。</p></li></ul><h2 id="业务面（二面）"><a href="#业务面（二面）" class="headerlink" title="业务面（二面）"></a>业务面（二面）</h2><p>邮件约定面试时间为上午11：00，大概提前五分钟进入面试房间，11：20左右结束，共面试25分钟左右。主要问题包含自我介绍及相关问题。</p><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>简单介绍了一下自己的学校、专业及学习情况，日常爱好，相关技术栈，参加的比赛及获奖情况，实习经历等。‘</p><h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><ul><li><p>简要介绍印象深刻的项目经历（扮演角色，工作内容，学习内容，结果）</p><p>把参与20年作品赛的项目拿出来详细讲了讲，感觉面试官对合作而非技术细节感兴趣。</p></li><li><p>团队合作时有没有受到质疑？如何解决的？</p><p>结合项目经历简单讲了一下解决办法（其实没什么质疑</p></li><li><p>参加过什么实习？聊一下实习经历</p><p>啊这…显然没参加过什么实习，提到了”翔鹰计划”但是面试官没让继续说下去，这个问题就结束了（感觉不是很满意？</p></li><li><p>大学有没有和人发生过冲突？评价下自己的性格，最讨厌什么样的人？</p><p>这三个问题感觉是对面试者人际交往能力和性格的把握吧，就正常回答了一下。</p></li><li><p>你本科学的是网络空间安全，和网络安全有什么区别？</p><p>这个问题算是遇到的比较有趣的非常规问题了，简单讲了一下国家讲网络空间作为”第五空间”的发展战略，以及这个专业广阔的发展前景，还聊了聊网络空间安全和信息安全的区别与联系。</p></li><li><p>网络空间安全对口的公司有什么？</p><p>举了BAT，360，奇安信，绿盟，安恒等经典公司，当然提到了深信服的网络安全、超融合、云计算等标杆。</p></li><li><p>在学校参加过何种比赛？</p><p>由于校园经历偏作品赛比较多，CTF比赛没拿到什么好成绩，所以就简要介绍了几个本专业作品赛的情况。</p></li><li><p>课余时间如何安排生活？</p><p>看技术书+保持几个爱好。</p></li><li><p>看过哪些技术书籍+日常逛哪些论坛？</p><p>举了几个密码学技术书籍，外加计算机网络自顶向下、深入理解计算机系统、软件测试等。论坛聊了Freebuf、先知社区等。</p></li><li><p>简单聊了下技服工程师跨省调度的政策，就是不能回原籍省份工作也不能在学校所在省份工作。</p></li></ul><h2 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h2><p>邮件约定时间为下午16：45，进入房间大概等到17：00开始面试，整个时长为25min。首先进行自我介绍，然后面试官了解情况，大概问了如下几个问题：</p><ul><li><p>概括本科三年生活。</p><p>从技术和日常生活的角度进行概括，技术上提到了CTF比赛和参加的项目，生活角度没怎么提。</p></li><li><p>本科最有挑战和最有成就的事情。</p><p>最有挑战的事情选择了其中一个做过的项目，最有成就的事情选择了”美亚杯”比赛经历。</p></li><li><p>为什么选择”翔鹰计划”实习？</p><p>一是为了了却去年的遗憾，二是线上实习的形式比较安全高效，结合开学时间与暑假安排的考虑，最终选择了”翔鹰计划”。</p></li><li><p>技服工程师这个岗位是做什么的，为什么选择这个岗位？</p><p>简单介绍了一下自己对技术服务的理解。选择原因确定为两点：个人代码水平不高+热爱与人打交道。</p></li><li><p>追问：为什么不选择售前经理？</p><p>个人还是比较热爱技术。（感觉这个岗位和技术关系不大）</p></li><li><p>概括一下自己的优点和缺点（各两条）。</p></li><li><p>评价一下自己是个怎么样的人？</p></li><li><p>有没有长时间坚持的事情？</p><p>运动。</p></li><li><p>确定不考研了吗，为什么？</p><p>总感觉说正在备考拿不到offer，于是胡乱编造了一些理由。</p></li><li><p>期望岗位是什么？想去什么样的公司？</p><p>这个问题回答的比较粗略，给面试官一种没有准备好进入工作+对未来没有明确规划的感觉。可能是因为真的没有准备好本科毕业直接工作吧。事后仔细想想，个人期望岗位还是管理岗，对专注安全的乙方公司没什么向往，对大厂还是比较向往的（阿里、百度、腾讯、字节）。除此之外当个测试工程师或者去公司实验室进行安全研究感觉也挺好。现阶段还是一门心思学习，重点还是提升下学历吧。</p></li><li><p>还有没有投递其他公司？收到过其他offer吗？</p><p>实话实说，并没有，甚至连华为提前批都没打算投。。。</p></li><li><p>工作情况相关</p><ul><li><p>随机工作省份可以接受吗？偏远地区呢？</p><p>个人不能接受过于偏远的地区，对其他工作地点没有太大的执念。不回原籍和学校所在地倒是无所谓。</p></li><li><p>家庭状况：独生子女？父母同意吗？女朋友呢？</p><p>啊这…</p></li></ul></li><li><p>最后简单聊了一下拿到offer的后续安排以及薪资问题。</p></li></ul><h2 id="目前状态"><a href="#目前状态" class="headerlink" title="目前状态"></a>目前状态</h2><ul><li>7.23 等业务面通知中…</li><li>7.30 等HR面通知中…</li><li>8.4 HR面试结束，等offer中，大概率凉…</li><li>9.18 offer沟通</li><li>9.22 没有去签三方协定，选择继续考研</li></ul><h2 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h2><p>各种意义上来说这次面试都是人生中经历的第一次完整的企业面试，不仅体验了整套面试流程，还发现了一些重点问题，并且引发一些思考。</p><ul><li>仔细回顾大学本科真的没有做什么惊天动地的事情，技术水平也比较平庸，这种状态下直接工作感觉难度较大。倒不是说找不到工作，但是能进的公司个人不太喜欢。当然也不想当拿钱少的用爱发电的社畜。</li><li>技术方面：大学阅读的技术书籍太少了，对于Web安全的掌握并不到位，这两点需要后续加强。不管从事哪一个与安全相关的岗位，应聘时技术短板都是致命的。</li><li>应聘技巧：针对不同内容进行准备，多刷面经，提高算法及代码能力。面试时扬长避短，努力主导谈论的话题。该掩饰的时候千万不要实话实说。</li><li>认识到自己的平凡，好好学习，未来可期。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;近日考研期间，适逢深信服”翔鹰计划”线上实习结束，公司给了秋招提前批的面试机会，准备了大概两天就去面试了，岗位是&lt;strong&gt;技服工程师&lt;
      
    
    </summary>
    
      <category term="Interview" scheme="https://blank-vax.github.io/categories/Interview/"/>
    
    
      <category term="Sangfor" scheme="https://blank-vax.github.io/tags/Sangfor/"/>
    
  </entry>
  
  <entry>
    <title>Windows基础及常用命令</title>
    <link href="https://blank-vax.github.io/2020/07/23/Windows%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://blank-vax.github.io/2020/07/23/Windows基础及常用命令/</id>
    <published>2020-07-22T16:20:00.000Z</published>
    <updated>2021-07-07T12:43:49.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows常见目录"><a href="#Windows常见目录" class="headerlink" title="Windows常见目录"></a>Windows常见目录</h2><ul><li><p>Documents and Settings/用户</p><p>存储用户设置，包括用户文档、上网浏览信息、配置文件等数据</p></li><li><p>Windows目录</p><p>Windows安装目录，用来放置Windows程序的使用数据、设置等文件。不建议修改此目录下数据，易造成Windows系统使用异常</p></li><li><p>Program File</p><p>应用程序文件夹，一般软件默认安装位置。当然此处也包含系统自带的应用程序。Windows10系统中，64位用户多出一个Program Files(x86)文件夹，用作系统中32位软件的安装目录</p></li><li><p>Temp目录 临时文件目录</p><p>文件路径：C:\Users\user\AppData\Local\Temp</p><p>上面存在许多垃圾文件，包括使用压缩软件等解压的临时文件。此目录也是病毒检测过程中快速扫描的位置。</p></li></ul><h2 id="Windows注册表"><a href="#Windows注册表" class="headerlink" title="Windows注册表"></a>Windows注册表</h2><p>注册表是Windows操作系统中的一个核心数据库，其中存放各种参数，直接控制Windows的启动、硬件驱动程序的装装载以及一些Windows应用程序的运行。</p><p>恶意病毒通常通过修改注册表的键<strong>HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\Main Start Page</strong>项对应的URL值来修改IE起始页面。</p><h2 id="系统启动项"><a href="#系统启动项" class="headerlink" title="系统启动项"></a>系统启动项</h2><p>开机时系统会在前台或后台自动运行的程序。查看方式为msconfig命令。</p><p>将文件、程序等放入位于<strong>C:\Users\user\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</strong>的启动文件夹中即可实现开机自启动。</p><h2 id="设备管理器"><a href="#设备管理器" class="headerlink" title="设备管理器"></a>设备管理器</h2><p>设备管理器常被用来查看和更改设备属性、更新设备驱动程序、配置设备设置和卸载设备。所有设备通过<strong>设备驱动程序</strong>与Windows进行通信。</p><ul><li>超融合迁移（虚拟机网卡网络适配器）</li><li>云桌面外设（USB白名单）</li></ul><p>使用设备管理器可以安装和更新硬件设备的驱动程序、修改这些设备的硬件设置以及通过查看硬件设备状态信息来排查问题。</p><h2 id="任务管理器"><a href="#任务管理器" class="headerlink" title="任务管理器"></a>任务管理器</h2><p>Windows任务管理器提供了有关计算机性能的信息，并显示了计算机上所运行的程序和进程的详细信息（哪个用户创建了哪个进程或程序，该进程或程序占用了多少CPU及其他系统资源）。</p><ul><li>应用程序</li><li>进程（*32代表32位系统进程）</li><li>服务</li><li>性能（详细Windows系统资源占用情况）</li><li>联网（网卡流量）</li><li>用户（当前运行的用户名）</li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是正在运行的程序实例。每个进程存在属于自己的地址空间，一般包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储<strong>处理器执行的代码</strong>；数据区域存储<strong>变量和进程执行期间使用的动态分配的内存</strong>；堆栈区域存储<strong>活动过程调用的指令和本地变量</strong>。</p><ul><li>虚拟机出现CPU、内存异常偏高时，可以通过任务管理器查看进程的资源利用率</li><li>病毒常伪装成<strong>svchost.exe</strong>，<strong>explorer.exe</strong>和<strong>rundll32.exe</strong>等系统进程，当发现这些进程CPU及内存资源占用异常时，需要重点查杀</li></ul><h2 id="组策略"><a href="#组策略" class="headerlink" title="组策略"></a>组策略</h2><p>组策略在部分意义上可控制用户可以或无法在计算机上执行什么操作，提供了操作系统、应用程序和活动目录中用户设置的集中化管理和配置。在运行模式下输入<strong>gpedit.msc</strong>可以打开组策略配置。</p><h3 id="刷新时间"><a href="#刷新时间" class="headerlink" title="刷新时间"></a>刷新时间</h3><p>默认情况下，Mircosoft Windows每90分钟刷新一次组策略，随机偏移为30分钟。在域控制器上，Microsoft Windows每隔5分钟刷新一次。</p><h3 id="处理顺序"><a href="#处理顺序" class="headerlink" title="处理顺序"></a>处理顺序</h3><ul><li>本地——任何在本地计算机的设置。在Windows Vista和之后的Windows版本中，允许每个用户账户分别拥有组策略</li><li>站点——任何与计算机所在的活动目录站点关联的组策略。活动目录站点旨在管理促进物理上接近的计算机的一种逻辑分组。如果多个策略链接到一个站点，将按照管理员设置的顺序处理</li><li>域——任何与计算机所在Windows域关联的组策略。如果多个策略链接到一个域，将按照管理员设置的顺序处理</li><li>组织单元——任何与计算机或用户所在的活动目录组织单元（OU）关联的组策略。OU是帮助组织和管理一组用户、计算机或其他活动目录对象的逻辑单元。如果多个策略链接到一个OU，将按照管理员设置的顺序处理</li></ul><h2 id="安全组"><a href="#安全组" class="headerlink" title="安全组"></a>安全组</h2><p>可以列出用于定义资源和对象权限的任意访问控制列表（DACL）中的组。Windows安全组策略其实是组策略中关于安全设置的部分，囊括了账户安全策略、Windows防火墙配置等配置目录。</p><p>在运行任务栏输入<strong>secpol.msc</strong>，修改安全组相关配置之后，需要重新登录Windows用户方可生效。</p><h2 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h2><p>工作组就是将不同的电脑按功能分别列入不同的组中，以方便管理。</p><p>Windows 9x/NT/2000引入工作组概念后，若要访问某个系列的资源，需要在网上邻居内找到对应的工作组名，即可找到该系列资源。</p><h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2><p>工作组中一切设置在本机上进行，包括各种策略、用户登录等过程，对应密码也存放在本机数据库中进行验证。</p><p>域作为工作组的升级版，计算机的各种策略通过域控制器统一设定，用户名和密码的验证过程也在域控制器中完成。因此，用户信息可以实现在域中电脑上的漫游。</p><h3 id="域控制器"><a href="#域控制器" class="headerlink" title="域控制器"></a>域控制器</h3><p>在域模式下，至少有一台服务器负责每台联入网络的电脑和用户的验证工作，被称为<strong>域控制器（Domain Controller，DC）</strong>。域控制器包含由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。</p><h2 id="安全日志"><a href="#安全日志" class="headerlink" title="安全日志"></a>安全日志</h2><p>Windows用户所有的登录注销、安全策略更改都会以安全日志的形式记录。</p><p>日志位置：计算机管理—&gt;系统工具—&gt;事件查看器—&gt;Windows日志—&gt;安全</p><ul><li>溯源黑客入侵行为</li><li>通过事件ID快速检索日志</li></ul><h2 id="常用网络排查命令"><a href="#常用网络排查命令" class="headerlink" title="常用网络排查命令"></a>常用网络排查命令</h2><h3 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h3><p>通过发送Internet控制消息协议（ICMP）验证与其他TCP/IP计算机的IP级连接回显请求消息。显示相应的回音回复信息的接受以及往返时间。该命令可用于解决连接、可访问性和名称解析等问题。</p><h4 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><code>Ping IP/域名 -t</code>：长时间执行Ping命令，以推断连接健壮性</li><li><code>Ping IP/域名 -n number</code>： 指定发送数据包的数量</li><li><code>Ping IP/域名 -l length</code>： 指定发送数据包的长度（默认长度为32Bytes）</li></ul><p>一般使用<code>Ping IP/域名 -l big-number -n big-number</code>探测连接稳定性，其中big-number为大于1000的数字，需要多次尝试以找到合适的数据包长度。</p><h4 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h4><ul><li>找不到主机：排查DNS是否正确解析指定域名</li><li>请求超时：目标地址禁止Ping/目标地址不存在</li><li>传输失败：主机网络存在问题</li></ul><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>显示和修改地址解析协议缓存中的条目，其中包含一个或多个用于存储IP地址及其解析结果的以太网或令牌环物理地址的表。计算机上安装的每个以太网或令牌环网络适配器都存在单独的表。</p><h4 id="常用选项-1"><a href="#常用选项-1" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><code>Arp -a</code>：显示所有的地址信息及接口信息</li><li><code>Arp -s ip_addr mac_addr</code>：静态配置ARP地址表项</li><li><code>Arp -d</code>：用于删除当前ARP信息</li></ul><h3 id="Tracert"><a href="#Tracert" class="headerlink" title="Tracert"></a>Tracert</h3><p>确定通过发送Internet控制消息协议（ICMP）回显请求或以递增的生存时间（TTL）字段值向目标发送消息。路径显示源主机和目标之间路径中路由器的近/侧路由器接口列表。无参数使用。</p><h4 id="常用选项-2"><a href="#常用选项-2" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><p><code>Tracert -d</code>：不将地址解析成主机名</p></li><li><p><code>Tracert -h maximum_hops</code>：搜索目标的最大跃点数</p></li></ul><h3 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h3><p>显示并修改本地IP路由表中的输入。无参数使用。需要<strong>以管理员身份打开</strong>以进行相关配置。常用命令结构：<code>Route command ip_addr mask mask_number gateway_addr</code>。</p><h4 id="常用选项-3"><a href="#常用选项-3" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><p>command</p><ul><li><code>Route PRINT</code>：打印路由表</li><li><code>Route ADD</code>：添加静态路由（临时，重启后消失）</li><li><code>Route DELETE</code>：删除路由信息</li><li><code>Route CHANGE</code>：修改现有路由的网关和跃点数</li></ul></li><li><p><code>Route -p</code>：使得对路由表的添加操作永久生效</p></li></ul><h3 id="Ipconfig"><a href="#Ipconfig" class="headerlink" title="Ipconfig"></a>Ipconfig</h3><p>显示所有当前TCP/IP网络配置值，并刷新动态主机配置协议（DHCP）和域名系统（DNS）设置。无参数使用时，为所有适配器显示Internet协议版本4和IPv6地址、子网掩码和默认网关。</p><h4 id="常用选项-4"><a href="#常用选项-4" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><code>Ipconfig /all</code>：显示所有网络适配器的所有信息</li><li><code>Ipconfig /release</code>：释放当前所有网卡的DHCP信息</li><li><code>Ipconfig /renew</code>：释放当前网卡的所有DHCP信息并重新获取</li><li><code>Ipconfig /displaydns</code>：展示当前DNS缓存信息</li><li><code>Ipconfig /flushdns</code>：清理当前DNS缓存信息</li></ul><h3 id="Netstat"><a href="#Netstat" class="headerlink" title="Netstat"></a>Netstat</h3><p>显示有源TCP连接，计算机在哪个端口被侦听，以太网统计，IP路由表，IPv4统计和IPv6统计。无参数使用时，网络显示激活TCP连接。</p><h4 id="常用选项-5"><a href="#常用选项-5" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><code>Netstat -a</code>：展示当前监听的所有网口信息</li><li><code>Netstat -n</code>：展示所有TCP&amp;UDP连接信息及端口详细信息</li><li><code>Netstat -o</code>：展示当前连接的PID</li><li><code>Netstat -p</code>：指定当前监听协议</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Windows常见目录&quot;&gt;&lt;a href=&quot;#Windows常见目录&quot; class=&quot;headerlink&quot; title=&quot;Windows常见目录&quot;&gt;&lt;/a&gt;Windows常见目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Documents and Settings/用户
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Windows Foundation" scheme="https://blank-vax.github.io/tags/Windows-Foundation/"/>
    
  </entry>
  
  <entry>
    <title>云计算基础</title>
    <link href="https://blank-vax.github.io/2020/07/15/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80/"/>
    <id>https://blank-vax.github.io/2020/07/15/云计算基础/</id>
    <published>2020-07-14T16:09:00.000Z</published>
    <updated>2021-07-07T12:58:28.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="云计算基础"><a href="#云计算基础" class="headerlink" title="云计算基础"></a>云计算基础</h2><h3 id="云计算定义"><a href="#云计算定义" class="headerlink" title="云计算定义"></a>云计算定义</h3><ul><li>技术角度：云计算是一种基于互联网的计算方式，通过这种方式，共享的软硬件资源和信息可以按需求提供给计算机和其他设备。</li><li><p>经济学角度：云计算依赖资源的共享以达成规模经济，类似基础设施如电力网等。</p></li><li><p>云计算现阶段的发展还远远未达到基础设施建设水平。</p></li></ul><p><img src="/2020/07/15/云计算基础/1.png" alt="image-20200711112223579.png-264.8kB"></p><ul><li>滴滴打车</li></ul><h3 id="云计算本质"><a href="#云计算本质" class="headerlink" title="云计算本质"></a>云计算本质</h3><p>云计算是新技术+IT业务模式的创新，随着数字化时代的发展，IT消费模式产生重大转变：云计算通过技术将IT资源池化和服务化，通过互联网提供IT服务，而用户由网络浏览器或轻量级终端软件来获取和使用这些IT服务。整个IT市场商业模式正实现<strong>“从产品到服务”</strong>的转型。</p><h3 id="云计算特性"><a href="#云计算特性" class="headerlink" title="云计算特性"></a>云计算特性</h3><ul><li>按需自助</li><li>可度量服务</li><li>快速灵活</li><li>资源池</li><li>广阔网络访问</li></ul><h3 id="相关分类"><a href="#相关分类" class="headerlink" title="相关分类"></a>相关分类</h3><h4 id="服务模型分类"><a href="#服务模型分类" class="headerlink" title="服务模型分类"></a>服务模型分类</h4><ul><li><p>IaaS（Infrastructure as a Service）：基础架构即服务</p><p>用户通过网络使用计算机（物理机或虚拟机）、存储空间、网络连接等完善的计算机基础设施服务。</p></li><li><p>PaaS（Platform as a Service）：平台即服务</p><p>将软件研发的平台作为一种服务提交给用户，意在加快SaaS应用的开发速度。</p></li><li><p>SaaS（Software as a Service）：软件即服务</p><p>通过Internet提供软件的模式，用户无需购买软件，而是向提供商租用基于Web的软件来管理企业经营活动。</p></li></ul><h4 id="部署模型分类"><a href="#部署模型分类" class="headerlink" title="部署模型分类"></a>部署模型分类</h4><ul><li>公有云</li><li>私有云</li><li>混合云</li></ul><h3 id="公有云"><a href="#公有云" class="headerlink" title="公有云"></a>公有云</h3><p>通过Internet为外部客户提供服务的云。典型公有云包括Amazon EC2、阿里云、腾讯云等。</p><ul><li><p>优点</p><p>所有应用服务数据等均存放在公有云提供商处，客户无需硬件投资与建设，使用成本低；</p></li><li><p>缺点</p><p>数据存放在供应商处，安全性存在风险。公有云的可用性不受使用者控制，存在不确定性。</p></li></ul><h3 id="私有云"><a href="#私有云" class="headerlink" title="私有云"></a>私有云</h3><p>由企业或机构独享使用和掌控的云，仅供自己内部人员或分支机构使用，一般部署在企业或机构的数据中心。</p><ul><li><p>优点</p><p>数据安全性和系统可用性可控，对现有IT流程管理影响小、IT资源利用率高；</p></li><li><p>缺点</p><p>投资较大。</p></li></ul><h3 id="混合云"><a href="#混合云" class="headerlink" title="混合云"></a>混合云</h3><p>同一份数据、同一套应用，同时采用私有云技术构建自己的IT服务平台，同时又采购了公有云服务商提供的IT服务。为保证数据安全，企业将核心数据和关键技术存放于私有云上，而将面向用户的服务托管在公有云上，具有较高的弹性。一般是需要具备可控的前提下，具备一定的弹性或可靠性。多应用于潮汐应用及混合云灾备。</p><ul><li><p>优点</p><p>具备较大弹性，并且可以在保障可控性的同时兼顾建设成本；</p></li><li><p>缺点</p><p>IT业务管理界面不统一，需要投入相应的混合云管理成本。</p></li></ul><h2 id="数据中心基础"><a href="#数据中心基础" class="headerlink" title="数据中心基础"></a>数据中心基础</h2><h3 id="重要组成要素"><a href="#重要组成要素" class="headerlink" title="重要组成要素"></a>重要组成要素</h3><ul><li>处理资源请求和资源分发的云平台</li><li>网络管道</li><li>终端用户</li></ul><h3 id="数据中心"><a href="#数据中心" class="headerlink" title="数据中心"></a>数据中心</h3><p>数据中心是云计算后端基础设施的承载体，云计算依托数据中心提供各种云计算服务。数据中心内部除包含基础物理设施外，还包含网络、安全、优化、存储、服务器、操作系统、虚拟机及应用软件等成分。</p><h3 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h3><p><img src="/2020/07/15/云计算基础/2.png" alt="云计算逻辑架构.png-140.1kB"></p><h2 id="计算基础"><a href="#计算基础" class="headerlink" title="计算基础"></a>计算基础</h2><h3 id="服务器分类"><a href="#服务器分类" class="headerlink" title="服务器分类"></a>服务器分类</h3><p>随着云计算技术的发展与并行计算思想的出现，未来x86服务器在市场中将占据主导地位。</p><h4 id="x86服务器"><a href="#x86服务器" class="headerlink" title="x86服务器"></a>x86服务器</h4><p>又称CISC（复杂指令集）架构服务器，即通常所讲的PC服务器，它基于PC机体系结构，使用Intel或其它兼容x86指令集的处理器芯片和Windows/Linux操作系统的服务器。</p><h4 id="非x86服务器"><a href="#非x86服务器" class="headerlink" title="非x86服务器"></a>非x86服务器</h4><p>包括大型机、小型机和UNIX服务器，它们是使用RISC（精简指令集）或EPIC（并行指令代码）的处理器，并且主要采用UNIX和其他专用操作系统的服务器。</p><h3 id="小型机"><a href="#小型机" class="headerlink" title="小型机"></a>小型机</h3><p>中国业内习惯上称UNIX服务器为小型机，其最引以为傲的特点就是高RAS——高可靠性、高可用性与高服务性。随着CPU和虚拟化技术的发展，x86服务器的可靠性与可用性不再是问题，为用户提供更多选择，小型机的竞争力逐渐下降。</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>Central Process Unit，是一块超大规模的集成电路，是一台计算机的运算核心和控制核心。常见参数如下：</p><ul><li>主频：表示CPU的处理频率，常见的频率为1.7-3.1GHz。数值越高，处理的速度越快。超频表示CPU可以超越主频规定的处理频率进行运算处理。当计算机进入节能模式时，为提高电量续航，采用降频策略，主动下调CPU的计算效率。</li><li>核数：表示CPU的并行处理能力。核数越多则并行处理速度越快。超线程表示CPU可以高负荷处理数据。</li></ul><p>为适应信息化发展，Intel推出VT（Virtualization Technology，虚拟化技术）系列以满足不同的上层操作系统对底层处理器的调用，如VT-x、VT-d、VT-c。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>Memory，也被称为内存储器，用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。内存主频与CPU主频一样，习惯上被用来表示内存的速度，代表着该内存所能达到的最高工作频率。可分为ROM只读存储器、RAM随机存储器和Cache高速缓存三类。</p><h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><p>Disk，数据的最终归属地。可分为机械硬盘HDD与固态硬盘SSD。</p><h3 id="常见卡"><a href="#常见卡" class="headerlink" title="常见卡"></a>常见卡</h3><ul><li>网卡：通过网络连接线与网络交换机连接。</li><li>存储卡：通过网络连接线和存储设备对接。</li><li>RAID卡：通过总线和硬盘连接。</li></ul><p>常见接口为PCI、PCI-X和PCI-E。</p><h3 id="光模块"><a href="#光模块" class="headerlink" title="光模块"></a>光模块</h3><p>光模块的作用为光电转换，发送端将电信号转换为光信号，通过光纤传送后，接收端再将光信号转换为电信号。光模块具有传输速率高，传输距离远的特点。</p><h3 id="光纤跳线"><a href="#光纤跳线" class="headerlink" title="光纤跳线"></a>光纤跳线</h3><p>用来做从设备到光纤布线链路的跳接线。常见LC接口的光模块为：SFF、SFP、SFP+和XFP。常见SC接口的光明模块为GBIC。而FC、ST接口多用于光纤配线架。</p><h3 id="操作系统OS"><a href="#操作系统OS" class="headerlink" title="操作系统OS"></a>操作系统OS</h3><p>管理和控制计算机硬件与软件资源的计算机程序，具有承上启下的功能：对上有效管理系统资源，为应用软件提供基础的底层环境，提高系统资源使用效率。对下屏蔽硬件物理特性和操作细节，为用户使用计算机提供便利。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;云计算基础&quot;&gt;&lt;a href=&quot;#云计算基础&quot; class=&quot;headerlink&quot; title=&quot;云计算基础&quot;&gt;&lt;/a&gt;云计算基础&lt;/h2&gt;&lt;h3 id=&quot;云计算定义&quot;&gt;&lt;a href=&quot;#云计算定义&quot; class=&quot;headerlink&quot; title=&quot;云计算
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Cloud Computing" scheme="https://blank-vax.github.io/tags/Cloud-Computing/"/>
    
  </entry>
  
  <entry>
    <title>终端安全检测及防御技术</title>
    <link href="https://blank-vax.github.io/2020/07/06/%E7%BB%88%E7%AB%AF%E5%AE%89%E5%85%A8%E6%A3%80%E6%B5%8B%E5%8F%8A%E9%98%B2%E5%BE%A1%E6%8A%80%E6%9C%AF/"/>
    <id>https://blank-vax.github.io/2020/07/06/终端安全检测及防御技术/</id>
    <published>2020-07-06T01:20:00.000Z</published>
    <updated>2020-11-09T03:39:33.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="终端安全风险"><a href="#终端安全风险" class="headerlink" title="终端安全风险"></a>终端安全风险</h2><p>黑客可以利用僵尸网络展开更多的危害行为，如APT攻击最常采用的跳板就是僵尸网络。黑客利用僵尸网络来实现渗透、监视、窃取敏感数据等目的，造成严重危害。</p><p>僵尸网络主要危害有：</p><ul><li>未知风险</li><li>高级持续威胁</li><li>本地渗透扩散</li><li>敏感信息窃取</li><li>脆弱信息收集</li></ul><h2 id="终端上网安全可视可控技术"><a href="#终端上网安全可视可控技术" class="headerlink" title="终端上网安全可视可控技术"></a>终端上网安全可视可控技术</h2><p>基于七层应用的深度数据包检测可实现终端安全可控。AF中实现了可视化的应用管控与全面的应用安全。可视化应用管控中包含<strong>应用识别</strong>与<strong>流量管控</strong>两大模块。</p><h3 id="应用控制策略"><a href="#应用控制策略" class="headerlink" title="应用控制策略"></a>应用控制策略</h3><p>应用控制策略可对应用/服务的访问做双向控制，AF存在一条默认拒绝所有应用/服务的控制策略。</p><ul><li>基于应用的控制策略：通过匹配数据包特征来进行过滤动作，需要一定数量的包通行后才能判断应用类型，然后进行拦截动作的判断。</li><li>基于服务的控制策略：通过匹配数据包的五元组（源/目的IP地址+源/目的端口号+协议类型）来进行过滤动作，对任何包可以立即进行拦截动作判断。</li></ul><h3 id="Web过滤"><a href="#Web过滤" class="headerlink" title="Web过滤"></a>Web过滤</h3><p>Web过滤指针对符合设定条件的访问网页数据进行过滤，包括URL过滤与文件过滤，同时可以针对HTTPS URL进行过滤。</p><h2 id="网关杀毒技术"><a href="#网关杀毒技术" class="headerlink" title="网关杀毒技术"></a>网关杀毒技术</h2><h3 id="计算机病毒"><a href="#计算机病毒" class="headerlink" title="计算机病毒"></a>计算机病毒</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>隐蔽性</li><li>破坏性</li><li>潜伏性</li><li>不可预见性</li><li>繁殖性</li><li>传染性</li></ul><h4 id="工作步骤"><a href="#工作步骤" class="headerlink" title="工作步骤"></a>工作步骤</h4><p><img src="http://static.zybuluo.com/B1ank/q220r9z8dhph5x9jbd066ox3/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92%E5%B7%A5%E4%BD%9C%E6%AD%A5%E9%AA%A4.png" alt="计算机病毒工作步骤.png-233.6kB"></p><h3 id="网关杀毒实现方式"><a href="#网关杀毒实现方式" class="headerlink" title="网关杀毒实现方式"></a>网关杀毒实现方式</h3><h4 id="代理扫描方式"><a href="#代理扫描方式" class="headerlink" title="代理扫描方式"></a>代理扫描方式</h4><p>将所有经过网关的需要进行病毒检测的数据报文透明地转交给网关自身的协议栈，通过网关自身的协议栈将文件全部缓存下来后，再送入病毒检测引擎进行病毒检测。</p><h4 id="流扫描方式"><a href="#流扫描方式" class="headerlink" title="流扫描方式"></a>流扫描方式</h4><p>依赖于状态检测技术以及协议解析技术，简单地提取文件的特征与本地签名库进行匹配。由于流扫描方式只针对部分数据进行扫描，故查准率低于代理扫描方式，属于轻量级检测技术。</p><h3 id="AF网关杀毒实现方式"><a href="#AF网关杀毒实现方式" class="headerlink" title="AF网关杀毒实现方式"></a>AF网关杀毒实现方式</h3><p><img src="http://static.zybuluo.com/B1ank/bkkhf877533ca6ulcqgasvnr/AF%E7%BD%91%E5%85%B3%E6%9D%80%E6%AF%92%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.png" alt="AF网关杀毒实现方式.png-430.3kB"></p><p>该杀毒体系具有以下特点：</p><ul><li>防火墙AF提供捕获文件能力和拦截处置能力。</li><li>SAVE提供本地无规则的检测能力。</li><li>云脑提供安全能力的更新和云端威胁情报查杀的能力。</li><li>具备威胁情报、本地引擎SAVE查杀、云沙箱能力。</li></ul><h3 id="网关杀毒配置思路"><a href="#网关杀毒配置思路" class="headerlink" title="网关杀毒配置思路"></a>网关杀毒配置思路</h3><ul><li>新建模块</li><li>选择杀毒协议</li><li>选择文件类型</li><li>新增安全策略</li></ul><h2 id="僵尸网络检测与防御技术"><a href="#僵尸网络检测与防御技术" class="headerlink" title="僵尸网络检测与防御技术"></a>僵尸网络检测与防御技术</h2><h3 id="僵尸网络"><a href="#僵尸网络" class="headerlink" title="僵尸网络"></a>僵尸网络</h3><p>僵尸网络（Botnet）是指骇客利用自己编写的分布式拒绝服务攻击程序将数万个沦陷的机器组织成一个个控制节点用来发送伪造包或垃圾数据包，使预定攻击目标瘫痪并拒绝服务。通常蠕虫病毒也可以被用来组成僵尸网络。</p><h3 id="僵尸网络感染过程"><a href="#僵尸网络感染过程" class="headerlink" title="僵尸网络感染过程"></a>僵尸网络感染过程</h3><ul><li>僵尸主控传播木马到网络中的感染终端。</li><li>主机受到感染，连接C&amp;C服务器，获取指令。</li><li>C&amp;C服务器下发指令给受感染主机，扫描网络并感染更多主机。</li><li>更多主机被感染并组成僵尸网络，连接C&amp;C服务器并获取操作指令。</li></ul><h3 id="异常流量检测"><a href="#异常流量检测" class="headerlink" title="异常流量检测"></a>异常流量检测</h3><p>通过对当前的网络层及应用层行为与安全模型进行偏离度分析，能够发现隐藏的网络异常行为，并根据行为特征确定攻击类型，发现特征匹配无法发现的攻击。</p><p>外发流量异常功能是一种启发式的DOS攻击检测手段，能够检测源IP不变的SYN Flood、UDP Flood等泛洪攻击。该功能原理为：当特定协议的外发包pps超过配置的阈值时，基于5分钟左右的抓包样本检测数据包是否为单向流量、是否有正常响应内容，得出分析结论并将发现的攻击提交日志显示。</p><h3 id="误判排除"><a href="#误判排除" class="headerlink" title="误判排除"></a>误判排除</h3><h4 id="AF僵尸网络防护排除"><a href="#AF僵尸网络防护排除" class="headerlink" title="AF僵尸网络防护排除"></a>AF僵尸网络防护排除</h4><p>AF僵尸网络防护排除方式具有以下三种：</p><ul><li>在僵尸网络功能模块下排除指定IP。</li><li>若误判由拦截规则引起，则可在【安全防护对象】-【僵尸网络规则库】找到并禁用指定规则。</li><li>可以在内置数据中心中，查询僵尸网络日志后使用【添加例外】排除。</li></ul><h4 id="DNS场景误判排除"><a href="#DNS场景误判排除" class="headerlink" title="DNS场景误判排除"></a>DNS场景误判排除</h4><p>通过蜜罐技术解决内网存在DNS服务器时，用于定位内网感染僵尸网络主机的真实IP地址。防止配置过程中忽略蜜罐设置，导致后续无法溯源的问题，策略配置界面新增DNS服务器服务界面。</p><h3 id="杀毒通知推送"><a href="#杀毒通知推送" class="headerlink" title="杀毒通知推送"></a>杀毒通知推送</h3><p>AF检测到的风险主机可以推送杀毒通知。重定向页面支持自定义，同时支持下载病毒查杀软件。</p><p>注意：杀毒通知推送设定的时间内，风险主机下载工具并查杀后也无法直接上网，需要等待指定时间，或管理员取消推送才可正常访问网站。重定向页面只对HTTP生效，HTTPS及NAT场景均不生效。</p><h2 id="勒索病毒防护"><a href="#勒索病毒防护" class="headerlink" title="勒索病毒防护"></a>勒索病毒防护</h2><h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>勒索病毒是一种新型电脑病毒，主机感染勒索病毒文件后，会自动运行勒索程序，遍历本地所有磁盘指定类型文件进行加密操作，加密后文件无法读取。随后生成勒索通知，要求受害者支付虚拟货币作为赎金。主要包含两种场景：</p><ul><li>服务器文件被加密</li><li>内网主机成片出现蓝屏现象，蓝屏代码提示<code>srv.sys驱动出现问题</code></li></ul><h3 id="防护措施"><a href="#防护措施" class="headerlink" title="防护措施"></a>防护措施</h3><ul><li>事前加固：勒索病毒风险评估，精准评估勒索病毒进入点风险，配置勒索病毒专项策略，全面防护勒索风险。</li><li>事中积极防御：通过配置的勒索病毒专项策略，全面防护勒索风险。</li><li>事后快速响应与处置：隔离识别已失陷的主机，采用专项工具进行杀毒。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;终端安全风险&quot;&gt;&lt;a href=&quot;#终端安全风险&quot; class=&quot;headerlink&quot; title=&quot;终端安全风险&quot;&gt;&lt;/a&gt;终端安全风险&lt;/h2&gt;&lt;p&gt;黑客可以利用僵尸网络展开更多的危害行为，如APT攻击最常采用的跳板就是僵尸网络。黑客利用僵尸网络来实现渗透、
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Terminal Security" scheme="https://blank-vax.github.io/tags/Terminal-Security/"/>
    
  </entry>
  
  <entry>
    <title>信息安全概述</title>
    <link href="https://blank-vax.github.io/2020/07/01/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/"/>
    <id>https://blank-vax.github.io/2020/07/01/信息安全概述/</id>
    <published>2020-07-01T03:50:00.000Z</published>
    <updated>2021-07-07T12:57:01.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安全背景"><a href="#安全背景" class="headerlink" title="安全背景"></a>安全背景</h2><ul><li>数字化时代威胁升级</li><li>传统安全防护在数字化转型中逐渐失效</li><li>安全风险能见度不足<ul><li>资产更替较快，无法全方位把握所有资产，导致安全加固操作不到位；</li><li>缺乏对水坑攻击、鱼叉邮件攻击、0day漏洞等新型威胁的及时全面的探测；</li><li>缺乏对预留后门、合法用户伪装等潜藏风险的把控；</li></ul></li><li>缺乏自动化防御手段</li><li>网络安全监管标准愈发严苛</li></ul><h2 id="常见网络安全术语"><a href="#常见网络安全术语" class="headerlink" title="常见网络安全术语"></a>常见网络安全术语</h2><ul><li>漏洞：可能被一个或多个威胁利用的资产或控制的弱点，包括软件漏洞、硬件漏洞、协议漏洞、算法漏洞等。</li><li>0day漏洞：亟待官方发现及开发安全补丁的漏洞。0day漏洞公开后称为Nday漏洞。</li><li>WEBSHELL：以asp、php、jsp或cgi等网页文件形式存在的一种命令执行环境。攻击者利用服务器本身开设的80端口采用POST请求上传WEBSHELL，绕过防火墙的检测，达到入侵服务器并提升用户权限的目的，最终实现完全控制服务器。针对这一攻击，可以通过设置白名单的方式限制文件上传。</li><li>exploit：漏洞利用即exp。本地攻击与远程攻击。</li><li>APT攻击：高级持续性威胁（Advanced Persistent Thread），利用先进的攻击手段对特定目标进行长期持续性网络攻击的攻击形式。</li></ul><h2 id="协议栈自身脆弱性及常见攻击"><a href="#协议栈自身脆弱性及常见攻击" class="headerlink" title="协议栈自身脆弱性及常见攻击"></a>协议栈自身脆弱性及常见攻击</h2><h3 id="协议栈脆弱性"><a href="#协议栈脆弱性" class="headerlink" title="协议栈脆弱性"></a>协议栈脆弱性</h3><ul><li>缺乏数据源验证机制</li><li>缺乏机密性保障机制</li><li>缺乏完整性检验机制</li></ul><h3 id="网络攻击基本模式"><a href="#网络攻击基本模式" class="headerlink" title="网络攻击基本模式"></a>网络攻击基本模式</h3><p>网络攻击包括被动威胁和主动威胁。其中被动威胁主要指截获这一手段，主动威胁包括篡改、中断和伪造这三种手段。</p><ul><li>截获—&gt;机密性：包括嗅探（Sniffing）和监听（Eavesdropping）；</li><li>篡改—&gt;完整性：主要指数据包篡改（Tampering）；</li><li>中断—&gt;可用性：常见的有拒绝服务（Dosing）；</li><li>伪造—&gt;真实性：通过欺骗（Spoofing）的方法破坏信息真实性；</li></ul><h3 id="常见攻击手段"><a href="#常见攻击手段" class="headerlink" title="常见攻击手段"></a>常见攻击手段</h3><ul><li>物理层：设备破坏、线路侦听</li><li>数据链路层：MAC欺骗、MAC泛洪、ARP欺骗</li><li>网络层：IP欺骗、Smurf攻击、ICMP攻击、地址扫描</li><li>传输层：TCP欺骗、TCP DOS、UDP DOS、端口扫描</li><li>应用层：漏洞、缓冲区溢出攻击、WEB应用攻击、病毒木马</li></ul><h4 id="物理层——物理攻击"><a href="#物理层——物理攻击" class="headerlink" title="物理层——物理攻击"></a>物理层——物理攻击</h4><ul><li>物理设备破坏：设备破坏攻击的目的主要是为了中断网络服务；</li><li>物理设备窃听：包括光纤监听和红外监听。</li><li>自然灾害：为尽量减少突发自然灾害对重要数据的破坏，常建设异地灾备数据中心。</li></ul><h4 id="数据链路层——MAC泛洪攻击"><a href="#数据链路层——MAC泛洪攻击" class="headerlink" title="数据链路层——MAC泛洪攻击"></a>数据链路层——MAC泛洪攻击</h4><p>泛洪攻击中，攻击者利用交换机中存储的MAC地址表的自动学习机制不断发送不同MAC地址给交换机，从而填满整个MAC表，此时交换机只能进行数据广播，攻击者凭此获得信息。由于交换机之间具有级联机制，故与受感交换机相连的所有交换机MAC地址表均被填满，整个网络出现数据发送缓慢、丢包甚至瘫痪的情况。可以在交换机上设置相应的端口保护机制以限制单个端口最大MAC数据接收条目数量。</p><h4 id="数据链路层——ARP欺骗"><a href="#数据链路层——ARP欺骗" class="headerlink" title="数据链路层——ARP欺骗"></a>数据链路层——ARP欺骗</h4><p>当A、B需要通讯时，A发送ARP请求询问B的MAC地址。攻击者冒充B持续发送ARP响应给A，并传递攻击者主机MAC地址，随后A发送给B的正常数据包都会被转发到攻击者主机处。</p><h4 id="网络层——ICMP攻击"><a href="#网络层——ICMP攻击" class="headerlink" title="网络层——ICMP攻击"></a>网络层——ICMP攻击</h4><p>ICMP具有多个控制报文如重定向和网络不可达等，常用于指导数据包的正确路由。</p><ul><li>ICMP重定向攻击中，攻击者主动向受害者发送ICMP重定向报文，改变受害者数据包传输路由，使其发送到不存在的网关，从而使得网关无法收到数据包，实现拒绝服务攻击。</li><li>ICMP不可达攻击中，攻击者向网关发送特定IP地址主机ICMP不可达报文，网关收到后便将受害者主机标记为不可达，从而导致受害者无法收到数据包。</li></ul><p>解决方法：通过修改注册表关闭ICMP不可达报文及重定向报文的处理功能。</p><h4 id="传输层——TCP-SYN-Flood攻击"><a href="#传输层——TCP-SYN-Flood攻击" class="headerlink" title="传输层——TCP SYN Flood攻击"></a>传输层——TCP SYN Flood攻击</h4><p>SYN报文是TCP连接的第一个报文，攻击者通过大量发送SYN报文，造成大量未完全建立的TCP连接，从而占用被攻击者的资源，以达到拒绝服务攻击的目的。</p><h4 id="应用层——DNS欺骗攻击"><a href="#应用层——DNS欺骗攻击" class="headerlink" title="应用层——DNS欺骗攻击"></a>应用层——DNS欺骗攻击</h4><p>攻击者通过篡改DNS服务器上的DNS数据破坏域名与IP地址的对应关系，当用户输入访问网站的URL后，该域名被解析成攻击者事先设置好的钓鱼网站对应的IP地址，随后用户主机会访问该IP地址进入钓鱼网站。</p><h3 id="DDoS攻击风险防护方案"><a href="#DDoS攻击风险防护方案" class="headerlink" title="DDoS攻击风险防护方案"></a>DDoS攻击风险防护方案</h3><ul><li><p>网络设备性能充裕</p><p>防火墙、路由器、交换机性能富余。</p></li><li><p>网络带宽资源充裕</p><p>保持一定比例的网络带宽余量。</p></li><li><p>异常流量清洗</p><p>通过抗D设备清洗异常流量。</p></li><li><p>通过CDN分流</p><p>多节点分担DDoS攻击流量。</p></li><li><p>分布式集群</p><p>每个节点分配足够资源数据回发瘫痪攻击源。</p></li></ul><h2 id="操作系统的脆弱性及常见攻击"><a href="#操作系统的脆弱性及常见攻击" class="headerlink" title="操作系统的脆弱性及常见攻击"></a>操作系统的脆弱性及常见攻击</h2><h3 id="操作系统漏洞分类"><a href="#操作系统漏洞分类" class="headerlink" title="操作系统漏洞分类"></a>操作系统漏洞分类</h3><ul><li>人为原因：开发者在程序代码中故意隐藏后门。</li><li>客观原因：受开发者能力、经验及当时安全技术限制，程序设计过程中存在不足之处，导致权限提升等后果。</li><li>硬件原因：编程人员无法弥补硬件自身的安全漏洞，从而使硬件问题通过软件体现。</li></ul><h3 id="缓冲区溢出攻击"><a href="#缓冲区溢出攻击" class="headerlink" title="缓冲区溢出攻击"></a>缓冲区溢出攻击</h3><p>缓冲区溢出攻击利用编写不够严谨的程序，通过向程序的缓冲区写入超过预定长度的数据，造成缓存溢出，从而破坏程序的堆栈结构，导致程序执行流程的改变，达到破坏系统或提取关键信息的目的。攻击者如果可以精确控制内存跳转地址，就可以执行指定代码，获得权限或破坏系统。</p><p><img src="/2020/07/01/信息安全概述/1.PNG" alt="缓冲区溢出.png-160.9kB"></p><p>缓冲区溢出的防范可以通过以下方面考虑：</p><ul><li>用户层面需要及时更新系统及软件补丁，并保持防火墙常开。</li><li>开发人员开发程序过程中，需要编写安全代码，对输入数据进行验证，如限制输入数据的长度。同时需要使用相对安全的函数，如C语言在字符串处理过程中提供大量安全函数，如<code>strcat_s()</code>，<code>strcpy_s()</code>，<code>gets_s()</code>等。</li><li>系统层面可以运用缓冲区不可执行技术来防止缓冲区恶意代码执行，也可以采用虚拟化技术来防止缓冲区溢出漏洞的产生。</li></ul><p>由于现阶段大量程序执行过程中均会由操作系统分配随机起始地址，故对于攻击者来说获取准确的函数返回地址并实现恶意代码执行较为困难。</p><h2 id="终端的脆弱性及常见攻击"><a href="#终端的脆弱性及常见攻击" class="headerlink" title="终端的脆弱性及常见攻击"></a>终端的脆弱性及常见攻击</h2><h3 id="勒索病毒"><a href="#勒索病毒" class="headerlink" title="勒索病毒"></a>勒索病毒</h3><p>作为一种恶意程序，勒索病毒可以感染设备、网络与数据中心并使其瘫痪，直至用户支付赎金使系统解锁。该类病毒执行过程如下：受害者主机植入勒索病毒后，病毒本身调用加密算法库解密自身数据并回连服务器，随后通过脚本文件执行HTTP GET请求并下载加密后的文件，随后在受害者主机环境中进行文件解密并将该文件封装成动态链接库，随后通过wscript执行DLL文件通过遍历系统文件的方法收集计算机信息。勒索病毒会将电脑中的各类文档进行加密，让用户无法打开，并弹窗限时勒索付款提示信息，达到勒索赎金的目的。</p><h4 id="发展阶段"><a href="#发展阶段" class="headerlink" title="发展阶段"></a>发展阶段</h4><ul><li>第一阶段：2008年以前，只锁定用户设备不加密数据，以LockScreen为代表家族。</li><li>第二阶段：2013年以前，采用高强度对称和非对称加密算法加密用户数据，以CTB-Locker、TeslaCrypt、Cerber为代表家族。</li><li><p>第三阶段：2017年前后，通过系统漏洞或弱口令等方式发起蠕虫式攻击，攻陷单点设备后还会在内网中横向扩散，以WannaCry和Satan为代表。</p></li><li><p>第四阶段：加密货币的出现改变勒索格局，加密货币具有匿名性与去中心化的特点，解决攻击者的传统问题，脱离货币交易链的追查与监管，黑色产业因此蓬勃发展。</p></li><li>第五阶段：勒索软件服务化，RaaS模式初见规模。</li></ul><h4 id="勒索病毒感染与传播方式"><a href="#勒索病毒感染与传播方式" class="headerlink" title="勒索病毒感染与传播方式"></a>勒索病毒感染与传播方式</h4><p><img src="/2020/07/01/信息安全概述/2.PNG" alt="勒索病毒感染与传播方式.png-798.9kB"></p><h4 id="勒索病毒攻击链"><a href="#勒索病毒攻击链" class="headerlink" title="勒索病毒攻击链"></a>勒索病毒攻击链</h4><p><strong>感染媒介—&gt;C&amp;C通信—&gt;文件加密—&gt;横向移动</strong></p><h4 id="高效勒索病毒协同防护体系"><a href="#高效勒索病毒协同防护体系" class="headerlink" title="高效勒索病毒协同防护体系"></a>高效勒索病毒协同防护体系</h4><p><img src="/2020/07/01/信息安全概述/3.PNG" alt="构建高效勒索病毒协同防护体系.png-1277.5kB"></p><h3 id="挖矿病毒"><a href="#挖矿病毒" class="headerlink" title="挖矿病毒"></a>挖矿病毒</h3><p>作为一种恶意程序，挖矿程序可以自动传播，在未授权的情况下占用系统资源，为攻击者牟利，使得受害者机器性能明显下降，影响正常使用。挖矿病毒占用CPU或GPU等计算资源，自动创建后门与混淆进程，同时该病毒定期改变进程名与PID并检测系统中是否存在对应的挖矿软件，若被查杀则再次从远端服务器上获取资源。同时该病毒通过扫描SSH文件感染其他机器，实现横向传播。</p><h3 id="特洛伊木马"><a href="#特洛伊木马" class="headerlink" title="特洛伊木马"></a>特洛伊木马</h3><p>完整的木马程序一般由服务器程序与控制器程序两部分组成，当受害者主机安装了木马的服务器程序后，拥有控制器程序的攻击者就可以通过网络控制受害者主机。木马程序通常注入正常程序中，当用户执行正常程序时启动。同时，木马程序自动在任务管理器中隐藏，并以”系统服务”的方式欺骗操作系统，包含具有未公开并且可能产生危险后果的功能的程序，具备自动恢复与打开特殊端口的功能。</p><h3 id="蠕虫病毒"><a href="#蠕虫病毒" class="headerlink" title="蠕虫病毒"></a>蠕虫病毒</h3><p>蠕虫是一种可以自我复制并通过网络传播的代码，通常无需人为干预即可实现传播。蠕虫病毒入侵并完全控制一台计算机后，就会把这台主机作为宿主，进而扫描并感染其他计算机。蠕虫病毒具有不依赖宿主程序、利用漏洞主动攻击、通过蠕虫网络隐藏攻击者位置的特点。该类病毒易造成拒绝服务与隐私信息丢失。</p><h3 id="宏病毒"><a href="#宏病毒" class="headerlink" title="宏病毒"></a>宏病毒</h3><p>宏病毒是一种寄存在文档或模板的宏中的计算机病毒，具有感染文档、传播速度快、病毒制作周期短、可实现多平台交叉感染的特点。宏病毒通过调用系统命令造成系统破坏，除此之外，感染宏病毒的文档无法正常打印，并具有封闭或改变文件存储路径、非法复制文件等行为。</p><h3 id="僵尸网络"><a href="#僵尸网络" class="headerlink" title="僵尸网络"></a>僵尸网络</h3><p>采用一种或多种传播手段，将大量主机感染僵尸程序，从而在控制者和被感染主机之间形成一个一对多控制网络。僵尸网络的形成过程包含<strong>加入、传播和控制</strong>三个阶段。</p><p>僵尸程序多指实现恶意控制功能的程序代码，控制服务器多指控制和通信的中心服务器。</p><h2 id="其他常见攻击"><a href="#其他常见攻击" class="headerlink" title="其他常见攻击"></a>其他常见攻击</h2><h3 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h3><p>社会工程攻击通常被认为是一种欺诈他人以收集信息、行骗和入侵计算机系统的行为，可以通过定期更换各种系统账号密码或使用高强度密码等防御该类攻击。</p><h3 id="人为因素"><a href="#人为因素" class="headerlink" title="人为因素"></a>人为因素</h3><ul><li>无意行为：如工作失误、经验问题、体制不健全等；</li><li>恶意行为：攻击者出于政治、经济、商业或个人目的制造病毒及破坏性程序，攻击企业信息系统并获取重要资料。</li><li>防范措施<ul><li>提升安全意识</li><li>最低权限访问模式</li><li>完善和落地管理措施</li><li>利用已有安全手段对核心资产进行安全保护</li></ul></li></ul><h3 id="拖库洗库撞库"><a href="#拖库洗库撞库" class="headerlink" title="拖库洗库撞库"></a>拖库洗库撞库</h3><p>拖库是指黑客入侵有价值的网络站点并将注册用户的资料数据库全部盗走的行为。</p><p>洗库指在获取大量用户数据后，黑客通过一系列的技术手段和黑色产业链将有价值的用户数据变现的行为。</p><p>撞库指黑客利用获得的私密数据在其他网站上进行登录尝试的行为。</p><h3 id="跳板攻击"><a href="#跳板攻击" class="headerlink" title="跳板攻击"></a>跳板攻击</h3><p>攻击者通常不直接通过自己的系统向目标发动攻击，而是先攻破若干中间系统并将其作为”跳板”，借助这些计算机完成攻击行动。用户可以通过安装防火墙以控制流量进出、更改系统默认登录用户为普通用户并做好权限控制等手段抵御此类攻击。</p><h3 id="钓鱼式攻击"><a href="#钓鱼式攻击" class="headerlink" title="钓鱼式攻击"></a>钓鱼式攻击</h3><p>钓鱼攻击是一种企图从电子通讯中，通过伪装成信誉卓著的法人媒体以获得如用户名、密码和信用卡明细等个人敏感信息的犯罪诈骗过程。鱼叉式钓鱼攻击指针对特定受害公司或组织的钓鱼攻击，其钓鱼页面设计与整体操作流程具有定制化、精准化的特点，成功率较高。可以通过保证网络站点与用户之间的安全传输、加强网络站点的认证过程与监管等方式防御此类攻击。</p><h3 id="水坑攻击"><a href="#水坑攻击" class="headerlink" title="水坑攻击"></a>水坑攻击</h3><p>攻击者首先通过观察或猜测确定特定目标经常访问的网站，并入侵其中一个或多个网站，植入恶意软件。当目标组织或组织中部分成员访问该类网站时会被重定向到恶意网址，导致恶意软件执行，最终造成该组织机器的大量感染。为抵御此类攻击，运维人员通常在浏览器或软件上进行安全杀毒和检测工作，若检测到恶意内容，则持续监控该网站流量并阻止恶意流量。此外，运维人员可以通过定期更新补丁的方式减少浏览器漏洞。</p><h2 id="信息安全要素"><a href="#信息安全要素" class="headerlink" title="信息安全要素"></a>信息安全要素</h2><ul><li><p>保密性Confidentiality</p><p>确保信息不暴露给未授权的实体或进程。</p></li><li><p>完整性Integrity</p><p>只有得到允许的用户才能修改实体或进程，并且能够判别出实体或进程是否被篡改。</p></li><li><p>可用性Availability</p><p>得到授权的实体可获得服务，攻击者不能占用所有资源而阻碍授权者的工作。</p></li><li><p>可控性Controllability</p><p>可控性主要指对危害国家信息（包括利用加密的非法通信活动）的监视审计。</p></li><li><p>不可否认性Non-repudiation</p><p>为出现的安全问题提供调查的依据和手段，使用审计、监控、防抵赖等安全机制使得攻击者无法否认相关操作。</p></li></ul><h2 id="安全解决方案"><a href="#安全解决方案" class="headerlink" title="安全解决方案"></a>安全解决方案</h2><h3 id="企业安全解决方案构建"><a href="#企业安全解决方案构建" class="headerlink" title="企业安全解决方案构建"></a>企业安全解决方案构建</h3><h4 id="企业信息安全建设规划目标"><a href="#企业信息安全建设规划目标" class="headerlink" title="企业信息安全建设规划目标"></a>企业信息安全建设规划目标</h4><ul><li>风险可视化Visibility</li><li>防御主动话Proactive</li><li>运行自动化Automation</li><li>安全智能化Intelligent</li></ul><h4 id="传统安全方案痛点"><a href="#传统安全方案痛点" class="headerlink" title="传统安全方案痛点"></a>传统安全方案痛点</h4><ul><li>产品堆叠为主</li><li>边界防护为主</li><li>被动防守为主</li></ul><h4 id="APDRO智安全架构"><a href="#APDRO智安全架构" class="headerlink" title="APDRO智安全架构"></a>APDRO智安全架构</h4><ul><li>智能Artificial Intelligence</li><li>防御Protect</li><li>检测Detect</li><li>响应Respond</li><li>运营Operate</li></ul><h4 id="安全域划分"><a href="#安全域划分" class="headerlink" title="安全域划分"></a>安全域划分</h4><p>将企业数据区域进行安全等级划分，分成<strong>非安全区</strong>、<strong>半安全区</strong>、<strong>安全区</strong>和<strong>核心安全区</strong>四个部分。</p><ul><li>非安全区是数据中心等关键区域与外部直接连接的区域，属于非信任区域。</li><li>半安全区是非安全区与安全区之间的过渡区域，用于分割它们之间的直接联系，隐藏安全区的内部资源。</li><li>安全区是安全级别次高的区域。</li><li>核心安全区是安全级别最高的区域。</li></ul><p>各安全域访问原则如下：</p><p><img src="/2020/07/01/信息安全概述/4.PNG" alt="安全区域划分.png-118.4kB"></p><h3 id="上网行为安全解决方案-AC"><a href="#上网行为安全解决方案-AC" class="headerlink" title="上网行为安全解决方案 AC"></a>上网行为安全解决方案 AC</h3><h4 id="上网行为可视"><a href="#上网行为可视" class="headerlink" title="上网行为可视"></a>上网行为可视</h4><ul><li>用户可视</li><li>流量&amp;应用可视</li><li>内容可视</li></ul><h4 id="上网行为可控"><a href="#上网行为可控" class="headerlink" title="上网行为可控"></a>上网行为可控</h4><ul><li>工作效率提升</li><li>流量可视可控</li><li>规避法律法规法风险</li></ul><h3 id="纵深边界安全解决方案-Firewall"><a href="#纵深边界安全解决方案-Firewall" class="headerlink" title="纵深边界安全解决方案 Firewall"></a>纵深边界安全解决方案 Firewall</h3><h4 id="精细化资产攻击面管理"><a href="#精细化资产攻击面管理" class="headerlink" title="精细化资产攻击面管理"></a>精细化资产攻击面管理</h4><ul><li>资产可视</li><li>高危端口可视</li><li>策略智能调优</li></ul><h4 id="场景化安全防护实践"><a href="#场景化安全防护实践" class="headerlink" title="场景化安全防护实践"></a>场景化安全防护实践</h4><ul><li>防黑客渗透</li><li>防内网病毒扩散</li><li>办公环境安全性&amp;连续性保障</li><li>资产失陷外连泄密防护</li></ul><h3 id="移动接入安全解决方案"><a href="#移动接入安全解决方案" class="headerlink" title="移动接入安全解决方案"></a>移动接入安全解决方案</h3><h4 id="端到端移动安全"><a href="#端到端移动安全" class="headerlink" title="端到端移动安全"></a>端到端移动安全</h4><ul><li>精确身份认证</li><li>角色授权与URL级别授权</li><li>支持1024、2028位商密或国密算法</li><li>主从账号绑定、服务器地址伪装、应用隐藏</li></ul><h4 id="创新移动终端安全"><a href="#创新移动终端安全" class="headerlink" title="创新移动终端安全"></a>创新移动终端安全</h4><ul><li>移动终端个人域与工作域隔离</li><li>防中间人攻击、客户端安全检查</li><li>SSL专线、客户端痕迹清除</li></ul><h3 id="端点安全"><a href="#端点安全" class="headerlink" title="端点安全"></a>端点安全</h3><h4 id="方案优势"><a href="#方案优势" class="headerlink" title="方案优势"></a>方案优势</h4><ul><li>支持多个操作系统</li><li>实现跨平台</li><li>集中管控</li><li>轻量级</li></ul><h4 id="加固"><a href="#加固" class="headerlink" title="加固"></a>加固</h4><p>用于业务域内部及业务域之间，基于应用策略，实现主机东西向流量访问控制。</p><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><p>全面探测服务器主机和网络上的威胁活动，进行入侵行为主动IP封堵与恶意文件隔离。</p><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><p>结合传统技术与人工智能，采用机器学习模型实现针对病毒木马、僵尸网络及暴力破解行为的检测。</p><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><p>采用IP黑白名单机制及文件隔离机制，监控进程的可疑行为，以即时拦阻恶意代码。</p><h3 id="网络安全拓扑参考"><a href="#网络安全拓扑参考" class="headerlink" title="网络安全拓扑参考"></a>网络安全拓扑参考</h3><p><img src="/2020/07/01/信息安全概述/5.PNG" alt="网络安全拓扑参考.png-1531.1kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安全背景&quot;&gt;&lt;a href=&quot;#安全背景&quot; class=&quot;headerlink&quot; title=&quot;安全背景&quot;&gt;&lt;/a&gt;安全背景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数字化时代威胁升级&lt;/li&gt;
&lt;li&gt;传统安全防护在数字化转型中逐渐失效&lt;/li&gt;
&lt;li&gt;安全风险能见度不足&lt;
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Information Security" scheme="https://blank-vax.github.io/tags/Information-Security/"/>
    
  </entry>
  
  <entry>
    <title>服务器安全检测和防御技术</title>
    <link href="https://blank-vax.github.io/2020/06/26/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%A3%80%E6%B5%8B%E5%92%8C%E9%98%B2%E5%BE%A1%E6%8A%80%E6%9C%AF/"/>
    <id>https://blank-vax.github.io/2020/06/26/服务器安全检测和防御技术/</id>
    <published>2020-06-26T02:32:00.000Z</published>
    <updated>2020-11-09T03:39:09.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DoS攻击检测与防御"><a href="#DoS攻击检测与防御" class="headerlink" title="DoS攻击检测与防御"></a>DoS攻击检测与防御</h2><h3 id="DoS攻击"><a href="#DoS攻击" class="headerlink" title="DoS攻击"></a>DoS攻击</h3><p>Denial of Service，是一种拒绝服务攻击，常用来使服务器或网络瘫痪。</p><p>Distributed Denial of Service，简称为DDoS攻击，是一种分布式拒绝服务攻击。</p><h3 id="DoS类型"><a href="#DoS类型" class="headerlink" title="DoS类型"></a>DoS类型</h3><ul><li>发送大量所属协议的数据包达到占据服务端带宽并堵塞线路的目的<ul><li>ICMP洪水攻击</li><li>UDP洪水攻击</li><li>SYN洪水攻击</li></ul></li><li>利用TCP三次握手特性，大量发起请求包以占用服务器资源，最终实现服务器资源耗尽<ul><li>SYN洪水攻击</li></ul></li><li>畸形数据包攻击<ul><li>PingofDeath</li><li>TearDrop</li></ul></li><li>CC攻击（主要用来攻击页面）</li><li>慢速攻击</li></ul><h3 id="SYN洪水防护"><a href="#SYN洪水防护" class="headerlink" title="SYN洪水防护"></a>SYN洪水防护</h3><h4 id="每目的IP激活阈值"><a href="#每目的IP激活阈值" class="headerlink" title="每目的IP激活阈值"></a>每目的IP激活阈值</h4><p>每目的IP激活阈值指当针对策略设置的目的IP组内某IP发起的SYN请求速率数据包超过设定值，则触发AF的SYN代理功能。</p><h4 id="每目的IP丢包阈值"><a href="#每目的IP丢包阈值" class="headerlink" title="每目的IP丢包阈值"></a>每目的IP丢包阈值</h4><p>每目的IP丢包阈值指当针对策略设置的目的IP组内某IP发起的SYN请求速率数据包超过设定值，则AF不再启用SYN代理，直接丢弃SYN包。</p><h2 id="漏洞攻击防护入侵检测与防御"><a href="#漏洞攻击防护入侵检测与防御" class="headerlink" title="漏洞攻击防护入侵检测与防御"></a>漏洞攻击防护入侵检测与防御</h2><h3 id="IDS"><a href="#IDS" class="headerlink" title="IDS"></a>IDS</h3><p>Intrusion Detection Systems，即入侵检测系统，对网络、系统的运行状况进行监视，尽可能发现各种攻击企图、攻击行为或攻击结果。通过旁路镜像模式部署，多用于被动检测。</p><h3 id="IPS"><a href="#IPS" class="headerlink" title="IPS"></a>IPS</h3><p>Intrusion Prevention Systems，即入侵防御系统，可对网络、系统的运行状况进行监视，并可发现阻止各种攻击企图、攻击行为。通过路由模式、透明模式及并联模式部署，多用于主动检测。</p><h3 id="常见漏洞攻击手段"><a href="#常见漏洞攻击手段" class="headerlink" title="常见漏洞攻击手段"></a>常见漏洞攻击手段</h3><h4 id="Worm蠕虫"><a href="#Worm蠕虫" class="headerlink" title="Worm蠕虫"></a>Worm蠕虫</h4><p><img src="http://static.zybuluo.com/B1ank/cd1w8ekz3l3d1zdqn5flqy5x/worm%E8%A0%95%E8%99%AB.png" alt="worm蠕虫.png-291.6kB"></p><h4 id="口令暴力破解"><a href="#口令暴力破解" class="headerlink" title="口令暴力破解"></a>口令暴力破解</h4><p>常见的暴力破解方法包括<strong>字典法</strong>与<strong>规则破解法</strong>。</p><ul><li>字典法：黑客通过各种手段获取一些网络用户经常使用的弱密码，集合在一起形成文本文件，并使用该文件进行口令爆破。</li><li>规则破解法：通过账户相关信息或用户个人信息进行破解。</li></ul><h3 id="漏洞攻击防护原理"><a href="#漏洞攻击防护原理" class="headerlink" title="漏洞攻击防护原理"></a>漏洞攻击防护原理</h3><p>漏洞攻击防护通过对数据包应用层里的数据内容进行威胁特征检查，并与漏洞攻击防护规则库进行比对，如果匹配则拒绝该数据包，从而实现应用层漏洞攻击的防护。</p><h3 id="误判处置"><a href="#误判处置" class="headerlink" title="误判处置"></a>误判处置</h3><ul><li>配置漏洞攻击防护规则时，在漏洞攻击防护日志中勾选”记录”。</li><li>根据数据中心的日志，查询到误判规则的漏洞ID。</li><li>【对象】-【安全防护规则库】-【安全规则库】-漏洞特征识别库中，修改相应漏洞ID的动作。</li><li>白名单添加例外。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>配置漏洞攻击防护保护客户端和服务器时，源区域为数据连接发起的区域。</li><li>漏洞攻击防护保护客户端与保护服务器中的客户端漏洞和服务器漏洞规则是不同的。</li></ul><h2 id="Web攻击检测与防御"><a href="#Web攻击检测与防御" class="headerlink" title="Web攻击检测与防御"></a>Web攻击检测与防御</h2><h3 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h3><p>Web Application Firewall，即Web应用防护，主要用于保护Web服务器不受攻击，而导致软件服务中断或被远程控制。WAF常见攻击手段包括：</p><ul><li>SQL注入</li><li>XSS攻击</li><li>网页木马</li><li>网站扫描</li><li>WEBSHELL</li><li>跨站请求伪造</li><li>系统命令注入</li><li>文件包含攻击</li><li>目录遍历攻击</li><li>信息泄漏攻击</li></ul><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>通过将SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意SQL命令的目的。</p><h4 id="GET与POST请求"><a href="#GET与POST请求" class="headerlink" title="GET与POST请求"></a>GET与POST请求</h4><p>GET请求提交的内容经过URL编码直接在URL栏中显示。</p><p>POST提交的内容不会直接显示在URL部分，而是呈现在POST包的DATA字段中。</p><h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><p>Cross Site Request Fogery，即跨站请求伪造，攻击者盗用受害用户的身份，以其名义发送恶意请求，对服务器来说这个请求是合法的，但完成了攻击者所期望的操作，如以受害用户的名义发送邮件和信息，盗取账号，添加系统管理员等非法操作。</p><h3 id="误判处置-1"><a href="#误判处置-1" class="headerlink" title="误判处置"></a>误判处置</h3><ul><li><p>在【策略】-【安全策略】-【安全防护策略】-【高级设置】中新增URL参数排除后，Web应用防护的网站攻击检测将跳过这些参数的检查。主要用于正常业务下某些请求参数因携带特征串而被检测为攻击的情况，可以只针对这类参数进行排除。</p></li><li><p>在【内置数据中心】-【日志查询】-【WEB应用防护】中查询日志，找出误判日志然后点击日志后面的”添加例外”。</p></li></ul><h2 id="联动封锁技术"><a href="#联动封锁技术" class="headerlink" title="联动封锁技术"></a>联动封锁技术</h2><h3 id="联动封锁类型"><a href="#联动封锁类型" class="headerlink" title="联动封锁类型"></a>联动封锁类型</h3><p>高危行为联动封锁：仅封锁具有高危行为特征的IP，优先保证用户流畅上网、业务稳定；</p><p>任意攻击行为联动封锁：对任意具有攻击特征的IP执行访问封锁，最大化业务和用户的安全防御能力。</p><h3 id="联动封锁机制"><a href="#联动封锁机制" class="headerlink" title="联动封锁机制"></a>联动封锁机制</h3><ul><li>高危行为联动封锁功能仅关联。</li><li>任意攻击行为联动功能关联。</li><li>策略触发的联动封锁是针对数据包的会话五元组进行拦截。</li></ul><h2 id="网页防篡改技术"><a href="#网页防篡改技术" class="headerlink" title="网页防篡改技术"></a>网页防篡改技术</h2><p>深信服网页防篡改解决方案采用<strong>文件保护系统+下一代防火墙</strong>紧密结合，<strong>文件监控+二次认证</strong>功能紧密联动，保证网站内容不被篡改，其中文件保护系统采用业界防篡改技术中最先进的文件过滤驱动技术。</p><h3 id="管理员认证流程"><a href="#管理员认证流程" class="headerlink" title="管理员认证流程"></a>管理员认证流程</h3><p><img src="http://static.zybuluo.com/B1ank/3y4y65j05h0g5asinforhet8/%E7%BD%91%E9%A1%B5%E9%98%B2%E7%AF%A1%E6%94%B9.png" alt="网页防篡改.png-328.4kB"></p><ul><li>访问网站后台</li><li>AF重定向提交管理员邮箱地址的认证页面</li><li>提交接收验证码的管理员邮箱</li><li>发送带有验证码的邮件至上述管理员邮箱</li><li>管理员登录邮箱获取验证码</li><li>管理员提交验证码通过认证</li><li>通过验证后自动跳转到后台页面</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>防篡改客户端必须连接防火墙并匹配防篡改策略后才会生效，防篡改客户端生效后，即使防火墙不在线，功能依然生效。</li><li>若网站本身有webshell未删除，则防篡改客户端无法拦截webshell的文件篡改行为。</li><li>Windows系统中，防篡改客户端无法通过控制面板-卸载程序进行卸载，需要使用安装目录中的<code>tamper.exe</code>进行卸载，卸载时需要输入客户端密码。</li><li>Linux系统中，针对防篡改功能开启前已经建立的会话或连接，防篡改功能不会生效。</li><li>Linux系统中，已经被防篡改保护的会话或连接在防篡改进程停止的情况下依然会生效。</li><li>Linux系统中，开启防篡改的服务器，如果需要完全消除防篡改的影响，则需要先卸载防篡改程序后重启所有服务或直接重启服务器。</li><li>Linux系统中，Agent自身存在bypass机制，当服务器内存系统资源超过70%时，功能可以生效但无法向AF同步安全日志。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DoS攻击检测与防御&quot;&gt;&lt;a href=&quot;#DoS攻击检测与防御&quot; class=&quot;headerlink&quot; title=&quot;DoS攻击检测与防御&quot;&gt;&lt;/a&gt;DoS攻击检测与防御&lt;/h2&gt;&lt;h3 id=&quot;DoS攻击&quot;&gt;&lt;a href=&quot;#DoS攻击&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Server Security" scheme="https://blank-vax.github.io/tags/Server-Security/"/>
    
  </entry>
  
</feed>
