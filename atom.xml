<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>B1ank</title>
  
  
  <link href="/blank-vax.github.io/atom.xml" rel="self"/>
  
  <link href="https://blank-vax.github.io/"/>
  <updated>2020-04-25T09:58:22.000Z</updated>
  <id>https://blank-vax.github.io/</id>
  
  <author>
    <name>B1ank</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>码云合作办公指南</title>
    <link href="https://blank-vax.github.io/2020/11/09/%E7%A0%81%E4%BA%91%E5%90%88%E4%BD%9C%E5%8A%9E%E5%85%AC%E6%8C%87%E5%8D%97/"/>
    <id>https://blank-vax.github.io/2020/11/09/码云合作办公指南/</id>
    <published>2020-11-09T02:39:34.455Z</published>
    <updated>2020-04-25T09:58:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-合作场景"><a href="#0x00-合作场景" class="headerlink" title="0x00 合作场景"></a>0x00 合作场景</h2><p>最近团队在进行项目开发时出现了需要共享改动代码这一问题。由于GitHub的上传速度太慢，我们选择了Gitee平台来进行代码托管与合作修改，下面来整理一下流程以备不时之需。</p><h2 id="0x01-项目创建与邀请合作"><a href="#0x01-项目创建与邀请合作" class="headerlink" title="0x01 项目创建与邀请合作"></a>0x01 项目创建与邀请合作</h2><p>首先正常创建合作仓库，尽量选择创建私立仓库。创建好的仓库可以点击相关设置寻找邀请链接相关选项，将该选项中的链接路径复制并发送给其他合作者。参与合作的人登录自己的码云账号，点击该链接，即可作为合作者加入私有仓库。</p><h2 id="0x02-远程合作"><a href="#0x02-远程合作" class="headerlink" title="0x02 远程合作"></a>0x02 远程合作</h2><p>尽管合作参与者可以直接修改合作项目，但容易出现代码覆盖问题，所以我们选择将原项目fork到本账号仓库下，然后对其进行编辑。</p><p><img src="http://static.zybuluo.com/B1ank/xwnk5nfk8z8bjtq0cu73dgx3/original_project.PNG" alt="original_project.PNG-3751.6kB"></p><p>这里右上角的forked说明已经在本账号仓库完成fork。</p><p><img src="http://static.zybuluo.com/B1ank/kjbq5ame4uhkcsl1zsfy2ux4/forked_result.PNG" alt="forked_result.PNG-2572.5kB"></p><p>本账号仓库的内容修改完毕之后，点击<code>+Pull Request</code>可以发送代码合并申请。这样原创建者会收到合并请求即修改细节，待其审核通过后修改可以同步到源文件。与此同时，所有的合作参与者会收到相关通知，详细记录了修改细节。</p><h2 id="0x03-git码云远端库"><a href="#0x03-git码云远端库" class="headerlink" title="0x03 git码云远端库"></a>0x03 git码云远端库</h2><p>首先在网上下载git工具并完成安装。右键选择<code>Git Bash Here</code>，在命令行窗口中输入<code>git --version</code>命令可以查看git版本号。</p><p><img src="http://static.zybuluo.com/B1ank/q3bk8z3dqf8exyrwia8mllf8/git_1.PNG" alt="git_1.PNG-10.3kB"></p><p>然后配置用户名和邮箱：</p><ul><li><code>git config --global user.name &quot;username&quot;</code>。使用该命令设置git的全局姓名或昵称。</li><li><code>git config --global user.email &quot;email_address&quot;</code>。使用该命令设置全局邮箱地址。</li></ul><p>完成上述加入合作仓库以及fork到本账号步骤之后，我们继续进行项目到本地PC的迁移。首先复制该项目的地址，用于下一步的git操作。</p><p><img src="http://static.zybuluo.com/B1ank/mvya5fzubqusqzcirenucpbp/git_2.PNG" alt="git_2.PNG-32kB"></p><p>在本地新建空文件夹，进入文件夹内部执行<code>Git Bash Here</code>命令，使用<code>git init</code>命令将这个目录初始化为一个本地git仓库，继续键入命令并输入复制的git地址<code>git clone + git_address</code>。出现如下结果则可以在本地对项目进行代码修改。</p><p><img src="http://static.zybuluo.com/B1ank/aoz2r4ooqk3jl3miay4sg63b/git_3.PNG" alt="git_3.PNG-28.9kB"></p><p>然后进入clone后的文件目录，在这个目录下添加测试文件test.txt并编写测试内容。然后执行下述命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; git status</span><br><span class="line">&gt; git add .    (这里注意add与.之间存在空格)</span><br><span class="line">&gt; git commit -m &quot;add notification of this modification&quot;     (该操作是添加为本次修改添加注释)</span><br><span class="line">&gt; git remote add nickname git_address      (该命令用于为自己仓库地址取别名，下次提交时不需要执行该命令)</span><br><span class="line">&gt; git push nickname master</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/B1ank/1v46uf475fkjqelqyzz0td6w/git_4.PNG" alt="git_4.PNG-67.7kB"></p><p>以上为流程正确执行时git的返回结果。我们可以在自己的项目内发现新增的内容：</p><p><img src="http://static.zybuluo.com/B1ank/3nqkyzb5kr8871vz5af37by9/git_5.PNG" alt="git_5.PNG-2256.4kB"></p><p>至此，我们完成本地修改项目仓库的配置并实现一次成功提交。修改完成本账号仓库后，根据前述的步骤点击<code>+Pull Request</code>按键向项目拥有者发送审核请求即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-合作场景&quot;&gt;&lt;a href=&quot;#0x00-合作场景&quot; class=&quot;headerlink&quot; title=&quot;0x00 合作场景&quot;&gt;&lt;/a&gt;0x00 合作场景&lt;/h2&gt;&lt;p&gt;最近团队在进行项目开发时出现了需要共享改动代码这一问题。由于GitHub的上传速度太
      
    
    </summary>
    
      <category term="踩坑指南" scheme="https://blank-vax.github.io/categories/%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="Gitee" scheme="https://blank-vax.github.io/tags/Gitee/"/>
    
  </entry>
  
  <entry>
    <title>现代密码学解题报告(一)</title>
    <link href="https://blank-vax.github.io/2020/11/09/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A(%E4%B8%80)/"/>
    <id>https://blank-vax.github.io/2020/11/09/现代密码学解题报告(一)/</id>
    <published>2020-11-09T02:39:34.455Z</published>
    <updated>2019-11-12T17:37:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>该系列主要用于记录密码学实验过程中遇到的题目及相关分析方法.</p><h2 id="0x01-Cryptopals部分题目"><a href="#0x01-Cryptopals部分题目" class="headerlink" title="0x01 Cryptopals部分题目"></a>0x01 Cryptopals部分题目</h2><p>该部分题目参考Cryptopals系列博客Set1部分,链接如下:<br><a href="https://blank-vax.github.io/2019/11/12/Cryptopals%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%28%E4%B8%80%29/#more">Cryptopals-Set1</a></p><h2 id="0x02-Many-Time-Pad"><a href="#0x02-Many-Time-Pad" class="headerlink" title="0x02 Many Time Pad"></a>0x02 Many Time Pad</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://www.coursera.org/learn/crypto/home/week/1" target="_blank" rel="noopener">Coursera-Cryptography-Week1-PA</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Let us see what goes wrong when a stream cipher key is used more than once. Below are eleven hex-encoded ciphertexts that are the result of encrypting eleven plaintexts with a stream cipher, all with the same stream cipher key. Your goal is to decrypt the last ciphertext, and submit the secret message within it as solution.</p><p>Hint: XOR the ciphertexts together, and consider what happens when a space is XORed with a character in [a-zA-Z].</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ciphertext #1:</span><br><span class="line">315c4eeaa8b5f8aaf9174145bf43e1784b8fa00dc71d885a804e5ee9fa40b16349c146fb778cdf2d3aff021dfff5b403b510d0d0455468aeb98622b137dae857553ccd8883a7bc37520e06e515d22c954eba5025b8cc57ee59418ce7dc6bc41556bdb36bbca3e8774301fbcaa3b83b220809560987815f65286764703de0f3d524400a19b159610b11ef3e</span><br><span class="line"></span><br><span class="line">ciphertext #2:</span><br><span class="line">234c02ecbbfbafa3ed18510abd11fa724fcda2018a1a8342cf064bbde548b12b07df44ba7191d9606ef4081ffde5ad46a5069d9f7f543bedb9c861bf29c7e205132eda9382b0bc2c5c4b45f919cf3a9f1cb74151f6d551f4480c82b2cb24cc5b028aa76eb7b4ab24171ab3cdadb8356f</span><br><span class="line"></span><br><span class="line">ciphertext #3:</span><br><span class="line">32510ba9a7b2bba9b8005d43a304b5714cc0bb0c8a34884dd91304b8ad40b62b07df44ba6e9d8a2368e51d04e0e7b207b70b9b8261112bacb6c866a232dfe257527dc29398f5f3251a0d47e503c66e935de81230b59b7afb5f41afa8d661cb</span><br><span class="line"></span><br><span class="line">ciphertext #4:</span><br><span class="line">32510ba9aab2a8a4fd06414fb517b5605cc0aa0dc91a8908c2064ba8ad5ea06a029056f47a8ad3306ef5021eafe1ac01a81197847a5c68a1b78769a37bc8f4575432c198ccb4ef63590256e305cd3a9544ee4160ead45aef520489e7da7d835402bca670bda8eb775200b8dabbba246b130f040d8ec6447e2c767f3d30ed81ea2e4c1404e1315a1010e7229be6636aaa</span><br><span class="line"></span><br><span class="line">ciphertext #5:</span><br><span class="line">3f561ba9adb4b6ebec54424ba317b564418fac0dd35f8c08d31a1fe9e24fe56808c213f17c81d9607cee021dafe1e001b21ade877a5e68bea88d61b93ac5ee0d562e8e9582f5ef375f0a4ae20ed86e935de81230b59b73fb4302cd95d770c65b40aaa065f2a5e33a5a0bb5dcaba43722130f042f8ec85b7c2070</span><br><span class="line"></span><br><span class="line">ciphertext #6:</span><br><span class="line">32510bfbacfbb9befd54415da243e1695ecabd58c519cd4bd2061bbde24eb76a19d84aba34d8de287be84d07e7e9a30ee714979c7e1123a8bd9822a33ecaf512472e8e8f8db3f9635c1949e640c621854eba0d79eccf52ff111284b4cc61d11902aebc66f2b2e436434eacc0aba938220b084800c2ca4e693522643573b2c4ce35050b0cf774201f0fe52ac9f26d71b6cf61a711cc229f77ace7aa88a2f19983122b11be87a59c355d25f8e4</span><br><span class="line"></span><br><span class="line">ciphertext #7:</span><br><span class="line">32510bfbacfbb9befd54415da243e1695ecabd58c519cd4bd90f1fa6ea5ba47b01c909ba7696cf606ef40c04afe1ac0aa8148dd066592ded9f8774b529c7ea125d298e8883f5e9305f4b44f915cb2bd05af51373fd9b4af511039fa2d96f83414aaaf261bda2e97b170fb5cce2a53e675c154c0d9681596934777e2275b381ce2e40582afe67650b13e72287ff2270abcf73bb028932836fbdecfecee0a3b894473c1bbeb6b4913a536ce4f9b13f1efff71ea313c8661dd9a4ce</span><br><span class="line"></span><br><span class="line">ciphertext #8:</span><br><span class="line">315c4eeaa8b5f8bffd11155ea506b56041c6a00c8a08854dd21a4bbde54ce56801d943ba708b8a3574f40c00fff9e00fa1439fd0654327a3bfc860b92f89ee04132ecb9298f5fd2d5e4b45e40ecc3b9d59e9417df7c95bba410e9aa2ca24c5474da2f276baa3ac325918b2daada43d6712150441c2e04f6565517f317da9d3</span><br><span class="line"></span><br><span class="line">ciphertext #9:</span><br><span class="line">271946f9bbb2aeadec111841a81abc300ecaa01bd8069d5cc91005e9fe4aad6e04d513e96d99de2569bc5e50eeeca709b50a8a987f4264edb6896fb537d0a716132ddc938fb0f836480e06ed0fcd6e9759f40462f9cf57f4564186a2c1778f1543efa270bda5e933421cbe88a4a52222190f471e9bd15f652b653b7071aec59a2705081ffe72651d08f822c9ed6d76e48b63ab15d0208573a7eef027</span><br><span class="line"></span><br><span class="line">ciphertext #10:</span><br><span class="line">466d06ece998b7a2fb1d464fed2ced7641ddaa3cc31c9941cf110abbf409ed39598005b3399ccfafb61d0315fca0a314be138a9f32503bedac8067f03adbf3575c3b8edc9ba7f537530541ab0f9f3cd04ff50d66f1d559ba520e89a2cb2a83</span><br><span class="line"></span><br><span class="line">target ciphertext (decrypt this one): </span><br><span class="line">32510ba9babebbbefd001547a810e67149caee11d945cd7fc81a05e9f85aac650e9052ba6a8cd8257bf14d13e6f0a803b54fde9e77472dbff89d71b57bddef121336cb85ccb8f3315f4b52e301d16e9f52f904</span><br></pre></td></tr></table></figure><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>该题目提供了十条使用同一密钥(有意义的英文语句)加密后的密文结果,要求根据所给的密文解密最终的target ciphertext.由提示,空格space与大写字母异或结果为小写字母,与小写字母异或结果为大写字母.而任意两个字母异或的结果不在字母范围内.又由于对于使用同一密钥进行异或加密的两对密文,其进行异或的结果等于对应明文进行异或的结果,如果结果的某个位置出现字母,则说明对应的两个明文位置的其中之一可能为空格.故对十一条密文进行两两异或,对于第一条密文,寻找可能为空格的位置,将该位置与其余密文对应位置的字符进行异或,设定阈值为6,当结果中有超过该阈值数量的字母时,可以确定该位置明文为空格,从而确定该位置的密钥.获取足够多密钥信息后,可以对目标密文进行解密.得到的结果有部分未还原部分,根据常识还原出最终明文,并根据结果还原密钥.代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strxor</span><span class="params">(a, b)</span>:</span> </span><br><span class="line">    <span class="string">"""xor two strings of different lengths"""</span>  </span><br><span class="line">    <span class="keyword">if</span> len(a) &gt; len(b):  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join([chr(ord(x) ^ ord(y)) <span class="keyword">for</span> (x, y) <span class="keyword">in</span> zip(a[:len(b)], b)])  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join([chr(ord(x) ^ ord(y)) <span class="keyword">for</span> (x, y) <span class="keyword">in</span> zip(a, b[:len(a)])])   </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">letter_position</span><span class="params">(s)</span>:</span> </span><br><span class="line">    <span class="string">""" Return the position of letters in the given string """</span>  </span><br><span class="line">    position=[]</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> range(len(s)):  </span><br><span class="line">        <span class="keyword">if</span> (s[idx]&gt;=<span class="string">'A'</span> <span class="keyword">and</span> s[idx]&lt;=<span class="string">'Z'</span>) <span class="keyword">or</span> (s[idx]&gt;=<span class="string">'a'</span> <span class="keyword">and</span> s[idx]&lt;=<span class="string">'z'</span>):  </span><br><span class="line">            position.append(idx)  </span><br><span class="line">    <span class="keyword">return</span> position  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_space</span><span class="params">(cipher)</span>:</span></span><br><span class="line">    <span class="string">"""Find the position of space"""</span></span><br><span class="line">    space_position=&#123;&#125;</span><br><span class="line">    space_possible=&#123;&#125; </span><br><span class="line">    <span class="comment"># 进行两两异或,得到每一条消息对应的空格的可能位置 </span></span><br><span class="line">    <span class="keyword">for</span> cipher_idx_1 <span class="keyword">in</span> range(NUM_CIPHER):  </span><br><span class="line">        space_xor=[]  </span><br><span class="line">        <span class="keyword">for</span> cipher_idx_2 <span class="keyword">in</span> range(NUM_CIPHER):   </span><br><span class="line">            plain_xor=strxor(cipher[cipher_idx_1].decode(<span class="string">'hex'</span>),cipher[cipher_idx_2].decode(<span class="string">'hex'</span>))</span><br><span class="line">            <span class="keyword">if</span> cipher_idx_2!=cipher_idx_1:  </span><br><span class="line">                space_xor.append(letter_position(plain_xor)) <span class="comment"># record the possible value of space </span></span><br><span class="line">        space_possible[cipher_idx_1]=space_xor</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> cipher_idx_1 <span class="keyword">in</span> range(NUM_CIPHER):  </span><br><span class="line">        spa=[]  </span><br><span class="line">        <span class="keyword">for</span> position <span class="keyword">in</span> range(KEY_SIZE):  </span><br><span class="line">            count=<span class="number">0</span> </span><br><span class="line">            <span class="keyword">for</span> cipher_idx_2 <span class="keyword">in</span> range(NUM_CIPHER<span class="number">-1</span>):  </span><br><span class="line">                <span class="keyword">if</span> position <span class="keyword">in</span> space_possible[cipher_idx_1][cipher_idx_2]:  </span><br><span class="line">                    count+=<span class="number">1</span>  </span><br><span class="line">            <span class="keyword">if</span> count&gt;THRESHOLD_VALUE: <span class="comment"># if possible position value appear more than THRESHOLD_VALUE times,</span></span><br><span class="line">                                      <span class="comment"># we consider it as a space position</span></span><br><span class="line">                spa.append(position)</span><br><span class="line">        space_position[cipher_idx_1]=spa  </span><br><span class="line">    <span class="keyword">return</span> space_position</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_key</span><span class="params">(cipher)</span>:</span></span><br><span class="line">    key=[<span class="number">0</span>]*KEY_SIZE</span><br><span class="line">    space=find_space(cipher)  </span><br><span class="line">    <span class="keyword">for</span> cipher_idx_1 <span class="keyword">in</span> range(NUM_CIPHER):  </span><br><span class="line">        <span class="keyword">for</span> position <span class="keyword">in</span> range(len(space[cipher_idx_1])):  </span><br><span class="line">            idx=space[cipher_idx_1][position]*<span class="number">2</span> <span class="comment"># ciphertext is hex-encoded, so its scale times two</span></span><br><span class="line">            key[space[cipher_idx_1][position]]=ord((ciphertexts[cipher_idx_1][idx]+ciphertexts[cipher_idx_1][idx+<span class="number">1</span>]).decode(<span class="string">'hex'</span>))^ord(<span class="string">' '</span>) <span class="comment">#derive key  </span></span><br><span class="line">    key_str=<span class="string">""</span> </span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> key:  </span><br><span class="line">        key_str+=chr(k)</span><br><span class="line">    <span class="keyword">return</span> key_str   </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    ciphertexts=[  </span><br><span class="line">    <span class="string">"315c4eeaa8b5f8aaf9174145bf43e1784b8fa00dc71d885a804e5ee9fa40b16349c146fb778cdf2d3aff021dfff5b403b510d0d0455468aeb98622b137dae857553ccd8883a7bc37520e06e515d22c954eba5025b8cc57ee59418ce7dc6bc41556bdb36bbca3e8774301fbcaa3b83b220809560987815f65286764703de0f3d524400a19b159610b11ef3e"</span>,  </span><br><span class="line">    <span class="string">"234c02ecbbfbafa3ed18510abd11fa724fcda2018a1a8342cf064bbde548b12b07df44ba7191d9606ef4081ffde5ad46a5069d9f7f543bedb9c861bf29c7e205132eda9382b0bc2c5c4b45f919cf3a9f1cb74151f6d551f4480c82b2cb24cc5b028aa76eb7b4ab24171ab3cdadb8356f"</span>,  </span><br><span class="line">    <span class="string">"32510ba9a7b2bba9b8005d43a304b5714cc0bb0c8a34884dd91304b8ad40b62b07df44ba6e9d8a2368e51d04e0e7b207b70b9b8261112bacb6c866a232dfe257527dc29398f5f3251a0d47e503c66e935de81230b59b7afb5f41afa8d661cb"</span>,  </span><br><span class="line">    <span class="string">"32510ba9aab2a8a4fd06414fb517b5605cc0aa0dc91a8908c2064ba8ad5ea06a029056f47a8ad3306ef5021eafe1ac01a81197847a5c68a1b78769a37bc8f4575432c198ccb4ef63590256e305cd3a9544ee4160ead45aef520489e7da7d835402bca670bda8eb775200b8dabbba246b130f040d8ec6447e2c767f3d30ed81ea2e4c1404e1315a1010e7229be6636aaa"</span>,  </span><br><span class="line">    <span class="string">"3f561ba9adb4b6ebec54424ba317b564418fac0dd35f8c08d31a1fe9e24fe56808c213f17c81d9607cee021dafe1e001b21ade877a5e68bea88d61b93ac5ee0d562e8e9582f5ef375f0a4ae20ed86e935de81230b59b73fb4302cd95d770c65b40aaa065f2a5e33a5a0bb5dcaba43722130f042f8ec85b7c2070"</span>,  </span><br><span class="line">    <span class="string">"32510bfbacfbb9befd54415da243e1695ecabd58c519cd4bd2061bbde24eb76a19d84aba34d8de287be84d07e7e9a30ee714979c7e1123a8bd9822a33ecaf512472e8e8f8db3f9635c1949e640c621854eba0d79eccf52ff111284b4cc61d11902aebc66f2b2e436434eacc0aba938220b084800c2ca4e693522643573b2c4ce35050b0cf774201f0fe52ac9f26d71b6cf61a711cc229f77ace7aa88a2f19983122b11be87a59c355d25f8e4"</span>,  </span><br><span class="line">    <span class="string">"32510bfbacfbb9befd54415da243e1695ecabd58c519cd4bd90f1fa6ea5ba47b01c909ba7696cf606ef40c04afe1ac0aa8148dd066592ded9f8774b529c7ea125d298e8883f5e9305f4b44f915cb2bd05af51373fd9b4af511039fa2d96f83414aaaf261bda2e97b170fb5cce2a53e675c154c0d9681596934777e2275b381ce2e40582afe67650b13e72287ff2270abcf73bb028932836fbdecfecee0a3b894473c1bbeb6b4913a536ce4f9b13f1efff71ea313c8661dd9a4ce"</span>,  </span><br><span class="line">    <span class="string">"315c4eeaa8b5f8bffd11155ea506b56041c6a00c8a08854dd21a4bbde54ce56801d943ba708b8a3574f40c00fff9e00fa1439fd0654327a3bfc860b92f89ee04132ecb9298f5fd2d5e4b45e40ecc3b9d59e9417df7c95bba410e9aa2ca24c5474da2f276baa3ac325918b2daada43d6712150441c2e04f6565517f317da9d3"</span>,  </span><br><span class="line">    <span class="string">"271946f9bbb2aeadec111841a81abc300ecaa01bd8069d5cc91005e9fe4aad6e04d513e96d99de2569bc5e50eeeca709b50a8a987f4264edb6896fb537d0a716132ddc938fb0f836480e06ed0fcd6e9759f40462f9cf57f4564186a2c1778f1543efa270bda5e933421cbe88a4a52222190f471e9bd15f652b653b7071aec59a2705081ffe72651d08f822c9ed6d76e48b63ab15d0208573a7eef027"</span>,  </span><br><span class="line">    <span class="string">"466d06ece998b7a2fb1d464fed2ced7641ddaa3cc31c9941cf110abbf409ed39598005b3399ccfafb61d0315fca0a314be138a9f32503bedac8067f03adbf3575c3b8edc9ba7f537530541ab0f9f3cd04ff50d66f1d559ba520e89a2cb2a83"</span>,  </span><br><span class="line">    <span class="string">"32510ba9babebbbefd001547a810e67149caee11d945cd7fc81a05e9f85aac650e9052ba6a8cd8257bf14d13e6f0a803b54fde9e77472dbff89d71b57bddef121336cb85ccb8f3315f4b52e301d16e9f52f904"</span>  </span><br><span class="line">    ]  </span><br><span class="line"></span><br><span class="line">    KEY_SIZE=<span class="number">100</span></span><br><span class="line">    NUM_CIPHER=len(ciphertexts)</span><br><span class="line">    <span class="comment"># 设定阈值</span></span><br><span class="line">    THRESHOLD_VALUE=<span class="number">6</span></span><br><span class="line">    result=<span class="string">""</span></span><br><span class="line">    key=calculate_key(ciphertexts)</span><br><span class="line">    <span class="keyword">print</span> key</span><br><span class="line">    <span class="keyword">for</span> letter <span class="keyword">in</span> strxor(ciphertexts[<span class="number">10</span>].decode(<span class="string">'hex'</span>),key): <span class="comment"># decrypt the target cipher</span></span><br><span class="line">        <span class="keyword">if</span> (letter&gt;=<span class="string">'a'</span> <span class="keyword">and</span> letter&lt;=<span class="string">'z'</span>) <span class="keyword">or</span> (letter&gt;=<span class="string">'A'</span> <span class="keyword">and</span> letter&lt;=<span class="string">'Z'</span>):  </span><br><span class="line">            result+=letter  </span><br><span class="line">        <span class="keyword">elif</span> letter==<span class="string">' '</span>:  </span><br><span class="line">            result+=letter </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            result+=<span class="string">'0'</span>  </span><br><span class="line">    <span class="keyword">print</span> result</span><br><span class="line">    result = binascii.a2b_hex(<span class="string">b'The secret message is When using a stream cipher never use the key more than once'</span>)</span><br><span class="line">    key = strxor(result, ciphertexts[<span class="number">10</span>].decode(<span class="string">'hex'</span>))</span><br><span class="line">    <span class="keyword">print</span> key</span><br></pre></td></tr></table></figure><h2 id="0x03-Vigenere-like-cipher"><a href="#0x03-Vigenere-like-cipher" class="headerlink" title="0x03 Vigenere-like cipher"></a>0x03 Vigenere-like cipher</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>Write a program that allows you to “crack” ciphertexts generated using a Vigenere-like cipher, where byte-wise XOR is used instead of addition modulo 26.</p><p>Specifically, the ciphertext</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F96DE8C227A259C87EE1DA2AED57C93FE5DA36ED4EC87EF2C63AAE5B9A7EFFD673BE4ACF7BE8923CAB1ECE7AF2DA3DA44FCF7AE29235A24C963FF0DF3CA3599A70E5DA36BF1ECE77F8DC34BE129A6CF4D126BF5B9A7CFEDF3EB850D37CF0C63AA2509A76FF9227A55B9A6FE3D720A850D97AB1DD35ED5FCE6BF0D138A84CC931B1F121B44ECE70F6C032BD56C33FF9D320ED5CDF7AFF9226BE5BDE3FF7DD21ED56CF71F5C036A94D963FF8D473A351CE3FE5DA3CB84DDB71F5C17FED51DC3FE8D732BF4D963FF3C727ED4AC87EF5DB27A451D47EFD9230BF47CA6BFEC12ABE4ADF72E29224A84CDF3FF5D720A459D47AF59232A35A9A7AE7D33FB85FCE7AF5923AA31EDB3FF7D33ABF52C33FF0D673A551D93FFCD33DA35BC831B1F43CBF1EDF67F0DF23A15B963FE5DA36ED68D378F4DC36BF5B9A7AFFD121B44ECE76FEDC73BE5DD27AFCD773BA5FC93FE5DA3CB859D26BB1C63CED5CDF3FE2D730B84CDF3FF7DD21ED5ADF7CF0D636BE1EDB79E5D721ED57CE3FE6D320ED57D469F4DC27A85A963FF3C727ED49DF3FFFDD24ED55D470E69E73AC50DE3FE5DA3ABE1EDF67F4C030A44DDF3FF5D73EA250C96BE3D327A84D963FE5DA32B91ED36BB1D132A31ED87AB1D021A255DF71B1C436BF479A7AF0C13AA14794</span><br></pre></td></tr></table></figure><p>was generated by encrypting English-language text using the following C program:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_LENGTH 2 <span class="comment">// Can be anything from 1 to 13</span></span></span><br><span class="line"> </span><br><span class="line">main()&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> ch;</span><br><span class="line">  FILE *fpIn, *fpOut;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> key[KEY_LENGTH] = &#123;<span class="number">0x00</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line">  <span class="comment">/* of course, I did not use the all-0s key to encrypt */</span></span><br><span class="line"> </span><br><span class="line">  fpIn = fopen(<span class="string">"ptext.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">  fpOut = fopen(<span class="string">"ctext.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line"> </span><br><span class="line">  i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">fscanf</span>(fpIn, <span class="string">"%c"</span>, &amp;ch) != EOF) &#123;</span><br><span class="line">    <span class="comment">/* avoid encrypting newline characters */</span>  </span><br><span class="line">    <span class="comment">/* In a "real-world" implementation of the Vigenere cipher, </span></span><br><span class="line"><span class="comment">       every ASCII character in the plaintext would be encrypted.</span></span><br><span class="line"><span class="comment">       However, I want to avoid encrypting newlines here because </span></span><br><span class="line"><span class="comment">       it makes recovering the plaintext slightly more difficult... */</span></span><br><span class="line">    <span class="comment">/* ...and my goal is not to create "production-quality" code =) */</span></span><br><span class="line">    <span class="keyword">if</span> (ch!=<span class="string">'\n'</span>) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(fpOut, <span class="string">"%02X"</span>, ch ^ key[i % KEY_LENGTH]); <span class="comment">// ^ is logical XOR    </span></span><br><span class="line">      i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  fclose(fpIn);</span><br><span class="line">  fclose(fpOut);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(Of course, when encrypting I used a random key length and chose each byte of the key at random.) The plaintext contains upper- and lower-case letters, punctuation, and spaces, but no numbers.<br>Recovered the original plaintext.</p><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>该题目的本质依然为密钥重复使用问题,只是披上了维吉尼亚的外衣.假设加密者使用的密钥为v-key,长度为length,密文为字符串ciphertext.则字符串<code>cipherset0 = ciphertext[0+k*length]</code>是被v-key[0]加密的内容,字符串<code>cipherset1 = ciphertext[1+k*length]</code>是被v-key<a href="https://blank-vax.github.io/2019/11/12/Cryptopals%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%28%E4%B8%80%29/#more">1</a>加密的内容,依次类推.按照这种方法,可以将密文ciphertext分割成length份,每份都被密钥v-key的同一位解密还原明文.对每个加密密钥v-key[index],穷举其所有可能的值,并与对应的cipherset里的内容进行异或解密,找到能将该cipherset所有内容解为可见字符的所有可能密钥值.通过上述方法首先枚举得到密钥长度length,然后改变判定为明文的条件(假设明文只有字母、数字、空格和符号),再进行穷举,最终还原出密钥并进行解密.<br>爆破密钥长度代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findindexkey</span><span class="params">(subarr, visiable_chars)</span>:</span><span class="comment"># 该函数可以找出将密文subarr解密成可见字符的所有可能值</span></span><br><span class="line">    test_keys=[]<span class="comment"># 用于测试密钥</span></span><br><span class="line">    ans_keys=[] <span class="comment"># 用于结果的返回</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0x00</span>,<span class="number">0xFF</span>):<span class="comment"># 枚举密钥里所有的值</span></span><br><span class="line">        test_keys.append(x)</span><br><span class="line">        ans_keys.append(x)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> test_keys:</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> subarr:</span><br><span class="line">            <span class="keyword">if</span> chr(s^i) <span class="keyword">not</span> <span class="keyword">in</span> visiable_chars:<span class="comment"># 如果解密后明文不是可见字符，说明i不是密钥</span></span><br><span class="line">                ans_keys.remove(i)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> ans_keys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_length</span><span class="params">()</span>:</span></span><br><span class="line">    test_chars = string.ascii_letters+string.digits+<span class="string">','</span>+<span class="string">'.'</span>+<span class="string">' '</span></span><br><span class="line"></span><br><span class="line">    ciphertext = <span class="string">'F96DE8C227A259C87EE1DA2AED57C93FE5DA36ED4EC87EF2C63AAE5B9A7EFFD673BE4ACF7BE8923CAB1ECE7AF2DA3DA44FCF7AE29235A24C963FF0DF3CA3599A70E5DA36BF1ECE77F8DC34BE129A6CF4D126BF5B9A7CFEDF3EB850D37CF0C63AA2509A76FF9227A55B9A6FE3D720A850D97AB1DD35ED5FCE6BF0D138A84CC931B1F121B44ECE70F6C032BD56C33FF9D320ED5CDF7AFF9226BE5BDE3FF7DD21ED56CF71F5C036A94D963FF8D473A351CE3FE5DA3CB84DDB71F5C17FED51DC3FE8D732BF4D963FF3C727ED4AC87EF5DB27A451D47EFD9230BF47CA6BFEC12ABE4ADF72E29224A84CDF3FF5D720A459D47AF59232A35A9A7AE7D33FB85FCE7AF5923AA31EDB3FF7D33ABF52C33FF0D673A551D93FFCD33DA35BC831B1F43CBF1EDF67F0DF23A15B963FE5DA36ED68D378F4DC36BF5B9A7AFFD121B44ECE76FEDC73BE5DD27AFCD773BA5FC93FE5DA3CB859D26BB1C63CED5CDF3FE2D730B84CDF3FF7DD21ED5ADF7CF0D636BE1EDB79E5D721ED57CE3FE6D320ED57D469F4DC27A85A963FF3C727ED49DF3FFFDD24ED55D470E69E73AC50DE3FE5DA3ABE1EDF67F4C030A44DDF3FF5D73EA250C96BE3D327A84D963FE5DA32B91ED36BB1D132A31ED87AB1D021A255DF71B1C436BF479A7AF0C13AA14794'</span></span><br><span class="line">    ci_array = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>,len(ciphertext),<span class="number">2</span>):</span><br><span class="line">        ci_array.append(int(ciphertext[x:<span class="number">2</span>+x],<span class="number">16</span>))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> keylen <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">14</span>):</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>,keylen):</span><br><span class="line">            subarr = ci_array[index::keylen]<span class="comment"># 每隔keylen长度提取密文的内容,其均被同一密钥异或加密</span></span><br><span class="line">            ans_keys = findindexkey(subarr, test_chars)<span class="comment"># 找出密钥中第index个的可能的值</span></span><br><span class="line">            print(<span class="string">'keylen='</span>,keylen,<span class="string">'index='</span>,index,<span class="string">'keys='</span>,ans_keys)</span><br><span class="line">            <span class="keyword">if</span> ans_keys:</span><br><span class="line">                ch=[]</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> ans_keys:</span><br><span class="line">                    ch.append(chr(x^subarr[<span class="number">0</span>]))</span><br><span class="line">                print(ch)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#运行到这里，观察输出可以发现，密钥长度为7时有解</span></span><br><span class="line">    print(<span class="string">'###############'</span>)</span><br></pre></td></tr></table></figure><p>输出结果如下图:</p><p><img src="http://static.zybuluo.com/B1ank/kbxi8x4zil8v21d4dwtkal78/4.png" alt="4.png-69.5kB"></p><p>确定密钥长度为7后,直接进行穷举破解,得到最终密钥.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vigenerekeys=[]</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">7</span>):</span><br><span class="line">        subarr=ci_array[index::<span class="number">7</span>]</span><br><span class="line">        vigenerekeys.append(findindexkey(subarr, test_chars))</span><br><span class="line">    print(vigenerekeys)</span><br><span class="line"><span class="comment"># 最终密钥为[[186], [31], [145], [178], [83], [205], [62]].</span></span><br></pre></td></tr></table></figure><p>最后使用得到的唯一密钥进行解密即可.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plaintext = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(ci_array)):</span><br><span class="line">        plaintext = plaintext + chr(ci_array[i]^vigenerekeys[i%<span class="number">7</span>][<span class="number">0</span>])</span><br><span class="line">    print(plaintext)</span><br></pre></td></tr></table></figure><p>解密结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cryptography is the practice and study of techniques for, among other things, secure communication in the presence of attackers. Cryptography has been used for hundreds, if not thousands, of years, but traditional cryptosystems were designed and evaluated in a fairly ad hoc manner. For example, the Vigenere encryption scheme was thought to be secure for decades after it was invented, but we now know, and this exercise demonstrates, that it can be broken very easily.</span><br></pre></td></tr></table></figure><p>当然此破解过程也可以使用字母频率分析的方法来完成.</p><h2 id="0x04-MTC3-Cracking-SHA1-Hashed-Passwords"><a href="#0x04-MTC3-Cracking-SHA1-Hashed-Passwords" class="headerlink" title="0x04 MTC3 Cracking SHA1-Hashed Passwords"></a>0x04 MTC3 Cracking SHA1-Hashed Passwords</h2><h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="MTC3%20Cracking%20SHA1-Hashed%20Passwords">Keyboard-Attack</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>The Secure Hash Algorithmus 1 has been standardized by the National Institute of Standards and Technology in 1995 and is besides MD5 the most commonly used hash algorithm in practice. An example for its usage is password-based authentification. In that case, the server does not store the user password in plain text but instead the SHA1 hash value of it. Once the user enters his password and after its received at the server, its hash value is computed and compared to the value stored on the server in order to verify its correctness.</p><p>A vulnerability of a surveillance system’s webserver leaked the SHA1 hash value of the password of the administrator account. The password’s hash value is</p><p>67ae1a64661ac8b4494666f58c4822408dd0a3e4</p><p>Furthermore, the keyboard of the login terminal shows clear signs of the entered password since after a successful login navigation in the software is only done via arrow keys. What is the password?</p><p>Remark: Note the German keyboard layout!</p><p><img src="http://static.zybuluo.com/B1ank/2sq85zttc62cjawi76ahz57i/5.png" alt="5.png-317.4kB"></p><h3 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h3><p>该题目是一个简单的键盘还原问题,可以直接使用爆破的方法解决问题,注意需要考虑到时间限制.根据键盘上的按键分布,可以看出右边数字键只有2468,很有可能是当作上下左右的功能,对剩余按键按照每个键出现一次的原则进行暴力破解,可以得出最终键盘密码.脚本如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过爆破的方法得出符合要求的密码</span></span><br><span class="line"><span class="comment"># 最后完成整个程序需要的时间为9s</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> SHA</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">starttime = datetime.datetime.now()</span><br><span class="line">hash1=<span class="string">"67ae1a64661ac8b4494666f58c4822408dd0a3e4"</span></span><br><span class="line">str2=[[<span class="string">'Q'</span>, <span class="string">'q'</span>],[ <span class="string">'W'</span>, <span class="string">'w'</span>],[ <span class="string">'%'</span>, <span class="string">'5'</span>], [<span class="string">'8'</span>, <span class="string">'('</span>],[ <span class="string">'='</span>, <span class="string">'0'</span>], [<span class="string">'I'</span>, <span class="string">'i'</span>], [<span class="string">'*'</span>, <span class="string">'+'</span>], [<span class="string">'n'</span>, <span class="string">'N'</span>]]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sha_encrypt</span><span class="params">(str)</span>:</span></span><br><span class="line">    sha = hashlib.sha1(str)</span><br><span class="line">    encrypts = sha.hexdigest()</span><br><span class="line">    <span class="keyword">return</span> encrypts</span><br><span class="line">st3=<span class="string">"0"</span>*<span class="number">8</span></span><br><span class="line">str4=<span class="string">""</span></span><br><span class="line">str3=list(st3)</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">2</span>):</span><br><span class="line">    str3[<span class="number">0</span>]=str2[<span class="number">0</span>][a]</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">2</span>):</span><br><span class="line">        str3[<span class="number">1</span>]=str2[<span class="number">1</span>][b]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">2</span>):</span><br><span class="line">            str3[<span class="number">2</span>]=str2[<span class="number">2</span>][c]</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">2</span>):</span><br><span class="line">                str3[<span class="number">3</span>] = str2[<span class="number">3</span>][d]</span><br><span class="line">                <span class="keyword">for</span> e <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">2</span>):</span><br><span class="line">                    str3[<span class="number">4</span>] = str2[<span class="number">4</span>][e]</span><br><span class="line">                    <span class="keyword">for</span> f <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">2</span>):</span><br><span class="line">                        str3[<span class="number">5</span>] = str2[<span class="number">5</span>][f]</span><br><span class="line">                        <span class="keyword">for</span> g <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">2</span>):</span><br><span class="line">                            str3[<span class="number">6</span>] = str2[<span class="number">6</span>][g]</span><br><span class="line">                            <span class="keyword">for</span> h <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">2</span>):</span><br><span class="line">                                str3[<span class="number">7</span>] = str2[<span class="number">7</span>][h]</span><br><span class="line">                                newS=<span class="string">""</span>.join(str3)</span><br><span class="line">                                <span class="keyword">for</span> i <span class="keyword">in</span> itertools.permutations(newS, <span class="number">8</span>):</span><br><span class="line">                                    str4 = sha_encrypt(<span class="string">""</span>.join(i))</span><br><span class="line">                                    <span class="keyword">if</span> str4==hash1:</span><br><span class="line">                                        <span class="keyword">print</span> <span class="string">""</span>.join(i)</span><br><span class="line">                                        endtime = datetime.datetime.now()</span><br><span class="line">                                        <span class="keyword">print</span> (endtime - starttime).seconds</span><br><span class="line">                                        exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>该程序破解用时11s,结果如下图:</p><p><img src="http://static.zybuluo.com/B1ank/ywhvje3lpj2gvbgbz74fgrtz/6.png" alt="6.png-18.7kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;该系列主要用于记录密码学实验过程中遇到的题目及相关分析方法.&lt;/p&gt;
&lt;h2 id=&quot;0x01-Cr
      
    
    </summary>
    
      <category term="Problem Solving Report" scheme="https://blank-vax.github.io/categories/Problem-Solving-Report/"/>
    
    
      <category term="Vigenere" scheme="https://blank-vax.github.io/tags/Vigenere/"/>
    
      <category term="Keyboard-Attack" scheme="https://blank-vax.github.io/tags/Keyboard-Attack/"/>
    
  </entry>
  
  <entry>
    <title>终端安全检测及防御技术</title>
    <link href="https://blank-vax.github.io/2020/11/09/%E7%BB%88%E7%AB%AF%E5%AE%89%E5%85%A8%E6%A3%80%E6%B5%8B%E5%8F%8A%E9%98%B2%E5%BE%A1%E6%8A%80%E6%9C%AF/"/>
    <id>https://blank-vax.github.io/2020/11/09/终端安全检测及防御技术/</id>
    <published>2020-11-09T02:39:34.455Z</published>
    <updated>2020-07-06T02:32:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="终端安全风险"><a href="#终端安全风险" class="headerlink" title="终端安全风险"></a>终端安全风险</h2><p>黑客可以利用僵尸网络展开更多的危害行为，如APT攻击最常采用的跳板就是僵尸网络。黑客利用僵尸网络来实现渗透、监视、窃取敏感数据等目的，造成严重危害。</p><p>僵尸网络主要危害有：</p><ul><li>未知风险</li><li>高级持续威胁</li><li>本地渗透扩散</li><li>敏感信息窃取</li><li>脆弱信息收集</li></ul><h2 id="终端上网安全可视可控技术"><a href="#终端上网安全可视可控技术" class="headerlink" title="终端上网安全可视可控技术"></a>终端上网安全可视可控技术</h2><p>基于七层应用的深度数据包检测可实现终端安全可控。AF中实现了可视化的应用管控与全面的应用安全。可视化应用管控中包含<strong>应用识别</strong>与<strong>流量管控</strong>两大模块。</p><h3 id="应用控制策略"><a href="#应用控制策略" class="headerlink" title="应用控制策略"></a>应用控制策略</h3><p>应用控制策略可对应用/服务的访问做双向控制，AF存在一条默认拒绝所有应用/服务的控制策略。</p><ul><li>基于应用的控制策略：通过匹配数据包特征来进行过滤动作，需要一定数量的包通行后才能判断应用类型，然后进行拦截动作的判断。</li><li>基于服务的控制策略：通过匹配数据包的五元组（源/目的IP地址+源/目的端口号+协议类型）来进行过滤动作，对任何包可以立即进行拦截动作判断。</li></ul><h3 id="Web过滤"><a href="#Web过滤" class="headerlink" title="Web过滤"></a>Web过滤</h3><p>Web过滤指针对符合设定条件的访问网页数据进行过滤，包括URL过滤与文件过滤，同时可以针对HTTPS URL进行过滤。</p><h2 id="网关杀毒技术"><a href="#网关杀毒技术" class="headerlink" title="网关杀毒技术"></a>网关杀毒技术</h2><h3 id="计算机病毒"><a href="#计算机病毒" class="headerlink" title="计算机病毒"></a>计算机病毒</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>隐蔽性</li><li>破坏性</li><li>潜伏性</li><li>不可预见性</li><li>繁殖性</li><li>传染性</li></ul><h4 id="工作步骤"><a href="#工作步骤" class="headerlink" title="工作步骤"></a>工作步骤</h4><p><img src="http://static.zybuluo.com/B1ank/q220r9z8dhph5x9jbd066ox3/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92%E5%B7%A5%E4%BD%9C%E6%AD%A5%E9%AA%A4.png" alt="计算机病毒工作步骤.png-233.6kB"></p><h3 id="网关杀毒实现方式"><a href="#网关杀毒实现方式" class="headerlink" title="网关杀毒实现方式"></a>网关杀毒实现方式</h3><h4 id="代理扫描方式"><a href="#代理扫描方式" class="headerlink" title="代理扫描方式"></a>代理扫描方式</h4><p>将所有经过网关的需要进行病毒检测的数据报文透明地转交给网关自身的协议栈，通过网关自身的协议栈将文件全部缓存下来后，再送入病毒检测引擎进行病毒检测。</p><h4 id="流扫描方式"><a href="#流扫描方式" class="headerlink" title="流扫描方式"></a>流扫描方式</h4><p>依赖于状态检测技术以及协议解析技术，简单地提取文件的特征与本地签名库进行匹配。由于流扫描方式只针对部分数据进行扫描，故查准率低于代理扫描方式，属于轻量级检测技术。</p><h3 id="AF网关杀毒实现方式"><a href="#AF网关杀毒实现方式" class="headerlink" title="AF网关杀毒实现方式"></a>AF网关杀毒实现方式</h3><p><img src="http://static.zybuluo.com/B1ank/bkkhf877533ca6ulcqgasvnr/AF%E7%BD%91%E5%85%B3%E6%9D%80%E6%AF%92%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.png" alt="AF网关杀毒实现方式.png-430.3kB"></p><p>该杀毒体系具有以下特点：</p><ul><li>防火墙AF提供捕获文件能力和拦截处置能力。</li><li>SAVE提供本地无规则的检测能力。</li><li>云脑提供安全能力的更新和云端威胁情报查杀的能力。</li><li>具备威胁情报、本地引擎SAVE查杀、云沙箱能力。</li></ul><h3 id="网关杀毒配置思路"><a href="#网关杀毒配置思路" class="headerlink" title="网关杀毒配置思路"></a>网关杀毒配置思路</h3><ul><li>新建模块</li><li>选择杀毒协议</li><li>选择文件类型</li><li>新增安全策略</li></ul><h2 id="僵尸网络检测与防御技术"><a href="#僵尸网络检测与防御技术" class="headerlink" title="僵尸网络检测与防御技术"></a>僵尸网络检测与防御技术</h2><h3 id="僵尸网络"><a href="#僵尸网络" class="headerlink" title="僵尸网络"></a>僵尸网络</h3><p>僵尸网络（Botnet）是指骇客利用自己编写的分布式拒绝服务攻击程序将数万个沦陷的机器组织成一个个控制节点用来发送伪造包或垃圾数据包，使预定攻击目标瘫痪并拒绝服务。通常蠕虫病毒也可以被用来组成僵尸网络。</p><h3 id="僵尸网络感染过程"><a href="#僵尸网络感染过程" class="headerlink" title="僵尸网络感染过程"></a>僵尸网络感染过程</h3><ul><li>僵尸主控传播木马到网络中的感染终端。</li><li>主机受到感染，连接C&amp;C服务器，获取指令。</li><li>C&amp;C服务器下发指令给受感染主机，扫描网络并感染更多主机。</li><li>更多主机被感染并组成僵尸网络，连接C&amp;C服务器并获取操作指令。</li></ul><h3 id="异常流量检测"><a href="#异常流量检测" class="headerlink" title="异常流量检测"></a>异常流量检测</h3><p>通过对当前的网络层及应用层行为与安全模型进行偏离度分析，能够发现隐藏的网络异常行为，并根据行为特征确定攻击类型，发现特征匹配无法发现的攻击。</p><p>外发流量异常功能是一种启发式的DOS攻击检测手段，能够检测源IP不变的SYN Flood、UDP Flood等泛洪攻击。该功能原理为：当特定协议的外发包pps超过配置的阈值时，基于5分钟左右的抓包样本检测数据包是否为单向流量、是否有正常响应内容，得出分析结论并将发现的攻击提交日志显示。</p><h3 id="误判排除"><a href="#误判排除" class="headerlink" title="误判排除"></a>误判排除</h3><h4 id="AF僵尸网络防护排除"><a href="#AF僵尸网络防护排除" class="headerlink" title="AF僵尸网络防护排除"></a>AF僵尸网络防护排除</h4><p>AF僵尸网络防护排除方式具有以下三种：</p><ul><li>在僵尸网络功能模块下排除指定IP。</li><li>若误判由拦截规则引起，则可在【安全防护对象】-【僵尸网络规则库】找到并禁用指定规则。</li><li>可以在内置数据中心中，查询僵尸网络日志后使用【添加例外】排除。</li></ul><h4 id="DNS场景误判排除"><a href="#DNS场景误判排除" class="headerlink" title="DNS场景误判排除"></a>DNS场景误判排除</h4><p>通过蜜罐技术解决内网存在DNS服务器时，用于定位内网感染僵尸网络主机的真实IP地址。防止配置过程中忽略蜜罐设置，导致后续无法溯源的问题，策略配置界面新增DNS服务器服务界面。</p><h3 id="杀毒通知推送"><a href="#杀毒通知推送" class="headerlink" title="杀毒通知推送"></a>杀毒通知推送</h3><p>AF检测到的风险主机可以推送杀毒通知。重定向页面支持自定义，同时支持下载病毒查杀软件。</p><p>注意：杀毒通知推送设定的时间内，风险主机下载工具并查杀后也无法直接上网，需要等待指定时间，或管理员取消推送才可正常访问网站。重定向页面只对HTTP生效，HTTPS及NAT场景均不生效。</p><h2 id="勒索病毒防护"><a href="#勒索病毒防护" class="headerlink" title="勒索病毒防护"></a>勒索病毒防护</h2><h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>勒索病毒是一种新型电脑病毒，主机感染勒索病毒文件后，会自动运行勒索程序，遍历本地所有磁盘指定类型文件进行加密操作，加密后文件无法读取。随后生成勒索通知，要求受害者支付虚拟货币作为赎金。主要包含两种场景：</p><ul><li>服务器文件被加密</li><li>内网主机成片出现蓝屏现象，蓝屏代码提示<code>srv.sys驱动出现问题</code></li></ul><h3 id="防护措施"><a href="#防护措施" class="headerlink" title="防护措施"></a>防护措施</h3><ul><li>事前加固：勒索病毒风险评估，精准评估勒索病毒进入点风险，配置勒索病毒专项策略，全面防护勒索风险。</li><li>事中积极防御：通过配置的勒索病毒专项策略，全面防护勒索风险。</li><li>事后快速响应与处置：隔离识别已失陷的主机，采用专项工具进行杀毒。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;终端安全风险&quot;&gt;&lt;a href=&quot;#终端安全风险&quot; class=&quot;headerlink&quot; title=&quot;终端安全风险&quot;&gt;&lt;/a&gt;终端安全风险&lt;/h2&gt;&lt;p&gt;黑客可以利用僵尸网络展开更多的危害行为，如APT攻击最常采用的跳板就是僵尸网络。黑客利用僵尸网络来实现渗透、
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Terminal Security" scheme="https://blank-vax.github.io/tags/Terminal-Security/"/>
    
  </entry>
  
  <entry>
    <title>服务器安全检测和防御技术</title>
    <link href="https://blank-vax.github.io/2020/11/09/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%A3%80%E6%B5%8B%E5%92%8C%E9%98%B2%E5%BE%A1%E6%8A%80%E6%9C%AF/"/>
    <id>https://blank-vax.github.io/2020/11/09/服务器安全检测和防御技术/</id>
    <published>2020-11-09T02:39:34.452Z</published>
    <updated>2020-07-06T02:32:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DoS攻击检测与防御"><a href="#DoS攻击检测与防御" class="headerlink" title="DoS攻击检测与防御"></a>DoS攻击检测与防御</h2><h3 id="DoS攻击"><a href="#DoS攻击" class="headerlink" title="DoS攻击"></a>DoS攻击</h3><p>Denial of Service，是一种拒绝服务攻击，常用来使服务器或网络瘫痪。</p><p>Distributed Denial of Service，简称为DDoS攻击，是一种分布式拒绝服务攻击。</p><h3 id="DoS类型"><a href="#DoS类型" class="headerlink" title="DoS类型"></a>DoS类型</h3><ul><li>发送大量所属协议的数据包达到占据服务端带宽并堵塞线路的目的<ul><li>ICMP洪水攻击</li><li>UDP洪水攻击</li><li>SYN洪水攻击</li></ul></li><li>利用TCP三次握手特性，大量发起请求包以占用服务器资源，最终实现服务器资源耗尽<ul><li>SYN洪水攻击</li></ul></li><li>畸形数据包攻击<ul><li>PingofDeath</li><li>TearDrop</li></ul></li><li>CC攻击（主要用来攻击页面）</li><li>慢速攻击</li></ul><h3 id="SYN洪水防护"><a href="#SYN洪水防护" class="headerlink" title="SYN洪水防护"></a>SYN洪水防护</h3><h4 id="每目的IP激活阈值"><a href="#每目的IP激活阈值" class="headerlink" title="每目的IP激活阈值"></a>每目的IP激活阈值</h4><p>每目的IP激活阈值指当针对策略设置的目的IP组内某IP发起的SYN请求速率数据包超过设定值，则触发AF的SYN代理功能。</p><h4 id="每目的IP丢包阈值"><a href="#每目的IP丢包阈值" class="headerlink" title="每目的IP丢包阈值"></a>每目的IP丢包阈值</h4><p>每目的IP丢包阈值指当针对策略设置的目的IP组内某IP发起的SYN请求速率数据包超过设定值，则AF不再启用SYN代理，直接丢弃SYN包。</p><h2 id="漏洞攻击防护入侵检测与防御"><a href="#漏洞攻击防护入侵检测与防御" class="headerlink" title="漏洞攻击防护入侵检测与防御"></a>漏洞攻击防护入侵检测与防御</h2><h3 id="IDS"><a href="#IDS" class="headerlink" title="IDS"></a>IDS</h3><p>Intrusion Detection Systems，即入侵检测系统，对网络、系统的运行状况进行监视，尽可能发现各种攻击企图、攻击行为或攻击结果。通过旁路镜像模式部署，多用于被动检测。</p><h3 id="IPS"><a href="#IPS" class="headerlink" title="IPS"></a>IPS</h3><p>Intrusion Prevention Systems，即入侵防御系统，可对网络、系统的运行状况进行监视，并可发现阻止各种攻击企图、攻击行为。通过路由模式、透明模式及并联模式部署，多用于主动检测。</p><h3 id="常见漏洞攻击手段"><a href="#常见漏洞攻击手段" class="headerlink" title="常见漏洞攻击手段"></a>常见漏洞攻击手段</h3><h4 id="Worm蠕虫"><a href="#Worm蠕虫" class="headerlink" title="Worm蠕虫"></a>Worm蠕虫</h4><p><img src="http://static.zybuluo.com/B1ank/cd1w8ekz3l3d1zdqn5flqy5x/worm%E8%A0%95%E8%99%AB.png" alt="worm蠕虫.png-291.6kB"></p><h4 id="口令暴力破解"><a href="#口令暴力破解" class="headerlink" title="口令暴力破解"></a>口令暴力破解</h4><p>常见的暴力破解方法包括<strong>字典法</strong>与<strong>规则破解法</strong>。</p><ul><li>字典法：黑客通过各种手段获取一些网络用户经常使用的弱密码，集合在一起形成文本文件，并使用该文件进行口令爆破。</li><li>规则破解法：通过账户相关信息或用户个人信息进行破解。</li></ul><h3 id="漏洞攻击防护原理"><a href="#漏洞攻击防护原理" class="headerlink" title="漏洞攻击防护原理"></a>漏洞攻击防护原理</h3><p>漏洞攻击防护通过对数据包应用层里的数据内容进行威胁特征检查，并与漏洞攻击防护规则库进行比对，如果匹配则拒绝该数据包，从而实现应用层漏洞攻击的防护。</p><h3 id="误判处置"><a href="#误判处置" class="headerlink" title="误判处置"></a>误判处置</h3><ul><li>配置漏洞攻击防护规则时，在漏洞攻击防护日志中勾选”记录”。</li><li>根据数据中心的日志，查询到误判规则的漏洞ID。</li><li>【对象】-【安全防护规则库】-【安全规则库】-漏洞特征识别库中，修改相应漏洞ID的动作。</li><li>白名单添加例外。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>配置漏洞攻击防护保护客户端和服务器时，源区域为数据连接发起的区域。</li><li>漏洞攻击防护保护客户端与保护服务器中的客户端漏洞和服务器漏洞规则是不同的。</li></ul><h2 id="Web攻击检测与防御"><a href="#Web攻击检测与防御" class="headerlink" title="Web攻击检测与防御"></a>Web攻击检测与防御</h2><h3 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h3><p>Web Application Firewall，即Web应用防护，主要用于保护Web服务器不受攻击，而导致软件服务中断或被远程控制。WAF常见攻击手段包括：</p><ul><li>SQL注入</li><li>XSS攻击</li><li>网页木马</li><li>网站扫描</li><li>WEBSHELL</li><li>跨站请求伪造</li><li>系统命令注入</li><li>文件包含攻击</li><li>目录遍历攻击</li><li>信息泄漏攻击</li></ul><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>通过将SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意SQL命令的目的。</p><h4 id="GET与POST请求"><a href="#GET与POST请求" class="headerlink" title="GET与POST请求"></a>GET与POST请求</h4><p>GET请求提交的内容经过URL编码直接在URL栏中显示。</p><p>POST提交的内容不会直接显示在URL部分，而是呈现在POST包的DATA字段中。</p><h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><p>Cross Site Request Fogery，即跨站请求伪造，攻击者盗用受害用户的身份，以其名义发送恶意请求，对服务器来说这个请求是合法的，但完成了攻击者所期望的操作，如以受害用户的名义发送邮件和信息，盗取账号，添加系统管理员等非法操作。</p><h3 id="误判处置-1"><a href="#误判处置-1" class="headerlink" title="误判处置"></a>误判处置</h3><ul><li><p>在【策略】-【安全策略】-【安全防护策略】-【高级设置】中新增URL参数排除后，Web应用防护的网站攻击检测将跳过这些参数的检查。主要用于正常业务下某些请求参数因携带特征串而被检测为攻击的情况，可以只针对这类参数进行排除。</p></li><li><p>在【内置数据中心】-【日志查询】-【WEB应用防护】中查询日志，找出误判日志然后点击日志后面的”添加例外”。</p></li></ul><h2 id="联动封锁技术"><a href="#联动封锁技术" class="headerlink" title="联动封锁技术"></a>联动封锁技术</h2><h3 id="联动封锁类型"><a href="#联动封锁类型" class="headerlink" title="联动封锁类型"></a>联动封锁类型</h3><p>高危行为联动封锁：仅封锁具有高危行为特征的IP，优先保证用户流畅上网、业务稳定；</p><p>任意攻击行为联动封锁：对任意具有攻击特征的IP执行访问封锁，最大化业务和用户的安全防御能力。</p><h3 id="联动封锁机制"><a href="#联动封锁机制" class="headerlink" title="联动封锁机制"></a>联动封锁机制</h3><ul><li>高危行为联动封锁功能仅关联。</li><li>任意攻击行为联动功能关联。</li><li>策略触发的联动封锁是针对数据包的会话五元组进行拦截。</li></ul><h2 id="网页防篡改技术"><a href="#网页防篡改技术" class="headerlink" title="网页防篡改技术"></a>网页防篡改技术</h2><p>深信服网页防篡改解决方案采用<strong>文件保护系统+下一代防火墙</strong>紧密结合，<strong>文件监控+二次认证</strong>功能紧密联动，保证网站内容不被篡改，其中文件保护系统采用业界防篡改技术中最先进的文件过滤驱动技术。</p><h3 id="管理员认证流程"><a href="#管理员认证流程" class="headerlink" title="管理员认证流程"></a>管理员认证流程</h3><p><img src="http://static.zybuluo.com/B1ank/3y4y65j05h0g5asinforhet8/%E7%BD%91%E9%A1%B5%E9%98%B2%E7%AF%A1%E6%94%B9.png" alt="网页防篡改.png-328.4kB"></p><ul><li>访问网站后台</li><li>AF重定向提交管理员邮箱地址的认证页面</li><li>提交接收验证码的管理员邮箱</li><li>发送带有验证码的邮件至上述管理员邮箱</li><li>管理员登录邮箱获取验证码</li><li>管理员提交验证码通过认证</li><li>通过验证后自动跳转到后台页面</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>防篡改客户端必须连接防火墙并匹配防篡改策略后才会生效，防篡改客户端生效后，即使防火墙不在线，功能依然生效。</li><li>若网站本身有webshell未删除，则防篡改客户端无法拦截webshell的文件篡改行为。</li><li>Windows系统中，防篡改客户端无法通过控制面板-卸载程序进行卸载，需要使用安装目录中的<code>tamper.exe</code>进行卸载，卸载时需要输入客户端密码。</li><li>Linux系统中，针对防篡改功能开启前已经建立的会话或连接，防篡改功能不会生效。</li><li>Linux系统中，已经被防篡改保护的会话或连接在防篡改进程停止的情况下依然会生效。</li><li>Linux系统中，开启防篡改的服务器，如果需要完全消除防篡改的影响，则需要先卸载防篡改程序后重启所有服务或直接重启服务器。</li><li>Linux系统中，Agent自身存在bypass机制，当服务器内存系统资源超过70%时，功能可以生效但无法向AF同步安全日志。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DoS攻击检测与防御&quot;&gt;&lt;a href=&quot;#DoS攻击检测与防御&quot; class=&quot;headerlink&quot; title=&quot;DoS攻击检测与防御&quot;&gt;&lt;/a&gt;DoS攻击检测与防御&lt;/h2&gt;&lt;h3 id=&quot;DoS攻击&quot;&gt;&lt;a href=&quot;#DoS攻击&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Server Security" scheme="https://blank-vax.github.io/tags/Server-Security/"/>
    
  </entry>
  
  <entry>
    <title>流密码密钥重用</title>
    <link href="https://blank-vax.github.io/2020/11/09/%E6%B5%81%E5%AF%86%E7%A0%81%E5%AF%86%E9%92%A5%E9%87%8D%E7%94%A8/"/>
    <id>https://blank-vax.github.io/2020/11/09/流密码密钥重用/</id>
    <published>2020-11-09T02:39:34.452Z</published>
    <updated>2019-10-30T13:18:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近参加了De1CTF,其中的密码学题目xorz就需要对流密码重用加密后的密文进行爆破攻击,从而得到加密明文和密钥.介于之前接触过流密码相关的题目但没有进行细致归纳,故在此进行归纳总结.</p><h2 id="0x01-异或运算"><a href="#0x01-异或运算" class="headerlink" title="0x01 异或运算"></a>0x01 异或运算</h2><p>异或运算,也是在模2域上进行的加法,遵循以下法则:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 xor 1 = 0</span><br><span class="line">0 xor 0 = 0</span><br><span class="line">1 xor 0 = 1</span><br><span class="line">0 xor 1 = 1</span><br></pre></td></tr></table></figure><p>下面通过cryptopals set1中的题目进行说明.</p><h2 id="0x02-Cryptopals-Set1"><a href="#0x02-Cryptopals-Set1" class="headerlink" title="0x02 Cryptopals Set1"></a>0x02 Cryptopals Set1</h2><p>题目链接:<a href="https://cryptopals.com/sets/1" target="_blank" rel="noopener">https://cryptopals.com/sets/1</a></p><h3 id="Set0-函数储备"><a href="#Set0-函数储备" class="headerlink" title="Set0 函数储备"></a>Set0 函数储备</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 十六进制字符串转化为字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hex_to_bytelist</span><span class="params">(hexString)</span>:</span></span><br><span class="line"><span class="keyword">return</span> [ord(c) <span class="keyword">for</span> c <span class="keyword">in</span> hexString.decode(<span class="string">'hex'</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字节数组转化为十六进制字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bytelist_to_hex</span><span class="params">(bytelist)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">''</span>.join(hex(x)[<span class="number">2</span>:] <span class="keyword">if</span> x &gt; <span class="number">15</span> <span class="keyword">else</span> <span class="string">'0'</span> + hex(x)[<span class="number">2</span>:] <span class="keyword">for</span> x <span class="keyword">in</span> bytelist)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串转化为十六进制字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_to_hex</span><span class="params">(string)</span>:</span></span><br><span class="line"><span class="keyword">return</span> string.encode(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 十六进制字符串转化为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hex_to_str</span><span class="params">(hexString)</span>:</span></span><br><span class="line"><span class="keyword">return</span> hexString.decode(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字节数组转化为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bytelist_to_str</span><span class="params">(bytelist)</span>:</span></span><br><span class="line"><span class="keyword">return</span> hex_to_str(bytelist_to_hex(bytelist))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串转化为字节数组</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str_to_bytelist</span><span class="params">(string)</span>:</span></span><br><span class="line"><span class="keyword">return</span> hex_to_bytelist(str_to_hex(string))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字节数组异或</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span><span class="params">(b1, b2)</span>:</span></span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(b1)):</span><br><span class="line">result.append(b1[i]^b2[i])</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串string以n字节长度的大小进行切分,切分后的每块合为一个列表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chunks</span><span class="params">(string, n)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, len(string), n):</span><br><span class="line"><span class="keyword">yield</span> string[i:i+n]</span><br></pre></td></tr></table></figure><h3 id="Challenge2-Fixed-XOR"><a href="#Challenge2-Fixed-XOR" class="headerlink" title="Challenge2 Fixed XOR"></a>Challenge2 Fixed XOR</h3><p>题目要求:实现一个函数,输入为两个等长的字符串,输出为这两个字符串的异或结果.功能为实现两个等长的字符串异或.<br>实现方法:  </p><ol><li>先使用Set0中的str_to_bytelist()方法将字符串转化为字节数组;  </li><li>然后调用xor()方法进行异或操作;  </li><li>最后调用bytelist_to_hex()方法将得到的字节数组转化为十六进制字符串.<br>脚本如下:</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bytelist_to_hex</span><span class="params">(bytelist)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">''</span>.join(hex(x)[<span class="number">2</span>:] <span class="keyword">if</span> x &gt; <span class="number">15</span> <span class="keyword">else</span> <span class="string">'0'</span> + hex(x)[<span class="number">2</span>:] <span class="keyword">for</span> x <span class="keyword">in</span> bytelist)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hex_to_bytelist</span><span class="params">(hexString)</span>:</span></span><br><span class="line"><span class="keyword">return</span> [ord(c) <span class="keyword">for</span> c <span class="keyword">in</span> hexString.decode(<span class="string">'hex'</span>)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span><span class="params">(b1, b2)</span>:</span></span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(b1)):</span><br><span class="line">result.append(b1[i]^b2[i])</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">s1 = hex_to_bytelist(<span class="string">'1c0111001f010100061a024b53535009181c'</span>)</span><br><span class="line">s2 = hex_to_bytelist(<span class="string">'686974207468652062756c6c277320657965'</span>)</span><br><span class="line"><span class="keyword">print</span> bytelist_to_hex(xor(s1,s2))</span><br></pre></td></tr></table></figure><h3 id="Challenge3-Single-byte-XOR-cipher"><a href="#Challenge3-Single-byte-XOR-cipher" class="headerlink" title="Challenge3 Single-byte XOR cipher"></a>Challenge3 Single-byte XOR cipher</h3><p>题目要求:给定一个十六进制字符串hexString,它是某个字符串与一个单字符key异或进行加密之后得到的结果.现在已知hexString,我们需要找到key,来解密字符串.<br>实现方法:  </p><ol><li>在这个挑战中,我们可以从0-255遍历字符key,对所给的密文进行逐字符异或解密;  </li><li>通过解密后的英文文本中的字符频率,来对测试key解密结果进行评估.选择出得分最高的key,即可能为正确的key.<br>脚本如下:</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">CHARACTER_FREQ = &#123; <span class="comment">#字符频率表</span></span><br><span class="line">    <span class="string">'a'</span>: <span class="number">0.0651738</span>, <span class="string">'b'</span>: <span class="number">0.0124248</span>, <span class="string">'c'</span>: <span class="number">0.0217339</span>, <span class="string">'d'</span>: <span class="number">0.0349835</span>, <span class="string">'e'</span>: <span class="number">0.1041442</span>, <span class="string">'f'</span>: <span class="number">0.0197881</span>, <span class="string">'g'</span>: <span class="number">0.0158610</span>,</span><br><span class="line">    <span class="string">'h'</span>: <span class="number">0.0492888</span>, <span class="string">'i'</span>: <span class="number">0.0558094</span>, <span class="string">'j'</span>: <span class="number">0.0009033</span>, <span class="string">'k'</span>: <span class="number">0.0050529</span>, <span class="string">'l'</span>: <span class="number">0.0331490</span>, <span class="string">'m'</span>: <span class="number">0.0202124</span>, <span class="string">'n'</span>: <span class="number">0.0564513</span>,</span><br><span class="line">    <span class="string">'o'</span>: <span class="number">0.0596302</span>, <span class="string">'p'</span>: <span class="number">0.0137645</span>, <span class="string">'q'</span>: <span class="number">0.0008606</span>, <span class="string">'r'</span>: <span class="number">0.0497563</span>, <span class="string">'s'</span>: <span class="number">0.0515760</span>, <span class="string">'t'</span>: <span class="number">0.0729357</span>, <span class="string">'u'</span>: <span class="number">0.0225134</span>,</span><br><span class="line">    <span class="string">'v'</span>: <span class="number">0.0082903</span>, <span class="string">'w'</span>: <span class="number">0.0171272</span>, <span class="string">'x'</span>: <span class="number">0.0013692</span>, <span class="string">'y'</span>: <span class="number">0.0145984</span>, <span class="string">'z'</span>: <span class="number">0.0007836</span>, <span class="string">' '</span>: <span class="number">0.1918182</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(string)</span>:</span> <span class="comment">#计算字符串的频率得分</span></span><br><span class="line">    score = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> string:</span><br><span class="line">        ch = ch.lower()</span><br><span class="line">        <span class="keyword">if</span> ch <span class="keyword">in</span> CHARACTER_FREQ:</span><br><span class="line">            score += CHARACTER_FREQ[ch]</span><br><span class="line">    <span class="keyword">return</span> score</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singlebyte_xor</span><span class="params">(key, string)</span>:</span> <span class="comment">#单字符异或加密</span></span><br><span class="line">    res = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> string:</span><br><span class="line">        ch = chr(key ^ ord(i))</span><br><span class="line">        res += ch</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traversal_singlebyte</span><span class="params">(string)</span>:</span> <span class="comment">#遍历单个字符解密,评估</span></span><br><span class="line">    candidate = []</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">        plaintext = singlebyte_xor(key, string)</span><br><span class="line">        score = get_score(plaintext)</span><br><span class="line">        res=&#123;<span class="string">'key'</span>: key, <span class="string">'plaintext'</span>: plaintext, <span class="string">'score'</span>: score&#125;</span><br><span class="line">        candidate.append(res)</span><br><span class="line">    <span class="comment">#取得分最高的返回</span></span><br><span class="line">    <span class="keyword">return</span> sorted(candidate, key = <span class="keyword">lambda</span> c:c[<span class="string">'score'</span>])[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">hexString=<span class="string">"1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736"</span></span><br><span class="line"><span class="keyword">print</span> traversal_singlebyte(hexString.decode(<span class="string">'hex'</span>))</span><br></pre></td></tr></table></figure><h3 id="Challenge5-Implement-repeating-key-XOR"><a href="#Challenge5-Implement-repeating-key-XOR" class="headerlink" title="Challenge5 Implement repeating-key XOR"></a>Challenge5 Implement repeating-key XOR</h3><p>题目要求:实现一个函数,给定待加密的字符串和密钥,该函数通过使用重复密钥异或(repeating-key XOR)的方法,加密一段英文文本,返回加密后的结果.<br>直接贴出实现脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeatingkey_xor</span><span class="params">(string, key)</span>:</span></span><br><span class="line">    res=<span class="string">""</span> <span class="comment">#字符串连接&lt;存放每一次加密后的结果</span></span><br><span class="line">    <span class="comment">#xrange方法使得每次处理len(key)长度的字符串</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, len(string), len(key)):</span><br><span class="line">        res += bytelist_to_hex(xor(str_to_bytelist(string[i:i+len(key)]), str_to_bytelist(key)))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">string = <span class="string">"Burning 'em, if you ain't quick and nimble\nI go crazy when I hear a cymbal"</span></span><br><span class="line">key = <span class="string">"ICE"</span></span><br><span class="line"><span class="keyword">print</span> repeatingkey_xor(string, key)</span><br></pre></td></tr></table></figure><h3 id="Challenge6-Break-repeating-key-XOR"><a href="#Challenge6-Break-repeating-key-XOR" class="headerlink" title="Challenge6 Break repeating-key XOR"></a>Challenge6 Break repeating-key XOR</h3><p>题目要求:在该挑战中提供了一个文件challenge6.txt,文件中是使用重复密钥异或方法加密后,再经过base64编码后得到的文本,我们需要找到密钥,对其进行解密.<br>实现方法:  </p><ol><li>猜测密钥长度KEYSIZE,在一定范围内爆破;  </li><li>对于每个KEYSIZE,求得每个解密块两两之间的汉明距离,对KEYSIZE取平均值;  </li><li>选取2-3个最小汉明距离的KEYSIZE;  </li><li>获取KEYSIZE之后,对每一块的对应字节组合后的字符串与单字符异或,从而可以破解密钥;  </li><li>对不同KEYSIZE解密之后的明文进行评估,选取得分最高的一组.<br>对于汉明距离的解释说明及整个爆破过程的具体解法可以参考Hamming Distance的内容.<br>脚本如下:</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hamming_distance</span><span class="params">(s1, s2)</span>:</span></span><br><span class="line">        dis = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(min(len(s1), len(s2))):</span><br><span class="line">            b = bin(ord(s1[i]) ^ ord(s2[i]))</span><br><span class="line">            dis += b.count(<span class="string">'1'</span>)</span><br><span class="line">        <span class="keyword">return</span> dis</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">guess_keysize</span><span class="params">(string)</span>:</span></span><br><span class="line">    keys = []</span><br><span class="line">    <span class="keyword">for</span> keysize <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">40</span>):</span><br><span class="line">        blocks = []</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        dis = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(string), keysize):</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            blocks.append(string[i:i+keysize])</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment">#选取四个块,两两组合求汉明距离</span></span><br><span class="line">        pairs = itertools.combinations(blocks, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> (x, y) <span class="keyword">in</span> pairs:</span><br><span class="line">            dis += hamming_distance(x, y)</span><br><span class="line">        ndis = dis / keysize</span><br><span class="line">        key = &#123;<span class="string">'keysize'</span>: keysize, <span class="string">'distance'</span>: ndis&#125;</span><br><span class="line">        keys.append(key)</span><br><span class="line">    <span class="keyword">return</span> sorted(keys, key=<span class="keyword">lambda</span> c:c[<span class="string">'distance'</span>])[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">guess_key</span><span class="params">(keysize, string)</span>:</span></span><br><span class="line">    key = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(keysize):</span><br><span class="line">        now_str = <span class="string">''</span></span><br><span class="line">        <span class="comment">#获取每个块相同位置的字符</span></span><br><span class="line">        <span class="keyword">for</span> index, ch <span class="keyword">in</span> enumerate(string):</span><br><span class="line">            <span class="keyword">if</span> index % keysize == i:</span><br><span class="line">                now_str += ch</span><br><span class="line">        key += chr(traversal_singlebyte(now_str)[<span class="string">'key'</span>])</span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">break_repeatingkey_xor</span><span class="params">(string)</span>:</span></span><br><span class="line">    keysizes = guess_keysize(string)</span><br><span class="line">    candidate = []</span><br><span class="line">    plains = []</span><br><span class="line">    <span class="keyword">for</span> keysize <span class="keyword">in</span> keysizes:</span><br><span class="line">        key = guess_key(keysize[<span class="string">'keysize'</span>], string)</span><br><span class="line">        <span class="comment">#二元组:重复密钥异或解密明文,对应密钥key</span></span><br><span class="line">        plains.append((hex_to_str(repeatingkey_xor(string, key)), key))</span><br><span class="line">    <span class="keyword">return</span> sorted(plains, key=<span class="keyword">lambda</span> c:get_score(c[<span class="number">0</span>]))[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'challenge6.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">s = f.read()</span><br><span class="line">string=base64.b64decode(s)</span><br><span class="line">res=break_repeatingkey_xor(string)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'plaintext: \n'</span>+res[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'key: \n'</span>+res[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="0x03-xorz"><a href="#0x03-xorz" class="headerlink" title="0x03 xorz"></a>0x03 xorz</h2><p>题目来源: 2019.8.3-8.5 De1ctf Crypto<br>题目描述: xorzzz…<br>题目附件中的py脚本如下:  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> data <span class="keyword">import</span> flag,plain</span><br><span class="line"></span><br><span class="line">key=flag.strip(<span class="string">"de1ctf&#123;"</span>).strip(<span class="string">"&#125;"</span>)</span><br><span class="line"><span class="keyword">assert</span>(len(key)&lt;<span class="number">38</span>)</span><br><span class="line">salt=<span class="string">"WeAreDe1taTeam"</span></span><br><span class="line">ki=cycle(key)</span><br><span class="line">si=cycle(salt)</span><br><span class="line">cipher = <span class="string">''</span>.join([hex(ord(p) ^ ord(next(ki)) ^ ord(next(si)))[<span class="number">2</span>:].zfill(<span class="number">2</span>) <span class="keyword">for</span> p <span class="keyword">in</span> plain])</span><br><span class="line"><span class="keyword">print</span> cipher</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># 49380d773440222d1b421b3060380c3f403c3844791b202651306721135b6229294a3c3222357e766b2f15561b35305e3c3b670e49382c295c6c170553577d3a2b791470406318315d753f03637f2b614a4f2e1c4f21027e227a4122757b446037786a7b0e37635024246d60136f7802543e4d36265c3e035a725c6322700d626b345d1d6464283a016f35714d434124281b607d315f66212d671428026a4f4f79657e34153f3467097e4e135f187a21767f02125b375563517a3742597b6c394e78742c4a725069606576777c314429264f6e330d7530453f22537f5e3034560d22146831456b1b72725f30676d0d5c71617d48753e26667e2f7a334c731c22630a242c7140457a42324629064441036c7e646208630e745531436b7c51743a36674c4f352a5575407b767a5c747176016c0676386e403a2b42356a727a04662b4446375f36265f3f124b724c6e346544706277641025063420016629225b43432428036f29341a2338627c47650b264c477c653a67043e6766152a485c7f33617264780656537e5468143f305f4537722352303c3d4379043d69797e6f3922527b24536e310d653d4c33696c635474637d0326516f745e610d773340306621105a7361654e3e392970687c2e335f3015677d4b3a724a4659767c2f5b7c16055a126820306c14315d6b59224a27311f747f336f4d5974321a22507b22705a226c6d446a37375761423a2b5c29247163046d7e47032244377508300751727126326f117f7a38670c2b23203d4f27046a5c5e1532601126292f577776606f0c6d0126474b2a73737a41316362146e581d7c1228717664091c</span></span><br></pre></td></tr></table></figure><p>解题思路:<br>拿到题目之后关注运算代码段:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cipher = &apos;&apos;.join([hex(ord(p) ^ ord(next(ki)) ^ ord(next(si)))[2:].zfill(2) for p in plain])</span><br></pre></td></tr></table></figure><p>可以发现密文通过key、salt和plain逐位异或得到.题目中已知salt,可以通过逐位异或还原key和plain的异或值.下面可以想到的方法就是爆破,使用上面提到的Break repeating-key XOR脚本,可以爆破出最有可能的明文,从而得到flag,结果如下:<br><img src="http://static.zybuluo.com/B1ank/m2dxqzx98ll9a2iuzvo5t2qk/xorz.png" alt="xorz.png-283.2kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;最近参加了De1CTF,其中的密码学题目xorz就需要对流密码重用加密后的密文进行爆破攻击,从而得到
      
    
    </summary>
    
      <category term="Crypto_Attack" scheme="https://blank-vax.github.io/categories/Crypto-Attack/"/>
    
    
      <category term="xor" scheme="https://blank-vax.github.io/tags/xor/"/>
    
  </entry>
  
  <entry>
    <title>云计算基础</title>
    <link href="https://blank-vax.github.io/2020/11/09/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80/"/>
    <id>https://blank-vax.github.io/2020/11/09/云计算基础/</id>
    <published>2020-11-09T02:39:34.445Z</published>
    <updated>2020-09-30T16:09:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="云计算基础"><a href="#云计算基础" class="headerlink" title="云计算基础"></a>云计算基础</h2><h3 id="云计算定义"><a href="#云计算定义" class="headerlink" title="云计算定义"></a>云计算定义</h3><ul><li>技术角度：云计算是一种基于互联网的计算方式，通过这种方式，共享的软硬件资源和信息可以按需求提供给计算机和其他设备。</li><li><p>经济学角度：云计算依赖资源的共享以达成规模经济，类似基础设施如电力网等。</p></li><li><p>云计算现阶段的发展还远远未达到基础设施建设水平。</p></li></ul><p><img src="http://static.zybuluo.com/B1ank/bmg3x73stk7ol7hgyap45g4o/image-20200711112223579.png" alt="image-20200711112223579.png-264.8kB"></p><ul><li>滴滴打车</li></ul><h3 id="云计算本质"><a href="#云计算本质" class="headerlink" title="云计算本质"></a>云计算本质</h3><p>云计算是新技术+IT业务模式的创新，随着数字化时代的发展，IT消费模式产生重大转变：云计算通过技术将IT资源池化和服务化，通过互联网提供IT服务，而用户由网络浏览器或轻量级终端软件来获取和使用这些IT服务。整个IT市场商业模式正实现<strong>“从产品到服务”</strong>的转型。</p><h3 id="云计算特性"><a href="#云计算特性" class="headerlink" title="云计算特性"></a>云计算特性</h3><ul><li>按需自助</li><li>可度量服务</li><li>快速灵活</li><li>资源池</li><li>广阔网络访问</li></ul><h3 id="相关分类"><a href="#相关分类" class="headerlink" title="相关分类"></a>相关分类</h3><h4 id="服务模型分类"><a href="#服务模型分类" class="headerlink" title="服务模型分类"></a>服务模型分类</h4><ul><li><p>IaaS（Infrastructure as a Service）：基础架构即服务</p><p>用户通过网络使用计算机（物理机或虚拟机）、存储空间、网络连接等完善的计算机基础设施服务。</p></li><li><p>PaaS（Platform as a Service）：平台即服务</p><p>将软件研发的平台作为一种服务提交给用户，意在加快SaaS应用的开发速度。</p></li><li><p>SaaS（Software as a Service）：软件即服务</p><p>通过Internet提供软件的模式，用户无需购买软件，而是向提供商租用基于Web的软件来管理企业经营活动。</p></li></ul><h4 id="部署模型分类"><a href="#部署模型分类" class="headerlink" title="部署模型分类"></a>部署模型分类</h4><ul><li>公有云</li><li>私有云</li><li>混合云</li></ul><h3 id="公有云"><a href="#公有云" class="headerlink" title="公有云"></a>公有云</h3><p>通过Internet为外部客户提供服务的云。典型公有云包括Amazon EC2、阿里云、腾讯云等。</p><ul><li><p>优点</p><p>所有应用服务数据等均存放在公有云提供商处，客户无需硬件投资与建设，使用成本低；</p></li><li><p>缺点</p><p>数据存放在供应商处，安全性存在风险。公有云的可用性不受使用者控制，存在不确定性。</p></li></ul><h3 id="私有云"><a href="#私有云" class="headerlink" title="私有云"></a>私有云</h3><p>由企业或机构独享使用和掌控的云，仅供自己内部人员或分支机构使用，一般部署在企业或机构的数据中心。</p><ul><li><p>优点</p><p>数据安全性和系统可用性可控，对现有IT流程管理影响小、IT资源利用率高；</p></li><li><p>缺点</p><p>投资较大。</p></li></ul><h3 id="混合云"><a href="#混合云" class="headerlink" title="混合云"></a>混合云</h3><p>同一份数据、同一套应用，同时采用私有云技术构建自己的IT服务平台，同时又采购了公有云服务商提供的IT服务。为保证数据安全，企业将核心数据和关键技术存放于私有云上，而将面向用户的服务托管在公有云上，具有较高的弹性。一般是需要具备可控的前提下，具备一定的弹性或可靠性。多应用于潮汐应用及混合云灾备。</p><ul><li><p>优点</p><p>具备较大弹性，并且可以在保障可控性的同时兼顾建设成本；</p></li><li><p>缺点</p><p>IT业务管理界面不统一，需要投入相应的混合云管理成本。</p></li></ul><h2 id="数据中心基础"><a href="#数据中心基础" class="headerlink" title="数据中心基础"></a>数据中心基础</h2><h3 id="重要组成要素"><a href="#重要组成要素" class="headerlink" title="重要组成要素"></a>重要组成要素</h3><ul><li>处理资源请求和资源分发的云平台</li><li>网络管道</li><li>终端用户</li></ul><h3 id="数据中心"><a href="#数据中心" class="headerlink" title="数据中心"></a>数据中心</h3><p>数据中心是云计算后端基础设施的承载体，云计算依托数据中心提供各种云计算服务。数据中心内部除包含基础物理设施外，还包含网络、安全、优化、存储、服务器、操作系统、虚拟机及应用软件等成分。</p><h3 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h3><p><img src="http://static.zybuluo.com/B1ank/llbtq6h73ym6pvcx50wqnl3z/%E4%BA%91%E8%AE%A1%E7%AE%97%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.png" alt="云计算逻辑架构.png-140.1kB"></p><h2 id="计算基础"><a href="#计算基础" class="headerlink" title="计算基础"></a>计算基础</h2><h3 id="服务器分类"><a href="#服务器分类" class="headerlink" title="服务器分类"></a>服务器分类</h3><p>随着云计算技术的发展与并行计算思想的出现，未来x86服务器在市场中将占据主导地位。</p><h4 id="x86服务器"><a href="#x86服务器" class="headerlink" title="x86服务器"></a>x86服务器</h4><p>又称CISC（复杂指令集）架构服务器，即通常所讲的PC服务器，它基于PC机体系结构，使用Intel或其它兼容x86指令集的处理器芯片和Windows/Linux操作系统的服务器。</p><h4 id="非x86服务器"><a href="#非x86服务器" class="headerlink" title="非x86服务器"></a>非x86服务器</h4><p>包括大型机、小型机和UNIX服务器，它们是使用RISC（精简指令集）或EPIC（并行指令代码）的处理器，并且主要采用UNIX和其他专用操作系统的服务器。</p><h3 id="小型机"><a href="#小型机" class="headerlink" title="小型机"></a>小型机</h3><p>中国业内习惯上称UNIX服务器为小型机，其最引以为傲的特点就是高RAS——高可靠性、高可用性与高服务性。随着CPU和虚拟化技术的发展，x86服务器的可靠性与可用性不再是问题，为用户提供更多选择，小型机的竞争力逐渐下降。</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>Central Process Unit，是一块超大规模的集成电路，是一台计算机的运算核心和控制核心。常见参数如下：</p><ul><li>主频：表示CPU的处理频率，常见的频率为1.7-3.1GHz。数值越高，处理的速度越快。超频表示CPU可以超越主频规定的处理频率进行运算处理。当计算机进入节能模式时，为提高电量续航，采用降频策略，主动下调CPU的计算效率。</li><li>核数：表示CPU的并行处理能力。核数越多则并行处理速度越快。超线程表示CPU可以高负荷处理数据。</li></ul><p>为适应信息化发展，Intel推出VT（Virtualization Technology，虚拟化技术）系列以满足不同的上层操作系统对底层处理器的调用，如VT-x、VT-d、VT-c。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>Memory，也被称为内存储器，用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。内存主频与CPU主频一样，习惯上被用来表示内存的速度，代表着该内存所能达到的最高工作频率。可分为ROM只读存储器、RAM随机存储器和Cache高速缓存三类。</p><h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><p>Disk，数据的最终归属地。可分为机械硬盘HDD与固态硬盘SSD。</p><h3 id="常见卡"><a href="#常见卡" class="headerlink" title="常见卡"></a>常见卡</h3><ul><li>网卡：通过网络连接线与网络交换机连接。</li><li>存储卡：通过网络连接线和存储设备对接。</li><li>RAID卡：通过总线和硬盘连接。</li></ul><p>常见接口为PCI、PCI-X和PCI-E。</p><h3 id="光模块"><a href="#光模块" class="headerlink" title="光模块"></a>光模块</h3><p>光模块的作用为光电转换，发送端将电信号转换为光信号，通过光纤传送后，接收端再将光信号转换为电信号。光模块具有传输速率高，传输距离远的特点。</p><h3 id="光纤跳线"><a href="#光纤跳线" class="headerlink" title="光纤跳线"></a>光纤跳线</h3><p>用来做从设备到光纤布线链路的跳接线。常见LC接口的光模块为：SFF、SFP、SFP+和XFP。常见SC接口的光明模块为GBIC。而FC、ST接口多用于光纤配线架。</p><h3 id="操作系统OS"><a href="#操作系统OS" class="headerlink" title="操作系统OS"></a>操作系统OS</h3><p>管理和控制计算机硬件与软件资源的计算机程序，具有承上启下的功能：对上有效管理系统资源，为应用软件提供基础的底层环境，提高系统资源使用效率。对下屏蔽硬件物理特性和操作细节，为用户使用计算机提供便利。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;云计算基础&quot;&gt;&lt;a href=&quot;#云计算基础&quot; class=&quot;headerlink&quot; title=&quot;云计算基础&quot;&gt;&lt;/a&gt;云计算基础&lt;/h2&gt;&lt;h3 id=&quot;云计算定义&quot;&gt;&lt;a href=&quot;#云计算定义&quot; class=&quot;headerlink&quot; title=&quot;云计算
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Cloud Computing" scheme="https://blank-vax.github.io/tags/Cloud-Computing/"/>
    
  </entry>
  
  <entry>
    <title>两道CTF-RSA类题目总结</title>
    <link href="https://blank-vax.github.io/2020/11/09/%E4%B8%A4%E9%81%93CTF-RSA%E7%B1%BB%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>https://blank-vax.github.io/2020/11/09/两道CTF-RSA类题目总结/</id>
    <published>2020-11-09T02:39:34.445Z</published>
    <updated>2019-10-30T13:33:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-几句废话"><a href="#0x00-几句废话" class="headerlink" title="0x00 几句废话"></a>0x00 几句废话</h2><p>可能是由于刚开学的原因,CTF线上赛不仅数量多,赛题质量也比较高.而且智能合约越来越成为比赛的宠儿,有空需要专门学习记录一下相关题目的做法及常见漏洞.<br>下面记录一下两道比较有意思的Crypto类RSA相关题目.   </p><h2 id="0x01-数学知识补充"><a href="#0x01-数学知识补充" class="headerlink" title="0x01 数学知识补充"></a>0x01 数学知识补充</h2><h3 id="Legendre-symbol"><a href="#Legendre-symbol" class="headerlink" title="Legendre symbol"></a>Legendre symbol</h3><p>勒让德符号(下文写成a|p)有如下定义:  </p><p><img src="http://static.zybuluo.com/B1ank/7ul03xufwy3ovh26soy14jxe/legendre_symbol.png" alt="legendre_symbol.png-52.3kB">  </p><p>基本性质  </p><ul><li>如果(a|p)=1,a便称为modp下的二次剩余;如果(a|p)=-1,则a称为modp下的二次非剩余.通常把0视为一种特殊情况.</li><li>(a|p) = +1/-1 $\equiv$ a^((p-1)/2) (mod p)</li></ul><p>其他性质</p><ul><li>(a*b|p) = (a|p)*(b|p)</li><li>如果a$\equiv$b (mod p),则(a|p) = (b|p)</li><li>(a**2|p) = 1</li><li>一般二次互反律<br>如果p和q是奇素数,则(q|p)=(p|q)*(-1)**((p-1)/2*(q-1)/2)  </li><li>二次互反律的第一补充<br><img src="http://static.zybuluo.com/B1ank/li4p8nl065y70dj7jg3fn5n3/2.png" alt="2.png-19.4kB"></li><li>二次互反律的第二补充<br><img src="http://static.zybuluo.com/B1ank/yhuw3bkb78iohm25o6awcrk6/3.png" alt="3.png-22.3kB"></li></ul><h3 id="Jacobi-symbol"><a href="#Jacobi-symbol" class="headerlink" title="Jacobi symbol"></a>Jacobi symbol</h3><p>雅可比符号是勒让德符号的推广,整数a对整数m的雅可比符号表示为(a|m).设m是大于1的奇数,且m的素因数分解式为m=p1*p2*p3….pr(式中因数可以相同),如果(a,m)=1,则雅可比符号定义为:<br><code>(a|m) = (a|p1)(a|p2)(a|p3)...(a|pr)</code><br>其中(a|pi)是a对pi的勒让德符号符号.    </p><p>相关定理</p><ul><li>定理1<br><img src="http://static.zybuluo.com/B1ank/tuxyin7hs3sr5tkjo0pgxw4z/4.png" alt="4.png-69.3kB"></li><li>定理2<br><img src="http://static.zybuluo.com/B1ank/o3fmbogr0kflioirzgw746js/5.png" alt="5.png-38.9kB"></li><li>定理3<br><img src="http://static.zybuluo.com/B1ank/469iqk8nbmemsh8dm6u15z1h/6.png" alt="6.png-112.6kB"></li></ul><h2 id="0x02-Application-of-jacobi-symbol"><a href="#0x02-Application-of-jacobi-symbol" class="headerlink" title="0x02 Application of jacobi symbol"></a>0x02 Application of jacobi symbol</h2><h3 id="计算雅可比符号的python函数-gmpy2-jacobi"><a href="#计算雅可比符号的python函数-gmpy2-jacobi" class="headerlink" title="计算雅可比符号的python函数 gmpy2.jacobi()"></a>计算雅可比符号的python函数 <code>gmpy2.jacobi()</code></h3><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p>2019-9-6 N1ctf babyrsa   </p><h3 id="题目类型"><a href="#题目类型" class="headerlink" title="题目类型"></a>题目类型</h3><p><strong>Crypto,jacobi symbol,operator precedence</strong>   </p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>该题目给出了加密脚本<code>babyrsa.py</code>以及加密之后的文件<code>flag.enc</code>.加密脚本如下:   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util <span class="keyword">import</span> number</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line">N = <span class="number">23981306327188221819291352455300124608114670714977979223022816906368788909398653961976023086718129607035805397846230124785550919468973090809881210560931396002918119995710297723411794214888622784232065592366390586879306041418300835178522354945438521139847806375923379136235993890801176301812907708937658277646761892297209069757559519399120988948212988924583632878840216559421398253025960456164998680766732013248599742397199862820924441357624187811402515396393385081892966284318521068948266144251848088067639941653475035145362236917008153460707675427945577597137822575880268720238301307972813226576071488632898694390629</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">m = number.bytes_to_long(flag)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'flag.enc'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">while</span> m:</span><br><span class="line">        padding = random.randint(<span class="number">0</span>, <span class="number">2</span>**<span class="number">1000</span>) ** <span class="number">2</span></span><br><span class="line">        message = padding &lt;&lt; <span class="number">1</span> + m % <span class="number">2</span></span><br><span class="line">        cipher = pow(message, e, N)</span><br><span class="line">        f.write(hex(cipher)+<span class="string">'\n'</span>)</span><br><span class="line">        m /= <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>通过脚本我们可以看出大致的加密过程:首先将flag字符串转换成长整型数字.然后随机生成一定范围内的随机数并进行<strong>平方</strong>.由于运算符优先级问题,<code>&lt;&lt;</code>的优先级高于<code>+</code>,所以将处理后的随机数左移<code>(1+flag[i])</code>位.将移动后的结果进行rsa加密,结果以hex的形式存储在输出文件中.<br>分析算法之后,我们有两点需要注意,第一是运算符优先级问题,即左移的位数只能是1或2.第二是由于<code>m%2</code>的存在,加密的顺序是从flag的低位向高位进行,所以解密结果需要注意顺序.<br>下面来进行数学分析.经过上面的分析我们知道<code>plain[i] = 2^(1+flag[i])*r^2</code>显然当<code>flag[i] == 1</code>时,<code>plain[i] = (2*r)^2(mod n)</code>是一个二次剩余.如果<code>flag[i] == 0</code>时,<code>plain[i]=2*r^2</code>,此时<code>2^(-1)*plain[i]=r^2 (mod n)</code>是一个二次剩余.此类问题本质为模数域内的平方检测问题,于是联想到使用雅可比符号.<br>根据题目描述,我们可以得到<code>cipher[i]=(2^(1+flag[i])*r^2)^e (mod n)</code>,根据性质计算雅可比符号:<br><img src="http://static.zybuluo.com/B1ank/blb4d2l3dzbdmqoybpnygpt4/7.png" alt="7.png-70.3kB"><br>由于N $\equiv$ 5(mod 8),根据二次互反律可得(2|N) = -1,而且(1|N)=1.所以当雅可比符号为-1时, <code>flag[i]=1</code>,当雅可比符号为1时,<code>flag[i]=0</code>.根据这一分析我们可以最终恢复出flag.<br><strong>Tips: If x is a quadratic residue and gcd(x,N)=1,then(x|N)=1.If the Jacobi symbol is 0, then x contains a factor of N.</strong></p><h3 id="解题脚本"><a href="#解题脚本" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">N = <span class="number">23981306327188221819291352455300124608114670714977979223022816906368788909398653961976023086718129607035805397846230124785550919468973090809881210560931396002918119995710297723411794214888622784232065592366390586879306041418300835178522354945438521139847806375923379136235993890801176301812907708937658277646761892297209069757559519399120988948212988924583632878840216559421398253025960456164998680766732013248599742397199862820924441357624187811402515396393385081892966284318521068948266144251848088067639941653475035145362236917008153460707675427945577597137822575880268720238301307972813226576071488632898694390629</span></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">two_inv = pow(gmpy2.invert(<span class="number">2</span>, N), e, N)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'flag.enc'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    flag = <span class="string">''</span></span><br><span class="line">    tmp = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> ct <span class="keyword">in</span> f:</span><br><span class="line">        ct = int(ct.strip().rstrip(<span class="string">'L'</span>), <span class="number">16</span>)</span><br><span class="line">        jacobi = gmpy2.jacobi(two_inv * ct, N)</span><br><span class="line">        <span class="keyword">if</span> jacobi == <span class="number">-1</span>:</span><br><span class="line">            tmp = <span class="string">'1'</span> + tmp <span class="comment"># 注意顺序 不是tmp += '1'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp = <span class="string">'0'</span> + tmp</span><br><span class="line">        <span class="keyword">if</span> len(tmp) == <span class="number">8</span>:</span><br><span class="line">            flag = chr(int(tmp, <span class="number">2</span>)) + flag</span><br><span class="line">    flag = chr(int(tmp, <span class="number">2</span>)) + flag</span><br><span class="line"></span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><h2 id="0x03-RSAchain"><a href="#0x03-RSAchain" class="headerlink" title="0x03 RSAchain"></a>0x03 RSAchain</h2><h3 id="题目来源-1"><a href="#题目来源-1" class="headerlink" title="题目来源"></a>题目来源</h3><p>2019-9-22 Teaser-Dragon ctf RSAchained</p><h3 id="题目类型-1"><a href="#题目类型-1" class="headerlink" title="题目类型"></a>题目类型</h3><p><strong>Crypto,rsa,sagemath,partial private key explosure attack</strong></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>题目给出了加密脚本<code>task.py</code>以及加密之后的结果<code>output.txt</code>.加密脚本如下:    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">flag = int(open(<span class="string">'flag.txt'</span>).read().encode(<span class="string">"hex"</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genPrime</span><span class="params">(bits)</span>:</span></span><br><span class="line">    data = os.urandom(bits/<span class="number">8</span>)</span><br><span class="line">    number = int(data.encode(<span class="string">"hex"</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="comment"># gmpy2.next_prime()返回下一个可能的大于number的素数</span></span><br><span class="line">    <span class="keyword">return</span> gmpy2.next_prime(number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e = <span class="number">1667</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># rsa1: p - 700 bits q - 1400 bits</span></span><br><span class="line"></span><br><span class="line">p = genPrime(<span class="number">700</span>)</span><br><span class="line">q = genPrime(<span class="number">1400</span>)</span><br><span class="line"></span><br><span class="line">n = p*q</span><br><span class="line">phi = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line">d = gmpy2.powmod(e, <span class="number">-1</span>, phi)</span><br><span class="line"></span><br><span class="line">rsa1 = (n, d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># rsa2: p - 700 bits, q - 700 bits, r = 700 bits</span></span><br><span class="line"></span><br><span class="line">p = genPrime(<span class="number">700</span>)</span><br><span class="line">q = genPrime(<span class="number">700</span>)</span><br><span class="line">r = genPrime(<span class="number">700</span>)</span><br><span class="line"></span><br><span class="line">n = p*q*r</span><br><span class="line">phi = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)*(r<span class="number">-1</span>)</span><br><span class="line">d = gmpy2.powmod(e, <span class="number">-1</span>, phi)</span><br><span class="line"></span><br><span class="line">rsa2 = (n, d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># rsa3: p - 700 bits, q - 700 bits, r = 700 bits</span></span><br><span class="line"></span><br><span class="line">p = genPrime(<span class="number">700</span>)</span><br><span class="line">q = genPrime(<span class="number">700</span>)</span><br><span class="line"></span><br><span class="line">n = p*q*r</span><br><span class="line">phi = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)*(r<span class="number">-1</span>)</span><br><span class="line">d = gmpy2.powmod(e, <span class="number">-1</span>, phi)</span><br><span class="line"></span><br><span class="line">rsa3 = (n, d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># rsa4: p - 700 bits, q - 700 bits</span></span><br><span class="line"></span><br><span class="line">p = genPrime(<span class="number">700</span>)</span><br><span class="line">q = genPrime(<span class="number">700</span>)</span><br><span class="line"></span><br><span class="line">n = p*q*q</span><br><span class="line">phi = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)*q</span><br><span class="line">d = gmpy2.powmod(e, <span class="number">-1</span>, phi)</span><br><span class="line"></span><br><span class="line">rsa4 = (n, d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照n从小到大进行排序</span></span><br><span class="line">rsa = sorted([rsa1, rsa2, rsa3, rsa4])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n, d <span class="keyword">in</span> rsa:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'pubkey:'</span>, n, d % (<span class="number">2</span>**<span class="number">1050</span>)</span><br><span class="line">    flag = pow(flag, e, n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'encrypted flag'</span>, flag</span><br></pre></td></tr></table></figure><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>拿到题目之后发现是一个链式rsa加密,明文经过四次加密得到密文.四次加密均采用rsa算法,加密指数<code>e = 1667</code>,并且模数n满足:    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n1 = p1*q1</span><br><span class="line">n2 = p2*q2*r</span><br><span class="line">n3 = p3*q3*r</span><br><span class="line">n4 = p4*q4*q4</span><br></pre></td></tr></table></figure><p>除大素数r之外的p,q每轮都单独生成.将n1-n4从小到大排列之后对flag进行多次加密.观察每次加密的输出,每次输出排序后对应的n以及<code>d % (2**1050)</code>.<br>简单分析之后,我们可以得出一些思路:首先观察四个模数,显然n2,n3具有公因数r,通过<code>math.gcd()</code>可以求出大素数r,并同时确定n2和n3的位置.然后我们会考虑到加密顺序的问题,由于上一步已经明确找出了n2和n3的位置,故确定n1,n4的顺序最多需要爆破两次.最后我们观察每次输出,给出了<code>d % (2**1050)</code>,属于部分密钥暴露的情况,联想到使用<code>partial private key explosure attack</code>,但由于无法确定暴露的位数故存在失败的可能性.<br>这里我们通过分析n1-n4的构成可以从另一个角度解决问题.    </p><h4 id="Pretreatment-e-d-1-mod-phi-N"><a href="#Pretreatment-e-d-1-mod-phi-N" class="headerlink" title="Pretreatment: e*d == 1 mod phi(N)"></a>Pretreatment: <code>e*d == 1 mod phi(N)</code></h4><p>将上式变形为<code>e\*d-k*phi(N)=1</code>.由于d&lt;phi(N),故上式成立,则k&lt;e,从而确定出k的爆破范围.将上式与d0建立转换联系,有: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e * d == 1 mod phi(N)</span><br><span class="line">(e * d) mod 2**1050 == (1 mod phi(N)) mod 2**1050</span><br><span class="line">(e mod 2**1050) * (d mod 2**1050) mod 2**1050 == (1 mod phi(N)) mod 2**1050</span><br><span class="line">e * d0 == (1 mod phi(N)) mod 2**1050</span><br><span class="line">e * d0 - k*phi(N) == 1 mod 2**1050</span><br></pre></td></tr></table></figure><h4 id="Case1-N-p-q-r"><a href="#Case1-N-p-q-r" class="headerlink" title="Case1: N = p*q*r"></a>Case1: <code>N = p*q*r</code></h4><p>首先通过GCD函数求出大素数r的值以及n2,n3的位置.计算后发现<code>r = 32619972550448885952992763634430245734911201344234854263395196070105784406551510361671421185736962007609664176708457560859146461127127352439294740476944600948487063407599124272043110271125538616418873138407229</code>,n2,n3分别位于加密的第一、二位.<br>观察上一步处理得到的关系式<code>e * d0 - k*phi(N) == 1 mod 2**1050</code>,发现e,d0,k均为常数,于是联想到处理<code>phi(N)</code>,由于<code>phi(N) = (p-1)*(q-1)*(r-1)</code>,且N和r均为已知常数,故在方程两侧同乘变量进行变量转换,最终变成只包含p、N、r的方程:    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(p-1)*(q-1)*(r-1) = </span><br><span class="line">(p-1)*(qr-q-r+1) = </span><br><span class="line">pqr-pq-pr+p-qr+q+r-1 = </span><br><span class="line">N-pq-pr+p-qr+q+r-1 = | *r</span><br><span class="line">Nr-pqr-pr^2+pr-qr^2+qr+r^2-r =</span><br><span class="line">Nr-N-pr^2+pr-qr^2+qr+r^2-r = |*p</span><br><span class="line">Nrp-Np-p^2r^2+p^2r-pqr^2+pqr+pr^2-rp = </span><br><span class="line">Nrp-Np-p^2r^2+p^2r-Nr+N+pr^2-pr</span><br><span class="line">final equation: e*d0*p*r - k*(Nrp-Np-p^2r^2+p^2r-Nr+N+pr^2-pr) == p*r mod 2**1050</span><br></pre></td></tr></table></figure><p>最终解上述方程(使用sagemath)可以找出p2,p3的值,成功分解n2,n3.   </p><h4 id="Case2-N-p-q-2"><a href="#Case2-N-p-q-2" class="headerlink" title="Case2: N = p*q**2"></a>Case2: <code>N = p*q**2</code></h4><p>此种情况下,我们有如下信息:<code>phi(N) = (p-1)*(q-1)*q</code>,<code>N = p*q^2</code>.我们使用和前一种情况相同的方法进行方程转化.由于只有q的最高次数为2,所以将q作为未知参数进行转换:    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(p-1)*(q-1)*q = </span><br><span class="line">(p-1)*(q^2-q) = </span><br><span class="line">pq^2-pq-q^2+q = </span><br><span class="line">N-pq-q^2+q = | *q</span><br><span class="line">Nq-pq^2-q^3+q^2 = </span><br><span class="line">Nq-N-q^3+q^2</span><br><span class="line">final equation: e*d0*q - k*(Nq-N-q^3+q^2) == q mod 2**1050</span><br></pre></td></tr></table></figure><p>尽管我们无法确定最后两个密钥对应的顺序,我们只需要最多进行两次尝试就可以进行正确分解,从而得到q4,成功分解n4.   </p><h4 id="Case3-N-p-q-and-q-nbits-1400"><a href="#Case3-N-p-q-and-q-nbits-1400" class="headerlink" title="Case3: N = p*q and q.nbits() == 1400"></a>Case3: <code>N = p*q</code> and <code>q.nbits() == 1400</code></h4><p>这种情况下,分解方法同上面的一样: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(p-1)*(q-1) = </span><br><span class="line">pq-p-q+1 = </span><br><span class="line">N-p-q+1 = |*p</span><br><span class="line">Np-p^2-pq+p =</span><br><span class="line">Np-p^2-N+p</span><br><span class="line">final equation: e*d0*p - k*(Np-p^2-N+p) == p mod 2**1050</span><br></pre></td></tr></table></figure><p>成功分解n1之后依次解密可以得到最终的flag.   </p><h3 id="解题脚本-1"><a href="#解题脚本-1" class="headerlink" title="解题脚本"></a>解题脚本</h3><p>Case1: <code>N = p*q*r</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># exp.sage</span><br><span class="line">def find_p(d0, e, n, start, stop):</span><br><span class="line">    r = 32619972550448885952992763634430245734911201344234854263395196070105784406551510361671421185736962007609664176708457560859146461127127352439294740476944600948487063407599124272043110271125538616418873138407229</span><br><span class="line">    X = var(&apos;X&apos;)</span><br><span class="line">    for k in xrange(start, stop):</span><br><span class="line">        print(&quot;test for&quot;, k)</span><br><span class="line">        results = solve_mod([e*d0*r*X - k*(n*r*X -n*X - X*X*r*r + X*X*r - n*r + n +X*r*r - X*r) == X*r], 2^1050)</span><br><span class="line">        for x in results:</span><br><span class="line">            p0 = ZZ(x[0])</span><br><span class="line">            if is_prime(p0) and gcd(n,p0)!=1:</span><br><span class="line">                return p0</span><br></pre></td></tr></table></figure><p>Case2: <code>N = p*q^2</code><br>将上述函数的方程改为<code>results = solve_mod([e*d0*X - k*(n*X-n-X*X*X + X*X) == X], 2^1050)</code>即可.<br>Case3: <code>N = p*q</code> and <code>q.nbits() == 1400</code><br>将关键函数改为<code>results = solve_mod([e*d0*X - k*(n*X-X*X-n+X) == X], 2^1050)</code>即可.<br>得到所有参数之后直接解密: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util <span class="keyword">import</span> number</span><br><span class="line"></span><br><span class="line">e = <span class="number">1667</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">()</span>:</span></span><br><span class="line">    r = calculated_r</span><br><span class="line">    <span class="keyword">assert</span> gmpy2.is_prime(r)</span><br><span class="line">    n1 = given_n1</span><br><span class="line">    p1 = <span class="number">90298557884682577669238320760096423994217812898822512514104930945042122418007925771281125855142645396913218673571816112036657123492733042972301983242487835472292994595416656844378721884370309120262139835889657</span></span><br><span class="line">    q1 = (n1 // r) // p1</span><br><span class="line">    <span class="keyword">assert</span> gmpy2.is_prime(q1)</span><br><span class="line">    <span class="keyword">assert</span> gmpy2.is_prime(p1)</span><br><span class="line">    d1 = gmpy2.invert(e, (p1 - <span class="number">1</span>) * (q1 - <span class="number">1</span>) * (r - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    n2 = given_n2</span><br><span class="line">    p2 = <span class="number">142270506848638924547091203976235495577725242858694711068289574174127601000137457280276860615471044907560710121669055364010408768146949985099404319539891688093875478389341632242096859500255283810703767020918479</span></span><br><span class="line">    q2 = (n2 // r) // p2</span><br><span class="line">    <span class="keyword">assert</span> gmpy2.is_prime(q2)</span><br><span class="line">    <span class="keyword">assert</span> gmpy2.is_prime(p2)</span><br><span class="line">    d2 = gmpy2.invert(e, (p2 - <span class="number">1</span>) * (q2 - <span class="number">1</span>) * (r - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    q3 = <span class="number">267307309343866797026967908679365544381223264502857628608660439661084648014195234872217075156454448820508389018205344581075300847474799458610853350116251989700007053821013120164193801622760845268409925117073227</span></span><br><span class="line">    n3 = given_n3</span><br><span class="line">    p3 = n3 // (q3 * q3)</span><br><span class="line">    <span class="keyword">assert</span> gmpy2.is_prime(q3)</span><br><span class="line">    <span class="keyword">assert</span> gmpy2.is_prime(p3)</span><br><span class="line">    d3 = gmpy2.invert(e, (p3 - <span class="number">1</span>) * (q3 - <span class="number">1</span>) * q3)</span><br><span class="line"></span><br><span class="line">    p4 = <span class="number">188689169745401648234984799686937623590015544678958930140026860499157441295507274434268349194461155162481283679350641089523071656015001291946438485044113564467435184782104140072331748380561726605546500856968771</span></span><br><span class="line">    n4 = given_n4</span><br><span class="line">    q4 = n4 // p4</span><br><span class="line">    <span class="keyword">assert</span> gmpy2.is_prime(q4)</span><br><span class="line">    <span class="keyword">assert</span> gmpy2.is_prime(p4)</span><br><span class="line">    d4 = gmpy2.invert(e, (p4 - <span class="number">1</span>) * (q4 - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    ct = ciphertext</span><br><span class="line"></span><br><span class="line">    rsa1 = (n1, d1)</span><br><span class="line">    rsa2 = (n2, d2)</span><br><span class="line">    rsa3 = (n3, d3)</span><br><span class="line">    rsa4 = (n4, d4)</span><br><span class="line"></span><br><span class="line">    rsa = sorted([rsa1, rsa2, rsa3, rsa4], reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n, d <span class="keyword">in</span> rsa:</span><br><span class="line">        ct = pow(ct, d, n)</span><br><span class="line">    print(number.long_to_bytes(ct))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">solve()</span><br></pre></td></tr></table></figure><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>这两道题目分别运用了雅可比符号和方程化简的知识点.第二道题目使用sagemath这一工具快速解决模域方程问题,但sagemath的效率较低(可以考虑并行编程).<br>折腾了好久终于成功安装上sagemath这一数学工具,但爆破效率也太低了吧….需要抽个时间好好研究一下sage编程.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-几句废话&quot;&gt;&lt;a href=&quot;#0x00-几句废话&quot; class=&quot;headerlink&quot; title=&quot;0x00 几句废话&quot;&gt;&lt;/a&gt;0x00 几句废话&lt;/h2&gt;&lt;p&gt;可能是由于刚开学的原因,CTF线上赛不仅数量多,赛题质量也比较高.而且智能合约越来越
      
    
    </summary>
    
      <category term="CTF_Writeup" scheme="https://blank-vax.github.io/categories/CTF-Writeup/"/>
    
    
      <category term="RSA" scheme="https://blank-vax.github.io/tags/RSA/"/>
    
      <category term="sagemath" scheme="https://blank-vax.github.io/tags/sagemath/"/>
    
      <category term="Jacobi symbol" scheme="https://blank-vax.github.io/tags/Jacobi-symbol/"/>
    
  </entry>
  
  <entry>
    <title>数字证书</title>
    <link href="https://blank-vax.github.io/2020/11/09/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"/>
    <id>https://blank-vax.github.io/2020/11/09/数字证书/</id>
    <published>2020-11-09T02:39:34.445Z</published>
    <updated>2020-06-26T10:13:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h2><h3 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h3><ul><li>对称加密过程中，Alice和Bob使用相同的密钥进行数据加密</li><li>非对称加密过程中，密钥由（公钥，私钥）密钥对构成。<ul><li><strong>非对称密钥加解密</strong>：Alice与Bob通信过程中，Alice首先在公开信道上发送公钥。Bob使用Alice的公钥加密信息，随后Alice使用自己的私钥进行解密。</li><li><strong>非对称密钥签名</strong>：Alice使用私钥加密签名消息，Bob使用Alice的公钥对签名进行相关验证，以确认Alice的身份。</li></ul></li></ul><h3 id="特点及应用场景"><a href="#特点及应用场景" class="headerlink" title="特点及应用场景"></a>特点及应用场景</h3><p>由于对称加密具有更快的数据传输速度，而非对称加密具有更高的安全性，故实际应用过程中常常通过非对称加密的公钥对对称加密的密钥进行加密处理，随后接收方使用私钥进行解密，至此双方实现密钥共享。之后二者便可以用相同的对称加密密钥实现对大量数据的对称加解密过程。</p><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>数字证书（Digital Certificate or Public Key Certificate）指在互联网通讯中标志通讯各方身份信息的数字认证，在网络中使用其识别对方身份，本质上是一种身份证明电子文档。</p><p>证书授权中心CA（Certificate Authority）负责发放和管理数字证书，具有足够的权威性。</p><h3 id="证书分类"><a href="#证书分类" class="headerlink" title="证书分类"></a>证书分类</h3><p>按照持有者可分为个人证书、单位证书及系统证书。</p><p>按照证书用途可分为签名证书及加密证书，具体区别如下：</p><ul><li>签名证书用于签名和验证签名，为确保密钥安全，一般在客户端产生和保存密钥对。</li><li>加密证书用于加密，密钥对由CA产生，通过保护算法和协议发送给用户使用，同时CA中心对该密钥进行备份处理。</li></ul><h3 id="证书格式"><a href="#证书格式" class="headerlink" title="证书格式"></a>证书格式</h3><p>证书具有PEM和DER两种编码格式，其中PEM采用Base64编码字符保存，而DER格式采用二进制保存。</p><p>一张证书包含非对称加密密钥对，通常用.crt后缀标识公钥，用.key后缀标识私钥。还有一种将公钥与私钥捆绑保存的方法，其后缀通常为.pfx或.p12。</p><h3 id="证书内容"><a href="#证书内容" class="headerlink" title="证书内容"></a>证书内容</h3><p>证书公钥除保存公钥内容外，通常包含颁发者、使用者、有效期和签名等信息。</p><p>证书私钥中包含公钥信息以及所有非对称加密算法的参数。</p><h3 id="证书信任链"><a href="#证书信任链" class="headerlink" title="证书信任链"></a>证书信任链</h3><ul><li>CA：数字证书认证中心的简称。</li><li>根CA：处在信任链的顶端，其证书公钥默认导入各种操作系统和浏览器中。</li><li>中级CA：处于信任链的中部，由根CA或其他中级CA颁发的证书，本身还可以继续颁发子证书。</li><li><p>个人证书：处在信任链末端，由中级CA或根CA颁发的证书。</p></li><li><p>证书之间的信任关系可以嵌套。只要信任链上的头部证书，则后续证书均可信任。证书链的存在作用为降低中级CA私钥泄露造成的影响。</p></li></ul><p><img src="http://static.zybuluo.com/B1ank/td398udjr4yvi1054ybyl3wg/CA%E9%93%BE.png" alt="CA链.png-189.8kB"></p><h3 id="证书吊销列表"><a href="#证书吊销列表" class="headerlink" title="证书吊销列表"></a>证书吊销列表</h3><p>为防止证书持有者泄露证书私钥造成的身份冒用，各CA都维护一张CRL列表，内部标记虽处于有效期内但无法正常使用的证书。</p><h3 id="证书工作原理"><a href="#证书工作原理" class="headerlink" title="证书工作原理"></a>证书工作原理</h3><h4 id="数字证书生成"><a href="#数字证书生成" class="headerlink" title="数字证书生成"></a>数字证书生成</h4><p>服务器给客户端发送公钥的过程中，将公钥与服务器的个人信息通过哈希算法生成消息摘要。为防止摘要被人调换，服务器还会用CA提供的私钥对消息摘要进行加密，从而形成数字签名。最后服务器将未经哈希处理的信息与数字签名合并在一起形成数字证书。</p><p><img src="http://static.zybuluo.com/B1ank/6oq68hu6r9u1u5q3sepxub6y/certificate_generation.png" alt="certificate_generation.png-47.7kB"></p><h4 id="数字证书验证"><a href="#数字证书验证" class="headerlink" title="数字证书验证"></a>数字证书验证</h4><p>客户端收到数字证书后，使用CA提供的公钥对数字证书内部的数字签名进行解密得到消息摘要，随后对数字证书内部服务器的公钥和个人信息进行哈希计算以获取另外一份消息摘要。对比这两份摘要，若吻合则通过服务器身份验证，否则不通过验证。</p><p><img src="http://static.zybuluo.com/B1ank/hru2f9uxqjlulau1qtwurf3j/certificate_verification.png" alt="certificate_verification.png-108.7kB"></p><h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><p>SSL（Secure Sockets Layer，安全套接层）是HTTPS下的协议加密层，建立在可靠的传输协议上，为高层协议提供数据封装、压缩、加密等基本功能，主要分为以下两层：</p><h4 id="SSL记录协议层"><a href="#SSL记录协议层" class="headerlink" title="SSL记录协议层"></a>SSL记录协议层</h4><p>SSL记录协议层为高层协议提供基本的安全服务，记录封装各种高层协议，具体实施压缩解压缩、加密解密、计算和校验MAC等与安全有关的操作。</p><h4 id="SSL握手协议层"><a href="#SSL握手协议层" class="headerlink" title="SSL握手协议层"></a>SSL握手协议层</h4><p>SSL握手协议层包括SSL握手协议（SSL HandShake Protocol）、SSL密码参数修改协议（SSL Change Cipher Spec Protocol）、应用数据协议（Application Data Protocol）和SSL告警协议（SSL Alert Protocol）。这些协议用于SSL管理信息的交换，允许应用协议传送数据之前相互验证，执行协商加密算法和生成密钥等操作，以建立同步状态。</p><h4 id="SSL单向认证过程"><a href="#SSL单向认证过程" class="headerlink" title="SSL单向认证过程"></a>SSL单向认证过程</h4><p><img src="http://static.zybuluo.com/B1ank/exmuhynb7xl7tt7n8qirtmc4/SSL%E5%8D%95%E5%90%91%E8%AE%A4%E8%AF%81.png" alt="SSL单向认证.png-260kB"></p><p>单向认证过程中只进行客户端对服务器的认证。客户端首先向服务器发送<code>Client Hello</code>数据包，包含随机数A以及可供选择的加密套件与加密算法参数。服务器收到后回复<code>Server Hello</code>数据包，包含随机数B及服务器选择的加密套件，随后回复证书链并完成服务器数据发送。客户端收到后验证服务器证书链并发送使用服务器公钥加密后的随机数C，服务器端使用私钥对客户端发送信息进行解密以获取随机数C。至此双方均获得随机数A、B、C，使用这三个随机数并结合服务器选择的加密套件，对数据流进行对称加密，实现安全传输。</p><h4 id="SSL双向认证过程"><a href="#SSL双向认证过程" class="headerlink" title="SSL双向认证过程"></a>SSL双向认证过程</h4><p><img src="http://static.zybuluo.com/B1ank/s7e55r8ztxga58iz3er1qqrt/SSL%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81.png" alt="SSL双向认证.png-325.8kB"></p><p>与单向认证相比，双向认证过程中除进行客户端对服务器证书链的验证外，还包含服务器对客户端的证书链验证操作，从而实现双向安全认证。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;密码学基础&quot;&gt;&lt;a href=&quot;#密码学基础&quot; class=&quot;headerlink&quot; title=&quot;密码学基础&quot;&gt;&lt;/a&gt;密码学基础&lt;/h2&gt;&lt;h3 id=&quot;对称加密与非对称加密&quot;&gt;&lt;a href=&quot;#对称加密与非对称加密&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Digital Certificate" scheme="https://blank-vax.github.io/tags/Digital-Certificate/"/>
    
  </entry>
  
  <entry>
    <title>信息安全概述</title>
    <link href="https://blank-vax.github.io/2020/11/09/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/"/>
    <id>https://blank-vax.github.io/2020/11/09/信息安全概述/</id>
    <published>2020-11-09T02:39:34.445Z</published>
    <updated>2020-07-06T02:32:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安全背景"><a href="#安全背景" class="headerlink" title="安全背景"></a>安全背景</h2><ul><li>数字化时代威胁升级</li><li>传统安全防护在数字化转型中逐渐失效</li><li>安全风险能见度不足<ul><li>资产更替较快，无法全方位把握所有资产，导致安全加固操作不到位；</li><li>缺乏对水坑攻击、鱼叉邮件攻击、0day漏洞等新型威胁的及时全面的探测；</li><li>缺乏对预留后门、合法用户伪装等潜藏风险的把控；</li></ul></li><li>缺乏自动化防御手段</li><li>网络安全监管标准愈发严苛</li></ul><h2 id="常见网络安全术语"><a href="#常见网络安全术语" class="headerlink" title="常见网络安全术语"></a>常见网络安全术语</h2><ul><li>漏洞：可能被一个或多个威胁利用的资产或控制的弱点，包括软件漏洞、硬件漏洞、协议漏洞、算法漏洞等。</li><li>0day漏洞：亟待官方发现及开发安全补丁的漏洞。0day漏洞公开后称为Nday漏洞。</li><li>WEBSHELL：以asp、php、jsp或cgi等网页文件形式存在的一种命令执行环境。攻击者利用服务器本身开设的80端口采用POST请求上传WEBSHELL，绕过防火墙的检测，达到入侵服务器并提升用户权限的目的，最终实现完全控制服务器。针对这一攻击，可以通过设置白名单的方式限制文件上传。</li><li>exploit：漏洞利用即exp。本地攻击与远程攻击。</li><li>APT攻击：高级持续性威胁（Advanced Persistent Thread），利用先进的攻击手段对特定目标进行长期持续性网络攻击的攻击形式。</li></ul><h2 id="协议栈自身脆弱性及常见攻击"><a href="#协议栈自身脆弱性及常见攻击" class="headerlink" title="协议栈自身脆弱性及常见攻击"></a>协议栈自身脆弱性及常见攻击</h2><h3 id="协议栈脆弱性"><a href="#协议栈脆弱性" class="headerlink" title="协议栈脆弱性"></a>协议栈脆弱性</h3><ul><li>缺乏数据源验证机制</li><li>缺乏机密性保障机制</li><li>缺乏完整性检验机制</li></ul><h3 id="网络攻击基本模式"><a href="#网络攻击基本模式" class="headerlink" title="网络攻击基本模式"></a>网络攻击基本模式</h3><p>网络攻击包括被动威胁和主动威胁。其中被动威胁主要指截获这一手段，主动威胁包括篡改、中断和伪造这三种手段。</p><ul><li>截获—&gt;机密性：包括嗅探（Sniffing）和监听（Eavesdropping）；</li><li>篡改—&gt;完整性：主要指数据包篡改（Tampering）；</li><li>中断—&gt;可用性：常见的有拒绝服务（Dosing）；</li><li>伪造—&gt;真实性：通过欺骗（Spoofing）的方法破坏信息真实性；</li></ul><h3 id="常见攻击手段"><a href="#常见攻击手段" class="headerlink" title="常见攻击手段"></a>常见攻击手段</h3><ul><li>物理层：设备破坏、线路侦听</li><li>数据链路层：MAC欺骗、MAC泛洪、ARP欺骗</li><li>网络层：IP欺骗、Smurf攻击、ICMP攻击、地址扫描</li><li>传输层：TCP欺骗、TCP DOS、UDP DOS、端口扫描</li><li>应用层：漏洞、缓冲区溢出攻击、WEB应用攻击、病毒木马</li></ul><h4 id="物理层——物理攻击"><a href="#物理层——物理攻击" class="headerlink" title="物理层——物理攻击"></a>物理层——物理攻击</h4><ul><li>物理设备破坏：设备破坏攻击的目的主要是为了中断网络服务；</li><li>物理设备窃听：包括光纤监听和红外监听。</li><li>自然灾害：为尽量减少突发自然灾害对重要数据的破坏，常建设异地灾备数据中心。</li></ul><h4 id="数据链路层——MAC泛洪攻击"><a href="#数据链路层——MAC泛洪攻击" class="headerlink" title="数据链路层——MAC泛洪攻击"></a>数据链路层——MAC泛洪攻击</h4><p>泛洪攻击中，攻击者利用交换机中存储的MAC地址表的自动学习机制不断发送不同MAC地址给交换机，从而填满整个MAC表，此时交换机只能进行数据广播，攻击者凭此获得信息。由于交换机之间具有级联机制，故与受感交换机相连的所有交换机MAC地址表均被填满，整个网络出现数据发送缓慢、丢包甚至瘫痪的情况。可以在交换机上设置相应的端口保护机制以限制单个端口最大MAC数据接收条目数量。</p><h4 id="数据链路层——ARP欺骗"><a href="#数据链路层——ARP欺骗" class="headerlink" title="数据链路层——ARP欺骗"></a>数据链路层——ARP欺骗</h4><p>当A、B需要通讯时，A发送ARP请求询问B的MAC地址。攻击者冒充B持续发送ARP响应给A，并传递攻击者主机MAC地址，随后A发送给B的正常数据包都会被转发到攻击者主机处。</p><h4 id="网络层——ICMP攻击"><a href="#网络层——ICMP攻击" class="headerlink" title="网络层——ICMP攻击"></a>网络层——ICMP攻击</h4><p>ICMP具有多个控制报文如重定向和网络不可达等，常用于指导数据包的正确路由。</p><ul><li>ICMP重定向攻击中，攻击者主动向受害者发送ICMP重定向报文，改变受害者数据包传输路由，使其发送到不存在的网关，从而使得网关无法收到数据包，实现拒绝服务攻击。</li><li>ICMP不可达攻击中，攻击者向网关发送特定IP地址主机ICMP不可达报文，网关收到后便将受害者主机标记为不可达，从而导致受害者无法收到数据包。</li></ul><p>解决方法：通过修改注册表关闭ICMP不可达报文及重定向报文的处理功能。</p><h4 id="传输层——TCP-SYN-Flood攻击"><a href="#传输层——TCP-SYN-Flood攻击" class="headerlink" title="传输层——TCP SYN Flood攻击"></a>传输层——TCP SYN Flood攻击</h4><p>SYN报文是TCP连接的第一个报文，攻击者通过大量发送SYN报文，造成大量未完全建立的TCP连接，从而占用被攻击者的资源，以达到拒绝服务攻击的目的。</p><h4 id="应用层——DNS欺骗攻击"><a href="#应用层——DNS欺骗攻击" class="headerlink" title="应用层——DNS欺骗攻击"></a>应用层——DNS欺骗攻击</h4><p>攻击者通过篡改DNS服务器上的DNS数据破坏域名与IP地址的对应关系，当用户输入访问网站的URL后，该域名被解析成攻击者事先设置好的钓鱼网站对应的IP地址，随后用户主机会访问该IP地址进入钓鱼网站。</p><h3 id="DDoS攻击风险防护方案"><a href="#DDoS攻击风险防护方案" class="headerlink" title="DDoS攻击风险防护方案"></a>DDoS攻击风险防护方案</h3><ul><li><p>网络设备性能充裕</p><p>防火墙、路由器、交换机性能富余。</p></li><li><p>网络带宽资源充裕</p><p>保持一定比例的网络带宽余量。</p></li><li><p>异常流量清洗</p><p>通过抗D设备清洗异常流量。</p></li><li><p>通过CDN分流</p><p>多节点分担DDoS攻击流量。</p></li><li><p>分布式集群</p><p>每个节点分配足够资源数据回发瘫痪攻击源。</p></li></ul><h2 id="操作系统的脆弱性及常见攻击"><a href="#操作系统的脆弱性及常见攻击" class="headerlink" title="操作系统的脆弱性及常见攻击"></a>操作系统的脆弱性及常见攻击</h2><h3 id="操作系统漏洞分类"><a href="#操作系统漏洞分类" class="headerlink" title="操作系统漏洞分类"></a>操作系统漏洞分类</h3><ul><li>人为原因：开发者在程序代码中故意隐藏后门。</li><li>客观原因：受开发者能力、经验及当时安全技术限制，程序设计过程中存在不足之处，导致权限提升等后果。</li><li>硬件原因：编程人员无法弥补硬件自身的安全漏洞，从而使硬件问题通过软件体现。</li></ul><h3 id="缓冲区溢出攻击"><a href="#缓冲区溢出攻击" class="headerlink" title="缓冲区溢出攻击"></a>缓冲区溢出攻击</h3><p>缓冲区溢出攻击利用编写不够严谨的程序，通过向程序的缓冲区写入超过预定长度的数据，造成缓存溢出，从而破坏程序的堆栈结构，导致程序执行流程的改变，达到破坏系统或提取关键信息的目的。攻击者如果可以精确控制内存跳转地址，就可以执行指定代码，获得权限或破坏系统。</p><p><img src="http://static.zybuluo.com/B1ank/iqj0joxzi58uv01phvganocc/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA.png" alt="缓冲区溢出.png-160.9kB"></p><p>缓冲区溢出的防范可以通过以下方面考虑：</p><ul><li>用户层面需要及时更新系统及软件补丁，并保持防火墙常开。</li><li>开发人员开发程序过程中，需要编写安全代码，对输入数据进行验证，如限制输入数据的长度。同时需要使用相对安全的函数，如C语言在字符串处理过程中提供大量安全函数，如<code>strcat_s()</code>，<code>strcpy_s()</code>，<code>gets_s()</code>等。</li><li>系统层面可以运用缓冲区不可执行技术来防止缓冲区恶意代码执行，也可以采用虚拟化技术来防止缓冲区溢出漏洞的产生。</li></ul><p>由于现阶段大量程序执行过程中均会由操作系统分配随机起始地址，故对于攻击者来说获取准确的函数返回地址并实现恶意代码执行较为困难。</p><h2 id="终端的脆弱性及常见攻击"><a href="#终端的脆弱性及常见攻击" class="headerlink" title="终端的脆弱性及常见攻击"></a>终端的脆弱性及常见攻击</h2><h3 id="勒索病毒"><a href="#勒索病毒" class="headerlink" title="勒索病毒"></a>勒索病毒</h3><p>作为一种恶意程序，勒索病毒可以感染设备、网络与数据中心并使其瘫痪，直至用户支付赎金使系统解锁。该类病毒执行过程如下：受害者主机植入勒索病毒后，病毒本身调用加密算法库解密自身数据并回连服务器，随后通过脚本文件执行HTTP GET请求并下载加密后的文件，随后在受害者主机环境中进行文件解密并将该文件封装成动态链接库，随后通过wscript执行DLL文件通过遍历系统文件的方法收集计算机信息。勒索病毒会将电脑中的各类文档进行加密，让用户无法打开，并弹窗限时勒索付款提示信息，达到勒索赎金的目的。</p><h4 id="发展阶段"><a href="#发展阶段" class="headerlink" title="发展阶段"></a>发展阶段</h4><ul><li>第一阶段：2008年以前，只锁定用户设备不加密数据，以LockScreen为代表家族。</li><li>第二阶段：2013年以前，采用高强度对称和非对称加密算法加密用户数据，以CTB-Locker、TeslaCrypt、Cerber为代表家族。</li><li><p>第三阶段：2017年前后，通过系统漏洞或弱口令等方式发起蠕虫式攻击，攻陷单点设备后还会在内网中横向扩散，以WannaCry和Satan为代表。</p></li><li><p>第四阶段：加密货币的出现改变勒索格局，加密货币具有匿名性与去中心化的特点，解决攻击者的传统问题，脱离货币交易链的追查与监管，黑色产业因此蓬勃发展。</p></li><li>第五阶段：勒索软件服务化，RaaS模式初见规模。</li></ul><h4 id="勒索病毒感染与传播方式"><a href="#勒索病毒感染与传播方式" class="headerlink" title="勒索病毒感染与传播方式"></a>勒索病毒感染与传播方式</h4><p><img src="http://static.zybuluo.com/B1ank/kf8g2f60fue34frqaqbdqzti/%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E6%84%9F%E6%9F%93%E4%B8%8E%E4%BC%A0%E6%92%AD%E6%96%B9%E5%BC%8F.png" alt="勒索病毒感染与传播方式.png-798.9kB"></p><h4 id="勒索病毒攻击链"><a href="#勒索病毒攻击链" class="headerlink" title="勒索病毒攻击链"></a>勒索病毒攻击链</h4><p><strong>感染媒介—&gt;C&amp;C通信—&gt;文件加密—&gt;横向移动</strong></p><h4 id="高效勒索病毒协同防护体系"><a href="#高效勒索病毒协同防护体系" class="headerlink" title="高效勒索病毒协同防护体系"></a>高效勒索病毒协同防护体系</h4><p><img src="http://static.zybuluo.com/B1ank/46s9biegbyjcg5rdic2oteuz/%E6%9E%84%E5%BB%BA%E9%AB%98%E6%95%88%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%8D%8F%E5%90%8C%E9%98%B2%E6%8A%A4%E4%BD%93%E7%B3%BB.png" alt="构建高效勒索病毒协同防护体系.png-1277.5kB"></p><h3 id="挖矿病毒"><a href="#挖矿病毒" class="headerlink" title="挖矿病毒"></a>挖矿病毒</h3><p>作为一种恶意程序，挖矿程序可以自动传播，在未授权的情况下占用系统资源，为攻击者牟利，使得受害者机器性能明显下降，影响正常使用。挖矿病毒占用CPU或GPU等计算资源，自动创建后门与混淆进程，同时该病毒定期改变进程名与PID并检测系统中是否存在对应的挖矿软件，若被查杀则再次从远端服务器上获取资源。同时该病毒通过扫描SSH文件感染其他机器，实现横向传播。</p><h3 id="特洛伊木马"><a href="#特洛伊木马" class="headerlink" title="特洛伊木马"></a>特洛伊木马</h3><p>完整的木马程序一般由服务器程序与控制器程序两部分组成，当受害者主机安装了木马的服务器程序后，拥有控制器程序的攻击者就可以通过网络控制受害者主机。木马程序通常注入正常程序中，当用户执行正常程序时启动。同时，木马程序自动在任务管理器中隐藏，并以”系统服务”的方式欺骗操作系统，包含具有未公开并且可能产生危险后果的功能的程序，具备自动恢复与打开特殊端口的功能。</p><h3 id="蠕虫病毒"><a href="#蠕虫病毒" class="headerlink" title="蠕虫病毒"></a>蠕虫病毒</h3><p>蠕虫是一种可以自我复制并通过网络传播的代码，通常无需人为干预即可实现传播。蠕虫病毒入侵并完全控制一台计算机后，就会把这台主机作为宿主，进而扫描并感染其他计算机。蠕虫病毒具有不依赖宿主程序、利用漏洞主动攻击、通过蠕虫网络隐藏攻击者位置的特点。该类病毒易造成拒绝服务与隐私信息丢失。</p><h3 id="宏病毒"><a href="#宏病毒" class="headerlink" title="宏病毒"></a>宏病毒</h3><p>宏病毒是一种寄存在文档或模板的宏中的计算机病毒，具有感染文档、传播速度快、病毒制作周期短、可实现多平台交叉感染的特点。宏病毒通过调用系统命令造成系统破坏，除此之外，感染宏病毒的文档无法正常打印，并具有封闭或改变文件存储路径、非法复制文件等行为。</p><h3 id="僵尸网络"><a href="#僵尸网络" class="headerlink" title="僵尸网络"></a>僵尸网络</h3><p>采用一种或多种传播手段，将大量主机感染僵尸程序，从而在控制者和被感染主机之间形成一个一对多控制网络。僵尸网络的形成过程包含<strong>加入、传播和控制</strong>三个阶段。</p><p>僵尸程序多指实现恶意控制功能的程序代码，控制服务器多指控制和通信的中心服务器。</p><h2 id="其他常见攻击"><a href="#其他常见攻击" class="headerlink" title="其他常见攻击"></a>其他常见攻击</h2><h3 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h3><p>社会工程攻击通常被认为是一种欺诈他人以收集信息、行骗和入侵计算机系统的行为，可以通过定期更换各种系统账号密码或使用高强度密码等防御该类攻击。</p><h3 id="人为因素"><a href="#人为因素" class="headerlink" title="人为因素"></a>人为因素</h3><ul><li>无意行为：如工作失误、经验问题、体制不健全等；</li><li>恶意行为：攻击者出于政治、经济、商业或个人目的制造病毒及破坏性程序，攻击企业信息系统并获取重要资料。</li><li>防范措施<ul><li>提升安全意识</li><li>最低权限访问模式</li><li>完善和落地管理措施</li><li>利用已有安全手段对核心资产进行安全保护</li></ul></li></ul><h3 id="拖库洗库撞库"><a href="#拖库洗库撞库" class="headerlink" title="拖库洗库撞库"></a>拖库洗库撞库</h3><p>拖库是指黑客入侵有价值的网络站点并将注册用户的资料数据库全部盗走的行为。</p><p>洗库指在获取大量用户数据后，黑客通过一系列的技术手段和黑色产业链将有价值的用户数据变现的行为。</p><p>撞库指黑客利用获得的私密数据在其他网站上进行登录尝试的行为。</p><h3 id="跳板攻击"><a href="#跳板攻击" class="headerlink" title="跳板攻击"></a>跳板攻击</h3><p>攻击者通常不直接通过自己的系统向目标发动攻击，而是先攻破若干中间系统并将其作为”跳板”，借助这些计算机完成攻击行动。用户可以通过安装防火墙以控制流量进出、更改系统默认登录用户为普通用户并做好权限控制等手段抵御此类攻击。</p><h3 id="钓鱼式攻击"><a href="#钓鱼式攻击" class="headerlink" title="钓鱼式攻击"></a>钓鱼式攻击</h3><p>钓鱼攻击是一种企图从电子通讯中，通过伪装成信誉卓著的法人媒体以获得如用户名、密码和信用卡明细等个人敏感信息的犯罪诈骗过程。鱼叉式钓鱼攻击指针对特定受害公司或组织的钓鱼攻击，其钓鱼页面设计与整体操作流程具有定制化、精准化的特点，成功率较高。可以通过保证网络站点与用户之间的安全传输、加强网络站点的认证过程与监管等方式防御此类攻击。</p><h3 id="水坑攻击"><a href="#水坑攻击" class="headerlink" title="水坑攻击"></a>水坑攻击</h3><p>攻击者首先通过观察或猜测确定特定目标经常访问的网站，并入侵其中一个或多个网站，植入恶意软件。当目标组织或组织中部分成员访问该类网站时会被重定向到恶意网址，导致恶意软件执行，最终造成该组织机器的大量感染。为抵御此类攻击，运维人员通常在浏览器或软件上进行安全杀毒和检测工作，若检测到恶意内容，则持续监控该网站流量并阻止恶意流量。此外，运维人员可以通过定期更新补丁的方式减少浏览器漏洞。</p><h2 id="信息安全要素"><a href="#信息安全要素" class="headerlink" title="信息安全要素"></a>信息安全要素</h2><ul><li><p>保密性Confidentiality</p><p>确保信息不暴露给未授权的实体或进程。</p></li><li><p>完整性Integrity</p><p>只有得到允许的用户才能修改实体或进程，并且能够判别出实体或进程是否被篡改。</p></li><li><p>可用性Availability</p><p>得到授权的实体可获得服务，攻击者不能占用所有资源而阻碍授权者的工作。</p></li><li><p>可控性Controllability</p><p>可控性主要指对危害国家信息（包括利用加密的非法通信活动）的监视审计。</p></li><li><p>不可否认性Non-repudiation</p><p>为出现的安全问题提供调查的依据和手段，使用审计、监控、防抵赖等安全机制使得攻击者无法否认相关操作。</p></li></ul><h2 id="安全解决方案"><a href="#安全解决方案" class="headerlink" title="安全解决方案"></a>安全解决方案</h2><h3 id="企业安全解决方案构建"><a href="#企业安全解决方案构建" class="headerlink" title="企业安全解决方案构建"></a>企业安全解决方案构建</h3><h4 id="企业信息安全建设规划目标"><a href="#企业信息安全建设规划目标" class="headerlink" title="企业信息安全建设规划目标"></a>企业信息安全建设规划目标</h4><ul><li>风险可视化Visibility</li><li>防御主动话Proactive</li><li>运行自动化Automation</li><li>安全智能化Intelligent</li></ul><h4 id="传统安全方案痛点"><a href="#传统安全方案痛点" class="headerlink" title="传统安全方案痛点"></a>传统安全方案痛点</h4><ul><li>产品堆叠为主</li><li>边界防护为主</li><li>被动防守为主</li></ul><h4 id="APDRO智安全架构"><a href="#APDRO智安全架构" class="headerlink" title="APDRO智安全架构"></a>APDRO智安全架构</h4><ul><li>智能Artificial Intelligence</li><li>防御Protect</li><li>检测Detect</li><li>响应Respond</li><li>运营Operate</li></ul><h4 id="安全域划分"><a href="#安全域划分" class="headerlink" title="安全域划分"></a>安全域划分</h4><p>将企业数据区域进行安全等级划分，分成<strong>非安全区</strong>、<strong>半安全区</strong>、<strong>安全区</strong>和<strong>核心安全区</strong>四个部分。</p><ul><li>非安全区是数据中心等关键区域与外部直接连接的区域，属于非信任区域。</li><li>半安全区是非安全区与安全区之间的过渡区域，用于分割它们之间的直接联系，隐藏安全区的内部资源。</li><li>安全区是安全级别次高的区域。</li><li>核心安全区是安全级别最高的区域。</li></ul><p>各安全域访问原则如下：</p><p><img src="http://static.zybuluo.com/B1ank/3ks10jb35kbi99384msudatw/%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86.png" alt="安全区域划分.png-118.4kB"></p><h3 id="上网行为安全解决方案-AC"><a href="#上网行为安全解决方案-AC" class="headerlink" title="上网行为安全解决方案 AC"></a>上网行为安全解决方案 AC</h3><h4 id="上网行为可视"><a href="#上网行为可视" class="headerlink" title="上网行为可视"></a>上网行为可视</h4><ul><li>用户可视</li><li>流量&amp;应用可视</li><li>内容可视</li></ul><h4 id="上网行为可控"><a href="#上网行为可控" class="headerlink" title="上网行为可控"></a>上网行为可控</h4><ul><li>工作效率提升</li><li>流量可视可控</li><li>规避法律法规法风险</li></ul><h3 id="纵深边界安全解决方案-Firewall"><a href="#纵深边界安全解决方案-Firewall" class="headerlink" title="纵深边界安全解决方案 Firewall"></a>纵深边界安全解决方案 Firewall</h3><h4 id="精细化资产攻击面管理"><a href="#精细化资产攻击面管理" class="headerlink" title="精细化资产攻击面管理"></a>精细化资产攻击面管理</h4><ul><li>资产可视</li><li>高危端口可视</li><li>策略智能调优</li></ul><h4 id="场景化安全防护实践"><a href="#场景化安全防护实践" class="headerlink" title="场景化安全防护实践"></a>场景化安全防护实践</h4><ul><li>防黑客渗透</li><li>防内网病毒扩散</li><li>办公环境安全性&amp;连续性保障</li><li>资产失陷外连泄密防护</li></ul><h3 id="移动接入安全解决方案"><a href="#移动接入安全解决方案" class="headerlink" title="移动接入安全解决方案"></a>移动接入安全解决方案</h3><h4 id="端到端移动安全"><a href="#端到端移动安全" class="headerlink" title="端到端移动安全"></a>端到端移动安全</h4><ul><li>精确身份认证</li><li>角色授权与URL级别授权</li><li>支持1024、2028位商密或国密算法</li><li>主从账号绑定、服务器地址伪装、应用隐藏</li></ul><h4 id="创新移动终端安全"><a href="#创新移动终端安全" class="headerlink" title="创新移动终端安全"></a>创新移动终端安全</h4><ul><li>移动终端个人域与工作域隔离</li><li>防中间人攻击、客户端安全检查</li><li>SSL专线、客户端痕迹清除</li></ul><h3 id="端点安全"><a href="#端点安全" class="headerlink" title="端点安全"></a>端点安全</h3><h4 id="方案优势"><a href="#方案优势" class="headerlink" title="方案优势"></a>方案优势</h4><ul><li>支持多个操作系统</li><li>实现跨平台</li><li>集中管控</li><li>轻量级</li></ul><h4 id="加固"><a href="#加固" class="headerlink" title="加固"></a>加固</h4><p>用于业务域内部及业务域之间，基于应用策略，实现主机东西向流量访问控制。</p><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><p>全面探测服务器主机和网络上的威胁活动，进行入侵行为主动IP封堵与恶意文件隔离。</p><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><p>结合传统技术与人工智能，采用机器学习模型实现针对病毒木马、僵尸网络及暴力破解行为的检测。</p><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><p>采用IP黑白名单机制及文件隔离机制，监控进程的可疑行为，以即时拦阻恶意代码。</p><h3 id="网络安全拓扑参考"><a href="#网络安全拓扑参考" class="headerlink" title="网络安全拓扑参考"></a>网络安全拓扑参考</h3><p><img src="http://static.zybuluo.com/B1ank/0oyed4w8i7oqhv4wlm20lt2s/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8B%93%E6%89%91%E5%8F%82%E8%80%83.png" alt="网络安全拓扑参考.png-1531.1kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安全背景&quot;&gt;&lt;a href=&quot;#安全背景&quot; class=&quot;headerlink&quot; title=&quot;安全背景&quot;&gt;&lt;/a&gt;安全背景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数字化时代威胁升级&lt;/li&gt;
&lt;li&gt;传统安全防护在数字化转型中逐渐失效&lt;/li&gt;
&lt;li&gt;安全风险能见度不足&lt;
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Information Security" scheme="https://blank-vax.github.io/tags/Information-Security/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界 —— Crypto(新手区)</title>
    <link href="https://blank-vax.github.io/2020/11/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%20%E2%80%94%E2%80%94%20Crypto%EF%BC%88%E6%96%B0%E6%89%8B%E5%8C%BA%EF%BC%89/"/>
    <id>https://blank-vax.github.io/2020/11/09/攻防世界 —— Crypto（新手区）/</id>
    <published>2020-11-09T02:39:34.445Z</published>
    <updated>2020-03-04T11:25:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近打算边上课边刷一下攻防世界的题目，一是为了保持密码学的做题手感，二是为了打发上某些课的时间（指一心二用，因为某些课实在是太无聊了），话不多说，开始。</p><h2 id="0x01-base64"><a href="#0x01-base64" class="headerlink" title="0x01 base64"></a>0x01 base64</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题属于密码学部分的签到题，结合提示与附件内容可以发现其为base64加密，直接写脚本解密即可。</p><p>需要注意的是，python2中base系列直接对字符串进行加解密，得到的结果都是字符串类型。</p><p>然而python3中，如果直接对字符串类型的明文进行加密，系统会抛出类型错误报错：</p><p><img src="http://static.zybuluo.com/B1ank/gsnd1cbd66h0q20n8tpzj8ov/base2.PNG" alt="base2.PNG-4kB"></p><p>根据报错提示可知，python3中base系列函数对字节类型的变量而非字符串进行加解密，所以我们需要使用<code>string.encode()</code>函数完成string类型到bytes类型的转换，使用<code>byte.decode()</code>完成bytes类型到string类型的转换。</p><h3 id="解题脚本"><a href="#解题脚本" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">ciphertext = <span class="string">'Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9'</span></span><br><span class="line">plaintext = base64.b64decode(ciphertext)</span><br><span class="line">print(plaintext.decode())</span><br></pre></td></tr></table></figure><h3 id="一些经验"><a href="#一些经验" class="headerlink" title="一些经验"></a>一些经验</h3><p>分辨base系列典型的三种加密方式对应密文：</p><ul><li>Base16：该编码使用16个ASCII可打印字符对任意字节数据进行编码，编码后的数据量是原数据的两倍。故编码结果范围为十六进制数字。</li><li>Base32：该编码使用32个可打印字符对任意字节数据进行编码，编码结果范围为字母A-Z和数字2-7，如果位数不够则使用=进行填充。</li><li>Base64：该编码使用64个可打印ASCII字符将任意字节序列编码成ASCII字符串，编码结果范围为字母A-Z，a-z，数字0-9以及字符+/，如果位数不够则使用=进行填充。</li></ul><p>我们可以观察得到的密文结尾，一般以=结尾的密文大概率是base32/64加密的结果。</p><p>当然，一般题目不会简单到提供base加密后的密文，然后经过一次解密直接得到flag。大部分对于base系列加解密应用的题目可分为两种：一种是将base作为混淆的手段嵌入到加解密算法中，我们需要通过多种分析写出逆算法解得flag；还有一种是将base与web系列的题目结合，用于加密数据包中的信息。</p><p>除此之外还有一类仅由base系列构成的加密，即使用base16/32/64进行多次加密，这类题目我们需要编写循环，根据每次解得密文的特点来选择下次解密使用的算法。当然，base36/58/85等算法在各类题目中也层出不穷，当使用常用base算法无法解密密文时，可以考虑这些不常见的算法。</p><p>我们来探寻base系列算法的本质，baseN就是使用选定的N个ASCII可打印字符将任意字节数据编码成ASCII字符串，从而达到正常传输数据的目的。我们可以将其等价转换为N进制来理解。</p><h2 id="0x02-Caesar"><a href="#0x02-Caesar" class="headerlink" title="0x02 Caesar"></a>0x02 Caesar</h2><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>根据题目的提示Caesar，可知该题目解题的方法与凯撒密码相关。对于凯撒位移，我们直接采用爆破移动位数的方法，对于密文提供的<code>{}</code>和<code>_</code>这种特殊标志，我们保持原状即可。</p><p>最后从运行结果中找到合理的明文即为答案。</p><p><img src="http://static.zybuluo.com/B1ank/kp0pzflkt41oxadf4prqk477/caesar.PNG" alt="caesar.PNG-43.5kB"></p><h3 id="解题脚本-1"><a href="#解题脚本-1" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ciphertext = <span class="string">'oknqdbqmoq&#123;kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz&#125;'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">    result = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> ciphertext:</span><br><span class="line">        <span class="keyword">if</span> ord(item) &gt; <span class="number">122</span> <span class="keyword">or</span> ord(item) &lt; <span class="number">97</span>:</span><br><span class="line">            result += item</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result += str(chr((ord(item)-ord(<span class="string">'a'</span>)+i)%<span class="number">26</span> + ord(<span class="string">'a'</span>)))</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure><h3 id="一些经验-1"><a href="#一些经验-1" class="headerlink" title="一些经验"></a>一些经验</h3><p>原始的凯撒密码是一个移动位数为3的单表代换加密过程。由凯撒延申出来的ROT系列如ROT5，ROT13等将移动位数变成了5位和13位等。对于该系列的密文，我们可以进行爆破处理，从最终的结果中寻找合理的结果作为明文。还有一种名为<code>雷劈密码</code>的类凯撒加密，其特点为每一个字符移动的位数不同但有等差规律。</p><p>对于纯凯撒密码的题目，如果有flag格式，其移动位数可以通过<code>{</code>前的字符与flag前缀一一对应得到。</p><h2 id="0x03-Morse"><a href="#0x03-Morse" class="headerlink" title="0x03 Morse"></a>0x03 Morse</h2><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题的提示为Morse即摩斯电码，我们打开附件可以发现只有0和1两个字符，并且分隔符为空格。</p><p>使用python编写自动替代脚本先将1转换为<code>.</code>，0转换为<code>-</code>，进行解密测试，如果不正确则进行相反转换即可。</p><h3 id="解题脚本-2"><a href="#解题脚本-2" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 摩斯电码检测</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Morse_decode</span><span class="params">(ciphertext)</span>:</span></span><br><span class="line">    Morse_dict = &#123;<span class="string">".-"</span> : <span class="string">"A"</span>,</span><br><span class="line">            <span class="string">"-..."</span> : <span class="string">"B"</span>,</span><br><span class="line">            <span class="string">"-.-."</span> : <span class="string">"C"</span>,</span><br><span class="line">            <span class="string">"-.."</span> : <span class="string">"D"</span>,</span><br><span class="line">            <span class="string">"."</span> : <span class="string">"E"</span>,</span><br><span class="line">            <span class="string">"..-."</span> : <span class="string">"F"</span>,</span><br><span class="line">            <span class="string">"--."</span> : <span class="string">"G"</span>,</span><br><span class="line">            <span class="string">"...."</span> : <span class="string">"H"</span>,</span><br><span class="line">            <span class="string">".."</span> : <span class="string">"I"</span>,</span><br><span class="line">            <span class="string">".---"</span> : <span class="string">"J"</span>,</span><br><span class="line">            <span class="string">"-.-"</span> : <span class="string">"K"</span>,</span><br><span class="line">            <span class="string">".-.."</span> : <span class="string">"L"</span>,</span><br><span class="line">            <span class="string">"--"</span> : <span class="string">"M"</span>,</span><br><span class="line">            <span class="string">"-."</span> : <span class="string">"N"</span>,</span><br><span class="line">            <span class="string">"---"</span> : <span class="string">"O"</span>,</span><br><span class="line">            <span class="string">".--."</span> : <span class="string">"P"</span>,</span><br><span class="line">            <span class="string">"--.-"</span> : <span class="string">"Q"</span>,</span><br><span class="line">            <span class="string">".-."</span> : <span class="string">"R"</span>,</span><br><span class="line">            <span class="string">"..."</span> : <span class="string">"S"</span>,</span><br><span class="line">            <span class="string">"-"</span> : <span class="string">"T"</span>,</span><br><span class="line">            <span class="string">"..-"</span> : <span class="string">"U"</span>,</span><br><span class="line">            <span class="string">"...-"</span> : <span class="string">"V"</span>,</span><br><span class="line">            <span class="string">".--"</span> : <span class="string">"W"</span>,</span><br><span class="line">            <span class="string">"-..-"</span> : <span class="string">"X"</span>,</span><br><span class="line">            <span class="string">"-.--"</span> : <span class="string">"Y"</span>,</span><br><span class="line">            <span class="string">"--.."</span> : <span class="string">"Z"</span>,</span><br><span class="line">            <span class="string">".----"</span> : <span class="string">"1"</span>,</span><br><span class="line">            <span class="string">"..---"</span> : <span class="string">"2"</span>,</span><br><span class="line">            <span class="string">"...--"</span> : <span class="string">"3"</span>,</span><br><span class="line">            <span class="string">"....-"</span> : <span class="string">"4"</span>,</span><br><span class="line">            <span class="string">"....."</span> : <span class="string">"5"</span>,</span><br><span class="line">            <span class="string">"-...."</span> : <span class="string">"6"</span>,</span><br><span class="line">            <span class="string">"--..."</span> : <span class="string">"7"</span>,</span><br><span class="line">            <span class="string">"---.."</span> : <span class="string">"8"</span>,</span><br><span class="line">            <span class="string">"----."</span> : <span class="string">"9"</span>,</span><br><span class="line">            <span class="string">"-----"</span> : <span class="string">"0"</span>,</span><br><span class="line">            <span class="string">"..--.."</span> : <span class="string">"?"</span>,</span><br><span class="line">            <span class="string">"-..-."</span> : <span class="string">"/"</span>,</span><br><span class="line">            <span class="string">"-.--.-"</span> : <span class="string">"()"</span>,</span><br><span class="line">            <span class="string">"-....-"</span> : <span class="string">"-"</span>,</span><br><span class="line">            <span class="string">".-.-.-"</span> : <span class="string">"."</span></span><br><span class="line">            &#125;</span><br><span class="line">    all_variable = list(set(ciphertext.replace(<span class="string">" "</span>, <span class="string">""</span>)))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        tmp_cipher = ciphertext.replace(all_variable[<span class="number">0</span>], <span class="string">"."</span>).replace(all_variable[<span class="number">1</span>],<span class="string">"-"</span>).split(<span class="string">" "</span>)</span><br><span class="line">        final_result = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> tmp_cipher:</span><br><span class="line">            final_result += Morse_dict.get(item)</span><br><span class="line">    <span class="keyword">except</span> TypeError:</span><br><span class="line">        tmp_cipher = ciphertext.replace(all_variable[<span class="number">0</span>], <span class="string">"-"</span>).replace(all_variable[<span class="number">1</span>],<span class="string">"."</span>).split(<span class="string">" "</span>)</span><br><span class="line">        final_result = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> tmp_cipher:</span><br><span class="line">            final_result += Morse_dict.get(item) </span><br><span class="line">    <span class="keyword">return</span> final_result</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    ciphertext = input(<span class="string">"Please input the ciphertext:"</span>)</span><br><span class="line">    plaintext = Morse_decode(ciphertext)</span><br><span class="line">    print(<span class="string">"The result is :\n"</span> + plaintext + <span class="string">"\n"</span> + plaintext.lower())</span><br></pre></td></tr></table></figure><h3 id="一些经验-2"><a href="#一些经验-2" class="headerlink" title="一些经验"></a>一些经验</h3><p>如果题目给出的密文只包含两个字符并且有明显分割，可以考虑培根密码或者摩斯电码。不同的是培根密码每5个字符为一组加密单个字符，而摩斯电码每个码组长度不定。</p><h2 id="0x04-混合编码"><a href="#0x04-混合编码" class="headerlink" title="0x04 混合编码"></a>0x04 混合编码</h2><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>根据题目的提示混合编码，我们将拿到的字符串先进行base64解码，得到HTML实体编码。将去掉特殊字符后的字符串分割并进行ASCII字符转换。转换后得到一串字符串：</p><p><img src="http://static.zybuluo.com/B1ank/eooal2dvg6zqf8sjgwonnel5/%E6%B7%B7%E5%90%88%E7%BC%96%E7%A0%81.PNG" alt="混合编码.PNG-4.6kB"></p><p>对该字符串再次进行base64解码，得到以<code>/</code>分割的一串数字，将该串分割之后转换为ASCII可读字符即为flag。</p><h3 id="解题脚本-3"><a href="#解题脚本-3" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">ciphertext = <span class="string">'JiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzk7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM2ODsmIzY5OyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjNTI7JiM3NjsmIzEyMjsmIzEwNzsmIzUzOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc3OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiMxMDc7JiMxMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzg7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjODQ7JiM2OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzUwOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc4OyYjMTA1OyYjNTY7JiM1MzsmIzc4OyYjMTIxOyYjNTY7JiM1MzsmIzc5OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM5OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjNjk7JiMxMTk7JiM3NzsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjNjU7JiMxMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM2OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjMTA3OyYjNTM7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM4NDsmIzEwNzsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzEyMDsmIzc2OyYjMTIyOyYjNjk7JiMxMjA7JiM3ODsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjMTAzOyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjMTE5Ow=='</span></span><br><span class="line">plain1 = base64.b64decode(ciphertext)</span><br><span class="line"><span class="comment"># print(plain1)</span></span><br><span class="line">plain2 = plain1.decode().replace(<span class="string">";"</span>, <span class="string">""</span>).split(<span class="string">"&amp;#"</span>)</span><br><span class="line"><span class="comment"># print(plain2)</span></span><br><span class="line">plain3 = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> plain2:</span><br><span class="line">    <span class="keyword">if</span> item == <span class="string">''</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        plain3 += chr(int(item))</span><br><span class="line"><span class="comment"># print(plain3)</span></span><br><span class="line">plain4 = base64.b64decode(plain3).decode()</span><br><span class="line"><span class="comment"># print(plain4)</span></span><br><span class="line">plain5 = plain4.split(<span class="string">"/"</span>)</span><br><span class="line">plain6 = <span class="string">""</span></span><br><span class="line"><span class="comment"># print(plain5)</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> plain5:</span><br><span class="line">    <span class="keyword">if</span> item == <span class="string">""</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        plain6 += chr(int(item))</span><br><span class="line">print(plain6)</span><br></pre></td></tr></table></figure><h2 id="0x05-不仅仅是Morse"><a href="#0x05-不仅仅是Morse" class="headerlink" title="0x05 不仅仅是Morse"></a>0x05 不仅仅是Morse</h2><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题目的附件显然是摩斯电码，我们编写脚本进行解密后发现有一串AB交替连缀的字符串，显然为培根密码。</p><p><img src="http://static.zybuluo.com/B1ank/i58g4e6i811u9u3lp7y8is0c/%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AFMorse.PNG" alt="不仅仅是Morse.PNG-13.4kB"></p><p>编写对应脚本解码即可。</p><h3 id="解题脚本-4"><a href="#解题脚本-4" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 摩斯电码检测</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Morse_decode</span><span class="params">(ciphertext)</span>:</span></span><br><span class="line">    Morse_dict = &#123;<span class="string">".-"</span> : <span class="string">"A"</span>,</span><br><span class="line">            <span class="string">"-..."</span> : <span class="string">"B"</span>,</span><br><span class="line">            <span class="string">"-.-."</span> : <span class="string">"C"</span>,</span><br><span class="line">            <span class="string">"-.."</span> : <span class="string">"D"</span>,</span><br><span class="line">            <span class="string">"."</span> : <span class="string">"E"</span>,</span><br><span class="line">            <span class="string">"..-."</span> : <span class="string">"F"</span>,</span><br><span class="line">            <span class="string">"--."</span> : <span class="string">"G"</span>,</span><br><span class="line">            <span class="string">"...."</span> : <span class="string">"H"</span>,</span><br><span class="line">            <span class="string">".."</span> : <span class="string">"I"</span>,</span><br><span class="line">            <span class="string">".---"</span> : <span class="string">"J"</span>,</span><br><span class="line">            <span class="string">"-.-"</span> : <span class="string">"K"</span>,</span><br><span class="line">            <span class="string">".-.."</span> : <span class="string">"L"</span>,</span><br><span class="line">            <span class="string">"--"</span> : <span class="string">"M"</span>,</span><br><span class="line">            <span class="string">"-."</span> : <span class="string">"N"</span>,</span><br><span class="line">            <span class="string">"---"</span> : <span class="string">"O"</span>,</span><br><span class="line">            <span class="string">".--."</span> : <span class="string">"P"</span>,</span><br><span class="line">            <span class="string">"--.-"</span> : <span class="string">"Q"</span>,</span><br><span class="line">            <span class="string">".-."</span> : <span class="string">"R"</span>,</span><br><span class="line">            <span class="string">"..."</span> : <span class="string">"S"</span>,</span><br><span class="line">            <span class="string">"-"</span> : <span class="string">"T"</span>,</span><br><span class="line">            <span class="string">"..-"</span> : <span class="string">"U"</span>,</span><br><span class="line">            <span class="string">"...-"</span> : <span class="string">"V"</span>,</span><br><span class="line">            <span class="string">".--"</span> : <span class="string">"W"</span>,</span><br><span class="line">            <span class="string">"-..-"</span> : <span class="string">"X"</span>,</span><br><span class="line">            <span class="string">"-.--"</span> : <span class="string">"Y"</span>,</span><br><span class="line">            <span class="string">"--.."</span> : <span class="string">"Z"</span>,</span><br><span class="line">            <span class="string">".----"</span> : <span class="string">"1"</span>,</span><br><span class="line">            <span class="string">"..---"</span> : <span class="string">"2"</span>,</span><br><span class="line">            <span class="string">"...--"</span> : <span class="string">"3"</span>,</span><br><span class="line">            <span class="string">"....-"</span> : <span class="string">"4"</span>,</span><br><span class="line">            <span class="string">"....."</span> : <span class="string">"5"</span>,</span><br><span class="line">            <span class="string">"-...."</span> : <span class="string">"6"</span>,</span><br><span class="line">            <span class="string">"--..."</span> : <span class="string">"7"</span>,</span><br><span class="line">            <span class="string">"---.."</span> : <span class="string">"8"</span>,</span><br><span class="line">            <span class="string">"----."</span> : <span class="string">"9"</span>,</span><br><span class="line">            <span class="string">"-----"</span> : <span class="string">"0"</span>,</span><br><span class="line">            <span class="string">"..--.."</span> : <span class="string">"?"</span>,</span><br><span class="line">            <span class="string">"-..-."</span> : <span class="string">"/"</span>,</span><br><span class="line">            <span class="string">"-....-"</span> : <span class="string">"-"</span>,</span><br><span class="line">            <span class="string">".-.-.-"</span> : <span class="string">"."</span>,</span><br><span class="line">            <span class="string">"-.-.--"</span> : <span class="string">"!"</span>,</span><br><span class="line">            <span class="string">"-.--."</span> : <span class="string">"("</span>,</span><br><span class="line">            <span class="string">".--.-."</span> : <span class="string">"@"</span>,</span><br><span class="line">            <span class="string">"---..."</span> : <span class="string">":"</span>,</span><br><span class="line">            <span class="string">"-...-"</span> : <span class="string">"="</span>,</span><br><span class="line">            <span class="string">"-....-"</span> : <span class="string">"-"</span>,</span><br><span class="line">            <span class="string">"-.--.-"</span> : <span class="string">")"</span>,</span><br><span class="line">            <span class="string">"--..--"</span> : <span class="string">","</span>,</span><br><span class="line">            <span class="string">".----."</span> : <span class="string">"'"</span>,</span><br><span class="line">            <span class="string">"..--.-"</span> : <span class="string">"_"</span>,</span><br><span class="line">            <span class="string">"...-..-"</span> : <span class="string">"$"</span>,</span><br><span class="line">            <span class="string">"-.-.-."</span> : <span class="string">";"</span>,</span><br><span class="line">            <span class="string">"-..-."</span> : <span class="string">"/"</span>,</span><br><span class="line">            <span class="string">".-..-."</span> : <span class="string">"\""</span>,</span><br><span class="line">            <span class="string">"...."</span> : <span class="string">"&amp;"</span></span><br><span class="line">            &#125;</span><br><span class="line">    all_variable = list(set(ciphertext.replace(<span class="string">"/"</span>, <span class="string">""</span>)))</span><br><span class="line">    print(all_variable)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        tmp_cipher = ciphertext.replace(all_variable[<span class="number">0</span>], <span class="string">"."</span>).replace(all_variable[<span class="number">1</span>],<span class="string">"-"</span>).split(<span class="string">"/"</span>)</span><br><span class="line">        print(tmp_cipher)</span><br><span class="line">        final_result = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> tmp_cipher:</span><br><span class="line">            final_result += Morse_dict.get(item)</span><br><span class="line">    <span class="keyword">except</span> TypeError:</span><br><span class="line">        tmp_cipher = ciphertext.replace(all_variable[<span class="number">0</span>], <span class="string">"-"</span>).replace(all_variable[<span class="number">1</span>],<span class="string">"."</span>).split(<span class="string">"/"</span>)</span><br><span class="line">        final_result = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> tmp_cipher:</span><br><span class="line">            final_result += Morse_dict.get(item) </span><br><span class="line">    <span class="keyword">return</span> final_result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Bacon_decode</span><span class="params">(ciphertext)</span>:</span></span><br><span class="line">    Bacon_dict = &#123;</span><br><span class="line">        <span class="string">"aaaaa"</span> : <span class="string">"A"</span>,</span><br><span class="line">        <span class="string">"aaaab"</span> : <span class="string">"B"</span>,</span><br><span class="line">        <span class="string">"aaaba"</span> : <span class="string">"C"</span>,</span><br><span class="line">        <span class="string">"aaabb"</span> : <span class="string">"D"</span>,</span><br><span class="line">        <span class="string">"aabaa"</span> : <span class="string">"E"</span>,</span><br><span class="line">        <span class="string">"aabab"</span> : <span class="string">"F"</span>,</span><br><span class="line">        <span class="string">"aabba"</span> : <span class="string">"G"</span>,</span><br><span class="line">        <span class="string">"aabbb"</span> : <span class="string">"H"</span>,</span><br><span class="line">        <span class="string">"abaaa"</span> : <span class="string">"I"</span>,</span><br><span class="line">        <span class="string">"abaab"</span> : <span class="string">"J"</span>,</span><br><span class="line">        <span class="string">"ababa"</span> : <span class="string">"K"</span>,</span><br><span class="line">        <span class="string">"ababb"</span> : <span class="string">"L"</span>,</span><br><span class="line">        <span class="string">"abbaa"</span> : <span class="string">"M"</span>,</span><br><span class="line">        <span class="string">"abbab"</span> : <span class="string">"N"</span>,</span><br><span class="line">        <span class="string">"abbba"</span> : <span class="string">"O"</span>,</span><br><span class="line">        <span class="string">"abbbb"</span> : <span class="string">"P"</span>,</span><br><span class="line">        <span class="string">"baaaa"</span> : <span class="string">"Q"</span>,</span><br><span class="line">        <span class="string">"baaab"</span> : <span class="string">"R"</span>,</span><br><span class="line">        <span class="string">"baaba"</span> : <span class="string">"S"</span>,</span><br><span class="line">        <span class="string">"baabb"</span> : <span class="string">"T"</span>,</span><br><span class="line">        <span class="string">"babaa"</span> : <span class="string">"U"</span>,</span><br><span class="line">        <span class="string">"babab"</span> : <span class="string">"V"</span>,</span><br><span class="line">        <span class="string">"babba"</span> : <span class="string">"W"</span>,</span><br><span class="line">        <span class="string">"babbb"</span> : <span class="string">"X"</span>,</span><br><span class="line">        <span class="string">"bbaaa"</span> : <span class="string">"Y"</span>,</span><br><span class="line">        <span class="string">"bbaab"</span> : <span class="string">"Z"</span></span><br><span class="line">    &#125;</span><br><span class="line">    final_plain = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(ciphertext), <span class="number">5</span>):</span><br><span class="line">        final_plain += Bacon_dict.get(ciphertext.lower()[i:i+<span class="number">5</span>])</span><br><span class="line">    <span class="keyword">return</span> final_plain</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    ciphertext = input(<span class="string">"Please input the ciphertext:"</span>)</span><br><span class="line">    plaintext = Morse_decode(ciphertext)</span><br><span class="line">    plaintext = plaintext[<span class="number">30</span>:]</span><br><span class="line">    final_plain = Bacon_decode(plaintext)</span><br><span class="line">    print(final_plain)</span><br><span class="line">    print(final_plain.lower())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="0x06-幂数加密"><a href="#0x06-幂数加密" class="headerlink" title="0x06 幂数加密"></a>0x06 幂数加密</h2><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>根据题目提示百度一下二进制幂数加密，其原理为十进制数都可以用二进制幂的形式表示，并且可以用十进制数字表示字符偏离首字母A的距离，于是我们可以用二进制幂来加密英文字符串。编写脚本解题即可。</p><h3 id="解题脚本-5"><a href="#解题脚本-5" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ciphertext = <span class="string">'8842101220480224404014224202480122'</span></span><br><span class="line">ciphertext = ciphertext.split(<span class="string">'0'</span>)</span><br><span class="line">plaintext = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> ciphertext:</span><br><span class="line">    tmp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> var <span class="keyword">in</span> item:</span><br><span class="line">        tmp += eval(var)</span><br><span class="line">    plaintext += chr(<span class="number">64</span> + tmp)</span><br><span class="line">print(plaintext)</span><br></pre></td></tr></table></figure><h2 id="0x07-Railfence"><a href="#0x07-Railfence" class="headerlink" title="0x07 Railfence"></a>0x07 Railfence</h2><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p>根据提示可知为railfence即栅栏密码。下载附件后观察密文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ccehgyaefnpeoobe&#123;lcirg&#125;epriec_ora_g</span><br></pre></td></tr></table></figure><p>由于题目的flag前缀为cyberpeace，但密文中这十个字母的间距不相等，而栅栏密码应用了<strong>等间距分组</strong>的思想，显然本题目不是普通的定间距栅栏密码。</p><p>多方搜寻后发现栅栏密码存在W形式的变种，举例如下：</p><p>明文为<code>helloworldtest</code>，key=3时，结果为：</p><p><img src="http://static.zybuluo.com/B1ank/qglgcu6pub39ngus9dgyqb1f/railfence1.PNG" alt="railfence1.PNG-1.5kB"></p><p>加密结果为<code>holselwrdetlot</code>。</p><p>回到本题，其实可以根据第一个字符c和第二个字符y之间的距离为4并且总字符数为35推测出第一行两字母之间相距7个字符，从而可以得到key=5，还原之后得到flag。</p><p><img src="http://static.zybuluo.com/B1ank/ddpgmmzd3tsuqtgs59l2w025/railfence2.PNG" alt="railfence2.PNG-3.2kB"></p><p>对于W型的栅栏密码，有专门的解密网址：<a href="http://www.atoolbox.net/Tool.php?Id=777" target="_blank" rel="noopener">W型栅栏密码</a></p><h3 id="一些经验-3"><a href="#一些经验-3" class="headerlink" title="一些经验"></a>一些经验</h3><p>CTF密码学题目中，对古典密码的考察较少；如果需要对其进行考察，则大概率会考察其变体。当使用常规古典密码解法无法得到合理的flag时，考虑复制粘贴密文并Google或百度，兴许可以发现新姿势。平时需要积累一些奇奇怪怪的网站，关键时刻或许可以派上用场（指做题。</p><h2 id="0x08-easy-RSA"><a href="#0x08-easy-RSA" class="headerlink" title="0x08 easy_RSA"></a>0x08 easy_RSA</h2><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题目不能称作基本的RSA解密，最多只是一个求RSA中特定参数的过程。题目给出了p，q和e，求解密指数d。RSA原理中有：</p><blockquote><p>phi(n) = (p-1) * (q-1)</p><p>e * d ≡ 1 (mod phi(n))</p></blockquote><p>直接编写脚本计算即可。</p><p>由于新的python环境没有安装解题需要的gmpy2库，于是考虑手动安装，python版本为3.8。命令行中直接输入<code>pip install gmpy2</code>瞬间满屏都是红色报错，仔细审查后发现出错的核心为<code>Failed building wheel for gmpy2</code>即缺少gmpy2对应的wheel文件。于是直接<code>pip install wheel</code>安装wheel库，然后从<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">python扩展wheel文件网站</a>中下载对应的wheel文件即可。下载之后在cmd中输入<code>pip install + gmpy2.wheel文件绝对路径</code>即可完成安装。</p><p><img src="http://static.zybuluo.com/B1ank/hzdjqz1bd504k3rgt0zmtsd5/gmpy2.PNG" alt="gmpy2.PNG-41.3kB"></p><h3 id="解题脚本-6"><a href="#解题脚本-6" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p=<span class="number">473398607161</span></span><br><span class="line">q=<span class="number">4511491</span></span><br><span class="line">e=<span class="number">17</span></span><br><span class="line">phi = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line">d = gmpy2.invert(e, phi)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><h2 id="0x09-easychallenge"><a href="#0x09-easychallenge" class="headerlink" title="0x09 easychallenge"></a>0x09 easychallenge</h2><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题目提供了将python脚本编译后的pyc文件。下载附件后使用<code>uncompyle6 xxx.pyc &gt; xx.py</code>命令将其反编译为python文件，可以获得加密脚本的细节如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode1</span><span class="params">(ans)</span>:</span></span><br><span class="line">    s = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ans:</span><br><span class="line">        x = ord(i) ^ <span class="number">36</span></span><br><span class="line">        x = x + <span class="number">25</span></span><br><span class="line">        s += chr(x)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode2</span><span class="params">(ans)</span>:</span></span><br><span class="line">    s = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ans:</span><br><span class="line">        x = ord(i) + <span class="number">36</span></span><br><span class="line">        x = x ^ <span class="number">36</span></span><br><span class="line">        s += chr(x)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode3</span><span class="params">(ans)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> base64.b32encode(ans)</span><br><span class="line">flag = <span class="string">' '</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Please Input your flag:'</span></span><br><span class="line">flag = raw_input()</span><br><span class="line">final = <span class="string">'UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E==='</span></span><br><span class="line"><span class="keyword">if</span> encode3(encode2(encode1(flag))) == final:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'correct'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'wrong'</span></span><br></pre></td></tr></table></figure><p>编写解密脚本后发现嵌套解密过程中出现问题：</p><p><img src="http://static.zybuluo.com/B1ank/rcxsi8d7flcbtcuowxut0jx9/ezchallenge1.PNG" alt="ezchallenge1.PNG-5.6kB"></p><p><img src="http://static.zybuluo.com/B1ank/bl344rvaqjk8hm0ebh7fhxm9/ezchallenge.PNG" alt="ezchallenge.PNG-5kB"></p><p>显然使用utf-8编码无法对结果进行解码。为了检测base解密结果为何种编码，引入chardet库，使用pip安装并导入后检测decode3()函数解密结果的编码类型，并使用该编码类型进行正确解码。（<code>chardet.detect()</code>函数返回结果为字典类型，故使用索引）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line">plain_tmp = decode3(ciphertext)</span><br><span class="line">code = chardet.detect(plain_tmp)</span><br><span class="line"><span class="comment"># code : &#123;'encoding' : 'ISO-8859-1','cofidence' : 0.73, 'language' : ''&#125;</span></span><br><span class="line">final_code = code[<span class="string">'encoding'</span>]</span><br><span class="line">flag = decode1(decode2(decode3(plain_tmp).decode(final_code)))</span><br></pre></td></tr></table></figure><h3 id="解题脚本-7"><a href="#解题脚本-7" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode3</span><span class="params">(ciphertext)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> base64.b32decode(ciphertext)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode2</span><span class="params">(ciphertext)</span>:</span></span><br><span class="line">    plain2 = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> ciphertext:</span><br><span class="line">        x = ord(item) ^ <span class="number">36</span></span><br><span class="line">        x = x - <span class="number">36</span></span><br><span class="line">        plain2 += chr(x)</span><br><span class="line">    <span class="keyword">return</span> plain2</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode1</span><span class="params">(ciphertext)</span>:</span></span><br><span class="line">    plain1 = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> ciphertext:</span><br><span class="line">        x = ord(item) - <span class="number">25</span></span><br><span class="line">        x = x ^ <span class="number">36</span></span><br><span class="line">        plain1 += chr(x)</span><br><span class="line">    <span class="keyword">return</span> plain1</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    ciphertext = <span class="string">'UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E==='</span></span><br><span class="line">    plain_tmp = decode3(ciphertext)</span><br><span class="line">    code = chardet.detect(plain_tmp)</span><br><span class="line">    final_code = code[<span class="string">'encoding'</span>]</span><br><span class="line">    flag = decode1(decode2(plain_tmp.decode(final_code)))</span><br><span class="line">    print(flag)</span><br></pre></td></tr></table></figure><h2 id="0x0A-Normal-RSA"><a href="#0x0A-Normal-RSA" class="headerlink" title="0x0A Normal_RSA"></a>0x0A Normal_RSA</h2><h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><p>下载附件并解压，打开后发现给出了<code>flag.enc</code>和<code>pub.key</code>这两个文件。根据文件后缀得知本题显然为文件类型RSA题目。我们下载<a href="https://github.com/ius/rsatool" target="_blank" rel="noopener">rsatool-master</a>并向其提供p和q的值以生成<code>private.pem</code>解密证书。</p><p>将题目提供的文件拖入kali虚拟机，使用其自带的openssl功能从公钥文件<code>pubkey.pem</code>中获得模数N和加密指数e：</p><p><img src="http://static.zybuluo.com/B1ank/m6r68nnmtmwmrhgioxoerh5z/normal_RSA.PNG" alt="normal_RSA.PNG-114.9kB"></p><p>可以看到Modulus的十六进制表示，将其转换为十进制并进行大数分解得到p和q，这里推荐一个大数分解的网站：<a href="http://factordb.com/" target="_blank" rel="noopener">factordb.com</a>。分解之后进入rsatool-master的目录，执行如下命令生成私钥文件：</p><p><img src="http://static.zybuluo.com/B1ank/hpqz5mevnifmga8l5bn1vwtq/normal_RSA2.PNG" alt="normal_RSA2.PNG-150.2kB"></p><p>得到私钥文件之后使用openssl命令解密可得flag：</p><p><img src="http://static.zybuluo.com/B1ank/h0z1bn3ry0qqpk2u1cqnx7zf/normal_RSA3.PNG" alt="normal_RSA3.PNG-99.1kB"></p><h2 id="0x0B-转轮机加密"><a href="#0x0B-转轮机加密" class="headerlink" title="0x0B 转轮机加密"></a>0x0B 转轮机加密</h2><h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><p>根据提示搜索托马斯杰斐逊转轮机密码，可以找到其加解密原理，我们结合题目给出的密码表和密文进行简要说明。</p><p><img src="http://static.zybuluo.com/B1ank/3y4x1eao3i0vx8ik6s1wry8y/%E8%BD%AC%E8%BD%AE%E6%9C%BA.PNG" alt="转轮机.PNG-34.7kB"></p><p>可以看到，题目给出具有标号的密码表，我们按照所给的密钥对密码表进行行序交换。对于交换后的结果，将密码本的每行与密文的每个字母对应，使对应行的首字母为密文的对应字母即可。</p><p>例如将第二行<code>KPBELNACZDTRXMJQOYHGVSFUWI</code>移动到第一行并变成<code>NACZDTRXMJQOYHGVSFUWIKPBEL</code>。最后将排序好的字母表以列为单位输出，从中寻找语法正确的明文即可。</p><p>（本题flag没有前缀，得到的字符串直接变成小写输入即可！</p><h3 id="解题脚本-8"><a href="#解题脚本-8" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">key = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">6</span>]</span><br><span class="line">ciphertext = <span class="string">'NFQKSEVOQOFNP'</span></span><br><span class="line">tmp_alphabet = []</span><br><span class="line">final_alphabet = []</span><br><span class="line">new_alphabet = []</span><br><span class="line"><span class="comment"># 对输入的密码表按照密钥进行行排序</span></span><br><span class="line">f = open(<span class="string">'test.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    tmp_alphabet.append(line.strip(<span class="string">'&lt; '</span>).strip(<span class="string">'\n'</span>).strip(<span class="string">' &lt;'</span>))</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> key:</span><br><span class="line">    final_alphabet.append(tmp_alphabet[item - <span class="number">1</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(ciphertext)):</span><br><span class="line">    baffle = final_alphabet[i].index(ciphertext[i])</span><br><span class="line">    new_alphabet.append(final_alphabet[i][baffle:] + final_alphabet[i][:baffle])</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(new_alphabet[<span class="number">0</span>])):</span><br><span class="line">    plaintext = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> new_alphabet:</span><br><span class="line">        plaintext += item[j]</span><br><span class="line">    print(plaintext.lower())</span><br></pre></td></tr></table></figure><h2 id="0x0C-easy-ECC"><a href="#0x0C-easy-ECC" class="headerlink" title="0x0C easy_ECC"></a>0x0C easy_ECC</h2><h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题主要考察了基于椭圆曲线离散对数困难问题（即ECC）的加密签名过程中公钥的获取过程。下面先对椭圆曲线相关知识进行简要介绍。</p><h4 id="椭圆曲线定义"><a href="#椭圆曲线定义" class="headerlink" title="椭圆曲线定义"></a>椭圆曲线定义</h4><p>首先来看椭圆曲线的定义，椭圆曲线标准公式为：</p><script type="math/tex; mode=display">y^2 = x^3 + a*x + b</script><p>其中$4<em>a^3 + 27</em>b^2 ≠ 0$这个限定条件保证曲线不包含奇点（即无穷远点）。这种椭圆曲线被称为Weierstrass标准形式。当然，为了完整定义椭圆曲线，还需要一个无穷远点作为曲线的一部分，这里使用A表示。</p><p>最终可以将表达式精炼为：</p><script type="math/tex; mode=display">\{(x,y) ∈ R^2 | y^2 = x^3 + a*x + b, 4*a^3 + 27*b^2 ≠ 0\} ∪ \{A\}</script><p>对于生成元P，其加法是一个闭环，nP的集合是<strong>椭圆曲线形成的群里的一个具有循环性质的子群</strong>，根据此i性质可以简化nP的代码。</p><h4 id="ECC算法步骤"><a href="#ECC算法步骤" class="headerlink" title="ECC算法步骤"></a>ECC算法步骤</h4><p>将ECC算法步骤总结如下：</p><ul><li>计算椭圆曲线的阶N</li><li>选择一个阶为n的子群，n为素数且为N的因子</li><li>计算辅因子h = N/n</li><li>在曲线上选择一个基点P</li><li>计算G = hP</li><li>如果G是0，那么重新选择基点，否则找到了阶为n，生成元为P的子群</li></ul><h4 id="困难问题本质"><a href="#困难问题本质" class="headerlink" title="困难问题本质"></a>困难问题本质</h4><p>现在假设有一条在有限域$F_{p}$上的椭圆曲线，要解决的困难问题如下：</p><p><strong>已知P和Q的情况下，对于Q=k*P，如何计算满足要求的k?</strong></p><p>这个就是椭圆曲线中的离散对数问题。</p><h4 id="ECDH"><a href="#ECDH" class="headerlink" title="ECDH"></a>ECDH</h4><p>进行加解密之前，我们首先选取一些重要的域参数：</p><ul><li>素数p</li><li>椭圆曲线系数a与b</li><li>基点（生成元）G</li><li>子群的阶n</li><li>辅因子h</li></ul><p>之后将这六个域参数合成一个六元组（p,a,b,G,n,h）</p><p>选取完毕一个六元组后，定义如下内容：</p><ul><li>私钥：一个随机的整数d，选取自{1,2,3,…..,n-1}</li><li>公钥：H = dG（G是循环子群的生成元）</li></ul><p>如果我们已知d与六元组，计算出H是一件非常简单的事情（也就是本题目需要解决的问题）。但是如果我们只知道H和G，去寻找符合要求的d是非常困难的，这就是上面提到的离散对数问题。</p><p>下面对ECDH算法进行说明，该算法流程基于DH密钥交换协议</p><ul><li>Alice和Bob首先约定一个六元组，生成自己的私钥和公钥，定义关键参数如下：<ul><li>Alice Private Key: $d_{A}$</li><li>Alice Public Key: $H<em>{A} = d</em>{A}*G$</li><li>Bob Private Key: $d_{B}$</li><li>Bob Public Key:$H<em>{B} = d</em>{B}*G$</li></ul></li><li>Alice和Bob公开交换公钥，第三方可以窃听到$H<em>{A}$和$H</em>{B}$，但由于困难问题的存在，其无法解出$d<em>{A}$和$d</em>{B}$</li><li>Alice用自己的私钥计算$S<em>{A} = d</em>{A}<em>H<em>{B}$，Bob用自己的私钥计算$S</em>{B} = d_{B}</em>H_{A}$</li></ul><p>由于$S = d<em>{A}*H</em>{B} = d<em>{A}(d</em>{B}<em>G) = d<em>{B}(d</em>{A}</em>G)$，显然$S<em>{A} = S</em>{B}$。基于以上步骤，Alice和Bob完成了DH密钥交换，他们可以将该密钥用于对称密码如AES中来传递信息。</p><h4 id="ECDSA"><a href="#ECDSA" class="headerlink" title="ECDSA"></a>ECDSA</h4><p>接下来简单介绍一下ECDSA原理。</p><p>在预定完毕一个六元组后，Alice定义公钥和私钥：</p><ul><li>私钥：一个选自[1,n-1]范围内的随机整数$d_{A}$</li><li>公钥：$H<em>{A} = d</em>{A}*G$，其中G是循环子群的生成元</li></ul><p>随后，Alice进行如下操作：</p><ul><li>从[1,n-1]范围内选取一个随机的整数k</li><li>计算$P = k*G$</li><li>计算$r \equiv x<em>{p} (mod n)$，其中$x</em>{p}$是P的横坐标</li><li>如果r = 0则重新选取k</li><li>计算$s \equiv k^{-1}<em>(z+r</em>d<em>{A}) (mod n)$，其中$d</em>{A}$是Alice的私钥，$k^{-1}$是k的逆元</li><li>如果s = 0则重新选取k</li><li>将(r, s)封装为一个签名</li></ul><p>需要注意的是，私钥必须为素数，否则在计算模逆的时候会出现一些奇奇怪怪的状况，直接导致ECDSA无法正常使用。</p><p>对于Bob，其拿到Alice传递的信息z和Alice的签名(r, s)，通过以下方法对签名进行验证：</p><ul><li>计算$u_{1} \equiv s^{-1}*z (mod n)$</li><li>计算$u_{2} \equiv s^{-1}*r (mod n)$</li><li>计算$P<em>{0} = u</em>{1}<em>G + u_{2}</em>H_{A}$</li><li>当且仅当$r \equiv x<em>{p}(mod n) $的时候$P</em>{0} = H_{A}$</li></ul><p>可以将ECDSA的过程用下图进行概括：</p><p><img src="http://static.zybuluo.com/B1ank/16pnwhvgc5f0r4u3eagagd4q/ECDSA.PNG" alt="ECDSA.PNG-32.2kB"></p><p>回到题目，本题给出p，a，b和生成元G以及私钥k，要求公钥。即求K(x, y) = k*G，最后返回x+y的值作为flag。</p><p>关于ECC原理及攻击方法，可以参考<a href="http://shaobaobaoer.cn/" target="_blank" rel="noopener">ShaoBaoBaoR师傅的博客</a>，其中有三篇ECC相关文章分析地非常透彻：</p><ul><li><a href="http://shaobaobaoer.cn/archives/ecc-learning-elliptic-curve-from-real-to-finite-field" target="_blank" rel="noopener">ECC椭圆曲线加密算法学习————从实数域到有限域的椭圆曲线</a></li><li><a href="http://shaobaobaoer.cn/archives/721/ecc-learning-ecdh-and-ecdsa" target="_blank" rel="noopener">ECC椭圆曲线加密算法学习————ECDH与ECDSA</a></li><li><a href="http://shaobaobaoer.cn/archives/ecc-learning-security-problem-and-practice" target="_blank" rel="noopener">ECC椭圆曲线加密算法学习————安全性问题与实战</a></li></ul><h3 id="解题脚本-9"><a href="#解题脚本-9" class="headerlink" title="解题脚本"></a>解题脚本</h3><p>相关代码参考上面提到师傅文章中给出的<a href="https://github.com/ninthDevilHAUNSTER/ecc_learning" target="_blank" rel="noopener">Github项目：shaobaobaoer的椭圆曲线密码学习之路</a>，代码逻辑非常清晰易懂。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;最近打算边上课边刷一下攻防世界的题目，一是为了保持密码学的做题手感，二是为了打发上某些课的时间（指一
      
    
    </summary>
    
      <category term="CTF_Writeup" scheme="https://blank-vax.github.io/categories/CTF-Writeup/"/>
    
    
      <category term="攻防世界" scheme="https://blank-vax.github.io/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
      <category term="经验文章" scheme="https://blank-vax.github.io/tags/%E7%BB%8F%E9%AA%8C%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界 —— Crypto（进阶区1）</title>
    <link href="https://blank-vax.github.io/2020/11/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%20%E2%80%94%E2%80%94%20Crypto%EF%BC%88%E8%BF%9B%E9%98%B6%E5%8C%BA1%EF%BC%89/"/>
    <id>https://blank-vax.github.io/2020/11/09/攻防世界 —— Crypto（进阶区1）/</id>
    <published>2020-11-09T02:39:34.445Z</published>
    <updated>2020-05-10T03:07:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>更新完Crypto新手区的题目之后，接下来开始练习进阶区的题目。本系列文章持续更新中~</p><h2 id="0x01-告诉你个秘密"><a href="#0x01-告诉你个秘密" class="headerlink" title="0x01 告诉你个秘密"></a>0x01 告诉你个秘密</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>打开附件发现为两行十六进制数据，一开始考虑将其转换成十进制，后来发现转完之后不易和字符串建立联系，遂考虑直接将其转换为字符串。</p><p>这里使用python的binascii库中的<code>binascii.a2b_hex(hex)</code>实现将十六进制字符串转换成ASCII字符串并输出。输出结果显然为Base64加密，直接解密得到如下结果：</p><p><img src="http://static.zybuluo.com/B1ank/z9j4icbmpvvzmpep45u3b7o6/%E5%91%8A%E8%AF%89%E4%BD%A0%E4%B8%AA%E7%A7%98%E5%AF%86.PNG" alt="告诉你个秘密.PNG-3.6kB"></p><p>乍看是一堆无意义的字符串，但注意其使用空格作为分隔符分开，考虑到键盘密码，与键盘上的字母对应得到最后的flag。注意本题flag的格式直接为最后得到的字符串，没有任何前缀。</p><h3 id="解题脚本"><a href="#解题脚本" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">cipher1 = <span class="string">'636A56355279427363446C4A49454A7154534230526D6843'</span></span><br><span class="line">cipher2 = <span class="string">'56445A31614342354E326C4B4946467A5769426961453067'</span></span><br><span class="line">final_plain = binascii.a2b_hex(cipher1) + binascii.a2b_hex(cipher2)</span><br><span class="line">final_plain2 = base64.b64decode(final_plain).decode()</span><br><span class="line">print(final_plain2)</span><br></pre></td></tr></table></figure><h3 id="一些经验"><a href="#一些经验" class="headerlink" title="一些经验"></a>一些经验</h3><p>下面来讨论一下使用binascii库进行ASCII字符串与十六进制字符串转换的细节。</p><p><img src="http://static.zybuluo.com/B1ank/sb9mauwpmxxbkihdl3bro6a2/hex_to_string.PNG" alt="hex_to_string.PNG-37.9kB"></p><p>由上图可知，在ASCII字符串与十六进制字符串转换过程中，binascii库提供了四个函数。</p><p>我们可以使用<code>binascii.a2b_hex(hex_string)</code>和<code>binascii.unhexlify(hex_string)</code>这两个函数实现从十六进制字符串到ASCII字符串的转换过程。可以使用<code>binascii.b2a_hex(ASCII_string)</code>和<code>binascii.hexlify(ASCII_string)</code>这两个函数实现从ASCII字符串到十六进制字符串的转换过程。值得注意的是，在python3中，互相转换的数据类型为byte型而非string型，否则就会出现TypeError报错。</p><h2 id="0x02-Broadcast"><a href="#0x02-Broadcast" class="headerlink" title="0x02 Broadcast"></a>0x02 Broadcast</h2><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题目提供了加密脚本<code>task.py</code>，Bob、Dan、Carol和Erin的pem与enc文件。单独看这道题目确实很简单，因为flag直接包含在题目给出的脚本中。但是如果对题目提供的加密方式进行挖掘，可以得到许多有趣的信息。</p><p>题目名字为Broadcast，实际上并不是简单的广播攻击。对于RSA的简单广播攻击，其前提是对同一个m加密，攻击细节如下图：</p><p><img src="http://static.zybuluo.com/B1ank/hnmhfbjcdzqiqm1eejeyxlnp/Basic%20Broadcast%20Attack.PNG" alt="Basic Broadcast Attack.PNG-69.2kB"></p><p>分析加密脚本中对待加密信息的处理过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">'from'</span>: sha256( <span class="string">b'Alice'</span> ).hexdigest(),</span><br><span class="line">        <span class="string">'to'</span>  : sha256( name.encode() ).hexdigest(),</span><br><span class="line">        <span class="string">'msg'</span> : msg</span><br><span class="line">       &#125;</span><br><span class="line">data = json.dumps(data, sort_keys=<span class="literal">True</span>)</span><br><span class="line">m = number.bytes_to_long( data.encode() )</span><br></pre></td></tr></table></figure><p>显然每一次的m不同，并且取<code>e=3</code>和<code>e=5</code>时分别只有两个其他明密文对，无法使用应对传统广播攻击的方法进行处理。</p><p>观察可知，每次m都由以下内容构成：</p><blockquote><ul><li>from Alice（每次相同）</li><li>to name（每次不同）</li><li>msg（每次相同）</li></ul></blockquote><p>其中只有<code>to: name</code>每次变化，而另外两个参数保持不变。由于引入语句<code>data = json.dumps(data, sort_keys=True)</code>，在加密之前会根据data字典的key进行排序，由于三个键的首字母排序为<code>from-msg-to</code>，可以发现msg被放到中间位置。即<code>m = high + mid + low</code>。</p><p>对于每次构造的信息m，其高、中位(<code>&#39;from&#39;:Alice</code>，<code>&#39;msg&#39;: msg</code>)都是不变的，只是低位由于每次接收方不同有所不同。由于<code>high</code>和<code>low</code>已知的（可以通过构造过程中提供的方法进行计算），我们只需要求出<code>mid</code>部分即可。</p><p>由于<code>low</code>部分包含64位的sha256摘要信息以及12位其他符号，故构造m如下：</p><script type="math/tex; mode=display">m_{i} = (high << 1368) + (x << 608) + low_{i}</script><script type="math/tex; mode=display">m_{i} = a*x*2^{608} + b_{i}</script><p>其中a = 1, $b<em>{i} = high*2^{1368} + low</em>{i}$</p><p>且x仅为95*8=760位</p><p>此时可以利用<a href="https://en.wikipedia.org/wiki/Coppersmith%27s_attack#Generalizations" target="_blank" rel="noopener">Broad Attack with Linear Padding</a>结合Copper Smith Attack进行求解。</p><p>构造多项式$f(x) = (x*2^{608} + b) ^{3} - c (mod n<em>{1}n</em>{2})$的<code>small root</code>。</p><p>需要注意的是，<code>small root</code>要求小于模数n的1/e次方，而x为760位，760<em>3 = 2280 &gt; 2048 = 1024</em>2，所以需要使用两组加密信息使得模数的位数增大为4096位，从而760位的x满足<code>small root</code>的条件。 </p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><p>根据以上分析，根据给出的pem和enc文件提取两对使用3作为加密指数的(n, c)对，编写sage脚本解密如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">n = [<span class="number">11743537468135317101480488020144809201914936988461977176868954193874417724397531738707729413940060004291802011501577549223271797288223565654061393379024948557114873802484065401046235691942131446370168987779343797500311519782297945918303703564655987952282482715476136773764831205732478344688915636069116516770855051840466960976764092858799500910720099908106249684080240663853178927556249049193503151085654884527269002477666950572742679984293662085069728877459286849951188181117702216469759179036558783079196215512501682142798495265635852347494193629555160491782509569392767123686061925883459482937083314597325931324903</span>,</span><br><span class="line">    <span class="number">14457209969884668177708697333084651442256193118762305783886170334587420837310297145702128170106972242068185696834421424217621080232658721763477597612126355466640947700608787202555955170003838596141926637700553638034795412618607691704863949191711837596504911369550275265047485577345602266210861036695691235637536527380239331718278464709412846966181787795995822367966392084870050879397930114908541580226650851547317522603090899886280170245299959983054236157294287800393659291904879499563552223080590816177114742527572796924746954499447982388532224932540152177949556088321209870823140903366811600475984145194404542130227</span>]</span><br><span class="line">c = [<span class="number">8190049298225986645065639656298172597926128706450768371303258134744480067344252838541490888036183464705944304534788993901104793815361341756431217860700928158019252752618919437673052832128577726977953950790902559970309709239504865249701468783648614158118356226876181834829777260079340923537145106302704145961190836661375363413110097880213997662546161624163926197325967768410253429584704238310212909716376684130921549808859640649278922277248496022978656354003386568276074858346316327173050731369576404526308212891898482132494538059251451015302281630189059974681450654073047538089109981563439870031087270051532901896822</span>,</span><br><span class="line">    <span class="number">12118101166054737713386215385862569765107262982956699621223784645643668203345111850159614142861485707244381466506582226100758646240135249724760825645393433062905277245716757630096083674730526877271237776864887538290354358982569685278734177038607779153674199245850037034568957234569159850767151815484600506473286544739506911281943726669304436835800686344966600632518764992677531015390701093253398220813342080495059893716294823513371481710159387645437923515728187314225175839309059255201792376404426500260584133880852811820804606509557432184294402579927159295465411669899092463872169344366863225658285149101653314280770</span>]</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment"># b_i = high + low_i</span></span><br><span class="line">b=[<span class="number">15544274873612998989866379328566946388285248570806564503108352867340017880252665817613208325183832507901409765669821491355202065667225050801744228447515864518584620720787409961012061302114074543857882368586098987225919736280924738224995075370843988377198544539266275729089636607095220506662375139381261384398438998662059177913249680151096549632879238896603189241688956490787338355571799212913598318011639865738648621731434747681682396930715043552472778331701738091587062917693835229391950847730617837543337471998802061973389340720433170042633451884844390746043635079083497185464124715717119052915013438803576714502781</span>,</span><br><span class="line">   <span class="number">15544274873612998989866379328566946388285248570806564503108352867340017880252665817613208325183832507901409765669821491355202065667225050801744228447515864518584620720787409961012061302114074543857882368586098987225919736280924738224995075370843988377198544539266275729089636607095220506662375139381261384398438998662059177913249680151096549632879238896603189241688956490787338355571799212913598318011639865738648621731434747681682396930715043552472778331701733991049485714120357663081338580983163588987883815040112341393183479429685436337175694444720513269496978577270272192766705854550355666404326847416678342795901</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chinese_remainder</span><span class="params">(n, a)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    prod = reduce(<span class="keyword">lambda</span> a, b: a * b, n)</span><br><span class="line">    <span class="keyword">for</span> n_i, a_i <span class="keyword">in</span> zip(n, a):</span><br><span class="line">        p = prod // n_i</span><br><span class="line">        sum += a_i * inverse_mod(p, n_i) * p</span><br><span class="line">    <span class="keyword">return</span> int(sum % prod)</span><br><span class="line"></span><br><span class="line">T = []</span><br><span class="line">T.append(chinese_remainder([n[<span class="number">0</span>],n[<span class="number">1</span>]],[<span class="number">1</span>,<span class="number">0</span>]))</span><br><span class="line">T.append(chinese_remainder([n[<span class="number">1</span>],n[<span class="number">0</span>]],[<span class="number">1</span>,<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N = n[<span class="number">0</span>]*n[<span class="number">1</span>]</span><br><span class="line">P.&lt;x&gt; = PolynomialRing(Zmod(N))</span><br><span class="line"></span><br><span class="line">g=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    g += ((a[i]*x *<span class="number">2</span>^<span class="number">608</span> + b[i])^<span class="number">3</span> - c[i])*T[i]</span><br><span class="line">g = g.monic()</span><br><span class="line">x = g.small_roots()[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> x</span><br><span class="line"><span class="keyword">print</span> hex(long(x))[<span class="number">2</span>:].strip(<span class="string">'L'</span>).decode(<span class="string">'hex'</span>)</span><br><span class="line"><span class="comment"># 1714661166087377473014475529806516832214035482305327415277479703776481564871479523924321275498885242003713793314464965569235093750357822116766965311615937698169583931123673327349849371866141948995747458407120138743748898874096942</span></span><br><span class="line"><span class="comment"># Hahaha, Hastad's method don't work on this. Flag is flag&#123;6b6c9731-5189-4937-9ead-310494b8f05b&#125;.</span></span><br></pre></td></tr></table></figure><h2 id="0x03-cr3-what-is-this-encryption"><a href="#0x03-cr3-what-is-this-encryption" class="headerlink" title="0x03 cr3-what-is-this-encryption"></a>0x03 cr3-what-is-this-encryption</h2><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题以十六进制明文的方式给出了<code>p, q, e</code>这三个RSA解密需要的参数以及密文<code>c</code>，直接编写脚本解密即可。需要用到<code>gmpy2</code>和<code>binascii</code>这两个库。</p><h3 id="解题脚本-1"><a href="#解题脚本-1" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">p=<span class="string">'0xa6055ec186de51800ddd6fcbf0192384ff42d707a55f57af4fcfb0d1dc7bd97055e8275cd4b78ec63c5d592f567c66393a061324aa2e6a8d8fc2a910cbee1ed9'</span> </span><br><span class="line">q=<span class="string">'0xfa0f9463ea0a93b929c099320d31c277e0b0dbc65b189ed76124f5a1218f5d91fd0102a4c8de11f28be5e4d0ae91ab319f4537e97ed74bc663e972a4a9119307'</span> </span><br><span class="line">e=<span class="string">'0x6d1fdab4ce3217b3fc32c9ed480a31d067fd57d93a9ab52b472dc393ab7852fbcb11abbebfd6aaae8032db1316dc22d3f7c3d631e24df13ef23d3b381a1c3e04abcc745d402ee3a031ac2718fae63b240837b4f657f29ca4702da9af22a3a019d68904a969ddb01bcf941df70af042f4fae5cbeb9c2151b324f387e525094c41'</span></span><br><span class="line">c=<span class="string">'0x7fe1a4f743675d1987d25d38111fae0f78bbea6852cba5beda47db76d119a3efe24cb04b9449f53becd43b0b46e269826a983f832abb53b7a7e24a43ad15378344ed5c20f51e268186d24c76050c1e73647523bd5f91d9b6ad3e86bbf9126588b1dee21e6997372e36c3e74284734748891829665086e0dc523ed23c386bb520'</span></span><br><span class="line"></span><br><span class="line">p_decimal = int(p, <span class="number">16</span>)</span><br><span class="line">q_decimal = int(q, <span class="number">16</span>)</span><br><span class="line">e_decimal = int(e, <span class="number">16</span>)</span><br><span class="line">c_decimal = int(c, <span class="number">16</span>)</span><br><span class="line">phi_n = (p_decimal<span class="number">-1</span>) * (q_decimal<span class="number">-1</span>)</span><br><span class="line">d = gmpy2.invert(e_decimal, phi_n)</span><br><span class="line">m_decimal = pow(c_decimal, d, (p_decimal)*(q_decimal))</span><br><span class="line">final_message = binascii.a2b_hex(hex(m_decimal)[<span class="number">2</span>:])</span><br><span class="line">print(final_message.decode())</span><br></pre></td></tr></table></figure><h2 id="0x04-flag-in-your-hand1-amp-flag-in-your-hand"><a href="#0x04-flag-in-your-hand1-amp-flag-in-your-hand" class="headerlink" title="0x04 flag_in_your_hand1 &amp; flag_in_your_hand"></a>0x04 flag_in_your_hand1 &amp; flag_in_your_hand</h2><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>这两个题的思路和flag都是一样的（小声逼逼</p><p>下载附件并解压，文件夹中有一个<code>html</code>页面和一个js脚本。首先进入页面，容易得到flag的获取流程为：手动输入Token，并运行<code>getFlag()</code>函数，步进查看该函数细节。</p><p><img src="http://static.zybuluo.com/B1ank/7xmysk8mnvmaeejut6pb0y2m/flag_in_your_hand1.PNG" alt="flag_in_your_hand1.PNG-17.3kB"></p><p>可以很清楚地看到，该函数首先获取输入框中的Token值，并将其传入<code>checkToken()</code>函数，返回结果为ic，然后将其传入<code>bm()</code>函数，该函数返回结果为fg。进入提供的js脚本中查看这两个函数，可以发现<code>bm()</code>函数与flag的生成过程有关，分析可以得到其运用单表替换的编码方式。单独查看<code>checkToken()</code>函数可以发现其返回结果为false。但结合<code>bm()</code>函数的运行流程可以发现，ic的值会通过<code>ck()</code>函数覆盖。</p><p><img src="http://static.zybuluo.com/B1ank/4ke5xx1ohv8a1h2r1r7vate5/flag_in_your_hand11.PNG" alt="flag_in_your_hand11.PNG-35.6kB"></p><p>观察<code>ck()</code>函数内部可知，其检验过程要求输入Token中每个字母的ASCII值与数组a中的对应位置ASCII值相差3，于是可以编写脚本得到验证正确的Token，输入以获得flag。</p><h3 id="解题脚本-2"><a href="#解题脚本-2" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">password = <span class="string">''</span></span><br><span class="line">a = [<span class="number">118</span>, <span class="number">104</span>, <span class="number">102</span>, <span class="number">120</span>, <span class="number">117</span>, <span class="number">108</span>, <span class="number">119</span>, <span class="number">124</span>, <span class="number">48</span>,<span class="number">123</span>,<span class="number">101</span>,<span class="number">120</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> a:</span><br><span class="line">    password += chr(item - <span class="number">3</span>)</span><br><span class="line">print(password)</span><br></pre></td></tr></table></figure><h2 id="0x05-工业协议分析1"><a href="#0x05-工业协议分析1" class="headerlink" title="0x05 工业协议分析1"></a>0x05 工业协议分析1</h2><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>下载附件后发现其为<code>pacap</code>文件，记录网络流量。使用wireshark打开后，追踪TCP流，在结果中搜索flag字符串，发现<code>flag.txt</code>字样，考虑网络流量中包含与flag相关的txt文件。</p><p>在命令行中搜索发现<code>flag.txt</code>结果不存在有意义的明文，遂搜索其他可能发送的文件类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;.txt&quot; -a sample.pcap</span><br><span class="line">grep &quot;.rar&quot; -a sample.pcap</span><br><span class="line">grep &quot;.zip&quot; -a sample.pcap</span><br><span class="line">grep &quot;.png&quot; -a sample.pcap</span><br></pre></td></tr></table></figure><p>当搜索png图片相关时，发现网络环境中传送了base64加密的图片。</p><p><img src="/2020/11/09/攻防世界 —— Crypto（进阶区1）/C:/Users\B1ank\Desktop\攻防世界\Crypto\工业控制协议1.PNG" alt="工业控制协议1"></p><p>编写脚本解密即可得到flag。</p><h3 id="解题脚本-3"><a href="#解题脚本-3" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment"># 将上图中的base64加密结果存入./final_result.txt文件中</span></span><br><span class="line">base_result = open(<span class="string">'./final_result.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">png_result = base_result.read()</span><br><span class="line">png_after_decode = base64.b64decode(png_result)</span><br><span class="line">result = open(<span class="string">'./result.png'</span>, <span class="string">'wb'</span>)</span><br><span class="line">result.write(png_after_decode)</span><br></pre></td></tr></table></figure><h2 id="0x06-你猜猜"><a href="#0x06-你猜猜" class="headerlink" title="0x06 你猜猜"></a>0x06 你猜猜</h2><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>下载并打开题目给出的附件，发现其开头为<code>50 4B 03 04</code>显然是<code>zip</code>格式压缩包的开头，我们将其复制粘贴到Winhex中，注意保存的时候选择<code>ASCII Hex</code>选项，可以看到其ASCII字符以PK开头并且内部包含flag.txt。</p><p>将该压缩包解压发现需要密码，首先考虑zip伪加密发现不符合要求，于是使用密钥爆破软件进行爆破，得到最终密码为123456，解压得flag。</p><h3 id="一些经验-1"><a href="#一些经验-1" class="headerlink" title="一些经验"></a>一些经验</h3><p>先知社区有一篇非常详细的手撕压缩包过程，对压缩包结构的理解有一些帮助：<a href="https://xz.aliyun.com/t/3994" target="_blank" rel="noopener">从做CTF题到手撕ZIP</a>。</p><h2 id="0x07-fanfie"><a href="#0x07-fanfie" class="headerlink" title="0x07 fanfie"></a>0x07 fanfie</h2><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p>攻防世界上的题目既没有提示也没有flag格式，直接给了一堆看上去像base32编码的字符串，完全没有思路。于是找到原题得到两个重要提示。这样我们有如下题目条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.flag的格式为:BITSCTF&#123;&#125;</span><br><span class="line">2.Brute and get the base 32 format of flag</span><br><span class="line">3.encrypted.txt : MZYVMIWLGBL7CIJOGJQVOA3IN5BLYC3NHI</span><br></pre></td></tr></table></figure><p>可以看到题目提供的密文是对base32加密结果进行未知方式加密的结果。所以我们需要将提供的密文先还原成base32加密的结果，再进行base32解密得到最终flag。</p><p>base32转换过程中将明文按照每五个字符为一组进行分组，将结果进行base32加密后长度填充为8的倍数。由于已知flag以<code>BITSCTF</code>开头，我们取前五个字符进行base32加密，得到结果为<code>MZYVMIWL</code>，看起来该未知加密方式为单表替代加密。构建字母表并寻找对应关系如下：</p><p><img src="http://static.zybuluo.com/B1ank/tkv073onf40rhwf1qrq4xyfa/fanfie.PNG" alt="fanfie.PNG-17.5kB"></p><p>整理得到如下关系式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3-&gt;11</span><br><span class="line">4-&gt;24</span><br><span class="line">8-&gt;12</span><br><span class="line">9-&gt;25</span><br><span class="line">20-&gt;8</span><br><span class="line">21-&gt;21</span><br><span class="line">26-&gt;22</span><br></pre></td></tr></table></figure><p>假设为仿射密码，可以解出<code>a = 13, b = 4, modulus = 27</code>，编写脚本解密后将结果进行长度填充至8的倍数，再进行一次base32解密即可。原来这个题目的名字进行移位之后会变成affine啊（小声逼逼</p><h3 id="解题脚本-4"><a href="#解题脚本-4" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">str = <span class="string">'BITSC'</span></span><br><span class="line">print(base64.b32encode(str.encode()))</span><br><span class="line">a = <span class="number">13</span></span><br><span class="line">b = <span class="number">4</span></span><br><span class="line">mod = <span class="number">32</span></span><br><span class="line">a_modinv = gmpy2.invert(a, mod)</span><br><span class="line">print(type(a_modinv))</span><br><span class="line">base32_result_after_encode = <span class="string">'MZYVMIWLGBL7CIJOGJQVOA3IN5BLYC3NHI'</span></span><br><span class="line">alphabet = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'</span></span><br><span class="line">base32_result_after_decode = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> base32_result_after_encode:</span><br><span class="line">    index = alphabet.find(item)</span><br><span class="line">    base32_result_after_decode += alphabet[a_modinv*(index - b) % mod]</span><br><span class="line">print(base32_result_after_decode)</span><br><span class="line">flag = base64.b32decode(base32_result_after_decode+<span class="string">"="</span>*<span class="number">6</span>)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><h2 id="0x08-wtc-rsa-bbq"><a href="#0x08-wtc-rsa-bbq" class="headerlink" title="0x08 wtc rsa bbq"></a>0x08 wtc rsa bbq</h2><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><p>拿到该题目的附件并解压，发现其包括<code>key.pem</code>和<code>cipher.bin</code>，说明密钥以证书的形式存在，而加密结果以二进制文件的形式存在。</p><p>进入到Kali中使用系统自带OpenSSL的命令：<code>rsa -pubin -text -modulus -in warmup -in key.pem</code>，获取公钥对如下：</p><p><img src="http://static.zybuluo.com/B1ank/8trausp5ssc517e8e3w9x5ty/wtc_rsa_bbq.PNG" alt="wtc_rsa_bbq.PNG-112.8kB"></p><p>可以发现其模数N非常大，e为标准加密指数。编写脚本将密文以十六进制的形式从<code>cipher.bin</code>中读出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ciphertext = open(<span class="string">'./cipher.bin'</span>, <span class="string">'rb'</span>).read().encode(<span class="string">'hex'</span>)</span><br></pre></td></tr></table></figure><p>至此，解密数据的提取过程完成。</p><p>整道题目没有其他可以操作的参数，我们只能分解模数。观察模数N，发现其位数较多，显然直接分解这条路行不通（指factordb，这里使用yafu的话理论上是可以跑出来的，我们考虑费马分解法。</p><p>费马分解法适用于RSA加密过程中选取的大素数p,q较为相近的情况，运用到了<code>|p-q|</code>这一参数较小的原理进行爆破，从而实现分解模数N的功能。编写费马分解函数将N分解之后即可正常解密得flag。</p><h3 id="解题脚本-5"><a href="#解题脚本-5" class="headerlink" title="解题脚本"></a>解题脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fermat_resolve</span><span class="params">(N)</span>:</span></span><br><span class="line">    B = math.factorial(<span class="number">2</span>**<span class="number">14</span>)</span><br><span class="line">    u = <span class="number">0</span>;v = <span class="number">0</span>; i = <span class="number">0</span></span><br><span class="line">    u0 = gmpy2.iroot(N, <span class="number">2</span>)[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=(B<span class="number">-1</span>)):</span><br><span class="line">        u = (u0+i)*(u0+i)-N</span><br><span class="line">        <span class="keyword">if</span> gmpy2.is_square(u):</span><br><span class="line">            v = gmpy2.isqrt(u)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">    p = u0+i+v</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">()</span>:</span></span><br><span class="line">    decimal_e = <span class="number">65537</span></span><br><span class="line">    n = <span class="string">'62D3D61C92452630147E89670FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'</span></span><br><span class="line">    decimal_n = int(n, <span class="number">16</span>)</span><br><span class="line">    p = fermat_resolve(decimal_n)</span><br><span class="line">    q = decimal_n // p</span><br><span class="line">    print(<span class="string">'p = '</span> + str(p))</span><br><span class="line">    print(<span class="string">'q = '</span> + str(q))</span><br><span class="line">    phi_n = (p<span class="number">-1</span>) * (q<span class="number">-1</span>)</span><br><span class="line">    d = gmpy2.invert(decimal_e, phi_n)</span><br><span class="line">    ciphertext = <span class="string">'04940e995809b8346a7225a4ef8f175ef3031d33f975b5398cae11e0accb9195c4e351274bb9dbac1d1b9819ae679e8d300457f3e5f8f31150648f8393cbf503e40b11140b8a8a51d22bc5bc74fdbfda0e8dabcc6704d128aa29fe480538801bd4de422e6f1a221e471f75d855a49033289e1f58e0db5e8d2a2dab473912b1b35ed0552890c8b73246266c27edb90b1509a2d5d209236e23050c45acf812df98b1be3a8bcdff9891c773daa17b72db3fd59cd2b65ee103ec7b24e1358ebe14ccb86831a617df10674dd842939ddd455e741d4fc8f1421917b782d1660651a5396928a94661bcdf9f0d2f956fc6ca238478ef44701eefb3b0e5610dd5562fce66be11b1b5d9ffca636a52037d7ce6cd44ea810ba84c49c02ae29bd2de3ffa03ae8f05b3e633f0f11c513528f1404c66217b9d5605e6f0869c25bf024b93ce35aef2ab16d0f14f34c850ec1d13c73e46bd58686903bf63740142579095d7d293f8bd35abf653729ecd0e84954a73a07d8504ca03d3aa44a6b08d776ecf8949c5b71d52e2000ebd6610a3e18f7f739e4958e070ec9b9c9493c990d637850d2aad752fb60859f676a76fc1f3e2956abedd2bdb8eb49f88ac0b9ae01d3c848187536803c7a99e61e9e4d9e10ad60952e9387b4242c24d06f3fdb247f4c8b85425b49a8db6a716144a0e62273cb722709f96f9c254eae9d5fc9b1a0abae30af9da49af765572908251e99beaf1605a40043b7ce8cfbdd49cdbc33c0216d966165a5f04599db3dcc2404139249be6cae78b5794293451a6902c18b7719759475b31b976e40c8d579f84202808836f5ddf04d4a1edf22555c7612df1973e45b343045d02b5a90a760cebb69ef862ffe2c023ee3ee5f3968c07120e9b8d036fdeccaed9f1b7ce678f44c3e507bf5015751078f990efe248fef787f34570134679207d599cab2d58524265167d3af2208325a671f9a0ced94b902121eaa6ee982d4c23b543f863580291aab134fea82c9a711d12d2bc19efa168c05be070258442c46da95ab6f1dbf5bef845fa48524ebcda31d5e19ccb69835bd50812ef0117ff33f4319072f94359cb69eb951133afb2d72e2773a5480d04969389153d831be6007915c571f8817d6d56ed6ed5dfda5d855e4ddab32ecfdabc2b5d2235712d13226093bdac6c7c283415cdde559b638d42a19ca97a842c01bf88bdc3ec55f71dcce5b0dad2527004601ae2b49c5c1a13ecfb7e7170938382b77724c208aed8d7cb1fb23a28596c1e43b64d46336c10dae18146faf4d5eb8c42c167410903d76f80fdde479beffb56a07bb9cef7a559579b637d625b783e74c495c495b162a98340c11ccdc3fd6a127f163757f94cbffc4542b913e993258ffdf85f7b04be637126dc195a7a6910d942cc870214a198a5e984a44a92c0827786515280bf7379bebdefe579c7e5a9a69116f603911d01010d1ca93882c8fe4791bf580a60731444eb09f1f50fca0ddfb9d99310a9ed699551eb17c16433'</span></span><br><span class="line">    c = int(ciphertext, <span class="number">16</span>)</span><br><span class="line">    plaintext = int(pow(c, d, p*q))</span><br><span class="line">    message = binascii.a2b_hex(hex(plaintext)[<span class="number">2</span>:])</span><br><span class="line">    print(message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    decode()</span><br></pre></td></tr></table></figure><h3 id="一些经验-2"><a href="#一些经验-2" class="headerlink" title="一些经验"></a>一些经验</h3><p>当题目只给出一个加密过程（广播攻击不适用）且其他参数没有明显可以攻击的特征时，我们只能考虑直接分解模数N。对于模数N的分解，我们常使用两种方法：借助<a href="www.factordb.com">大整数分解网站</a>和使用Windows自带的工具yafu。前者只适合分解一些初级题目中位数较小的模数，后者包含多种模数分解方法，但效率较低。除此之外我们可以参考GitHub上的CtfRSATools这一项目，其中模数分解环节提供了许多常见的分解算法。</p><p>所有分解算法中，费马分解法和Pollard p-1分解法。下面简要介绍这两种分解方法并给出分解脚本。</p><h4 id="费马分解法"><a href="#费马分解法" class="headerlink" title="费马分解法"></a>费马分解法</h4><p>该方法适用于构成模数N的两个大素数p,q相近即<code>|p-q|</code>较小的情况。过程如下：</p><p>任何一个正整数n都能拆成$n = 2^{k} <em> a$的形式，其中a为一个奇数。若$a = c</em>d$，则令$x = (c+d)/2$，$y = (c-d)/2$，则$x^{2} - y^{2} = a$，枚举$x^{2}$观察$x^{2}-a$是否为完全平方数，如果是，则$c  = x+(x^{2}-a)^{(1/2)}$和$d = x-(x^{2}-a)^{(1/2)}$就是a的因子。我们通过枚举$x^{2}$可以找到a的所有因子。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fermat_resolve</span><span class="params">(N)</span>:</span></span><br><span class="line">    B = math.factorial(<span class="number">2</span>**<span class="number">14</span>)</span><br><span class="line">    u = <span class="number">0</span>;v = <span class="number">0</span>; i = <span class="number">0</span></span><br><span class="line">    u0 = gmpy2.iroot(N, <span class="number">2</span>)[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=(B<span class="number">-1</span>)):</span><br><span class="line">        u = (u0+i)*(u0+i)-N</span><br><span class="line">        <span class="keyword">if</span> gmpy2.is_square(u):</span><br><span class="line">            v = gmpy2.isqrt(u)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">    p = u0+i+v</span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><h4 id="Pollard-p-1分解法"><a href="#Pollard-p-1分解法" class="headerlink" title="Pollard p-1分解法"></a>Pollard p-1分解法</h4><p>Pollard p-1方法由Pollard提出，适用于p-1或q-1能够被小素数整除的情况。具体流程如下：</p><p><img src="http://static.zybuluo.com/B1ank/yl9ag00nxiqztluenw5wvyyj/pollard_p-1.png" alt="pollard_p-1.png-64.9kB"></p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pollard_p</span><span class="params">(N)</span>:</span></span><br><span class="line">    B = <span class="number">2</span>**<span class="number">20</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,B+<span class="number">1</span>):</span><br><span class="line">        a = pow(a, i, N)</span><br><span class="line">        d = gmpy2.gcd(a<span class="number">-1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> d&gt;=<span class="number">2</span> <span class="keyword">and</span> d&lt;=(n<span class="number">-1</span>):</span><br><span class="line">            q = n // d</span><br><span class="line">            n = q*d</span><br><span class="line">    <span class="keyword">return</span> d</span><br></pre></td></tr></table></figure><h2 id="0x09-工业协议分析2"><a href="#0x09-工业协议分析2" class="headerlink" title="0x09 工业协议分析2"></a>0x09 工业协议分析2</h2><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题目给出pcap附件，可以想到为流量分析，使用wireshark打开，发现存在关于ARP、UDP、SNA协议的流量包以及大量的UDP流量包。</p><p>观察UDP流量包的长度，可以看到有些长度仅出现一次，其余长度多次出现。于是猜测这些流量包存在异常。分别分析这些流量包，发现长度为147和179的流量包出现异常字符串：</p><p><img src="http://static.zybuluo.com/B1ank/7ilsjwliubokdro7w0vkfgzh/%E5%B7%A5%E6%8E%A72.PNG" alt="工控2.PNG-13kB"></p><p><img src="http://static.zybuluo.com/B1ank/u5dfguc0vwe8xewspa8uxmqz/%E5%B7%A5%E6%8E%A723.PNG" alt="工控23.PNG-13.5kB"></p><p>长度为147的流量包传输的数据以<code>flag</code>结尾。故推测下一个从<code>192.168.1.123</code>向<code>192.168.1.181</code>发送的流量包可能包含flag信息。果然从长度为179的数据包中发现可疑数据：</p><p><img src="http://static.zybuluo.com/B1ank/omejzdg7g7p2xvtxyqdcfl1a/%E5%B7%A5%E6%8E%A722.PNG" alt="工控22.PNG-16.7kB"></p><p>将末尾的十六进制字符串转换为ASCII字符串可得flag。</p><h2 id="0x0A-工控安全取证"><a href="#0x0A-工控安全取证" class="headerlink" title="0x0A 工控安全取证"></a>0x0A 工控安全取证</h2><h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目给出<code>.log</code>文件并要求查找发起第四次扫描时的数据包编号。使用wireshark打开，发现有UDP，ICMP和TCP三种类型的数据包，并存在大量的TCP流量。</p><p>观察发现，UDP流量只有三条记录，TCP流量记录过多，显然第四次扫描时的数据包不在这两类流量中。接着分析剩下的ICMP数据包，可以看到每次发送大量TCP数据包之前，先发送ICMP数据包。找到第四次建立连接发送的ICMP数据包，其编号为flag。</p><p><img src="http://static.zybuluo.com/B1ank/tfsdr97jbo5jf18yfjdhs8tr/%E5%B7%A5%E6%8E%A73.PNG" alt="工控3.PNG-47.7kB"></p><h2 id="0x0B-小结"><a href="#0x0B-小结" class="headerlink" title="0x0B 小结"></a>0x0B 小结</h2><p>这十道题目里面需要特别注意的是第二题Broadcast和第八题wtc rsa bbq。前者提供了一种与普通RSA广播攻击不同的情形，引入了Hastad Attack以及Broadcast Attack with Linear Padding，并且其结合sagemath编写的解题模板值得借鉴。后者考察了只提供一对<code>(c, n, e)</code>情况下对参数n的处理，除在线网站及yafu分解外，还可以考虑Fermat Resolve和Pollard p-1 Resolve，注意二者适用的p,q对应情况。</p><p>以及，高校战疫的Crypto题目真的好少。pwntools杀我，这辈子都不想再看到EOFError了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;更新完Crypto新手区的题目之后，接下来开始练习进阶区的题目。本系列文章持续更新中~&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="CTF_Writeup" scheme="https://blank-vax.github.io/categories/CTF-Writeup/"/>
    
    
      <category term="攻防世界" scheme="https://blank-vax.github.io/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
      <category term="经验文章" scheme="https://blank-vax.github.io/tags/%E7%BB%8F%E9%AA%8C%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>RSA Breaking</title>
    <link href="https://blank-vax.github.io/2020/11/09/RSA_Breaking/"/>
    <id>https://blank-vax.github.io/2020/11/09/RSA_Breaking/</id>
    <published>2020-11-09T02:39:34.435Z</published>
    <updated>2020-06-26T10:12:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>该文章介绍<code>2016年全国高校密码数学挑战赛的赛题三——RSA加密体制破译真题</code>的相关解法，并提供RSA密文破解的常规思路。文章中提到的所有文件及相关脚本均可以从项目<a href="https://github.com/blank-vax/RSA_breaking" target="_blank" rel="noopener">RSA_Breaking</a>中获取。</p><h2 id="0x01-对应攻击方法"><a href="#0x01-对应攻击方法" class="headerlink" title="0x01 对应攻击方法"></a>0x01 对应攻击方法</h2><p><img src="http://static.zybuluo.com/B1ank/rtbsvh6g89kyyxvzar3x13ir/RSA_breaking.png" alt="RSA_breaking.png-199.7kB"></p><p>根据上表，我们在破译明文过程中采用了公共模数攻击法、猜测攻击法、Pollard p-1分解法、低加密指数法、费马分解法和因数碰撞法共六种方法。下面进行说明。</p><h2 id="0x02-解析密文结构"><a href="#0x02-解析密文结构" class="headerlink" title="0x02 解析密文结构"></a>0x02 解析密文结构</h2><p>题目给出了21个明文分片的加密结果。针对任意待加密明文，以8字符为单位长度进行划分，得到的结果随后进行相关填充，注意在填充过程中需要加入通信序号，我们可以通过通信序号进行片段还原。具体填充与加密过程可以参考<code>过程及参数.txt</code>。根据该txt文档，我们对提供的Frame0-Frame20进行密文解析，分离出重要参数模数n，加密指数e和密文c，脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">21</span>):</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"/Users/mac/Desktop/RSA大礼包/frame_set/Frame"</span>+str(i), <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        tmp = f.read()</span><br><span class="line">        ns.append(tmp[<span class="number">0</span>:<span class="number">256</span>])</span><br><span class="line">        es.append(tmp[<span class="number">256</span>:<span class="number">512</span>])</span><br><span class="line">        cs.append(tmp[<span class="number">512</span>:<span class="number">768</span>])</span><br></pre></td></tr></table></figure><p>对解析得到的参数进行分析，分析方法如下：</p><ul><li>遍历所有的模数N，判断是否存在模数相同的加密片段</li><li>遍历寻找任意两个模数N的公因子，如果得到不为1的公因子则可以成功分解这两个模数</li><li>遍历所有加密指数e，寻找低加密指数及对应的加密对</li><li>剩下的片段采用费马分解和Pollard p-1分解进行尝试</li><li>常规方法使用完如果还有剩余片段，可以采用猜测攻击的方法。当然，针对猜测攻击的结果需要进行游程计算，以验证结果的精确性。</li></ul><p>经过以上分析，得出结论：</p><ul><li>Frame0和Frame4的模数N相同，假设这两片段对应的明文内容相同，则可以使用公共模数攻击的方法</li><li>Frame1和Frame18的模数N具有公共因子，可以通过因数碰撞法还原明文</li><li>Frame3，Frame8，Frame12，Frame16和Frame20采用低加密指数<code>e=5</code>进行加密</li><li>Frame7，Frame11，Frame15采用低加密指数<code>e=3</code>进行加密</li></ul><h2 id="0x03-公共模数攻击"><a href="#0x03-公共模数攻击" class="headerlink" title="0x03 公共模数攻击"></a>0x03 公共模数攻击</h2><h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p><img src="http://static.zybuluo.com/B1ank/sqduwfektaos1ycflb95t6r9/Same_modules.PNG" alt="Same_modules.PNG-35.2kB"></p><h3 id="函数构建"><a href="#函数构建" class="headerlink" title="函数构建"></a>函数构建</h3><p>针对Frame0和Frame4，构建共模攻击函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 欧几里得算法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">egcd</span><span class="params">(a, b)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> (b, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    g, y, x = egcd(b % a, a)</span><br><span class="line">    <span class="keyword">return</span> (g, x - (b // a) * y, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 公共模数攻击</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">same_modulus</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 寻找公共模数</span></span><br><span class="line">    index1 = <span class="number">0</span></span><br><span class="line">    index2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">21</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, <span class="number">21</span>):</span><br><span class="line">            <span class="keyword">if</span> ns[i] == ns[j]:</span><br><span class="line">                print(<span class="string">'Same modulus found!'</span> + str((ns[i], ns[j])))</span><br><span class="line">                index1 ,index2 = i, j  </span><br><span class="line">    e1 = int(es[index1], <span class="number">16</span>)</span><br><span class="line">    e2 = int(es[index2], <span class="number">16</span>)</span><br><span class="line">    n = int(ns[index1], <span class="number">16</span>)</span><br><span class="line">    c1 = int(cs[index1], <span class="number">16</span>)</span><br><span class="line">    c2 = int(cs[index2], <span class="number">16</span>)</span><br><span class="line">    s = egcd(e1, e2)</span><br><span class="line">    s1 = s[<span class="number">1</span>]</span><br><span class="line">    s2 = s[<span class="number">2</span>]</span><br><span class="line">    <span class="comment"># 求模反元素</span></span><br><span class="line">    <span class="keyword">if</span> s1&lt;<span class="number">0</span>:</span><br><span class="line">        s1 = - s1</span><br><span class="line">        c1 = gmpy2.invert(c1, n)</span><br><span class="line">    <span class="keyword">elif</span> s2&lt;<span class="number">0</span>:</span><br><span class="line">        s2 = - s2</span><br><span class="line">        c2 = gmpy2.invert(c2, n)</span><br><span class="line"></span><br><span class="line">    m = pow(c1,s1,n)*pow(c2,s2,n) % n</span><br><span class="line"></span><br><span class="line">    print(m)</span><br><span class="line">    print(binascii.a2b_hex(hex(m)[<span class="number">2</span>:]))</span><br><span class="line">    result = binascii.a2b_hex(hex(m)[<span class="number">2</span>:])</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h3 id="破译结果"><a href="#破译结果" class="headerlink" title="破译结果"></a>破译结果</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Frame0: My secre</span></span><br><span class="line"><span class="comment"># Frame4: My secre</span></span><br></pre></td></tr></table></figure><h2 id="0x04-因数碰撞攻击"><a href="#0x04-因数碰撞攻击" class="headerlink" title="0x04 因数碰撞攻击"></a>0x04 因数碰撞攻击</h2><h3 id="攻击原理-1"><a href="#攻击原理-1" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>通过爆破的方法，如果发现两个模数N具有公共因子，则可以通过简单的乘除处理进行模数分解，最终破解出这两个模数对应的明文。</p><h3 id="函数构建-1"><a href="#函数构建-1" class="headerlink" title="函数构建"></a>函数构建</h3><p>针对Frame1和Frame18，构造因数碰撞函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因数碰撞法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">same_factor</span><span class="params">()</span>:</span></span><br><span class="line">    plaintext = []</span><br><span class="line">    index = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">21</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, <span class="number">21</span>):</span><br><span class="line">            <span class="keyword">if</span> int(ns[i], <span class="number">16</span>) == int(ns[j], <span class="number">16</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            prime = gmpy2.gcd(int(ns[i], <span class="number">16</span>), int(ns[j], <span class="number">16</span>))</span><br><span class="line">            <span class="keyword">if</span> prime != <span class="number">1</span>:</span><br><span class="line">                print((ns[i], ns[j]))</span><br><span class="line">                print((i, j))</span><br><span class="line">                index.append(i)</span><br><span class="line">                index.append(j)</span><br><span class="line">                p_of_frame = prime</span><br><span class="line">    q_of_frame1 = int(ns[index[<span class="number">0</span>]], <span class="number">16</span>) // p_of_frame</span><br><span class="line">    q_of_frame18 = int(ns[index[<span class="number">1</span>]], <span class="number">16</span>) // p_of_frame</span><br><span class="line">    print(p_of_frame)</span><br><span class="line">    print(q_of_frame1, q_of_frame18)</span><br><span class="line"></span><br><span class="line">    phi_of_frame1 = (p_of_frame<span class="number">-1</span>)*(q_of_frame1<span class="number">-1</span>)</span><br><span class="line">    phi_of_frame18 = (p_of_frame<span class="number">-1</span>)*(q_of_frame18<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    d_of_frame1 = gmpy2.invert(int(es[index[<span class="number">0</span>]],<span class="number">16</span>) ,phi_of_frame1)</span><br><span class="line">    d_of_frame18 = gmpy2.invert(int(es[index[<span class="number">1</span>]], <span class="number">16</span>), phi_of_frame18)</span><br><span class="line"></span><br><span class="line">    plaintext_of_frame1 = gmpy2.powmod(int(cs[index[<span class="number">0</span>]], <span class="number">16</span>), d_of_frame1, int(ns[index[<span class="number">0</span>]], <span class="number">16</span>))</span><br><span class="line">    plaintext_of_frame18 = gmpy2.powmod(int(cs[index[<span class="number">1</span>]], <span class="number">16</span>), d_of_frame18, int(ns[index[<span class="number">1</span>]], <span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">    final_plain_of_frame1 = binascii.a2b_hex(hex(plaintext_of_frame1)[<span class="number">2</span>:])</span><br><span class="line">    final_plain_of_frame18 = binascii.a2b_hex(hex(plaintext_of_frame18)[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">    plaintext.append(final_plain_of_frame1)</span><br><span class="line">    plaintext.append(final_plain_of_frame18)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br></pre></td></tr></table></figure><h3 id="破译结果-1"><a href="#破译结果-1" class="headerlink" title="破译结果"></a>破译结果</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Frame1: . Imagin</span></span><br><span class="line"><span class="comment"># Frame18: m A to B</span></span><br></pre></td></tr></table></figure><h2 id="0x05-低加密指数攻击"><a href="#0x05-低加密指数攻击" class="headerlink" title="0x05 低加密指数攻击"></a>0x05 低加密指数攻击</h2><h3 id="攻击原理-2"><a href="#攻击原理-2" class="headerlink" title="攻击原理"></a>攻击原理</h3><p><img src="http://static.zybuluo.com/B1ank/mg5oc4wlaawvfi9yqdpjqtoa/low_e.PNG" alt="low_e.PNG-23.1kB"></p><h3 id="函数构建-2"><a href="#函数构建-2" class="headerlink" title="函数构建"></a>函数构建</h3><p>通过以上原理可以看出，对于低加密指数进行的攻击实质上为爆破攻击，可以通过循环开方的方法进行破解。构造破解函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 低加密指数攻击</span></span><br><span class="line"><span class="comment"># 经过输出检测,发现Frame3,Frame8,Frame12,Frame16,Frame20采用低加密指数e=5进行加密</span></span><br><span class="line"><span class="comment"># 前置函数中国剩余定理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chinese_remainder_theorem</span><span class="params">(items)</span>:</span></span><br><span class="line">    N = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> a, n <span class="keyword">in</span> items:</span><br><span class="line">        N *= n</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a, n <span class="keyword">in</span> items:</span><br><span class="line">        m = N//n</span><br><span class="line">        d, r, s = egcd(n, m)</span><br><span class="line">        <span class="keyword">if</span> d != <span class="number">1</span>:</span><br><span class="line">            N = N//n</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        result += a*s*m</span><br><span class="line">    <span class="keyword">return</span> result % N, N</span><br><span class="line"><span class="comment"># 低加密指数e == 3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bruce_e_3</span><span class="params">()</span>:</span></span><br><span class="line">    bruce_range = [<span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        c = int(cs[bruce_range[i]], <span class="number">16</span>)</span><br><span class="line">        n = int(ns[bruce_range[i]], <span class="number">16</span>)</span><br><span class="line">        print(<span class="string">"This is frame"</span> + str(i))</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">            plain = gmpy2.iroot(gmpy2.mpz(c+j*n), <span class="number">3</span>)</span><br><span class="line">            print(<span class="string">"This is test"</span> + str(j))</span><br><span class="line">            print(binascii.a2b_hex(hex(plain[<span class="number">0</span>])[<span class="number">2</span>:]))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">low_e_3</span><span class="params">()</span>:</span></span><br><span class="line">    sessions=[&#123;<span class="string">"c"</span>: int(cs[<span class="number">7</span>], <span class="number">16</span>) ,<span class="string">"n"</span>: int(ns[<span class="number">7</span>], <span class="number">16</span>)&#125;,</span><br><span class="line">    &#123;<span class="string">"c"</span>:int(cs[<span class="number">11</span>], <span class="number">16</span>) ,<span class="string">"n"</span>:int(ns[<span class="number">11</span>], <span class="number">16</span>)&#125;,</span><br><span class="line">    &#123;<span class="string">"c"</span>:int(cs[<span class="number">15</span>], <span class="number">16</span>) ,<span class="string">"n"</span>:int(ns[<span class="number">15</span>], <span class="number">16</span>)&#125;]</span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> session <span class="keyword">in</span> sessions:</span><br><span class="line">        data = data+[(session[<span class="string">'c'</span>], session[<span class="string">'n'</span>])]</span><br><span class="line">    x, y = chinese_remainder_theorem(data)</span><br><span class="line">    <span class="comment"># 直接开三次方根</span></span><br><span class="line">    plaintext7_11_15 = gmpy2.iroot(gmpy2.mpz(x), <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> binascii.a2b_hex(hex(plaintext7_11_15[<span class="number">0</span>])[<span class="number">2</span>:])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">low_e_5</span><span class="params">()</span>:</span></span><br><span class="line">    sessions=[&#123;<span class="string">"c"</span>: int(cs[<span class="number">3</span>], <span class="number">16</span>),<span class="string">"n"</span>: int(ns[<span class="number">3</span>], <span class="number">16</span>)&#125;,</span><br><span class="line">    &#123;<span class="string">"c"</span>:int(cs[<span class="number">8</span>], <span class="number">16</span>) ,<span class="string">"n"</span>:int(ns[<span class="number">8</span>], <span class="number">16</span>) &#125;,</span><br><span class="line">    &#123;<span class="string">"c"</span>:int(cs[<span class="number">12</span>], <span class="number">16</span>),<span class="string">"n"</span>:int(ns[<span class="number">12</span>], <span class="number">16</span>)&#125;,</span><br><span class="line">    &#123;<span class="string">"c"</span>:int(cs[<span class="number">16</span>], <span class="number">16</span>),<span class="string">"n"</span>:int(ns[<span class="number">16</span>], <span class="number">16</span>)&#125;,</span><br><span class="line">    &#123;<span class="string">"c"</span>:int(cs[<span class="number">20</span>], <span class="number">16</span>),<span class="string">"n"</span>:int(ns[<span class="number">20</span>], <span class="number">16</span>)&#125;]</span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> session <span class="keyword">in</span> sessions:</span><br><span class="line">        data = data+[(session[<span class="string">'c'</span>], session[<span class="string">'n'</span>])]</span><br><span class="line">    x, y = chinese_remainder_theorem(data)</span><br><span class="line">    <span class="comment"># 直接开五次方根</span></span><br><span class="line">    plaintext3_8_12_16_20 = gmpy2.iroot(gmpy2.mpz(x),<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> binascii.a2b_hex(hex(plaintext3_8_12_16_20[<span class="number">0</span>])[<span class="number">2</span>:])</span><br></pre></td></tr></table></figure><h3 id="破译结果-2"><a href="#破译结果-2" class="headerlink" title="破译结果"></a>破译结果</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># e = 3对应的三段明文还原失败，均为不可识别的乱码，故需要使用其他方法破解Frame7、Frame11和Frame15</span></span><br><span class="line"><span class="comment"># e = 5</span></span><br><span class="line"><span class="comment"># Frame3: t is a f</span></span><br><span class="line"><span class="comment"># Frame8: t is a f</span></span><br><span class="line"><span class="comment"># Frame12: t is a f</span></span><br><span class="line"><span class="comment"># Frame16: t is a f</span></span><br><span class="line"><span class="comment"># Frame20: t is a f</span></span><br></pre></td></tr></table></figure><h2 id="0x06-费马分解法"><a href="#0x06-费马分解法" class="headerlink" title="0x06 费马分解法"></a>0x06 费马分解法</h2><h3 id="攻击原理-3"><a href="#攻击原理-3" class="headerlink" title="攻击原理"></a>攻击原理</h3><p><img src="http://static.zybuluo.com/B1ank/okm3wmq253mjvepasm2nw9bn/Fermat.PNG" alt="Fermat.PNG-25.1kB"></p><h3 id="函数构建-3"><a href="#函数构建-3" class="headerlink" title="函数构建"></a>函数构建</h3><p>根据原理构建解密函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义费马分解法,适用于p,q相近的情况</span></span><br><span class="line"><span class="comment"># 爆破之后发现Frame10中的模数可以在短时间内使用此方法分解</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pq</span><span class="params">(n)</span>:</span></span><br><span class="line">    B=math.factorial(<span class="number">2</span>**<span class="number">14</span>)</span><br><span class="line">    u=<span class="number">0</span>;v=<span class="number">0</span>;i=<span class="number">0</span></span><br><span class="line">    u0=gmpy2.iroot(n,<span class="number">2</span>)[<span class="number">0</span>]+<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=(B<span class="number">-1</span>)):</span><br><span class="line">        u=(u0+i)*(u0+i)-n</span><br><span class="line">        <span class="keyword">if</span> gmpy2.is_square(u):</span><br><span class="line">            v=gmpy2.isqrt(u)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        i=i+<span class="number">1</span>  </span><br><span class="line">    p=u0+i+v</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fermat_resolve</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>,<span class="number">14</span>):</span><br><span class="line">        N = int(ns[i], <span class="number">16</span>)</span><br><span class="line">        p = pq(N)</span><br><span class="line">        print(p)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_content_of_frame10</span><span class="params">()</span>:</span></span><br><span class="line">    p = <span class="number">9686924917554805418937638872796017160525664579857640590160320300805115443578184985934338583303180178582009591634321755204008394655858254980766008932978699</span></span><br><span class="line">    n = int(ns[<span class="number">10</span>], <span class="number">16</span>)</span><br><span class="line">    c = int(cs[<span class="number">10</span>], <span class="number">16</span>)</span><br><span class="line">    e = int(es[<span class="number">10</span>], <span class="number">16</span>)</span><br><span class="line">    q = n // p</span><br><span class="line">    phi_of_frame10 = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line">    d = gmpy2.invert(e, phi_of_frame10)</span><br><span class="line">    m = gmpy2.powmod(c, d, n)</span><br><span class="line">    final_plain = binascii.a2b_hex(hex(m)[<span class="number">2</span>:])</span><br><span class="line">    <span class="keyword">return</span> final_plain</span><br></pre></td></tr></table></figure><h3 id="破译结果-3"><a href="#破译结果-3" class="headerlink" title="破译结果"></a>破译结果</h3><p>爆破运行之后发现Frame10可以被快速解密，结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Frame10: will get</span></span><br></pre></td></tr></table></figure><h2 id="0x07-Pollard-p-1分解法"><a href="#0x07-Pollard-p-1分解法" class="headerlink" title="0x07 Pollard p-1分解法"></a>0x07 Pollard p-1分解法</h2><h3 id="攻击原理-4"><a href="#攻击原理-4" class="headerlink" title="攻击原理"></a>攻击原理</h3><p><img src="http://static.zybuluo.com/B1ank/l7mr898qyw22hkmez2aiu1c1/Pollardp-1.png" alt="Pollardp-1.png-64.9kB"></p><h3 id="函数构建-4"><a href="#函数构建-4" class="headerlink" title="函数构建"></a>函数构建</h3><p>根据以上原理，构造Pollard p-1分解函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义Pollard p-1分解法,适用于p-1或q-1能够被小素数整除的情况</span></span><br><span class="line"><span class="comment"># 经过爆破发现Frame2,Frame6,Frame19的模数可以使用该方法分解</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pp1</span><span class="params">(n)</span>:</span></span><br><span class="line">    B=<span class="number">2</span>**<span class="number">20</span></span><br><span class="line">    a=<span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,B+<span class="number">1</span>):</span><br><span class="line">        a=pow(a,i,n)</span><br><span class="line">        d=gmpy2.gcd(a<span class="number">-1</span>,n)</span><br><span class="line">        <span class="keyword">if</span> (d&gt;=<span class="number">2</span>)<span class="keyword">and</span>(d&lt;=(n<span class="number">-1</span>)):</span><br><span class="line">            q=n//d</span><br><span class="line">            n=q*d</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pollard_resolve</span><span class="params">()</span>:</span></span><br><span class="line">    index_list = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">19</span>]</span><br><span class="line">    plaintext = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        N = int(ns[index_list[i]], <span class="number">16</span>)</span><br><span class="line">        c = int(cs[index_list[i]], <span class="number">16</span>)</span><br><span class="line">        e = int(es[index_list[i]], <span class="number">16</span>)</span><br><span class="line">        p = pp1(N)</span><br><span class="line">        print(<span class="string">"p of "</span>+ str(index_list[i]) + <span class="string">" is : "</span> + str(p))</span><br><span class="line">        q = N // p</span><br><span class="line">        phi_of_frame = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line">        d = gmpy2.invert(e, phi_of_frame)</span><br><span class="line">        m = gmpy2.powmod(c, d, N)</span><br><span class="line">        plaintext.append(binascii.a2b_hex(hex(m)[<span class="number">2</span>:]))</span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br></pre></td></tr></table></figure><h3 id="破译结果-4"><a href="#破译结果-4" class="headerlink" title="破译结果"></a>破译结果</h3><p>使用该函数对所有内容进行爆破处理，发现Frame2，Frame6和Frame19的模数可以使用该方法分解，于是处理后结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Frame2: That is</span></span><br><span class="line"><span class="comment"># Frame6: "Logic "</span></span><br><span class="line"><span class="comment"># Frame19: instein.</span></span><br></pre></td></tr></table></figure><p>至此已完成使用常规RSA破解方法对题目的分析，结合所有的明文片段，我们得到现有明文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Frame0 My secre</span><br><span class="line">Frame1 . Imagin</span><br><span class="line">Frame2  That is </span><br><span class="line">Frame3 t is a f</span><br><span class="line">Frame4 My secre</span><br><span class="line">Frame5 </span><br><span class="line">Frame6  &quot;Logic </span><br><span class="line">Frame7 </span><br><span class="line">Frame8 t is a f</span><br><span class="line">Frame9</span><br><span class="line">Frame10 will get</span><br><span class="line">Frame11</span><br><span class="line">Frame12 t is a f</span><br><span class="line">Frame13</span><br><span class="line">Frame14</span><br><span class="line">Frame15</span><br><span class="line">Frame16 t is a f</span><br><span class="line">Frame17</span><br><span class="line">Frame18 m A to B</span><br><span class="line">Frame19 instein.</span><br><span class="line">Frame20 t is a f</span><br></pre></td></tr></table></figure><h2 id="0x08-猜测攻击"><a href="#0x08-猜测攻击" class="headerlink" title="0x08 猜测攻击"></a>0x08 猜测攻击</h2><p>结合上述破译结果及通信序号，我们整理之后发现可以连缀成有语义的句子，但部分区域存在空缺。于是使用Google搜索等方法找到原句。填补空缺之后进行相关游程计算。</p><p>由于该项目重点在于理清RSA破译思路，故剩余工作不再进行赘述。</p><h2 id="0x09-明文结果"><a href="#0x09-明文结果" class="headerlink" title="0x09 明文结果"></a>0x09 明文结果</h2><p>经过以上破译工作，明文结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"My secret is a famous saying of Albert Einstein. That is \"Logic will get you from A to B. Imagination will take you everywhere.\""</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;该文章介绍&lt;code&gt;2016年全国高校密码数学挑战赛的赛题三——RSA加密体制破译真题&lt;/code
      
    
    </summary>
    
      <category term="Crypto_Attack" scheme="https://blank-vax.github.io/categories/Crypto-Attack/"/>
    
    
      <category term="RSA" scheme="https://blank-vax.github.io/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>SUCTF-Crypto部分总结</title>
    <link href="https://blank-vax.github.io/2020/11/09/SUCTF-Crypto%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/"/>
    <id>https://blank-vax.github.io/2020/11/09/SUCTF-Crypto部分总结/</id>
    <published>2020-11-09T02:39:34.435Z</published>
    <updated>2019-10-30T13:32:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-几句废话"><a href="#0x00-几句废话" class="headerlink" title="0x00 几句废话"></a>0x00 几句废话</h2><p>总体来说,suctf的crypto部分的难度没有想象中的那么高(所以难度就全部集中到misc和web中去了吧可能),结合su-team分享的出题思路以及网上各路大神的解题脚本,学习了许多新姿势.</p><h2 id="0x01-题目概览"><a href="#0x01-题目概览" class="headerlink" title="0x01 题目概览"></a>0x01 题目概览</h2><p>此次比赛共出了四道密码学相关题目.    </p><ul><li>传统的DSA题目——重复使用r进行签名.</li><li>传统的RSA题目——LSB-Oracle攻击.</li><li>新型RSA题目——<code>e == n</code>情况下使用四个素数构造n的情况.</li><li>随机数发生器——考察mt19937-32位可逆随机比特发生器的应用.</li></ul><h2 id="0x02-解题新姿势"><a href="#0x02-解题新姿势" class="headerlink" title="0x02 解题新姿势"></a>0x02 解题新姿势</h2><h3 id="pwntools用于C-S交互"><a href="#pwntools用于C-S交互" class="headerlink" title="pwntools用于C/S交互"></a>pwntools用于C/S交互</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>pwntools是一个研究者开发的用于pwn的CTF框架,这里主要讨论其在用户端/客户端交互过程中的使用,从而对解决服务器交互类型的Crypto问题起到作用.</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul><li>Linux虚拟机中安装pwntools只需要命令<code>pip install pwntools</code>.  </li><li>Mac系统中使用<code>brew install pwntools</code>,该命令的安装效果要强于使用pip命令.安装好之后,进入python2所在的包路径,在其中放入<code>*.pth</code>文件,在该文件中写入pwntools所在路径即可完成安装.</li><li><a href="https://blog.csdn.net/youshaoduo/article/details/91446588" target="_blank" rel="noopener">安装参考链接</a></li></ul><h4 id="交互功能"><a href="#交互功能" class="headerlink" title="交互功能"></a>交互功能</h4><ul><li>导入方法: <code>from pwn import *</code></li><li>连接<ul><li>本地: <code>sh = process(&quot;./level10&quot;)</code></li><li>远程: <code>sh = remote(&quot;127.0.0.1&quot;,10001)</code></li><li>关闭连接: <code>sh.close()</code></li></ul></li><li>I/O模块<ul><li>发送数据: <code>sh.send(data)</code></li><li>发送一行数据,相当于在数据后面加”\n”(许多服务器交互题目必须模拟提交后的回车键,故需要在提交信息后加上”\n”): <code>sh.sendline(data)</code></li><li>接收数据,numb指定接收的字节,timeout指定超时: <code>sh.recv(numb=2048, timeout=default</code></li><li>接收一行数据,keepends为是否保留行尾的\n: <code>sh.recvline(keepends=True)</code></li><li>接收数据直到出现设置的标志(避免了使用正则表达式): <code>sh.recvutil(&quot;Hello,World\n&quot;,drop=false)</code></li><li>一直接收直到EOF: <code>recvall()</code></li><li>持续接收直到EOF或timeout: <code>recvrepeat(timeout=default)</code></li><li>直接进行交互,相当于回到shell的模式,在取得shell之后使用: <code>sh.interactive()</code></li></ul></li><li><a href="https://www.jianshu.com/p/355e4badab50" target="_blank" rel="noopener">pwntools常用函数</a></li></ul><h3 id="python-z3库"><a href="#python-z3库" class="headerlink" title="python-z3库"></a>python-z3库</h3><p>Z3约束求解器是针对Satisfiability modulo theories Problem 的一种通用求解器.所谓SMT问题,在 Z3环境下是指关于算术、位运算、数组等背景理论的一阶逻辑组合决定性问题.能够用约束求解器搞定的问题常见于密码题、二进制逆向、符号执行Fuzzing模糊测试等.</p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><ul><li>python3可以直接使用<code>pip3 install z3-solver</code>来安装z3库.</li><li>python2可以使用<code>pip2 install z3-solver</code>来获得安装包,再使用上文提到的创建<code>*.pth</code>文件将该包加入到python2包路径里</li><li>基础用法<ul><li>创建约束求解器: <code>solver = Solver()</code></li><li>添加约束条件: <code>solver.add()</code></li><li>判断解是否存在: <code>solver.check()</code>,当该函数返回sat时说明有解,返回unsat说明无解</li><li>求解: <code>solver.model()</code></li><li>数据类型: <ul><li><code>Int()</code>: 有符号数. </li><li><code>BitVec(variable, bits_number)</code>: 其中bits_number表示该变量的最大比特位数.只有BitVec变量可以进行异或,故可以用来解决位运算问题.BitVecVal值之间不能进行&gt;或&lt;比较,只能转换成python认识的类型才可以比较.</li><li><code>as_long()</code>: 该函数用于将BitVec()类型的数据转换成long类型数据从而输出.</li></ul></li></ul></li><li><a href="https://github.com/ericpony/z3py-tutorial" target="_blank" rel="noopener">z3详细介绍</a></li><li><a href="https://zhuanlan.zhihu.com/p/30548907" target="_blank" rel="noopener">z3在CTF中的应用-长亭技术专栏</a></li></ul><h2 id="0x03-题目分析"><a href="#0x03-题目分析" class="headerlink" title="0x03 题目分析"></a>0x03 题目分析</h2><h3 id="DSA"><a href="#DSA" class="headerlink" title="DSA"></a>DSA</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>签名方案:    </p><ol><li>选定公共参数p,q,g,其中g^q mod p = 1,即g的阶为p;</li><li>签名方随机生成私钥x,满足0 &lt; x &lt; q,计算并公开公钥<code>y = g^x mod q</code>;</li><li>针对消息m,计算其哈希值<code>h = H(m)</code>,并生成随机数k,满足0 &lt; k &lt; q;</li><li>计算<code>r = (g^k mod p)mod q</code>(相当于时间戳,防止重放攻击);</li><li>计算<code>s = k^(-1)(H(m)+x*r) mod q</code>;</li><li>以<r, s>为数字签名进行发布.</r,></li></ol><p>验证方案:<br>接收方在已知公共参数p,q,g和接收到消息m与签名<r, s>的基础上,可以通过验证以下等式是否成立来验证签名的有效性: <code>r = (g^(s^(-1)*H(m)) + y^(s^(-1)*r) mod p) mod q</code><br>其中s^(-1)指s在模q时的乘法逆元.     </r,></p><h4 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h4><p>一旦发现两条消息m1,m2的数字签名<r1,s1>和<r2,s2>,若满足r1=r2=r,则说明它们在签名过程中使用了相同的随机数k.根据签名方案,我们有:</r2,s2></r1,s1></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k*s1 = H(m1) + x*r mod q</span><br><span class="line">k*s2 = H(m2) + x*r mod q</span><br></pre></td></tr></table></figure><p>因此有<code>x*r*(s2-s1) = H(m2)*s1 - H(m1)*s2 (mod q)</code><br>所以<code>x = (r*(s2-s1))^(-1)*(H(m2)*s1 - H(m1)*s2) mod q</code>  求得私钥x后,自然可以根据DSA数字签名方案对任意消息进行签名.</p><h4 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h4><p>题目为典型的与服务器交互的类型.直接nc目标端口,发现给出了p,q,g以及明文m,明文压缩之后的哈希值H(m)以及签名对<r, s>.最后要求给提供的明文进行签名,并且同时提供了该明文的哈希结果.仔细观察发现,签名对中存在不只一个r相同的情况,联想到DSA攻击的方法,选取任意的重复r进行签名即可.脚本如下:   </r,></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2 </span><br><span class="line"><span class="comment"># flag&#123;Wh4t_a_Prety_Si3nature!&#125;</span></span><br><span class="line"></span><br><span class="line">r = repeated_r</span><br><span class="line"></span><br><span class="line">h_flag = given_hash</span><br><span class="line"></span><br><span class="line">p = given_p</span><br><span class="line"></span><br><span class="line">q = given_q</span><br><span class="line"></span><br><span class="line">g = given_g</span><br><span class="line"></span><br><span class="line">y = given_y</span><br><span class="line"></span><br><span class="line">h1 = <span class="number">193111848988193367504523557345609960681</span></span><br><span class="line"></span><br><span class="line">h2 = <span class="number">88354320495763378663407085075664840900</span></span><br><span class="line"></span><br><span class="line">s1 = <span class="number">248140921416747064122972352259424645911583156504</span></span><br><span class="line">s2 = <span class="number">99292285215174831827792682628484078123790973232</span></span><br><span class="line">ds = s2-s1</span><br><span class="line">dh = h2-h1</span><br><span class="line">k = gmpy2.mul(dh,gmpy2.invert(ds,q))</span><br><span class="line">k = gmpy2.f_mod(k,q)</span><br><span class="line">tmp = gmpy2.mul(k,s1)-h1</span><br><span class="line">x = tmp*gmpy2.invert(r,q)</span><br><span class="line">x = gmpy2.f_mod(x,q)</span><br><span class="line"></span><br><span class="line">print(int(x))</span><br><span class="line"></span><br><span class="line">s_flag = (gmpy2.invert(k,q)*(h_flag+x*r)) % q</span><br><span class="line"></span><br><span class="line">print((r,s_flag))</span><br><span class="line"></span><br><span class="line">(<span class="number">310344651614765735153054256874236002445047411858L</span>, <span class="number">684046261087521716196888684831381917051249892988L</span>)</span><br></pre></td></tr></table></figure><h3 id="mt"><a href="#mt" class="headerlink" title="mt"></a>mt</h3><h4 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h4><p>随机数发生器MT19937在从状态提取32bits随机数时进行了四步平移和异或运算,但该四步运算均为可逆运算,从而导致可从32bits随机数还原状态.随机数生成原始过程如下:   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_number</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.index &gt;= <span class="number">624</span>:</span><br><span class="line">            self.twist()</span><br><span class="line">        y = self.mt[self.index]</span><br><span class="line">        <span class="comment"># Right shift by 11 bits</span></span><br><span class="line">        y = y ^ y &gt;&gt; <span class="number">11</span></span><br><span class="line">        <span class="comment"># Shift y left by 7 and take the bitwise and of 2636928640d</span></span><br><span class="line">        y = y ^ y &lt;&lt; <span class="number">7</span> &amp; <span class="number">2636928640</span></span><br><span class="line">        <span class="comment"># Shift y left by 15 and take the bitwise and of y and 4022730752</span></span><br><span class="line">        y = y ^ y &lt;&lt; <span class="number">15</span> &amp; <span class="number">4022730752</span></span><br><span class="line">        <span class="comment"># Right shift by 18 bits</span></span><br><span class="line">        y = y ^ y &gt;&gt; <span class="number">18</span></span><br><span class="line">        self.index = self.index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> _int32(y)</span><br></pre></td></tr></table></figure><h4 id="解题过程-1"><a href="#解题过程-1" class="headerlink" title="解题过程"></a>解题过程</h4><p>这是一倒较为基础的逆向随机数生成器的题目,没有什么特殊的技巧.两个基础的思路是爆破和逆向算法.参考大佬们的解决方案:官方给出的wp实现了左移和右移异或的逆运算函数,然后调用两个函数对密文进行解密;de1ta战队则选择了爆破;还有师傅使用python-z3库实现了算法的逆向.<br>首先来看官方的解题过程:  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util <span class="keyword">import</span> number</span><br><span class="line"></span><br><span class="line">transformed_flag = <span class="string">'641460a9e3953b1aaa21f3a2'</span></span><br><span class="line">c = transformed_flag.decode(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt_left</span><span class="params">(cipher, blocksize, mask)</span>:</span></span><br><span class="line">    plain = cipher</span><br><span class="line">    t = cipher</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span> / blocksize):</span><br><span class="line">        tt = (t &lt;&lt; blocksize) &amp; mask</span><br><span class="line">        plain = plain ^ tt</span><br><span class="line">        t = tt</span><br><span class="line">    <span class="keyword">return</span> plain</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt_right</span><span class="params">(cipher, blocksize, mask)</span>:</span></span><br><span class="line">    plain = cipher</span><br><span class="line">    t = cipher</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span> / blocksize):</span><br><span class="line">        tt = (t &gt;&gt; blocksize) &amp; mask</span><br><span class="line">        plain = plain ^ tt</span><br><span class="line">        t = tt</span><br><span class="line">    <span class="keyword">return</span> plain</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invert</span><span class="params">(block)</span>:</span></span><br><span class="line">    block = decrypt_right(block, <span class="number">19</span>, <span class="number">0xffffffff</span>)</span><br><span class="line">    block = decrypt_left(block, <span class="number">17</span>, <span class="number">2245263360</span>)</span><br><span class="line">    block = decrypt_left(block, <span class="number">9</span>, <span class="number">2029229568</span>)</span><br><span class="line">    block = decrypt_right(block, <span class="number">13</span>, <span class="number">0xffffffff</span>)</span><br><span class="line">    <span class="keyword">return</span> block</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">(message)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> len(message) % <span class="number">4</span> == <span class="number">0</span></span><br><span class="line">    new_message = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(message) / <span class="number">4</span>):</span><br><span class="line">        block = message[i * <span class="number">4</span> : i * <span class="number">4</span> +<span class="number">4</span>]</span><br><span class="line">        block = number.bytes_to_long(block)</span><br><span class="line">        block = invert(block)</span><br><span class="line">        block = number.long_to_bytes(block)</span><br><span class="line">        new_message += block</span><br><span class="line">    <span class="keyword">return</span> new_message</span><br><span class="line"></span><br><span class="line">flag = transform(c)</span><br><span class="line"><span class="keyword">print</span> flag.encode(<span class="string">'hex'</span>)</span><br></pre></td></tr></table></figure><p>对于左移和右移异或,写出其逆运算函数.基于mt随机数发生器使用32bits为一轮,故进行<code>32/blocksize</code>次数的异或还原,而blocksize则为左移或右移的位数,还原循环中的函数与加密过程相同.先挖一个坑,具体原理等研究完mt19937后再来填.<br>使用z3-solver解决的过程中,实际上也是利用了爆破的原理,以题目给出的关系式<code>convert(init) == cipher</code>为约束条件进行处理.<br>采用直接爆破方法的关键代码为:   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">(c)</span>:</span></span><br><span class="line">    x = c</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        xx = x</span><br><span class="line">        <span class="comment"># 重复多次加密,直到达到随机数生成的循环周期,从而找到加密之后为所给密文的明文</span></span><br><span class="line">        x = transform(x.decode(<span class="string">'hex'</span>)).encode(<span class="string">'hex'</span>)</span><br><span class="line">        <span class="keyword">if</span> x == c:</span><br><span class="line">            <span class="keyword">return</span> xx</span><br><span class="line">c4 = <span class="string">'641460a9e3953b1aaa21f3a2'</span></span><br><span class="line">print(decode(c4)</span><br></pre></td></tr></table></figure><p>经过实验,爆破脚本的解题效率极高,以后碰到的随机数生成问题建议首选爆破脚本.该爆破能够成功主要由于伪随机数生成器得到的数字具有周期性,经测试该伪随机数生成器的周期为61320.    </p><h3 id="Prime"><a href="#Prime" class="headerlink" title="Prime"></a>Prime</h3><h4 id="基本原理-2"><a href="#基本原理-2" class="headerlink" title="基本原理"></a>基本原理</h4><p>该题目使用了RSA加密中<code>e == n</code>这一特殊情况构造模数n.<br>对任意两个不同素数p,q和整数n=p*q,对任意整数m,0 &lt; m &lt; p且m &lt; q,若<code>c = m^n mod n</code>,则<code>c^(q&#39;) mod q = m</code>,其中q’满足q1*p mod (q-1) = 1.予以证明如下:<br>c^(q’) mod q = m^(n*q’) mod q = m^(q*p*q’) mod q = m^(((q-1)+1)*(k*(q-1)+1)) mod q = m^(k’*(q-1)+1) mod q<br>根据费马小定理: m^(q-1) mod q = 1,所以 m^(k’*(q-1)+1) mod q = m.同理c^q’ mod p = m.<br>该题以此为原理,进行了扩展,将素数数量由2个扩大到了4个,并将m的范围扩大到0 &lt; m &lt; n.</p><h4 id="解题过程-2"><a href="#解题过程-2" class="headerlink" title="解题过程"></a>解题过程</h4><p>nc地址之后,首先进行通过爆破的方式验证哈希值,从而通过proof_of_work()函数.爆破代码如下:   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> hexdigits</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(hexdigits)):</span><br><span class="line">string = <span class="string">""</span>.join([choice(hexdigits) <span class="keyword">for</span> _ <span class="keyword">in</span> range(i)]).lower()</span><br><span class="line"><span class="keyword">if</span> (md5(string + salt).hexdigest()[<span class="number">0</span>:<span class="number">5</span>] == part_hash):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>然后返回c0-c3,n0-n3共四对(n,s)对.对给出的n0,n1,n2,n3进行最大公因子分析,可分别得出他们的四个素因子.一般的,对于<code>n = p1*p2*p3*p4</code>和<code>c = m^n mod n</code>,有c^$(p_i)$’ (mod $(p_i)$) = m (mod $(p_i)$),其中$(p_i)$’满足$(p_i)$’*(n/$(p_i)$)mod$(p_i-1)$ = 1,即pi’是(n/pi)在$(p_i-1)$下的乘法逆元.然后可以利用中国剩余定理求解.官方解题脚本如下:   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> gmpy2 <span class="keyword">as</span> gm</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack</span><span class="params">(N, ns, cs)</span>:</span></span><br><span class="line">    M = np.ones((N, N))</span><br><span class="line">    M = M.tolist()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        M[i][i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> i != j:</span><br><span class="line">                M[i][j] = gm.gcd(ns[i], ns[j])</span><br><span class="line">                M[i][i] *= M[i][j]</span><br><span class="line">        M[i][i] = ns[i] / M[i][i]</span><br><span class="line"></span><br><span class="line">    nsns = [<span class="number">1</span>] * <span class="number">4</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">            nsns[i] *= M[i][j]</span><br><span class="line"></span><br><span class="line">    index = np.ones((N, N))</span><br><span class="line">    index = index.tolist()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">            index[i][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(N):</span><br><span class="line">                <span class="keyword">if</span> k != j:</span><br><span class="line">                    index[i][j] *= gm.invert(M[i][k], M[i][j] - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    cc = np.ones((N, N))</span><br><span class="line">    cc = cc.tolist()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">            cc[i][j] = pow(cs[i], index[i][j], M[i][j])</span><br><span class="line"></span><br><span class="line">    mms = [<span class="number">0</span>] * N</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">            fac = cc[i][j]</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(N):</span><br><span class="line">                <span class="keyword">if</span> k != j:</span><br><span class="line">                    fac *= (M[i][k] * gm.invert(M[i][k], M[i][j]))</span><br><span class="line">            mms[i] += fac % ns[i]</span><br><span class="line">        mms[i] = mms[i] % ns[i]</span><br><span class="line">    <span class="keyword">return</span> mms</span><br></pre></td></tr></table></figure><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><h4 id="基本原理-3"><a href="#基本原理-3" class="headerlink" title="基本原理"></a>基本原理</h4><p>通读server2.py发现大致的交互过程如下:随机生成1024bits的n及加密密钥并公布.在0-(1024bits-1)范围内生成明文.用户可以不断向服务器发送加密过后的明文,服务器返回解密后明文的奇偶性.用户利用RSA的parity oracle漏洞得到随机生成的明文并上传给服务器.重复上述过程三次,当用户三次全部猜测正确时返回flag.    </p><h4 id="解题过程-3"><a href="#解题过程-3" class="headerlink" title="解题过程"></a>解题过程</h4><p>拿到脚本之后,根据返回odd和even,可以想到是利用了LSB oracle漏洞.该漏洞原理较为简单,但一般情况下最终还原出的明文和真实明文会存在一定偏差,这主要是因为max和min是整数类型,其表示的上界和下界不够精确.官方给出了精确还原m的脚本:   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack</span><span class="params">(n, e, c)</span>:</span></span><br><span class="line">    rounds = int(math.ceil(math.log(n, <span class="number">2</span>)))</span><br><span class="line">    d = pow(<span class="number">2</span>, e, n)</span><br><span class="line">    cc = c</span><br><span class="line">    eigenvalue = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(rounds):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">256</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">print</span> i</span><br><span class="line">        cc = (cc * d) % n</span><br><span class="line">        parity = getParity(cc) <span class="comment">#parity oracle返回明文奇偶性</span></span><br><span class="line">        eigenvalue = (eigenvalue &lt;&lt; <span class="number">1</span>) + parity</span><br><span class="line">    <span class="keyword">if</span> eigenvalue == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * eigenvalue / pow(<span class="number">2</span>, rounds) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>解题脚本如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"><span class="keyword">import</span> decimal</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> hexdigits</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oracle</span><span class="params">(num)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"Please input your option:"</span>)</span><br><span class="line">    p.sendline(<span class="string">"D"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Your encrypted message:"</span>)</span><br><span class="line">    p.sendline(str(num))</span><br><span class="line">    p.recvuntil(<span class="string">"The plain of your decrypted message is "</span>)</span><br><span class="line">    lsb = p.recv(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> lsb == <span class="string">'odd'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack</span><span class="params">(n, e, c)</span>:</span></span><br><span class="line">    rounds = int(math.ceil(math.log(n, <span class="number">2</span>)))</span><br><span class="line">    d = pow(<span class="number">2</span>, e, n)</span><br><span class="line">    cc = c</span><br><span class="line">    eigenvalue = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(rounds):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">256</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">print</span> i</span><br><span class="line">        cc = (cc * d) % n</span><br><span class="line">        parity = getParity(cc) <span class="comment">#parity oracle返回明文奇偶性</span></span><br><span class="line">        eigenvalue = (eigenvalue &lt;&lt; <span class="number">1</span>) + parity</span><br><span class="line">    <span class="keyword">if</span> eigenvalue == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * eigenvalue / pow(<span class="number">2</span>, rounds) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">"47.111.59.243"</span>,<span class="string">"9421"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"[*] Please find a string that md5(str + "</span>)</span><br><span class="line">salt = p.recv(<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">"[0:5] == "</span>)</span><br><span class="line">part_hash = p.recv(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(hexdigits)):</span><br><span class="line">string = <span class="string">""</span>.join([choice(hexdigits) <span class="keyword">for</span> _ <span class="keyword">in</span> range(i)]).lower()</span><br><span class="line"><span class="keyword">if</span> (md5(string + salt).hexdigest()[<span class="number">0</span>:<span class="number">5</span>] == part_hash):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line">p.sendline(string)</span><br><span class="line">p.recvuntil(<span class="string">"Guess the Secrets 3 times, Then you will get the flag!\n"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    R = p.recvline().strip()</span><br><span class="line">    p.recvuntil(<span class="string">"n = "</span>)</span><br><span class="line">    n = eval(p.recvline().strip())</span><br><span class="line">    p.recvuntil(<span class="string">"e = "</span>)</span><br><span class="line">    e = eval(p.recvline().strip())</span><br><span class="line">    p.recvuntil(<span class="string">"The Encypted secret:"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"c = "</span>)</span><br><span class="line">    c = eval(p.recvline().strip())</span><br><span class="line">    c_of_2 = pow(<span class="number">2</span>,e,n)</span><br><span class="line">    m = crack(n, e, (c*c_of_2)%n)</span><br><span class="line">    p.recvuntil(<span class="string">"Please input your option:"</span>)</span><br><span class="line">    p.sendline(<span class="string">"G"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'The secret:'</span>)</span><br><span class="line">    p.sendline(str(m))</span><br><span class="line">    s = p.recvline().strip()</span><br><span class="line">    print(s)</span><br><span class="line">    log.success(s+<span class="string">' '</span>+R+<span class="string">" success!"</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>完成与服务器的多次交互并正确猜测三次后即可得到flag.</p><h2 id="0x04-再说几句废话"><a href="#0x04-再说几句废话" class="headerlink" title="0x04 再说几句废话"></a>0x04 再说几句废话</h2><p>本次题目的crypto部分还是可以学到很多东西的.与nc类题目以前经常使用socket编程进行,但匹配到需要的数据需要同时使用正则表达式和eval()函数,较为繁琐,解题速度慢,这次比赛学到了pwntools这一集成工具的使用,大大加快了解题速度.另外使用python-z3库可以更快更明确地完成爆破,只需要提供约束条件即可.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-几句废话&quot;&gt;&lt;a href=&quot;#0x00-几句废话&quot; class=&quot;headerlink&quot; title=&quot;0x00 几句废话&quot;&gt;&lt;/a&gt;0x00 几句废话&lt;/h2&gt;&lt;p&gt;总体来说,suctf的crypto部分的难度没有想象中的那么高(所以难度就全部集中到
      
    
    </summary>
    
      <category term="CTF_Writeup" scheme="https://blank-vax.github.io/categories/CTF-Writeup/"/>
    
    
      <category term="z3-solver" scheme="https://blank-vax.github.io/tags/z3-solver/"/>
    
      <category term="LSB-Oracle" scheme="https://blank-vax.github.io/tags/LSB-Oracle/"/>
    
      <category term="RSA e==n" scheme="https://blank-vax.github.io/tags/RSA-e-n/"/>
    
      <category term="pwntools" scheme="https://blank-vax.github.io/tags/pwntools/"/>
    
  </entry>
  
  <entry>
    <title>RSA算法及攻击方法(一)</title>
    <link href="https://blank-vax.github.io/2020/11/09/RSA%E7%AE%97%E6%B3%95%E5%8F%8A%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95(%E4%B8%80)/"/>
    <id>https://blank-vax.github.io/2020/11/09/RSA算法及攻击方法(一)/</id>
    <published>2020-11-09T02:39:34.435Z</published>
    <updated>2020-01-31T11:33:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-RSA算法"><a href="#0x00-RSA算法" class="headerlink" title="0x00 RSA算法"></a>0x00 RSA算法</h2><p>RSA算法主要基于大整数分解这一困难问题设计.下面介绍一下加解密过程.<br>首先是需要用到的参数:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m: 需要加密的消息即明文.</span><br><span class="line">c: 加密之后的结果即密文.</span><br><span class="line">p,q: 两个大素数.</span><br><span class="line">N: N=p*q,加解密过程中的模数.</span><br><span class="line">e: 加密密钥.</span><br><span class="line">d: 解密密钥.</span><br><span class="line">phi(N): 模数N的欧拉函数.</span><br></pre></td></tr></table></figure><p>然后是加解密关系式:<br>c $\equiv$ m^e mod N<br>m $\equiv$ c^d mod N<br>e*d $\equiv$ 1 mod $\phi$(n)<br>$\phi$(n) = (p-1)*(q-1)<br>信息传播过程中,常将(e,N)作为公钥和密文c一同传播,而(d,N)作为私钥留在加密者和合法的接收者手中.选取并通过p*q计算N非常容易,但通过N还原p,q则是困难为题,这保证了该算法的安全性.  具体RSA基础可以参考:<a href="http://www.guideep.com/read?guide=5676830073815040" target="_blank" rel="noopener">RSA基础</a>  </p><h2 id="0x01-数学基础"><a href="#0x01-数学基础" class="headerlink" title="0x01 数学基础"></a>0x01 数学基础</h2><h3 id="理解模拟运算"><a href="#理解模拟运算" class="headerlink" title="理解模拟运算"></a>理解模拟运算</h3><ul><li>如果(a*b) mod c == 1,那么a和b互为对方模c的模逆元/数论倒数,也写作a^(-1) $\equiv$ b (mod c)或a*b $\equiv$ 1 (mod c)</li><li>关于最大公约数有一个基本事实:给予两整数a、b,必存在整数x、y,使得<code>a*x + b*y = gcd(a, b)</code>.从而当a、b互素时,有<code>a*x + b*y = 1</code>,就有<code>(a*x) mod b == 1</code>,所以x就是a对b的模逆元.</li><li>最大公约数有一个定义是:a和b的最大公约数g是a和b的线性和中的最小正整数.</li><li><p>常使用扩展欧几里得算法的一个python实现如下:  </p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">egcd</span> <span class="params">( a , b )</span>:</span></span><br><span class="line">     <span class="keyword">if</span> (b == <span class="number">0</span>):</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>, <span class="number">0</span>, a</span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">         x , y , q = egcd( b , a % b ) <span class="comment"># q = GCD(a, b) = GCD(b, a%b)</span></span><br><span class="line">         x , y = y, ( x - (a // b) * y )</span><br><span class="line">         <span class="keyword">return</span> x, y, q </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mod_inv</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> egcd(a,b)[<span class="number">0</span>]%b <span class="comment">#求a模b得逆元</span></span><br></pre></td></tr></table></figure></li><li><p>求模逆也可以使用gmpy2库的函数<code>gmpy2.invert(a, b)</code></p></li></ul><h3 id="模运算法则"><a href="#模运算法则" class="headerlink" title="模运算法则"></a>模运算法则</h3><p>推荐文章:<a href="https://blog.sengxian.com/algorithms/mod-world" target="_blank" rel="noopener">模运算总结</a>和<a href="https://github.com/wujr5/algorithm-analysis-and-design/blob/master/relative-algorithm-learning/6-algorithm-about-modulo-operation.md" target="_blank" rel="noopener">取模运算涉及的算法</a></p><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>基本原理为:<code>gcd(a,b) == gcd(b,a%b) while(b!=0)</code>和<code>gcd(a,0) == a</code><br>python实现如下: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归版</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="keyword">if</span> <span class="keyword">not</span> b <span class="keyword">else</span> gcd(b, a % b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代版</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd2</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> b:</span><br><span class="line">        a, b = b, a % b</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p>扩展欧几里得算法能够求出满足<code>a*x+b*y = gcd(a,b)</code>的一组x,y.<br><a href="http://blog.miskcoo.com/2014/09/chinese-remainder-theorem#i-3" target="_blank" rel="noopener">参考文章</a><br>python实现如下:   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归版</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ext_euclid</span> <span class="params">( a , b )</span>:</span></span><br><span class="line">    <span class="comment"># ref:https://zh.wikipedia.org/wiki/扩展欧几里得算法</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, <span class="number">0</span>, a</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x1 , y1 , q = ext_euclid( b , a % b ) <span class="comment"># q = GCD(a, b) = GCD(b, a%b)</span></span><br><span class="line">        x , y = y1, ( x1 - (a // b) * y1 )</span><br><span class="line">        <span class="keyword">return</span> x, y, q</span><br><span class="line"><span class="comment"># 迭代版</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">egcd</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="comment"># ref:https://blog.csdn.net/wyf12138/article/details/60476773</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>, <span class="number">0</span>, a)</span><br><span class="line">    x, y = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    s1, s2 = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    r, q = a % b, a / b</span><br><span class="line">    <span class="keyword">while</span> r:</span><br><span class="line">        m, n = x, y</span><br><span class="line">        x = s1 - x * q</span><br><span class="line">        y = s2 - y * q</span><br><span class="line">        s1, s2 = m, n</span><br><span class="line">        a, b = b, r</span><br><span class="line">        r, q = a % b, a / b</span><br><span class="line">    <span class="keyword">return</span> (x, y, b)</span><br></pre></td></tr></table></figure><h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p>具体算法可以参考上文提到的文章.<br>当mi两两互素的时候,可以使用如下脚本进行计算:   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CRT</span><span class="params">(mi, ai)</span>:</span></span><br><span class="line">    <span class="comment"># mi,ai分别表示模数和取模后的值,都为列表结构</span></span><br><span class="line">    <span class="comment"># Chinese Remainder Theorem</span></span><br><span class="line">    <span class="comment"># lcm=lambda x , y:x*y/gcd(x,y)</span></span><br><span class="line">    <span class="comment"># mul=lambda x , y:x*y</span></span><br><span class="line">    <span class="comment"># assert(reduce(mul,mi)==reduce(lcm,mi))</span></span><br><span class="line">    <span class="comment"># 以上可用于保证mi两两互质</span></span><br><span class="line">    <span class="keyword">assert</span> (isinstance(mi, list) <span class="keyword">and</span> isinstance(ai, list))</span><br><span class="line">    M = reduce(<span class="keyword">lambda</span> x, y: x * y, mi)</span><br><span class="line">    ai_ti_Mi = [a * (M / m) * gmpy2.invert(M / m, m) <span class="keyword">for</span> (m, a) <span class="keyword">in</span> zip(mi, ai)]</span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x + y, ai_ti_Mi) % M</span><br></pre></td></tr></table></figure><p>当mi不互素时,需要两两合并方程组.原理如下:<br><img src="http://static.zybuluo.com/B1ank/2m30kgxecoacwmiac9fxh4n8/444.png" alt="Mi不互素"><br>实现代码:   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GCRT</span><span class="params">(mi, ai)</span>:</span></span><br><span class="line">    <span class="comment"># mi,ai分别表示模数和取模后的值,都为列表结构</span></span><br><span class="line">    <span class="keyword">assert</span> (isinstance(mi, list) <span class="keyword">and</span> isinstance(ai, list))</span><br><span class="line">    curm, cura = mi[<span class="number">0</span>], ai[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (m, a) <span class="keyword">in</span> zip(mi[<span class="number">1</span>:], ai[<span class="number">1</span>:]):</span><br><span class="line">        d = gmpy2.gcd(curm, m)</span><br><span class="line">        c = a - cura</span><br><span class="line">        <span class="keyword">assert</span> (c % d == <span class="number">0</span>) <span class="comment">#不成立则不存在解</span></span><br><span class="line">        K = c / d * gmpy2.invert(curm / d, m / d)</span><br><span class="line">        cura += curm * K</span><br><span class="line">        curm = curm * m / d</span><br><span class="line">    <span class="keyword">return</span> (cura % curm, curm) <span class="comment">#(解,最小公倍数)</span></span><br></pre></td></tr></table></figure><h2 id="0x02-常规攻击方法"><a href="#0x02-常规攻击方法" class="headerlink" title="0x02 常规攻击方法"></a>0x02 常规攻击方法</h2><p>由于RSA密码体系是基于大数分解这一困难问题设计,于是最先考虑到的便是分解N,然后根据加解密流程和关系式进行明文还原.</p><h3 id="推荐工具"><a href="#推荐工具" class="headerlink" title="推荐工具"></a>推荐工具</h3><ul><li>大数分解网站:位数较低的模数(长度一般小于100bits)可以在网站的库中查询分解结果:<br><a href="http://www.factordb.com" target="_blank" rel="noopener">大数分解网站</a></li><li>如果模数的位数较高,可以使用工具<a href="https://sourceforge.net/projects/yafu/" target="_blank" rel="noopener">yafu</a>进行分解,该工具集成了NFS等分解算法,适用于windows系统</li><li>python环境下的libnum、gmpy2大数运算集成库</li><li>github上的集成工具,具体使用方法在项目内部有详细说明:<a href="https://github.com/D001UM3/CTF-RSA-tool" target="_blank" rel="noopener">CTF-RSA-Tools</a></li></ul><h3 id="常用脚本"><a href="#常用脚本" class="headerlink" title="常用脚本"></a>常用脚本</h3><ul><li>使用欧几里得算法求私钥d<br>input: p, q, e<br>output: d   </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 脚本一</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">egcd</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (b, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        g, y, x = egcd(b % a, a)</span><br><span class="line">        <span class="keyword">return</span> (g, x - (b // a) * y, y)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modinv</span><span class="params">(a, m)</span>:</span></span><br><span class="line">    g, x, y = egcd(a, m)</span><br><span class="line">    <span class="keyword">if</span> g != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'modular inverse does not exist'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x % m</span><br><span class="line"></span><br><span class="line">p = number1</span><br><span class="line">q = number2</span><br><span class="line">e = number3</span><br><span class="line">d = modinv(e,(p<span class="number">-1</span>)*(q<span class="number">-1</span>))</span><br><span class="line">print(<span class="string">"d = "</span> + str(d))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 脚本二</span></span><br><span class="line"><span class="comment">#RSA扩展欧几里得算法 已知p,q,e求d</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> a!=<span class="number">0</span>:</span><br><span class="line">        a,b = b%a,a</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"><span class="comment">#定义一个函数，参数分别为a,n，返回值为b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findModReverse</span><span class="params">(a,m)</span>:</span><span class="comment">#这个扩展欧几里得算法求模逆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> gcd(a,m)!=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    u1,u2,u3 = <span class="number">1</span>,<span class="number">0</span>,a</span><br><span class="line">    v1,v2,v3 = <span class="number">0</span>,<span class="number">1</span>,m</span><br><span class="line">    <span class="keyword">while</span> v3!=<span class="number">0</span>:</span><br><span class="line">        q = u3//v3</span><br><span class="line">        v1,v2,v3,u1,u2,u3 = (u1-q*v1),(u2-q*v2),(u3-q*v3),v1,v2,v3</span><br><span class="line">    <span class="keyword">return</span> u1%m</span><br><span class="line"></span><br><span class="line">p=eval(input(<span class="string">'p='</span>))</span><br><span class="line">q=eval(input(<span class="string">'q='</span>))</span><br><span class="line">e=eval(input(<span class="string">'e='</span>))</span><br><span class="line"></span><br><span class="line">N=p*q</span><br><span class="line">s=(p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">result=findModReverse(e,s)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><ul><li>加密脚本<br>input: m, p, q, e<br>output: c   </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2 <span class="keyword">as</span> gp</span><br><span class="line"></span><br><span class="line">m = gp.mpz(int(input(<span class="string">"m="</span>), <span class="number">16</span>))</span><br><span class="line">p = gp.mpz(int(input(<span class="string">"p="</span>)))</span><br><span class="line">q = gp.mpz(int(input(<span class="string">"q="</span>)))</span><br><span class="line">e = gp.mpz(int(input(<span class="string">"e="</span>)))</span><br><span class="line">N = p*q</span><br><span class="line">phin = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line">c = gp.powmod(m, e, N)</span><br></pre></td></tr></table></figure><ul><li>解密脚本<br>input: c, p, q, e<br>output: m   </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2 <span class="keyword">as</span> gp</span><br><span class="line"></span><br><span class="line">c = gp.mpz(int(input(<span class="string">"m="</span>), <span class="number">16</span>))</span><br><span class="line">p = gp.mpz(int(input(<span class="string">"p="</span>)))</span><br><span class="line">q = gp.mpz(int(input(<span class="string">"q="</span>)))</span><br><span class="line">e = gp.mpz(int(input(<span class="string">"e="</span>)))</span><br><span class="line">N = p*q</span><br><span class="line">phin = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line">d = gp.invert(e, N)</span><br><span class="line">m = gp.powmod(c, d, N)</span><br></pre></td></tr></table></figure><h3 id="文件型RSA攻击"><a href="#文件型RSA攻击" class="headerlink" title="文件型RSA攻击"></a>文件型RSA攻击</h3><p>所谓文件型RSA的题目,就是提供pubkey.pem和flag.enc文件.我们需要从pubkey.pem即证书文件中提取公钥信息,进行解密后生成private.pem私钥文件,然后对flag.enc文件进行解密得到结果.<br>常用命令如下(使用openssl对证书进行处理,使用rsatool.py对参数进行解密):      </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -pubin -text -modulus -in warmup -in pubkey.pem</span><br><span class="line">该命令用于从pem文件中提取公钥e和大数n</span><br><span class="line"></span><br><span class="line">python rsatool.py -o private.pem -e e -p p -q q</span><br><span class="line">其中,-p,-q,-e之后输入p,q,e的值,rsatool.py放在当前目录下</span><br><span class="line"></span><br><span class="line">openssl rsautl -decrypt -in flag.enc -inkey private.pem -out flag.dec</span><br><span class="line">得到公私钥之后使用上面的命令解密 输出可以选择flag.txt</span><br></pre></td></tr></table></figure><h2 id="0x03-基础CTF题目"><a href="#0x03-基础CTF题目" class="headerlink" title="0x03 基础CTF题目"></a>0x03 基础CTF题目</h2><h3 id="已知p-q-e-求d"><a href="#已知p-q-e-求d" class="headerlink" title="已知p,q,e,求d"></a>已知p,q,e,求d</h3><p>题目来源: buuctf RSA<br>题目描述:     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在一次RSA密钥对生成中，假设p=473398607161，q=4511491，e=17</span><br><span class="line">求解出d作为flag提交</span><br></pre></td></tr></table></figure><p>题目分析: 这是最基础的RSA题目,直接给出p和q的值.直接将所给信息写入脚本中即可求出d.将d按照flag提交要求进行进制转换后提交即可.    </p><h3 id="已知p-q-e-c-求m"><a href="#已知p-q-e-c-求m" class="headerlink" title="已知p,q,e,c,求m"></a>已知p,q,e,c,求m</h3><p>题目来源: buuctf rsarsa<br>题目描述:     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Math is cool! Use the RSA algorithm to decode the secret message, c, p, q, and e are parameters for the RSA algorithm.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p =  9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483</span><br><span class="line">q =  11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407</span><br><span class="line">e =  65537</span><br><span class="line">c =  83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034</span><br><span class="line"></span><br><span class="line">Use RSA to find the secret message</span><br></pre></td></tr></table></figure><p>题目分析: 该类题目已知p,q,e和c.先通过模逆算法求出d,再通过<code>m = gp.powmod(c, d, p*q)</code>求出m即可   </p><h3 id="已知p-q-dp-dq-c-求m"><a href="#已知p-q-dp-dq-c-求m" class="headerlink" title="已知p,q,dp,dq,c,求m"></a>已知p,q,dp,dq,c,求m</h3><p>题目来源: buuctf RSA1<br>题目描述:     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 </span><br><span class="line">q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 </span><br><span class="line">dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 </span><br><span class="line">dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 </span><br><span class="line">c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852</span><br></pre></td></tr></table></figure><p>题目分析: 其中dp $\equiv$ d mod $\phi$(p), dq $\equiv$ d mod $\phi$(q).<br>我们发现这是一个同于方程组,使用中国剩余定理合并即可.但是发现p-1和q-1不互素,我们进行推导如下:<br>令dd = (p-1, q-1)<br>d = k1*(p-1) + dp = k2*(q-1) + dq<br>k2*(q-1) $\equiv$ dp - dq mod(p-1)<br>k2<em>(q-1)/dd $\equiv$ (dp-dq)/dd mod (p-1)/dd<br>k2 = k’\</em>(p-1)/dd + (dp-dq)/dd*((q-1)/dd)^(-1)<br>d = k2*(q-1) + dq = (k’*(p-1)/dd + (dp-dq)/dd*((q-1)/dd)^(-1)*(q-1) + dq<br>我们令d = (dp-dq)/dd*((q-1)/dd)^(-1)*(q-1) + dq,从而合理运用所给参数得出最终结果.<br>脚本如下:   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2 <span class="keyword">as</span> gp</span><br><span class="line"></span><br><span class="line">p = gp.mpz(p)</span><br><span class="line">q = gp.mpz(q)</span><br><span class="line">dp = gp.mpz(dp)</span><br><span class="line">dq = gp.mpz(dq)</span><br><span class="line">c = gp.mpz(c)</span><br><span class="line"></span><br><span class="line">n = p*q</span><br><span class="line">phin = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">dd = gp.gcd(p<span class="number">-1</span>, q<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">d=(dp-dq)//dd * gp.invert((q<span class="number">-1</span>)//dd, (p<span class="number">-1</span>)//dd) * (q<span class="number">-1</span>) +dq</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">m = gp.powmod(c, d, n)</span><br><span class="line">print(<span class="string">'-------------------'</span>)</span><br><span class="line">print(m)</span><br><span class="line">print(hex(m)[<span class="number">2</span>:])</span><br><span class="line">print(bytes.fromhex(hex(m)[<span class="number">2</span>:]))</span><br></pre></td></tr></table></figure><h3 id="已知e-n-dp-c-求m"><a href="#已知e-n-dp-c-求m" class="headerlink" title="已知e, n, dp, c,求m"></a>已知e, n, dp, c,求m</h3><p>题目来源: buuctf RSA2<br>题目描述:     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e = 65537</span><br><span class="line">n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113</span><br><span class="line">dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657</span><br><span class="line"></span><br><span class="line">c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751</span><br></pre></td></tr></table></figure><p>题目分析: 我们根据dp $\equiv$ d mod $\phi$(p)进行推导.<br>e*dp $\equiv$ ed mod $\phi$(p)<br>e*d = k*$\phi$(p) + e*d*p<br>e*d = (k*$\phi$(p)+e*d*p) $\equiv$ 1 mod $\phi$(n)<br>从而k*$\phi$(p) + e*d*p = k’*(p-1)*(q-1) + 1<br>移项得:(p-1)*(k’*(q-1)-k) + 1 = e*d*p<br>$\because$ dp &lt; (p-1)<br>$\therefore$ e = 65537 &gt; (k’*(q-1)-k) = x<br>我们通过枚举x可以计算出p-1,从而还原所有参数.脚本如下:    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2 <span class="keyword">as</span> gp</span><br><span class="line"></span><br><span class="line">e = e</span><br><span class="line">n = gp.mpz(n)</span><br><span class="line">dp = gp.mpz(dp)</span><br><span class="line">c = gp.mpz(c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, e):</span><br><span class="line">    <span class="keyword">if</span>(e*dp%x==<span class="number">1</span>):</span><br><span class="line">        p=(e*dp<span class="number">-1</span>)//x+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(n%p!=<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        q=n//p</span><br><span class="line">        phin=(p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line">        d=gp.invert(e, phin)</span><br><span class="line">        m=gp.powmod(c, d, n)</span><br><span class="line">        <span class="keyword">if</span>(len(hex(m)[<span class="number">2</span>:])%<span class="number">2</span>==<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        print(<span class="string">'--------------'</span>)</span><br><span class="line">        print(m)</span><br><span class="line">        print(hex(m)[<span class="number">2</span>:])</span><br><span class="line">        print(bytes.fromhex(hex(m)[<span class="number">2</span>:]))</span><br></pre></td></tr></table></figure><h3 id="文件型RSA"><a href="#文件型RSA" class="headerlink" title="文件型RSA"></a>文件型RSA</h3><p>题目来源: buuctf RSA<br>题目描述: 下载附件之后发现有flag.enc和pub.key文件,于是使用openssl+rsatool解题.<br>题目分析: 题目中有.enc和.key文件,首先使用openssl的命令进行公钥提取.<br><img src="http://static.zybuluo.com/B1ank/4r9mcdhmr5i0wgshrjecfwb4/111.png" alt="111.png-297.4kB"><br>我们可以得到e和n,在线分解n之后作为参数生成私钥.<br><img src="http://static.zybuluo.com/B1ank/aw14ot2pd4fve0qfsyocrqft/222.png" alt="222.png-368.6kB"><br>最后使用private.pem与flag.enc生成flag文件.<br><img src="http://static.zybuluo.com/B1ank/kcm7xp0lmni0ueivsu479x6u/333.png" alt="333.png-54.8kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-RSA算法&quot;&gt;&lt;a href=&quot;#0x00-RSA算法&quot; class=&quot;headerlink&quot; title=&quot;0x00 RSA算法&quot;&gt;&lt;/a&gt;0x00 RSA算法&lt;/h2&gt;&lt;p&gt;RSA算法主要基于大整数分解这一困难问题设计.下面介绍一下加解密过程.&lt;br
      
    
    </summary>
    
      <category term="Crypto_Attack" scheme="https://blank-vax.github.io/categories/Crypto-Attack/"/>
    
    
      <category term="RSA" scheme="https://blank-vax.github.io/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>USTC hackergame2018 wp</title>
    <link href="https://blank-vax.github.io/2020/11/09/USTC%20hackergame2018%20wp/"/>
    <id>https://blank-vax.github.io/2020/11/09/USTC hackergame2018 wp/</id>
    <published>2020-11-09T02:39:34.435Z</published>
    <updated>2020-06-26T04:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><p>这次中科大hackergame可以说是既有技术性也有趣味性,总之玩的很开心,而且也学到了很多东西.无论是巧妙应用,还是另类攻击,或者是各种奇怪的算法,以及引入的挖矿和机器学习,都值得学习.下面整理一篇博客记录一下.</p><h2 id="0x01-签到类"><a href="#0x01-签到类" class="headerlink" title="0x01 签到类"></a>0x01 签到类</h2><h3 id="签到题-50"><a href="#签到题-50" class="headerlink" title="签到题 50"></a>签到题 50</h3><p>打开签到题,按照要求输入,发现输入框的长度不够,直接开发者工具,改变maxlength后再次输入即得flag.也可以在地址栏中修改url为<code>?key=hackergame2018</code></p><h3 id="猫咪问答-100"><a href="#猫咪问答-100" class="headerlink" title="猫咪问答 100"></a>猫咪问答 100</h3><p>无形之中宣传了一波中科大,然而对于校内和校外的同学来说都需要过硬的社工技巧,基本上百度谷歌全部都可以解决(虽然第三题是爆破的).</p><h3 id="游园会的集章卡片-100"><a href="#游园会的集章卡片-100" class="headerlink" title="游园会的集章卡片 100"></a>游园会的集章卡片 100</h3><p>丧心病狂的拼图游戏,把图片下载下来之后在桌面上一通操作可得flag.</p><h3 id="Word文档-150"><a href="#Word文档-150" class="headerlink" title="Word文档 150"></a>Word文档 150</h3><p>下载附件后使用hex friend打开,发现PK头,改后缀为zip,解压之后发现flag.txt,写脚本按行读取拼成flag即可.</p><h2 id="0x02-Misc类"><a href="#0x02-Misc类" class="headerlink" title="0x02 Misc类"></a>0x02 Misc类</h2><h3 id="猫咪和键盘-150"><a href="#猫咪和键盘-150" class="headerlink" title="猫咪和键盘 150"></a>猫咪和键盘 150</h3><p>使用sublime打开cpp文件,然后使用列编辑进行代码还原(网上还有还原的脚本),最后使用<code>g++ -std=c++17 typed_printf.cpp</code>编译并运行即可得到flag.<br>MacOS系统可以使用<code>Shift+鼠标右键</code>,<code>鼠标中键</code>,<code>command+A 以及 command+shift+L</code>来实现sublime的列编辑.<br>下面是使用脚本进行还原的过程:  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lines=open(<span class="string">'typed_printf.cpp'</span>,<span class="string">'r'</span>).readlines()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    <span class="keyword">print</span> line[<span class="number">0</span>]+line[<span class="number">32</span>:<span class="number">39</span>]+line[<span class="number">1</span>:<span class="number">7</span>]+line[<span class="number">20</span>:<span class="number">22</span>]+line[<span class="number">8</span>:<span class="number">20</span>]+line[<span class="number">22</span>:<span class="number">32</span>]+line[<span class="number">39</span>:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>还原后的main函数如下: </p><p><img src="http://static.zybuluo.com/B1ank/9syztbzj9dsjjd7pjkyonuti/oh_my_cat.png" alt="oh_my_cat.png-266kB"></p><p>彩蛋:在开头藏了base64加密过的url,还原后可以在github上找到类似的源码,修改后拿flag.</p><h3 id="回到过去-150"><a href="#回到过去-150" class="headerlink" title="回到过去 150"></a>回到过去 150</h3><p>由于macOS基于Unix,所以可以直接输入ed命令,但多次尝试并不正确.于是查看ed编辑器的命令,发现Esc按键后的字符不输入,改正后得到flag.</p><h3 id="猫咪遥控器-200"><a href="#猫咪遥控器-200" class="headerlink" title="猫咪遥控器 200"></a>猫咪遥控器 200</h3><p>下载附件后发现,该txt只包含UDLR,即up,down,left,right这四个英文字母,联想到画图,可以用官解给出的js脚本进行画图,也可以用python的turtle库,代码如下:  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"></span><br><span class="line">turtle.screensize()</span><br><span class="line">cat = open(<span class="string">'seq.txt'</span>,<span class="string">'r'</span>)</span><br><span class="line">info = cat.read()</span><br><span class="line">x,y = <span class="number">-200</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> info:</span><br><span class="line">    <span class="keyword">if</span> m == <span class="string">'D'</span>:</span><br><span class="line">        turtle.goto(x,y<span class="number">-1</span>)</span><br><span class="line">        y -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> m == <span class="string">'U'</span>:</span><br><span class="line">        turtle.goto(x,y+<span class="number">1</span>)</span><br><span class="line">        y += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> m == <span class="string">'L'</span>:</span><br><span class="line">        turtle.goto(x<span class="number">-1</span>,y)</span><br><span class="line">        x -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        turtle.goto(x+<span class="number">1</span>,y)</span><br><span class="line">        x += <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="猫咪电路-200"><a href="#猫咪电路-200" class="headerlink" title="猫咪电路 200"></a>猫咪电路 200</h3><p>下载后打开mc游戏,按照提示发现红石电路其实是一堆门组成的电路,用到一些数电上面的逻辑知识,连好电路可得flag.</p><h3 id="猫咪克星-200"><a href="#猫咪克星-200" class="headerlink" title="猫咪克星 200"></a>猫咪克星 200</h3><p>本题目主要考查eval()函数的危险性.<br>该题目先使用nc命令对端口进行请求,得到要求为在三十秒内完成python表达式的计算.首先尝试手动输入发现根本输入不完,便考虑采用脚本,详细思路为循环请求并使用eval()函数计算返回的python表达式的结果,再发送至服务器.<br>当然在解题过程中发现返回的东西并不全部为python数字表达式,而是含有print(),sleep(100),exit(),find~等奇怪的函数,便进行了替换.<br>脚本一:socket编程   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding = utf-8</span></span><br><span class="line"><span class="keyword">import</span> socket,time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_sender</span><span class="params">()</span>:</span></span><br><span class="line">    client = socket.socket()</span><br><span class="line">    client.connect((<span class="string">'202.38.95.46'</span>,<span class="number">12009</span>))</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        result = client.recv(<span class="number">1024</span>).decode()</span><br><span class="line">        print(result)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"flag&#123;"</span> <span class="keyword">in</span> result:</span><br><span class="line">                exit()</span><br><span class="line">            send_data = str(eval(result.replace(<span class="string">"exit()"</span>,<span class="string">"0"</span>).replace(<span class="string">"sleep(100)"</span>,<span class="string">"sleep(0)"</span>).replace(<span class="string">"__import__('os').system('find ~')"</span>,<span class="string">"0"</span>).replace(<span class="string">"print('\x1b\x5b\x33\x3b\x4a\x1b\x5b\x48\x1b\x5b\x32\x4a')"</span>,<span class="string">"0"</span>)))+<span class="string">'\n'</span></span><br><span class="line">            print(send_data)</span><br><span class="line">            client.send(send_data.encode())</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    client.close()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    client_sender()</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>替换过程使用str.replace()方法.<br>脚本二:命令行连接  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">substitute = [</span><br><span class="line"><span class="string">"__import__('os').system('find~')"</span>,</span><br><span class="line"><span class="string">"__import__('time').sleep(100)"</span>,</span><br><span class="line"><span class="string">r"print('\x1b\x5b\x33\x3b\x4a\x1b\x5b\x48\x1b\x5b\x32\x4a')"</span>,</span><br><span class="line"><span class="string">"exit()"</span></span><br><span class="line">]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span><span class="params">(content)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> substitute:</span><br><span class="line">content = content.replace(i,<span class="string">'None'</span>)</span><br><span class="line"><span class="keyword">return</span> content</span><br><span class="line">input()</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">print(j,file = sys.stderr)</span><br><span class="line">exp = input()</span><br><span class="line">print(exp,file = sys.stderr)</span><br><span class="line">answer = eval(exchange(exp)) </span><br><span class="line">print(answer,file = sys.stderr)</span><br><span class="line">print(answer)</span><br><span class="line">print(input(),file = sys.stderr)</span><br></pre></td></tr></table></figure><p>然后执行<code>nc -e ./filename.py 202.38.95.46 12009</code>或者<code>socat exec:./filename.py tcp:202.38.95.46:12009</code></p><p>替换过程使用字典的key-value对.</p><h3 id="滑稽Art"><a href="#滑稽Art" class="headerlink" title="滑稽Art"></a>滑稽Art</h3><p>直接使用火狐打开发现每一行对应并不准确,于是参考官方wp,使用wc w filename命令发现该txt文件共154012个文字,使用yafu进行在线分解,经验上,等宽字体字符画像素上的长宽比和字符数的长宽比大致在 1 : 2 左右.所以我们猜测,这个字符画的长宽大概是 <code>556 * 277</code> 或者 <code>574 * 278</code>.使用python编写脚本,每隔556个字符打印’\n’,重新打开新生成的文件发现还原的非常清晰的滑稽图案与flag.</p><h2 id="0x03-Web类"><a href="#0x03-Web类" class="headerlink" title="0x03 Web类"></a>0x03 Web类</h2><h3 id="猫咪银行-150"><a href="#猫咪银行-150" class="headerlink" title="猫咪银行 150"></a>猫咪银行 150</h3><p>仔细观察本题,发现使用正常的方法并不能得到足够的CTB,使用开发者工具审查元素也没有发现什么异常,于是只能在输入框里面做手脚.由于有2s的操作限制,而且每次兑换之后都会同步扣费,所以不考虑条件竞争.构造时间溢出payload如下:  </p><p><img src="http://static.zybuluo.com/B1ank/4p21627lh748ekng5z09vple/bank1.png" alt="bank1.png-98.6kB"><br><img src="http://static.zybuluo.com/B1ank/0nsknt7xe13nig42hmbh9zf9/bank2.png" alt="bank2.png-71.7kB"></p><h3 id="黑曜石浏览器-150"><a href="#黑曜石浏览器-150" class="headerlink" title="黑曜石浏览器 150"></a>黑曜石浏览器 150</h3><p>“黑曜石天下第一”表情包的出处大概就是本题了.打开页面发现提示需要用黑曜石浏览器访问.得到思路即为伪装UA头.<br>下面来获取UA头,网络上搜索只有谷歌会给出黑曜石安装网址.进入该网站发现做的确实不错(除了不能登陆和下载),浏览页面源代码(使用<code>view-source:url</code>或<code>curl url</code>寻找如何判断是否为黑曜石浏览器的部分,可以得到UA头:  </p><p><img src="http://static.zybuluo.com/B1ank/061q6gl5qu33y39zgub8fnhv/heicore.png" alt="heicore.png-71.1kB"></p><p>核心判断为判断UA是否为:  </p><pre><code>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) HEICORE/49.1.2623.213 Safari/537.36   </code></pre><p>拿到了UA之后构造访问,可以使用Chrome的控制台以及命令得到flag:  </p><pre><code>curl http://202.38.95.46:12001/ -H &quot;User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) HEICORE/49.1.2623.213 Safari/537.36&quot;</code></pre><h3 id="哲学思考-150"><a href="#哲学思考-150" class="headerlink" title="哲学思考 150"></a>哲学思考 150</h3><p>打开平淡无奇的页面,调用开发者工具的network,刷新页面,查看返回头<code>418 I&#39;m a teapot</code>,便得到答案.</p><h3 id="Can-I-help-me-300"><a href="#Can-I-help-me-300" class="headerlink" title="Can I help me? 300"></a>Can I help me? 300</h3><p>直接打开页面发现,需要使用其他的方法进行请求.当点击链接进入页面时,一般使用的是GET请求.于是我们考虑使用爬虫来实现POST请求.当然,页面会返回:</p><pre><code>The method &quot;POST&quot; is deprecated.See RFC-7168 for more information.</code></pre><p>去读RFC-7168,根据:</p><pre><code>To this end, a TEA-capable pot that receives a BREW message of content type &quot;message/teapot&quot; MUST respond in accordance with the URI requested, as below.</code></pre><p>最终使用BREW请求页面,且带上<code>Content-Type: message/teapot</code>请求头的时候,页面会在<code>Alternative</code>相应头给出真正的URL,再以相同的方式请求那个URL,得到第二个flag.<br>请求方式可以使用BurpSuite以及Chrome的开发者工具.  </p><p><img src="http://static.zybuluo.com/B1ank/e8bbpwk2xf6d35rw5uqqohpl/can%20I%20help%20me.png" alt="can I help me.png-223.1kB"></p><p>当然也可以使用nc命令:  </p><p><img src="http://static.zybuluo.com/B1ank/v5e18hwlmno3edmm48vsky48/can%20I%20help%20me2.png" alt="can I help me2.png-382.1kB"></p><h2 id="0x04-Crypto类"><a href="#0x04-Crypto类" class="headerlink" title="0x04 Crypto类"></a>0x04 Crypto类</h2><h3 id="她的诗-200"><a href="#她的诗-200" class="headerlink" title="她的诗 200"></a>她的诗 200</h3><p>先浏览一下解密脚本,发现是uuencode编码,运行一下后发现一篇非常正常的诗句(根据提示这些诗句并没有什么实际效果).检查后发现脚本没有什么问题,想到在线网站,使用uudecode在线网站解密后发现解密结果每一行都会多出来一些符号和字母,将这些东西拼接后得到部分flag.根据英文提示后将fu改成fun},提交即可.(这也是官方wp中的非预期题解).<br>如同base64使用=进行填充一样,uuencode在加密过程中也需要进行不足位填充,于是便可以在填充位隐藏信息.<br>修改之后的问题无法通过在线uudecode进行解码,脚本正在研究中.<br>先贴一个解题脚本: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># This script helps you decode "her poem"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> codecs <span class="keyword">import</span> decode</span><br><span class="line"></span><br><span class="line">fin = open(<span class="string">"poem.txt"</span>, <span class="string">"r"</span>)</span><br><span class="line">fout = open(<span class="string">"testpoem.out"</span>, <span class="string">"w"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> fin:</span><br><span class="line">    <span class="comment"># print chr(ord(i[0])+4)</span></span><br><span class="line">    <span class="comment"># print i[1:]</span></span><br><span class="line">    data = <span class="string">"begin 666 &lt;data&gt;\n"</span> + chr(ord(i[<span class="number">0</span>])+<span class="number">2</span>) + i[<span class="number">1</span>:] + <span class="string">" \nend\n"</span></span><br><span class="line">    decode_data = decode(data.encode(<span class="string">"ascii"</span>), <span class="string">"uu"</span>)</span><br><span class="line">    print(decode_data)[<span class="number">-2</span>:]</span><br><span class="line">    fout.write(decode_data.decode(<span class="string">"ascii"</span>) + <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">fin.close()</span><br><span class="line">fout.close()</span><br></pre></td></tr></table></figure><h3 id="Z同学的RSA-300"><a href="#Z同学的RSA-300" class="headerlink" title="Z同学的RSA 300"></a>Z同学的RSA 300</h3><p>本题主要考察爆破思想.<br>题目先随机生成了p和q,然后给出了$a=p<em>q^{(p+q)}$和$b=p</em>q^{(p-q)}$这两个大数运算后的结果,再将<code>p*q</code>作为公钥进行加密.<br>使用数学思想来进行分析发现,从异或的结果推出来e并不在容易处理的范围之内,于是我们想到了逐位爆破:由于a和b是由异或运算生成,所以它们的最低n位与p和q的最低n位有关.我们从最低位开始分别设为0和1进行爆破,这样每增加一位就会多出来四种可能,而a和b的该位又只能确定一种可能,所以计算工作量不会出现指数爆炸的可能,即在运算上是可行的.进行1024次爆破运算可以得到最后的<code>p*q</code>,然后再计算出私钥,进行rsa解密即可.脚本如下: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">a, b, c = [int(s) <span class="keyword">for</span> s <span class="keyword">in</span> open(<span class="string">'output.txt'</span>).read().split()] </span><br><span class="line"><span class="comment"># 定义匿名函数</span></span><br><span class="line">f1 = <span class="keyword">lambda</span> p, q: (p * q) ^ (p + q)</span><br><span class="line">f2 = <span class="keyword">lambda</span> p, q: (p * q) ^ (p - q)</span><br><span class="line"></span><br><span class="line">candidates = &#123;(<span class="number">0</span>, <span class="number">0</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">1025</span>):</span><br><span class="line">    print(m, len(candidates))</span><br><span class="line">    candidates_ = set() <span class="comment"># 将candidates_置为空集</span></span><br><span class="line">    mask = (<span class="number">2</span> &lt;&lt; m) - <span class="number">1</span>  <span class="comment"># 经过计算发现,mask分别为1,11,111,1111...</span></span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> candidates:</span><br><span class="line">        <span class="keyword">if</span> f1(x, y) == a <span class="keyword">and</span> f2(x, y) == b:</span><br><span class="line">            <span class="comment"># 引用gmpy2库中的invert函数,直接求解出明文</span></span><br><span class="line">            p, q = x, y</span><br><span class="line">            d = gmpy2.invert(<span class="number">65537</span>, (p - <span class="number">1</span>) * (q - <span class="number">1</span>))</span><br><span class="line">            m = pow(c, d, p * q)</span><br><span class="line">            print(bytes.fromhex(hex(m)[<span class="number">2</span>:]))</span><br><span class="line">            exit()</span><br><span class="line">        <span class="comment"># 使用两个循环分别置x,y为0和1</span></span><br><span class="line">        <span class="keyword">for</span> bx <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> by <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">                xx = x + (bx &lt;&lt; m) <span class="comment"># x为上次爆破出来的低n位,而(bx&lt;&lt;m)则将第n+1位置0或1</span></span><br><span class="line">                yy = y + (by &lt;&lt; m)</span><br><span class="line">                <span class="keyword">if</span> f1(xx, yy) &amp; mask != a &amp; mask: <span class="comment"># 根据x and 1 = x且 x and 0 = 0,故可以保持低n位不变将n+1到最高位全部置0,这样可以实现比较f1,f2与a,b的低n位 </span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> f2(xx, yy) &amp; mask != b &amp; mask:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                candidates_.add((xx, yy))</span><br><span class="line">    candidates = candidates_</span><br></pre></td></tr></table></figure><h3 id="加密算法和解密算法"><a href="#加密算法和解密算法" class="headerlink" title="加密算法和解密算法"></a>加密算法和解密算法</h3><p>研究wp后总算弄懂了大致的加解密过程,特此记录.<br>打开encrypt.bf文件,发现如下的符号,以两个方括号的内容为界限进行分割.  </p><p><img src="http://static.zybuluo.com/B1ank/7w7eb4r69fmnkjxxriaz0ooh/encryption_and_decryption.png" alt="encryption_and_decryption.png-77kB"></p><p>根据bf.js对符号进行解析. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;,&apos;表示在当前指针位置加入新变量  </span><br><span class="line">&apos;&gt;&apos;表示指针向右移动一位  </span><br><span class="line">&apos;&lt;&apos;表示指针向左移动一位  </span><br><span class="line">&apos;+&apos;表示指针当前位置变量加1  </span><br><span class="line">&apos;[]&apos;表示方括号中的内容需要进行数次循环直到第一个指针所指位置的值为0  </span><br><span class="line">&apos;.&apos;表示对数值与0的比较结果进行处理</span><br></pre></td></tr></table></figure><p>操作之后我们得到一个十一维矩阵[a1, a2, …, a10, 1]<br>如果我们设输出为b1…b10的话，我们的目标是找到一个十一维的矩阵R(11x11)满足：<br><code>[b1, b2, ..., b10, 1] = R(11x11) * [a1, a2, ..., a10, 1]</code><br>观察得到的十一维矩阵我们发现该矩阵是定义在整数模64环上的希尔密码的变种,可以使用python的sympy库中的inv_mod()函数直接对某个整数模n环求逆.<br>贴一下官方代码:  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">"encrypt.bf"</span>, <span class="string">"r"</span>)</span><br><span class="line">bf_code = f.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_matrix</span><span class="params">(code)</span>:</span></span><br><span class="line">    i = re.compile(<span class="string">"[+]+"</span>).finditer(code.replace(<span class="string">"\n"</span>, <span class="string">""</span>)) <span class="comment">#使用正则表达式按[]分离</span></span><br><span class="line">    m = [[<span class="number">0</span> <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">11</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">11</span>)]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>]:</span><br><span class="line">            m[j][k] += len(next(i).group(<span class="number">0</span>))</span><br><span class="line">        factor = len(next(i).group(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>]:</span><br><span class="line">            m[j][k] += factor * len(next(i).group(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        m[<span class="number">10</span>][k] += len(next(i).group(<span class="number">0</span>))</span><br><span class="line">    m[<span class="number">10</span>][<span class="number">10</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(matrix)</span>:</span></span><br><span class="line">    base64_mapping = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_output</span><span class="params">(output)</span>:</span></span><br><span class="line">        transformed_output = output[:<span class="number">4</span>, :<span class="number">10</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join([base64_mapping[o % <span class="number">64</span>] <span class="keyword">for</span> o <span class="keyword">in</span> transformed_output])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_input</span><span class="params">(input)</span>:</span></span><br><span class="line">        transformed_input = [base64_mapping.index(i) <span class="keyword">for</span> i <span class="keyword">in</span> input]</span><br><span class="line">        <span class="keyword">return</span> sympy.Matrix(<span class="number">4</span>, <span class="number">10</span>, transformed_input).row_join(sympy.ones(<span class="number">4</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    inv_matrix = sympy.Matrix(matrix).inv_mod(<span class="number">64</span>) <span class="comment">#进行模64环上求逆</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> input: to_output(from_input(input).multiply(inv_matrix))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    fn = decrypt(to_matrix(bf_code))</span><br><span class="line">    <span class="keyword">assert</span>(fn(<span class="string">"aMRKoll07lcf49SIuPrNg8v5bMctTkfrQmchaEkF"</span>)</span><br><span class="line">           == <span class="string">"QUICK_BROWN_FOXES_JUMP_OVER_THE_LAZY_DOG"</span>)</span><br><span class="line">    <span class="keyword">assert</span>(fn(<span class="string">"p9dJ4Jsrj3oDy_KxMJ1N750NvUBtXVUGNPVALq5l"</span>)</span><br><span class="line">           == <span class="string">"quick-brown-foxes-jump-over-the-lazy-dog"</span>)</span><br><span class="line">    <span class="keyword">assert</span>(fn(<span class="string">"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ"</span>)</span><br><span class="line">           == <span class="string">"ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ"</span>)</span><br><span class="line">    print(<span class="string">"flag&#123;"</span> + fn(<span class="string">"JzRVPiVpqo4iDM8celyueIs4ff4DKeG3EMKihzuH"</span>) + <span class="string">"&#125;"</span>)</span><br></pre></td></tr></table></figure><h2 id="0x04-others"><a href="#0x04-others" class="headerlink" title="0x04 others"></a>0x04 others</h2><p>本次比赛也出现许多新型的题目,如涉及到区块链、webq类型图片隐写以及机器学习等技术,先将这些题目记录,以备日后学习使用.  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-写在前面&quot;&gt;&lt;a href=&quot;#0x00-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在前面&quot;&gt;&lt;/a&gt;0x00 写在前面&lt;/h2&gt;&lt;p&gt;这次中科大hackergame可以说是既有技术性也有趣味性,总之玩的很开心,而且也学
      
    
    </summary>
    
      <category term="CTF_Writeup" scheme="https://blank-vax.github.io/categories/CTF-Writeup/"/>
    
    
      <category term="Summary" scheme="https://blank-vax.github.io/tags/Summary/"/>
    
      <category term="Game" scheme="https://blank-vax.github.io/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>RSA算法及攻击方法(二)</title>
    <link href="https://blank-vax.github.io/2020/11/09/RSA%E7%AE%97%E6%B3%95%E5%8F%8A%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95(%E4%BA%8C)/"/>
    <id>https://blank-vax.github.io/2020/11/09/RSA算法及攻击方法(二)/</id>
    <published>2020-11-09T02:39:34.435Z</published>
    <updated>2019-10-30T13:28:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>上一篇文章介绍了RSA的加解密过程及相关的数学基础以及对应的基础CTF题目,下面介绍几种针对加密过程中不同参数的攻击方法.  </p><h2 id="0x01-加密指数e"><a href="#0x01-加密指数e" class="headerlink" title="0x01 加密指数e"></a>0x01 加密指数e</h2><h3 id="Rabin加密"><a href="#Rabin加密" class="headerlink" title="Rabin加密"></a>Rabin加密</h3><p>Rabin加密是RSA的衍生算法,e==2是Rabin加密的典型特征,加密过程可以表示为<code>c = m^2 mod n</code>, 解密过程为<code>m = c^(1/2) mod n</code>.<br>详细算法可以参考<a href="https://www.cnblogs.com/jcchan/articles/8441159.html" target="_blank" rel="noopener">Rabin加密体制</a> </p><ul><li><p>python实现</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rabin_decrypt</span><span class="params">(c, p, q, e=<span class="number">2</span>)</span>:</span></span><br><span class="line">    n = p * q</span><br><span class="line">    mp = pow(c, (p + <span class="number">1</span>) / <span class="number">4</span>, p)</span><br><span class="line">    mq = pow(c, (q + <span class="number">1</span>) / <span class="number">4</span>, q)</span><br><span class="line">    yp = gmpy2.invert(p, q)</span><br><span class="line">    yq = gmpy2.invert(q, p)</span><br><span class="line">    r = (yp * p * mq + yq * q * mp) % n</span><br><span class="line">    rr = n - r</span><br><span class="line">    s = (yp * p * mq - yq * q * mp) % n</span><br><span class="line">    ss = n - s</span><br><span class="line">    <span class="keyword">return</span> (r, rr, s, ss)</span><br></pre></td></tr></table></figure></li></ul><p>函数返回四个数字,其中只有一个是我们想要的明文,需要通过其他的方法进行验证.</p><ul><li><p>典型题目<br>题目来源: Jarvis OJ hard RSA<br>题目分析: 题目给出了.enc文件和.pem文件,我们使用openssl命令读取后发现该加密的加密指数e=2,属于典型的Rabin加密体系,考虑使用脚本进行解密.<br>解题脚本:  </p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2,libnum</span><br><span class="line">n=<span class="number">0xC2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD</span></span><br><span class="line">p=<span class="number">275127860351348928173285174381581152299</span></span><br><span class="line">q=<span class="number">319576316814478949870590164193048041239</span></span><br><span class="line">e=<span class="number">2</span></span><br><span class="line">c=int(open(filepath,<span class="string">'rb'</span>).read().encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">mp=pow(c,(p+<span class="number">1</span>)/<span class="number">4</span>,p)</span><br><span class="line">mq=pow(c,(q+<span class="number">1</span>)/<span class="number">4</span>,q)</span><br><span class="line">yp=gmpy2.invert(p,q)</span><br><span class="line">yq=gmpy2.invert(q,p)</span><br><span class="line">r=(yp*p*mq+yq*q*mp)%n</span><br><span class="line">rr=n-r</span><br><span class="line">s=(yp*p*mq-yq*q*mp)%n</span><br><span class="line">ss=n-s</span><br><span class="line"><span class="keyword">print</span> libnum.n2s(r)</span><br><span class="line"><span class="keyword">print</span> libnum.n2s(rr)</span><br><span class="line"><span class="keyword">print</span> libnum.n2s(s)</span><br><span class="line"><span class="keyword">print</span> libnum.n2s(ss)</span><br></pre></td></tr></table></figure></li></ul><h3 id="低加密指数攻击"><a href="#低加密指数攻击" class="headerlink" title="低加密指数攻击"></a>低加密指数攻击</h3><p>当加密指数e较小且明文m也不大时,由于<code>m^e=k*n+m</code>中的k很小甚至为0,我们可以爆破k或者直接开e次方即可.</p><ul><li><p>python实现</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">small_msg</span><span class="params">(e, n, c)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> time.asctime(), <span class="string">"Let's waiting..."</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> xrange(<span class="number">200000000</span>):</span><br><span class="line">        <span class="keyword">if</span> gmpy2.iroot(c + n * k, e)[<span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">print</span> time.asctime(), <span class="string">"...done!"</span></span><br><span class="line">            <span class="keyword">return</span> gmpy2.iroot(c + n * k, e)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li><li><p>典型题目<br>题目来源: Jarvis OJ Extremely hard RSA<br>题目分析: 该题目提供的n为4096位,e=3.我们可以使用上述脚本进行爆破.判断停止条件为开三次方根的结果为整数,使用的开方函数为<code>gmpy2.iroot()</code><br>解题脚本: </p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2,binascii,libnum,time</span><br><span class="line">n=given_n(hex)</span><br><span class="line">e=<span class="number">3</span></span><br><span class="line">res=<span class="number">0</span></span><br><span class="line">c=int(open(filepath, <span class="string">'rb'</span>).read().encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> time.asctime()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">200000000</span>):</span><br><span class="line">    <span class="keyword">if</span> gmpy2.iroot(c+n*i,<span class="number">3</span>)[<span class="number">1</span>]==<span class="number">1</span>:</span><br><span class="line">        res=gmpy2.iroot(c+n*i,<span class="number">3</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">print</span> i,res</span><br><span class="line">        <span class="keyword">print</span> libnum.n2s(res)</span><br><span class="line">        <span class="keyword">print</span> time.asctime()</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="低加密指数广播攻击"><a href="#低加密指数广播攻击" class="headerlink" title="低加密指数广播攻击"></a>低加密指数广播攻击</h3><p>如果模数n和密文c不同,而明文m和加密指数e相同.一般取e=k,k为所给数据的数量且e较小.在题目中会得到多个形如<code>m^e == ci (mod ni)</code>的加密等式.取e=3,则有:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c1 = m^e mod n1</span><br><span class="line">c2 = m^e mod n2</span><br><span class="line">c3 = m^e mod n3</span><br></pre></td></tr></table></figure><p>对上述等式运用中国剩余定理,在e=3时,有:<br><code>cx = m^3 mod n1*n2*n3</code><br>对cx进行开方即可求得明文.</p><ul><li><p>典型例题<br>题目来源: 2018强网杯nextrsa-Level9<br>题目分析: 该题目给出了c1,c2,c3,n1,n2,n3,我们考虑使用中国剩余定理CRT()函数和iroot()函数进行爆破.<br>解题脚本: </p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m = random.randint(<span class="number">0x100000000000</span>, <span class="number">0xffffffffffff</span>)</span><br><span class="line">e = <span class="number">3</span></span><br><span class="line">n1 = modulus1</span><br><span class="line">n2 = modulus2</span><br><span class="line">n3 = modulus3</span><br><span class="line">c1 = pow(m, e, n1)</span><br><span class="line">c2 = pow(m, e, n2)</span><br><span class="line">c3 = pow(m, e, n3)</span><br><span class="line"><span class="keyword">print</span> m == gmpy2.iroot(CRT([n1, n2, n3], [c1, c2, c3]), e)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li></ul><h3 id="CopperSmith-Theorem"><a href="#CopperSmith-Theorem" class="headerlink" title="CopperSmith Theorem"></a>CopperSmith Theorem</h3><p>该定理指出在一个e阶的模n多项式f(x)中,如果有一个根小于n^(1/e),就可以运用一个O(log n)的算法求出这些根.<br>该定理运用在rsa算法中,如果e=3并且明文当中有三分之二比特是已知的,这种算法可以还原出明文中所有的比特.   </p><ul><li><p>sage实现的解题脚本</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n= number1(hex)</span><br><span class="line">p=0xBCF6D95C9FFCA2B17FD930C743BCEA314A5F24AE06C12CE62CDB6E8306A545DE468F1A23136321EB82B4B8695ECE58B763ECF8243CBBFADE0603922C130ED143D4D3E88E483529C820F7B53E4346511EB14D4D56CB2B714D3BDC9A2F2AB655993A31E0EB196E8F63028F9B29521E9B3609218BA0000000000000000000000000</span><br><span class="line">p_fake = p+0x10000000000000000000000000</span><br><span class="line">pbits = 1024</span><br><span class="line">kbits = pbits-576</span><br><span class="line">pbar = p_fake &amp; (2^pbits-2^kbits)</span><br><span class="line">print &quot;upper %d bits (of %d bits) is given&quot; % (pbits-kbits, pbits)</span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = x + pbar</span><br><span class="line">x0 = f.small_roots(X=2^kbits, beta=0.4)[0]  # find root &lt; 2^kbits with factor &gt;= n^0.4</span><br><span class="line">print x0 + pbar</span><br></pre></td></tr></table></figure></li><li><p>详细解释参考<a href="https://www.52pojie.cn/thread-653446-1-1.html" target="_blank" rel="noopener">Coppersmith</a>及维基百科说明</p></li><li><a href="https://sagecell.sagemath.org/" target="_blank" rel="noopener">sage在线运行</a></li></ul><h3 id="e与-phi-n-不互素"><a href="#e与-phi-n-不互素" class="headerlink" title="e与$\phi$(n)不互素"></a>e与$\phi$(n)不互素</h3><p>只有当e与$\phi$(n)互素时,才能保证e的逆元d唯一存在.当二者不互素时,我们通过gcd()操作寻找与$\phi$(n)互素的数,然后进行求解.我们通过一个例题来说明.<br>题目描述:   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n1=0xcfc59d54b4b2e9ab1b5d90920ae88f430d39fee60d18dddbc623d15aae645e4e50db1c07a02d472b2eebb075a547618e1154a15b1657fbf66ed7e714d23ac70bdfba4c809bbb1e27687163cb09258a07ab2533568192e29a3b8e31a5de886050b28b3ed58e81952487714dd7ae012708db30eaf007620cdeb34f150836a4b723L</span><br><span class="line">e1=0xfae3aL</span><br><span class="line">c1=0x81523a330fb15125b6184e4461dadac7601340960840c5213b67a788c84aecfcdc3caf0bf3e27e4c95bb3c154db7055376981972b1565c22c100c47f3fa1dd2994e56090067b4e66f1c3905f9f780145cdf8d0fea88a45bae5113da37c8879c9cdb8ee9a55892bac3bae11fbbabcba0626163d0e2e12c04d99f4eeba5071cbeaL</span><br><span class="line">n2=0xd45304b186dc82e40bd387afc831c32a4c7ba514a64ae051b62f483f27951065a6a04a030d285bdc1cb457b24c2f8701f574094d46d8de37b5a6d55356d1d368b89e16fa71b6603bd037c7f329a3096ce903937bb0c4f112a678c88fd5d84016f745b8281aea8fd5bcc28b68c293e4ef4a62a62e478a8b6cd46f3da73fa34c63L</span><br><span class="line">e2=0x1f9eaeL</span><br><span class="line">c2=0x4d7ceaadf5e662ab2e0149a8d18a4777b4cd4a7712ab825cf913206c325e6abb88954ebc37b2bda19aed16c5938ac43f43966e96a86913129e38c853ecd4ebc89e806f823ffb802e3ddef0ac6c5ba078d3983393a91cd7a1b59660d47d2045c03ff529c341f3ed994235a68c57f8195f75d61fc8cac37e936d9a6b75c4bd2347L</span><br><span class="line">assert pow(flag,e1,n1)==c1</span><br><span class="line">assert pow(flag,e2,n2)==c2</span><br><span class="line">assert gcd(e1,(p1-1)*(q1-1))==14</span><br><span class="line">assert gcd(e2,(p2-1)*(q2-1))==14</span><br></pre></td></tr></table></figure><p>题目分析:题目给出了n1和n2,我们联想到公约数,通过<code>p=gcd(n1,n2)</code>求得p,进而求出q1和q2.此时我们发现e与$\phi$(n)不互素.<br>如果我们需要求逆元,则需要找到与$\phi$(n)互素的数.    </p><p><img src="http://static.zybuluo.com/B1ank/4daca4b9ozlypgv26lha3dob/1.png" alt="1.png-11.4kB"><br>我们已知b=14,通过上面的推算我们可得a与$\phi$(n)互素,于是求出<code>b*d = gmpy2.invert(a,phin)</code>,进而求出d.可是经测试发现明文为乱码.<br>根据推导的最后一个公式,b*d可作为私钥求解出m^14.我们得到一个同余方程组.<br><img src="http://static.zybuluo.com/B1ank/1tpnsfcs7ne4jachn5pkydxm/2.png" alt="2.png-4kB"><br>进一步推导<br><img src="http://static.zybuluo.com/B1ank/5q8jhm7n2jipnofpspmmqlil/3.png" alt="3.png-5.4kB"><br>可以运用中国剩余定理计算特解m,即<code>m=solve_crt([m1,m2,m3], [q1,q2,p])</code>.如果模n1,n2不行那么可以转换为模q1*q2,从而有res $\equiv$ m^14 mod q1*q2.<br>这样就转换成一个新的rsa问题,且e=14.此时e与$\phi$(n)=(q1-1)*(q2-1)还有公因数2.那么我们参照上述思路,可以得出m^2满足的方程,从而开方求结果.<br><img src="http://static.zybuluo.com/B1ank/x4r70t8961voxq9zemanxjw7/5.png" alt="5.png-7.9kB"><br>解题脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">p=gcd(n1,n2)</span><br><span class="line">q1=n1/p</span><br><span class="line">q2=n2/p</span><br><span class="line"><span class="keyword">assert</span>(p*q1==n1)</span><br><span class="line"><span class="keyword">assert</span>(p*q2==n2)</span><br><span class="line">f1=(p<span class="number">-1</span>)*(q1<span class="number">-1</span>)</span><br><span class="line">f2=(p<span class="number">-1</span>)*(q2<span class="number">-1</span>)</span><br><span class="line">tmp=<span class="number">14</span></span><br><span class="line"></span><br><span class="line">e1=e1/tmp</span><br><span class="line">e2=e2/tmp</span><br><span class="line">bd1=invmod(e1,f1)</span><br><span class="line">bd2=invmod(e2,f2)</span><br><span class="line"></span><br><span class="line">m1=pow(c1,bd1,n1)</span><br><span class="line">m2=pow(c2,bd2,n2)</span><br><span class="line">m3=m1%p</span><br><span class="line">m2=m2%q2</span><br><span class="line">m1=m1%q1</span><br><span class="line"></span><br><span class="line">m=solve_crt([m1,m2,m3], [q1,q2,p]) </span><br><span class="line"><span class="keyword">print</span> m</span><br><span class="line">n=q1*q2</span><br><span class="line">f=(q1<span class="number">-1</span>)*(q2<span class="number">-1</span>)</span><br><span class="line">m=m%n</span><br><span class="line"><span class="number">2</span>d=invmod(<span class="number">7</span>,f)</span><br><span class="line">m=pow(m,<span class="number">2</span>d,n)</span><br><span class="line"><span class="keyword">print</span> n2s(gmpy2.iroot(m, <span class="number">2</span>)[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h2 id="0x02-解密指数d"><a href="#0x02-解密指数d" class="headerlink" title="0x02 解密指数d"></a>0x02 解密指数d</h2><h3 id="低解密指数攻击"><a href="#低解密指数攻击" class="headerlink" title="低解密指数攻击"></a>低解密指数攻击</h3><p>如果满足条件<code>d &lt; (1/3)*n^(1/4)</code>,那么一种基于连分数的特殊攻击类型就可以危害RSA的安全.此时需要满足<code>q&lt;p&lt;2*q</code>,则可以通过Wiener Attack在多项式时间中分解n.常适用于e过大或过小的情况.为了理解这个过程,我们讲解维纳定理相关知识.    </p><ul><li>Wiener’s Theorem<ul><li>连分数展开: <code>[a0,a1,a2,....,an]</code><br><img src="http://static.zybuluo.com/B1ank/ro2jz9fgdxuyp9p7tjc2lx45/1.png" alt="1.png-5kB"><br>举例如下:<br><img src="http://static.zybuluo.com/B1ank/af7d02gk7xfeyf9q7zf9636p/3.png" alt="3.png-28.3kB"></li><li>渐近分数<br><img src="http://static.zybuluo.com/B1ank/mjt8cit6vxais5bwpn6t99cb/2.png" alt="2.png-0.8kB"></li><li>定理内容<br>如果<code>N = p*q, q&lt;p&lt;2*q, d&lt;(1/3)*N^(1/4)</code>,且已知(e,N)满足e*d $\equiv$ 1 mod $\phi$(N),攻击者可以从e/N的连分数的渐近分数中找到正确的k/d从而获得密钥d.   </li><li>举例<br>已知(N,e)=(90581,17993),首先求e/N的连分数的渐近分数:<br><img src="http://static.zybuluo.com/B1ank/zecvquc04wbkq38al8pp2nfz/4.png" alt="4.png-88.2kB"><br>循环k,d的值,求解方程:<br><img src="http://static.zybuluo.com/B1ank/odlq2klwyutrumz8gbi7bqaj/5.png" alt="5.png-38.5kB"><br>如果方程有两个有效解则分别为p和q.本例中当k=1,d=5时,$\phi$(N)=89964,方程存在两解x1=379,x2=293.    </li></ul></li><li><p>python实现 </p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">import</span> ContinuedFractions, Arithmetic</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wiener_hack</span><span class="params">(e, n)</span>:</span></span><br><span class="line">    <span class="comment"># firstly git clone https://github.com/pablocelayes/rsa-wiener-attack.git !</span></span><br><span class="line">    frac = ContinuedFractions.rational_to_contfrac(e, n)</span><br><span class="line">    convergents = ContinuedFractions.convergents_from_contfrac(frac)</span><br><span class="line">    <span class="keyword">for</span> (k, d) <span class="keyword">in</span> convergents:</span><br><span class="line">        <span class="keyword">if</span> k != <span class="number">0</span> <span class="keyword">and</span> (e * d - <span class="number">1</span>) % k == <span class="number">0</span>:</span><br><span class="line">            phi = (e * d - <span class="number">1</span>) // k</span><br><span class="line">            s = n - phi + <span class="number">1</span></span><br><span class="line">            discr = s * s - <span class="number">4</span> * n</span><br><span class="line">            <span class="keyword">if</span> (discr &gt;= <span class="number">0</span>):</span><br><span class="line">                t = Arithmetic.is_perfect_square(discr)</span><br><span class="line">                <span class="keyword">if</span> t != <span class="number">-1</span> <span class="keyword">and</span> (s + t) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    print(<span class="string">"Hacked!"</span>)</span><br><span class="line">                    <span class="keyword">return</span> d</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><p>github参考工具:<a href="https://github.com/pablocelayes/rsa-wiener-attack" target="_blank" rel="noopener">rsa-wiener-attack</a></p></li><li><p>典型例题<br>题目来源: 2018强网杯nextrsa-Level2<br>解题脚本:</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># e与n的差距过小,考虑使用wiener&apos;s attack</span><br><span class="line">n = 0x92411fa0c93c1b27f89e436d8c4698bcf554938396803a5b62bd10c9bfcbf85a483bd87bb2d6a8dc00c32d8a7caf30d8899d90cb8f5838cae95f7ff5358847db1244006c140edfcc36adbdcaa16cd27432b4d50d2348b5c15c209364d7914ef50425e4c3da07612cc34e9b93b98d394b43f3eb0a5a806c70f06697b6189606eb9707104a7b6ff059011bac957e2aae9ec406a4ff8f8062400d2312a207a9e018f4b4e961c943dfc410a26828d2e88b24e4100162228a5bbf0824cf2f1c8e7b915efa385efeb505a9746e5d19967766618007ddf0d99525e9a41997217484d64c6a879d762098b9807bee46a219be76941b9ff31465463981e230eecec69691d1L</span><br><span class="line">e = 0x6f6b385dd0f06043c20a7d8e5920802265e1baab9d692e7c20b69391cc5635dbcaae59726ec5882f168b3a292bd52c976533d3ad498b7f561c3dc01a76597e47cfe60614f247551b3dbe200e2196eaa001a1d183886eeacddfe82d80b38aea24de1a337177683ed802942827ce4d28e20efef92f38f1b1a18c66f9b45f5148cceabfd736de8ac4a49e63a8d35a83b664f9f3b00f822b6f11ff13257ee6e0c00ca5c98e661ea594a9e66f2bd56b33d9a13f5c997e67a37fcf9a0c7f04d119fe1ba261127357e64a4b069aefed3049c1c1fe4f964fd078b88bedd064abea385cfebd65e563f93c12d34eb6426e8aa321033cfd8fe8855b9e74d07fe4f9d70de46fL</span><br><span class="line">d = wiener_hack(e, n)</span><br><span class="line">print d  #42043</span><br></pre></td></tr></table></figure></li></ul><h3 id="d泄露攻击"><a href="#d泄露攻击" class="headerlink" title="d泄露攻击"></a>d泄露攻击</h3><p>如果我们知道一组过期的(N, e1, d1)和一组由新的e2组成的公钥及其加密的密文(N, e2, c),我们可以由(e1, d1)得到模数N的两个因子p和q,然后再反解d2即可求出明文.    </p><h3 id="private-pem修复攻击"><a href="#private-pem修复攻击" class="headerlink" title="private.pem修复攻击"></a>private.pem修复攻击</h3><p>当题目提供的模数N过大不可分解且同时提供破损的私钥文件时,可以考虑private.pem修复.    </p><ul><li>典型题目: Jarvis OJ-God Like RSA</li><li>参考链接: <a href="https://www.40huo.cn/blog/rsa-private-key-recovery-and-oaep.html" target="_blank" rel="noopener">私钥文件修复</a></li></ul><h2 id="0x03-模数N"><a href="#0x03-模数N" class="headerlink" title="0x03 模数N"></a>0x03 模数N</h2><h3 id="N的特殊分解"><a href="#N的特殊分解" class="headerlink" title="N的特殊分解"></a>N的特殊分解</h3><p>针对大整数的分解有很多种算法,包括Fermat方法,Pollard rho p-1方法,试除法,以及椭圆曲线法,连分数法,二次筛选法,数域分析法等等.这里具体介绍Pollard rho和Fermat分解方法.    </p><ul><li><p>Pollard rho p-1分解<br>适用于p和q相差较大的情况.脚本如下:</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PollardRho_p_1</span><span class="params">(Q,N)</span>:</span></span><br><span class="line">    a = i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        a = pow(a, i, N)</span><br><span class="line">        d = gcd(a - <span class="number">1</span>, N)</span><br><span class="line">        <span class="keyword">if</span> d != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> d</span><br><span class="line">        i += <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>Fermat分解<br>适用于p和q相差不大的情况.脚本如下:</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fermat</span><span class="params">(Q,n)</span>:</span></span><br><span class="line">    a = isqrt_rem(n)[<span class="number">0</span>]+<span class="number">1</span></span><br><span class="line">    b = a ** <span class="number">2</span> - n</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        q = isqrt_rem(b)</span><br><span class="line">        <span class="keyword">if</span> q[<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> a - q[<span class="number">0</span>]</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">        b = a ** <span class="number">2</span> - n</span><br></pre></td></tr></table></figure></li><li><p>典型题目<br>分解<code>n = 0x4333AF6B43F36028D8D9650EC3EED3238541EE5C15E626C58C9EC33674A6D08D5B1F2580A1A0B07E9D853536CD994E197889D122701A62BB2A9E79559F3D5281014535F6C54F83CA8D9700EEB67D99AF318D20A5150AD46D622A6A12DE0A758EE7DF75F5D10F2FE2585F2348537787063321FFDAC91BB3C3D1D88CBD04A824ED</code>.<br>分解脚本如下:</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line">n = given_n</span><br><span class="line">x2 = <span class="number">1</span></span><br><span class="line">c = <span class="number">7</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    x1 = randint(<span class="number">1</span>, n)</span><br><span class="line">    x2 = pow(x2,<span class="number">2</span>,n)+c%n</span><br><span class="line">    fac = gcd(abs(x1-x2),n)</span><br><span class="line">    <span class="keyword">if</span> fac&gt;<span class="number">1</span> <span class="keyword">and</span> is_prime(fac):</span><br><span class="line">        <span class="keyword">print</span> fac</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">print</span> n/fac</span><br></pre></td></tr></table></figure></li></ul><h3 id="共模攻击"><a href="#共模攻击" class="headerlink" title="共模攻击"></a>共模攻击</h3><p>当明文m、模数n相同,公钥指数e、密文c不同且<code>gcd(e1,e2)==1</code>时,我们可以采取共模攻击来直接还原出明文.下面简单进行证明:<br>$\because$ gcd(e1,e2)==1<br>$\therefore$存在s2,使得s1*e1+s2*e2=1<br>又$\because$ c1 $\equiv$ m^e1 mod n,c2 $\equiv$ m^e2 mod n<br>$\therefore$ c1^e1*c2^e2 $\equiv$ m mod n  </p><ul><li><p>python实现 </p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">common_modulus</span><span class="params">(n, e1, e2, c1, c2)</span>:</span></span><br><span class="line"><span class="keyword">assert</span> (libnum.gcd(e1, e2) == <span class="number">1</span>)</span><br><span class="line">_, s1, s2 = gmpy2.gcdext(e1, e2)</span><br><span class="line"><span class="comment"># 若s1&lt;0，则c1^s1==(c1^-1)^(-s1)，其中c1^-1为c1模n的逆元。</span></span><br><span class="line">m = pow(c1, s1, n) <span class="keyword">if</span> s1 &gt; <span class="number">0</span> <span class="keyword">else</span> pow(gmpy2.invert(c1, n), -s1, n)</span><br><span class="line">m *= pow(c2, s2, n) <span class="keyword">if</span> s2 &gt; <span class="number">0</span> <span class="keyword">else</span> pow(gmpy2.invert(c2, n), -s2, n)</span><br><span class="line"><span class="keyword">return</span> m % n</span><br></pre></td></tr></table></figure></li><li><p>典型例题<br>题目来源: buuctf RSA3<br>题目分析: 该题给出了c1,c2,e1,e2和n,显然使用共模攻击.<br>解题脚本:</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2 <span class="keyword">as</span> gp</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exgcd</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> b==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, <span class="number">0</span>, a</span><br><span class="line">    x2, y2, r = exgcd(b, a%b)</span><br><span class="line">    x1 = y2</span><br><span class="line">    y1 = x2-(a//b)*y2</span><br><span class="line">    <span class="keyword">return</span> x1, y1, r</span><br><span class="line">c1=gp.mpz(c1)</span><br><span class="line">n=gp.mpz(n)</span><br><span class="line">e1=gp.mpz(e1)</span><br><span class="line">c2=gp.mpz(c2)</span><br><span class="line">e2=gp.mpz(e2)</span><br><span class="line">r1, r2, t = exgcd(e1, e2)</span><br><span class="line">m = gp.powmod(c1, r1, n) * gp.powmod(c2, r2, n) % n</span><br><span class="line">print(m)</span><br><span class="line">print(hex(m)[<span class="number">2</span>:])</span><br><span class="line">print(bytes.fromhex(str(hex(m)[<span class="number">2</span>:])))</span><br></pre></td></tr></table></figure></li></ul><h3 id="公共因子攻击"><a href="#公共因子攻击" class="headerlink" title="公共因子攻击"></a>公共因子攻击</h3><p>当题目给出同一个(m,e)使用较多组N加密后的多组(N,c)时,可以循环求解这些N的最大公因数.如果存在<code>gcd(Ni,Nj)!= 1</code>,则可以顺利分解Ni和Nj,从而还原明文.  </p><ul><li><p>python实现  </p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">common_primes</span><span class="params">(data)</span>:</span></span><br><span class="line"><span class="comment"># 按照data[0]=n1,data[1]=e1,data[2]=n2,....的顺序构造数组data</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)//<span class="number">2</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(data)//<span class="number">2</span>):</span><br><span class="line"><span class="keyword">if</span> math.gcd(data[<span class="number">2</span>*i],data[<span class="number">2</span>*j]) != <span class="number">1</span>:</span><br><span class="line">print(<span class="string">"[+]Successfully found!"</span>)</span><br><span class="line">print(<span class="string">"    [-]n1 ="</span> + str(data[<span class="number">2</span>*i]))</span><br><span class="line">print(<span class="string">"    [-]n2 ="</span> + str(data[<span class="number">2</span>*j]))</span><br><span class="line">print(<span class="string">"[+]One possible decomposition:"</span>)</span><br><span class="line">print(<span class="string">"    [!]p = "</span> + str(math.gcd(data[<span class="number">2</span>*i],data[<span class="number">2</span>*j])))</span><br><span class="line">print(<span class="string">"    [!]q = "</span> + str(data[<span class="number">2</span>*i]//math.gcd(data[<span class="number">2</span>*i],data[<span class="number">2</span>*j])))</span><br><span class="line">exit()</span><br></pre></td></tr></table></figure></li><li><p>典型题目<br>题目来源: buuctf RSA5<br>题目分析: 题目给出了e=65537,以及二十组对应的(n,c).由于所给的信息数量较多,考虑公共因子攻击.构造符合上文所给脚本的数组data,然后寻找拥有公共因子的模数对,最后还原明文.<br>解题脚本: </p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2 <span class="keyword">as</span> gp</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">data = [given_n_and_e_combinations]</span><br><span class="line">e = gp.mpz(<span class="number">65537</span>)</span><br><span class="line">common_primes(data)</span><br><span class="line"><span class="comment"># then we get the results as follows:</span></span><br><span class="line">n = gp.mpz(n)</span><br><span class="line">c = gp.mpz(c)</span><br><span class="line">d = gp.mpz(d)</span><br><span class="line">m = gp.powmod(c,d,n)</span><br><span class="line">print(m)</span><br><span class="line">print(binascii.a2b_hex(str(m))[<span class="number">2</span>:])</span><br><span class="line"><span class="comment"># flag = flag&#123;abdcbe5fd94e23b3de429223ab9c2fdf&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="0x04-密文c"><a href="#0x04-密文c" class="headerlink" title="0x04 密文c"></a>0x04 密文c</h2><h3 id="选择密文攻击"><a href="#选择密文攻击" class="headerlink" title="选择密文攻击"></a>选择密文攻击</h3><p>该类攻击适用于可以构造任意密文并获得对应明文的情况.<br>在一个RSA加密过程中,明文为m,密文为c,模数为n,加密指数为e,选取x以满足<code>gcd(x,n)==1</code>从而使x模n的逆存在,构造密文<code>c&#39;=c*(x^e)</code>,使解密后的明文为<code>m&#39;=(m*x)%n</code>,则<code>m=m&#39;*x^(-1)(mod n)</code>.    </p><h3 id="LSB-Oracle-Attack"><a href="#LSB-Oracle-Attack" class="headerlink" title="LSB Oracle Attack"></a>LSB Oracle Attack</h3><p>假如用户知道公钥中N, e, c,并且可以任意构造密文c1,返回此密文解密后p1的末尾某些比特位的性质(记为函数f).最简单的函数f是表示p1的奇偶性.<br>攻击者构造密文<code>c&#39;=((2^e)*c)%n=((2^e)*(m^e))%n=((2*m)^e)%n</code>,返回明文<code>m&#39;=(2*m)%n</code>及m’的lsb.下面继续分析,因为n是奇数,而2*m是偶数,所以如果lsb=0,则<code>(2\*m)%n</code>是偶数,没有超过n,从而确定<code>m&lt;n/2.0</code>,反之则<code>m&gt;n/2.0</code>.<br>以此类推,构造密文<code>c&#39;&#39;=((4^e)*c)%n</code>使其解密后有<code>m&#39;&#39;=(4*m)%n</code>,判断m’’的奇偶性就可以知道m和n/4的大小关系.此时我们得到一个在对数时间内将m的范围逼近到一个足够小范围的二分算法.      </p><ul><li><p>python实现</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> decimal</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oracle</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> lsb == <span class="string">'odd'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial</span><span class="params">(c, e, n)</span>:</span></span><br><span class="line">    k = n.bit_length()</span><br><span class="line">    decimal.getcontext().prec = k  <span class="comment"># for 'precise enough' floats</span></span><br><span class="line">    lo = decimal.Decimal(<span class="number">0</span>)</span><br><span class="line">    hi = decimal.Decimal(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> oracle(c):</span><br><span class="line">            hi = (lo + hi) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            lo = (lo + hi) / <span class="number">2</span></span><br><span class="line">        c = (c * pow(<span class="number">2</span>, e, n)) % n</span><br><span class="line">        <span class="comment"># print i, int(hi - lo)</span></span><br><span class="line">    <span class="keyword">return</span> int(hi)</span><br></pre></td></tr></table></figure></li><li><p>题目一: QCTF 2018-XMan选拔赛/Baby RSA<br>题目描述:   </p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">n = <span class="number">0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716db</span></span><br><span class="line">c = <span class="number">0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0</span></span><br><span class="line">λ nc <span class="number">47.96</span><span class="number">.239</span><span class="number">.28</span> <span class="number">23333</span></span><br><span class="line">----------------------------- baby rsa -----------------------------</span><br><span class="line">Come <span class="keyword">and</span> Decode your data</span><br><span class="line">If you give me ciphertext, I can tell you whether decoded data <span class="keyword">is</span> even <span class="keyword">or</span> odd</span><br><span class="line">You can input ciphertext(hexdecimal) now</span><br><span class="line"><span class="number">1</span></span><br><span class="line">odd</span><br><span class="line"> </span><br><span class="line">solve.py</span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> libnum, gmpy2, socket, time, decimal</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oracle</span><span class="params">(c1)</span>:</span></span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    hostname = <span class="string">'47.96.239.28'</span></span><br><span class="line">    port = <span class="number">23333</span></span><br><span class="line">    s.connect((hostname, port))</span><br><span class="line">    s.recv(<span class="number">1024</span>)</span><br><span class="line">    s.send(hex(c1)[<span class="number">2</span>:].strip(<span class="string">"lL"</span>) + <span class="string">'\n'</span>)</span><br><span class="line">    res = s.recv(<span class="number">1024</span>).strip()</span><br><span class="line">    s.close()</span><br><span class="line">    <span class="keyword">if</span> res == <span class="string">'even'</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> res == <span class="string">'odd'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">assert</span> (<span class="number">0</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial</span><span class="params">(c, n)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> c_of_2</span><br><span class="line">    k = n.bit_length()</span><br><span class="line">    decimal.getcontext().prec = k  <span class="comment"># allows for 'precise enough' floats</span></span><br><span class="line">    lower = decimal.Decimal(<span class="number">0</span>)</span><br><span class="line">    upper = decimal.Decimal(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        possible_plaintext = (lower + upper) / <span class="number">2</span></span><br><span class="line">        <span class="comment"># lower==0 when i&lt;1809</span></span><br><span class="line">        flag = oracle(c)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            upper = possible_plaintext  <span class="comment"># plaintext is in the lower half</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            lower = possible_plaintext  <span class="comment"># plaintext is in the upper half</span></span><br><span class="line">        c = (c * c_of_2) % n  <span class="comment"># multiply y by the encryption of 2 again</span></span><br><span class="line">        <span class="keyword">print</span> i, flag, int(upper - lower)</span><br><span class="line">        <span class="comment"># time.sleep(0.2)</span></span><br><span class="line">    <span class="comment"># By now, our plaintext is revealed!</span></span><br><span class="line">    <span class="keyword">return</span> int(upper)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"[*] Conducting Oracle attack..."</span></span><br><span class="line">    <span class="keyword">return</span> partial((c * c_of_2) % n, n)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    e = given_e</span><br><span class="line">    n = given_n</span><br><span class="line">    c = given_c</span><br><span class="line">    c_of_2 = pow(<span class="number">2</span>, e, n)</span><br><span class="line">    m = main()</span><br><span class="line">    <span class="comment"># m = 560856645743734814774953158390773525781916094468093308691660509501812349</span></span><br><span class="line">    <span class="keyword">print</span> libnum.n2s(m)</span><br><span class="line">    <span class="comment"># QCTF&#123;RSA_parity_oracle_is_fun&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>题目二:Backdoor CTF2018 BIT-LEAKER     </p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server.py</span><br><span class="line"><span class="comment">#!/usr/bin/python -u</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#from SECRET import flag</span></span><br><span class="line">flag = <span class="string">"CTF&#123;this_is_my_test_flag&#125;"</span></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">key = RSA.generate(<span class="number">1024</span>)</span><br><span class="line">c = pow(m, key.e, key.n)</span><br><span class="line">print(<span class="string">"Welcome to BACKDOORCTF17\n"</span>)</span><br><span class="line">print(<span class="string">"PublicKey:\n"</span>)</span><br><span class="line">print(<span class="string">"N = "</span> + str(key.n) + <span class="string">"\n"</span>)</span><br><span class="line">print(<span class="string">"e = "</span> + str(key.e) + <span class="string">"\n"</span>)</span><br><span class="line">print(<span class="string">"c = "</span> + str(c) + <span class="string">"\n"</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        temp_c = int(raw_input(<span class="string">"temp_c = "</span>))</span><br><span class="line">        temp_m = pow(temp_c, key.d, key.n)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    l = str(((temp_m&amp;<span class="number">5</span>) * random.randint(<span class="number">1</span>,<span class="number">10000</span>))%(<span class="number">2</span>*(random.randint(<span class="number">1</span>,<span class="number">10000</span>))))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"l = "</span>+l</span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">solve.py</span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">import</span> Crypto</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify,unhexlify</span><br><span class="line"><span class="keyword">if</span> len(sys.argv)&gt;<span class="number">1</span>:</span><br><span class="line">    p=remote(<span class="string">"127.0.0.1"</span>,<span class="number">2334</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p=remote(<span class="string">'127.0.0.1'</span>,<span class="number">2333</span>)</span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oracle</span><span class="params">(c)</span>:</span></span><br><span class="line">    l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        p.sendline(str(c))</span><br><span class="line">        s = p.recvuntil(<span class="string">"temp_c"</span>)</span><br><span class="line">        l.append(int(re.findall(<span class="string">"l\s*=\s*([0-9]*)"</span>,s)[<span class="number">0</span>]))</span><br><span class="line">    flag0 = <span class="number">0</span></span><br><span class="line">    flag2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        <span class="keyword">if</span> l[i]%<span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            flag0 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> l[i] &gt; <span class="number">10000</span>:</span><br><span class="line">            flag2 = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> [flag2,flag0]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    ss = p.recvuntil(<span class="string">"temp_c"</span>)</span><br><span class="line">    N = int(re.findall(<span class="string">"N\s*=\s*(\d+)"</span>,ss)[<span class="number">0</span>])</span><br><span class="line">    e = int(re.findall(<span class="string">"e\s*=\s*(\d+)"</span>,ss)[<span class="number">0</span>])</span><br><span class="line">    c = int(re.findall(<span class="string">"c\s*=\s*(\d+)"</span>,ss)[<span class="number">0</span>])</span><br><span class="line">    size = libnum.len_in_bits(N)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"N="</span>,N</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"e="</span>,e</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"c="</span>,c</span><br><span class="line">    c = (pow(<span class="number">2</span>,e,N)*c)%N</span><br><span class="line">    LB = <span class="number">0</span></span><br><span class="line">    UB = N</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> LB!=UB:</span><br><span class="line">        flag = oracle(c)</span><br><span class="line">        <span class="keyword">print</span> i,flag</span><br><span class="line">        <span class="keyword">if</span> flag[<span class="number">1</span>]%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">            UB = (LB+UB)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            LB = (LB+UB)/<span class="number">2</span></span><br><span class="line">        c = (pow(<span class="number">2</span>,e,N)*c)%N</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> LB</span><br><span class="line">    <span class="keyword">print</span> UB</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">-128</span>,<span class="number">128</span>,<span class="number">0</span>):</span><br><span class="line">        LB += i</span><br><span class="line">        <span class="keyword">if</span> pow(LB,e,N)==C:</span><br><span class="line">            <span class="keyword">print</span> unhexlify(hex(LB)[<span class="number">2</span>:<span class="number">-1</span>])</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure></li><li><p>参考链接: <a href="https://introspelliam.github.io/2018/03/27/crypto/RSA-Least-Significant-Bit-Oracle-Attack/" target="_blank" rel="noopener">RSA Least-Significant-Bit Oracle Attack</a></p></li></ul><h2 id="0x05-综合应用"><a href="#0x05-综合应用" class="headerlink" title="0x05 综合应用"></a>0x05 综合应用</h2><p>通过一道题目分析说明RSA的综合应用.<br>题目来源: 2019De1CTF BabyRSA<br>题目描述: 题目提供的脚本如下.  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> data <span class="keyword">import</span> e1,e2,p,q1p,q1q,hint,flag</span><br><span class="line"></span><br><span class="line">n =  [n1, n2, n3, n4]</span><br><span class="line">c =  [c1, c2, c3, c4]</span><br><span class="line">f=<span class="keyword">lambda</span> m,e,n,c:pow(m,e,n)==c</span><br><span class="line"><span class="keyword">assert</span>(sum(map(f,[p]*<span class="number">4</span>,[<span class="number">4</span>]*<span class="number">4</span>,n,c))==<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">ee1 = <span class="number">42</span></span><br><span class="line">ee2 = <span class="number">3</span></span><br><span class="line">ce1 =  <span class="number">45722651786340123946960815003059322528810481841378247280642868553607692149509126962872583037142461398806689489141741494974836882341505234255325683219092163052843461632338442529011502378931140356111756932712822516814023166068902569458299933391973504078898958921809723346229893913662577294963528318424676803942288386430172430880307619748186863890050113934573820505570928109017842647598266634344447182347849367714564686341871007505886728393751147033556889217604647355628557502208364412269944908011305064122941446516990168924709684092200183860653173856272384</span></span><br><span class="line">ce2 =  <span class="number">13908468332333567158469136439932325992349696889129103935400760239319454409539725389747059213835238373047899198211128689374049729578146875309231962936554403287882999967840346216695208424582739777034261079550395918048421086843927009452479936045850799096750074359160775182238980989229190157551197830879877097703347301072427149474991803868325769967332356950863518504965486565464059770451458557744949735282131727956056279292800694203866167270268988437389945703117070604488999247750139568614939965885211276821987586882908159585863514561191905040244967655444219603287214405014887994238259270716355378069726760953320025828158</span></span><br><span class="line">tmp =  <span class="number">864078778078609835167779565982540757684070450697854309005171742813414963447462554999012718960925081621571487444725528982424037419052194840720949809891134854871222612682162490991065015935449289960707882463387</span></span><br><span class="line">n  =  <span class="number">15911581555796798614711625288508309704791837516232122410440958830726078821069050404012820896260071751380436992710638364294658173571101596931605797509712839622479368850251206419748090059752427303611760004621378226431226983665746837779056271530181865648115862947527212787824629516204832313026456390047768174765687040950636530480549014401279054346098030395100387004111574278813749630986724706263655166289586230453975953773791945408589484679371854113457758157492241225180907090235116325034822993748409011554673180494306003272836905082473475046277554085737627846557240367696214081276345071055578169299060706794192776825039</span></span><br><span class="line"><span class="keyword">assert</span>(pow(e1,ee1,n)==ce1)</span><br><span class="line"><span class="keyword">assert</span>(pow(e2+tmp,ee2,n)==ce2)</span><br><span class="line"></span><br><span class="line">e = <span class="number">46531</span></span><br><span class="line">n = <span class="number">16278524034278364842964386062476113517067911891699789991355982121084973951738324063305190630865511554888330215827724887964565979607808294168282995825864982603759381323048907814961279012375346497781046417204954101076457350988751188332353062731641153547102721113593787978587135707313755661153376485647168543680503160420091693269984008764444291289486805840439906620313162344057956594836197521501755378387944609246120662335790110901623740990451586621846212047950084207251595169141015645449217847180683357626383565631317253913942886396494396189837432429078251573229378917400841832190737518763297323901586866664595327850603</span></span><br><span class="line">c = <span class="number">14992132140996160330967307558503117255626925777426611978518339050671013041490724616892634911030918360867974894371539160853827180596100892180735770688723270765387697604426715670445270819626709364566478781273676115921657967761494619448095207169386364541164659123273236874649888236433399127407801843412677293516986398190165291102109310458304626261648346825196743539220198199366711858135271877662410355585767124059539217274691606825103355310348607611233052725805236763220343249873849646219850954945346791015858261715967952461021650307307454434510851869862964236227932964442289459508441345652423088404453536608812799355469</span></span><br><span class="line">hint=int(binascii.hexlify(hint),<span class="number">16</span>)</span><br><span class="line"><span class="keyword">assert</span>(q1p*q1q==n)</span><br><span class="line"><span class="keyword">assert</span>(q1p&lt;q1q)</span><br><span class="line"><span class="keyword">assert</span>(c==pow(hint,e,n))</span><br><span class="line"></span><br><span class="line">flag=int(binascii.hexlify(flag),<span class="number">16</span>)</span><br><span class="line">q1=q1p</span><br><span class="line">q2 =  <span class="number">114401188227479584680884046151299704656920536168767132916589182357583461053336386996123783294932566567773695426689447410311969456458574731187512974868297092638677515283584994416382872450167046416573472658841627690987228528798356894803559278308702635288537653192098514966089168123710854679638671424978221959513</span></span><br><span class="line">c1 =  <span class="number">262739975753930281690942784321252339035906196846340713237510382364557685379543498765074448825799342194332681181129770046075018122033421983227887719610112028230603166527303021036386350781414447347150383783816869784006598225583375458609586450854602862569022571672049158809874763812834044257419199631217527367046624888837755311215081173386523806086783266198390289097231168172692326653657393522561741947951887577156666663584249108899327053951891486355179939770150550995812478327735917006194574412518819299303783243886962455399783601229227718787081785391010424030509937403600351414176138124705168002288620664809270046124</span></span><br><span class="line">c2 =  <span class="number">7395591129228876649030819616685821899204832684995757724924450812977470787822266387122334722132760470911599176362617225218345404468270014548817267727669872896838106451520392806497466576907063295603746660003188440170919490157250829308173310715318925771643105064882620746171266499859049038016902162599261409050907140823352990750298239508355767238575709803167676810456559665476121149766947851911064706646506705397091626648713684511780456955453552020460909638016134124590438425738826828694773960514221910109473941451471431637903182205738738109429736425025621308300895473186381826756650667842656050416299166317372707709596</span></span><br><span class="line"><span class="keyword">assert</span>(c1==pow(flag,e1,p*q1))</span><br><span class="line"><span class="keyword">assert</span>(c2==pow(flag,e2,p*q2))</span><br></pre></td></tr></table></figure><p>(由于数组n和c中的数字较多,故使用n1-n4,c1-c4代替表示)<br>题目分析:本题思路非常明确,空行将脚本分成四个部分,我们逐个部分解决.<br>第一部分: 给出了n1-n4和c1-c4,且sum()函数返回的结果为4,我们可以得到如下同余方程组:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c1 = p^4 mod n1</span><br><span class="line">c2 = p^4 mod n2</span><br><span class="line">c3 = p^4 mod n3</span><br><span class="line">c4 = p^4 mod n4</span><br></pre></td></tr></table></figure><p>联想到使用中国剩余定理解决,我们得到大素数p.<br>第二部分: 给出了两个较小的加密指数<code>e1=42</code>,<code>e2=3</code>,联想到使用低加密指数攻击.分别使用<code>gmpy2.iroot()</code>函数进行爆破处理,可以得到e1和e2.<br>第三部分: 该加密过程没有其他的办法,只能使用yafu进行模数分解.分解结果可以看出,p,q的差距不大,所以使用了Fermat分解法.<br>第四部分: 经过前三部分的解密,我们得到了如下参数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加密指数e1,e2</span><br><span class="line">大素数p,q1,q2</span><br></pre></td></tr></table></figure><p>再加上第四部分所给的c1,c2,我们有如下rsa问题: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1 % p*q1 = flag^e1 % p*q1</span><br><span class="line">c2 % p*q2 = flag^e2 % p*q2</span><br></pre></td></tr></table></figure><p>通过观察发现e1,e2与$\phi$(p*q1),$\phi$(p*q2)不互素,属于e与$\phi$(n)不互素的情况.而且我们发现<code>gcd(e1,p*q1)=gcd(e2,p*q2)=14</code>,按照上面的推导步骤,最终得到m^2 $\equiv$ c^(2*d) (mod q1*q2).进行开方爆破,最终得到flag.<br>解密脚本如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">import</span> binascii,gmpy2</span><br><span class="line"><span class="comment"># from data import e1,e2,p,q1p,q1q,hint,flag,q2</span></span><br><span class="line"></span><br><span class="line">n =  [n1, n2, n3, n4]</span><br><span class="line">c =  [c1, c2, c3, c4]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中国剩余定理解决低加密指数广播攻击</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CRT</span><span class="params">(mi, ai)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(reduce(gmpy2.gcd,mi)==<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">assert</span> (isinstance(mi, list) <span class="keyword">and</span> isinstance(ai, list))</span><br><span class="line">    M = reduce(<span class="keyword">lambda</span> x, y: x * y, mi)</span><br><span class="line">    ai_ti_Mi = [a * (M / m) * gmpy2.invert(M / m, m) <span class="keyword">for</span> (m, a) <span class="keyword">in</span> zip(mi, ai)]</span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x + y, ai_ti_Mi) % M</span><br><span class="line"></span><br><span class="line">p=gmpy2.iroot(CRT(n, c), <span class="number">4</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"p = "</span>,p</span><br><span class="line"><span class="comment"># ====================got p</span></span><br><span class="line">ee1 = <span class="number">42</span></span><br><span class="line">ee2 = <span class="number">3</span></span><br><span class="line">ce1 =  number_ce1</span><br><span class="line">ce2 =  number_ce2</span><br><span class="line">tmp =  number_tmp1</span><br><span class="line">n  =  number_n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用gmpy2.iroot()函数直接爆破</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">200000</span>):</span><br><span class="line"><span class="keyword">if</span> gmpy2.iroot(ce1+n*i,<span class="number">42</span>)[<span class="number">1</span>]==<span class="number">1</span>:</span><br><span class="line">res=gmpy2.iroot(ce1+n*i,<span class="number">42</span>)[<span class="number">0</span>]</span><br><span class="line">e1=res</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">200000</span>):</span><br><span class="line"><span class="keyword">if</span> gmpy2.iroot(ce2+n*i,<span class="number">3</span>)[<span class="number">1</span>]==<span class="number">1</span>:</span><br><span class="line">res=gmpy2.iroot(ce2+n*i,<span class="number">3</span>)[<span class="number">0</span>]</span><br><span class="line">e2=res-tmp</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"e1 = "</span>,e1</span><br><span class="line"><span class="keyword">print</span> <span class="string">"e2 = "</span>,e2</span><br><span class="line"><span class="comment"># ====================got e1,e2</span></span><br><span class="line">e = number_e</span><br><span class="line">n = number_n</span><br><span class="line">c = number_c</span><br><span class="line"></span><br><span class="line"><span class="comment"># yafu got q1p,q1q</span></span><br><span class="line">q1p = result_q1p</span><br><span class="line">q1q = result_q1q</span><br><span class="line"><span class="keyword">if</span> q1p&gt;q1q:</span><br><span class="line">q1p,q1q=q1q,q1p</span><br><span class="line"></span><br><span class="line"><span class="comment"># below is not necessary</span></span><br><span class="line">phi=(q1p<span class="number">-1</span>)*(q1q<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">assert</span>(gmpy2.gcd(e,phi)==<span class="number">1</span>)</span><br><span class="line">d=gmpy2.invert(e,phi)</span><br><span class="line">hint=pow(c,d,n)</span><br><span class="line">hint=binascii.unhexlify(hex(hint)[<span class="number">2</span>:])</span><br><span class="line"><span class="keyword">print</span> <span class="string">"hint = "</span>,hint</span><br><span class="line"><span class="comment"># ====================got  q1p as q1</span></span><br><span class="line"><span class="comment"># flag=int(binascii.hexlify(flag),16)</span></span><br><span class="line">q1 = q1p</span><br><span class="line"><span class="keyword">print</span> <span class="string">"q1 = "</span>,q1</span><br><span class="line">q2 =  number_q2</span><br><span class="line">c1 =  number_c1</span><br><span class="line">c2 =  number_c2</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">14</span>==gmpy2.gcd(e1,(p<span class="number">-1</span>)*(q1<span class="number">-1</span>)))</span><br><span class="line"><span class="keyword">assert</span>(<span class="number">14</span>== gmpy2.gcd(e2,(p<span class="number">-1</span>)*(q2<span class="number">-1</span>)))</span><br><span class="line">e1=e1//<span class="number">14</span>;e2=e2//<span class="number">14</span></span><br><span class="line">n1=p*q1;n2=p*q2</span><br><span class="line">phi1=(p<span class="number">-1</span>)*(q1<span class="number">-1</span>);phi2=(p<span class="number">-1</span>)*(q2<span class="number">-1</span>)</span><br><span class="line">d1=gmpy2.invert(e1,phi1);d2=gmpy2.invert(e2,phi2)</span><br><span class="line">f1=pow(c1,d1,n1);f2=pow(c2,d2,n2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当模数与加密次方不互素时使用中国剩余定理合并</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GCRT</span><span class="params">(mi, ai)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> (isinstance(mi, list) <span class="keyword">and</span> isinstance(ai, list))</span><br><span class="line">    curm, cura = mi[<span class="number">0</span>], ai[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (m, a) <span class="keyword">in</span> zip(mi[<span class="number">1</span>:], ai[<span class="number">1</span>:]):</span><br><span class="line">        d = gmpy2.gcd(curm, m)</span><br><span class="line">        c = a - cura</span><br><span class="line">        <span class="keyword">assert</span> (c % d == <span class="number">0</span>)</span><br><span class="line">        K = c // d * gmpy2.invert(curm // d, m // d)</span><br><span class="line">        cura += curm * K</span><br><span class="line">        curm = curm * m // d</span><br><span class="line">        cura %= curm</span><br><span class="line">    <span class="keyword">return</span> (cura % curm, curm) </span><br><span class="line"></span><br><span class="line">f3,lcm = GCRT([n1,n2],[f1,f2])</span><br><span class="line"><span class="keyword">assert</span>(f3%n1==f1);<span class="keyword">assert</span>(f3%n2==f2);<span class="keyword">assert</span>(lcm==q1*q2*p)</span><br><span class="line">n3=q1*q2</span><br><span class="line">c3=f3%n3</span><br><span class="line">phi3=(q1<span class="number">-1</span>)*(q2<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">assert</span>(gmpy2.gcd(<span class="number">7</span>,phi3)==<span class="number">1</span>)</span><br><span class="line">d3=gmpy2.invert(<span class="number">7</span>,phi3)</span><br><span class="line">m3=pow(c3,d3,n3)</span><br><span class="line"><span class="keyword">if</span> gmpy2.iroot(m3,<span class="number">2</span>)[<span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">    flag=gmpy2.iroot(m3,<span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">    print(binascii.unhexlify(hex(flag)[<span class="number">2</span>:]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># de1ctf&#123;9b10a98b-71bb-4bdf-a6ff-f319943de21f&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;上一篇文章介绍了RSA的加解密过程及相关的数学基础以及对应的基础CTF题目,下面介绍几种针对加密过程
      
    
    </summary>
    
      <category term="Crypto_Attack" scheme="https://blank-vax.github.io/categories/Crypto-Attack/"/>
    
    
      <category term="RSA" scheme="https://blank-vax.github.io/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>Windows基础及常用命令</title>
    <link href="https://blank-vax.github.io/2020/11/09/Windows%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://blank-vax.github.io/2020/11/09/Windows基础及常用命令/</id>
    <published>2020-11-09T02:39:34.435Z</published>
    <updated>2020-09-30T16:18:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows常见目录"><a href="#Windows常见目录" class="headerlink" title="Windows常见目录"></a>Windows常见目录</h2><ul><li><p>Documents and Settings/用户</p><p>存储用户设置，包括用户文档、上网浏览信息、配置文件等数据</p></li><li><p>Windows目录</p><p>Windows安装目录，用来放置Windows程序的使用数据、设置等文件。不建议修改此目录下数据，易造成Windows系统使用异常</p></li><li><p>Program File</p><p>应用程序文件夹，一般软件默认安装位置。当然此处也包含系统自带的应用程序。Windows10系统中，64位用户多出一个Program Files(x86)文件夹，用作系统中32位软件的安装目录</p></li><li><p>Temp目录 临时文件目录</p><p>文件路径：C:\Users\user\AppData\Local\Temp</p><p>上面存在许多垃圾文件，包括使用压缩软件等解压的临时文件。此目录也是病毒检测过程中快速扫描的位置。</p></li></ul><h2 id="Windows注册表"><a href="#Windows注册表" class="headerlink" title="Windows注册表"></a>Windows注册表</h2><p>注册表是Windows操作系统中的一个核心数据库，其中存放各种参数，直接控制Windows的启动、硬件驱动程序的装装载以及一些Windows应用程序的运行。</p><p>恶意病毒通常通过修改注册表的键<strong>HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\Main Start Page</strong>项对应的URL值来修改IE起始页面。</p><h2 id="系统启动项"><a href="#系统启动项" class="headerlink" title="系统启动项"></a>系统启动项</h2><p>开机时系统会在前台或后台自动运行的程序。查看方式为msconfig命令。</p><p>将文件、程序等放入位于<strong>C:\Users\user\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</strong>的启动文件夹中即可实现开机自启动。</p><h2 id="设备管理器"><a href="#设备管理器" class="headerlink" title="设备管理器"></a>设备管理器</h2><p>设备管理器常被用来查看和更改设备属性、更新设备驱动程序、配置设备设置和卸载设备。所有设备通过<strong>设备驱动程序</strong>与Windows进行通信。</p><ul><li>超融合迁移（虚拟机网卡网络适配器）</li><li>云桌面外设（USB白名单）</li></ul><p>使用设备管理器可以安装和更新硬件设备的驱动程序、修改这些设备的硬件设置以及通过查看硬件设备状态信息来排查问题。</p><h2 id="任务管理器"><a href="#任务管理器" class="headerlink" title="任务管理器"></a>任务管理器</h2><p>Windows任务管理器提供了有关计算机性能的信息，并显示了计算机上所运行的程序和进程的详细信息（哪个用户创建了哪个进程或程序，该进程或程序占用了多少CPU及其他系统资源）。</p><ul><li>应用程序</li><li>进程（*32代表32位系统进程）</li><li>服务</li><li>性能（详细Windows系统资源占用情况）</li><li>联网（网卡流量）</li><li>用户（当前运行的用户名）</li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是正在运行的程序实例。每个进程存在属于自己的地址空间，一般包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储<strong>处理器执行的代码</strong>；数据区域存储<strong>变量和进程执行期间使用的动态分配的内存</strong>；堆栈区域存储<strong>活动过程调用的指令和本地变量</strong>。</p><ul><li>虚拟机出现CPU、内存异常偏高时，可以通过任务管理器查看进程的资源利用率</li><li>病毒常伪装成<strong>svchost.exe</strong>，<strong>explorer.exe</strong>和<strong>rundll32.exe</strong>等系统进程，当发现这些进程CPU及内存资源占用异常时，需要重点查杀</li></ul><h2 id="组策略"><a href="#组策略" class="headerlink" title="组策略"></a>组策略</h2><p>组策略在部分意义上可控制用户可以或无法在计算机上执行什么操作，提供了操作系统、应用程序和活动目录中用户设置的集中化管理和配置。在运行模式下输入<strong>gpedit.msc</strong>可以打开组策略配置。</p><h3 id="刷新时间"><a href="#刷新时间" class="headerlink" title="刷新时间"></a>刷新时间</h3><p>默认情况下，Mircosoft Windows每90分钟刷新一次组策略，随机偏移为30分钟。在域控制器上，Microsoft Windows每隔5分钟刷新一次。</p><h3 id="处理顺序"><a href="#处理顺序" class="headerlink" title="处理顺序"></a>处理顺序</h3><ul><li>本地——任何在本地计算机的设置。在Windows Vista和之后的Windows版本中，允许每个用户账户分别拥有组策略</li><li>站点——任何与计算机所在的活动目录站点关联的组策略。活动目录站点旨在管理促进物理上接近的计算机的一种逻辑分组。如果多个策略链接到一个站点，将按照管理员设置的顺序处理</li><li>域——任何与计算机所在Windows域关联的组策略。如果多个策略链接到一个域，将按照管理员设置的顺序处理</li><li>组织单元——任何与计算机或用户所在的活动目录组织单元（OU）关联的组策略。OU是帮助组织和管理一组用户、计算机或其他活动目录对象的逻辑单元。如果多个策略链接到一个OU，将按照管理员设置的顺序处理</li></ul><h2 id="安全组"><a href="#安全组" class="headerlink" title="安全组"></a>安全组</h2><p>可以列出用于定义资源和对象权限的任意访问控制列表（DACL）中的组。Windows安全组策略其实是组策略中关于安全设置的部分，囊括了账户安全策略、Windows防火墙配置等配置目录。</p><p>在运行任务栏输入<strong>secpol.msc</strong>，修改安全组相关配置之后，需要重新登录Windows用户方可生效。</p><h2 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h2><p>工作组就是将不同的电脑按功能分别列入不同的组中，以方便管理。</p><p>Windows 9x/NT/2000引入工作组概念后，若要访问某个系列的资源，需要在网上邻居内找到对应的工作组名，即可找到该系列资源。</p><h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2><p>工作组中一切设置在本机上进行，包括各种策略、用户登录等过程，对应密码也存放在本机数据库中进行验证。</p><p>域作为工作组的升级版，计算机的各种策略通过域控制器统一设定，用户名和密码的验证过程也在域控制器中完成。因此，用户信息可以实现在域中电脑上的漫游。</p><h3 id="域控制器"><a href="#域控制器" class="headerlink" title="域控制器"></a>域控制器</h3><p>在域模式下，至少有一台服务器负责每台联入网络的电脑和用户的验证工作，被称为<strong>域控制器（Domain Controller，DC）</strong>。域控制器包含由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。</p><h2 id="安全日志"><a href="#安全日志" class="headerlink" title="安全日志"></a>安全日志</h2><p>Windows用户所有的登录注销、安全策略更改都会以安全日志的形式记录。</p><p>日志位置：计算机管理—&gt;系统工具—&gt;事件查看器—&gt;Windows日志—&gt;安全</p><ul><li>溯源黑客入侵行为</li><li>通过事件ID快速检索日志</li></ul><h2 id="常用网络排查命令"><a href="#常用网络排查命令" class="headerlink" title="常用网络排查命令"></a>常用网络排查命令</h2><h3 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h3><p>通过发送Internet控制消息协议（ICMP）验证与其他TCP/IP计算机的IP级连接回显请求消息。显示相应的回音回复信息的接受以及往返时间。该命令可用于解决连接、可访问性和名称解析等问题。</p><h4 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><code>Ping IP/域名 -t</code>：长时间执行Ping命令，以推断连接健壮性</li><li><code>Ping IP/域名 -n number</code>： 指定发送数据包的数量</li><li><code>Ping IP/域名 -l length</code>： 指定发送数据包的长度（默认长度为32Bytes）</li></ul><p>一般使用<code>Ping IP/域名 -l big-number -n big-number</code>探测连接稳定性，其中big-number为大于1000的数字，需要多次尝试以找到合适的数据包长度。</p><h4 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h4><ul><li>找不到主机：排查DNS是否正确解析指定域名</li><li>请求超时：目标地址禁止Ping/目标地址不存在</li><li>传输失败：主机网络存在问题</li></ul><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>显示和修改地址解析协议缓存中的条目，其中包含一个或多个用于存储IP地址及其解析结果的以太网或令牌环物理地址的表。计算机上安装的每个以太网或令牌环网络适配器都存在单独的表。</p><h4 id="常用选项-1"><a href="#常用选项-1" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><code>Arp -a</code>：显示所有的地址信息及接口信息</li><li><code>Arp -s ip_addr mac_addr</code>：静态配置ARP地址表项</li><li><code>Arp -d</code>：用于删除当前ARP信息</li></ul><h3 id="Tracert"><a href="#Tracert" class="headerlink" title="Tracert"></a>Tracert</h3><p>确定通过发送Internet控制消息协议（ICMP）回显请求或以递增的生存时间（TTL）字段值向目标发送消息。路径显示源主机和目标之间路径中路由器的近/侧路由器接口列表。无参数使用。</p><h4 id="常用选项-2"><a href="#常用选项-2" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><p><code>Tracert -d</code>：不将地址解析成主机名</p></li><li><p><code>Tracert -h maximum_hops</code>：搜索目标的最大跃点数</p></li></ul><h3 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h3><p>显示并修改本地IP路由表中的输入。无参数使用。需要<strong>以管理员身份打开</strong>以进行相关配置。常用命令结构：<code>Route command ip_addr mask mask_number gateway_addr</code>。</p><h4 id="常用选项-3"><a href="#常用选项-3" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><p>command</p><ul><li><code>Route PRINT</code>：打印路由表</li><li><code>Route ADD</code>：添加静态路由（临时，重启后消失）</li><li><code>Route DELETE</code>：删除路由信息</li><li><code>Route CHANGE</code>：修改现有路由的网关和跃点数</li></ul></li><li><p><code>Route -p</code>：使得对路由表的添加操作永久生效</p></li></ul><h3 id="Ipconfig"><a href="#Ipconfig" class="headerlink" title="Ipconfig"></a>Ipconfig</h3><p>显示所有当前TCP/IP网络配置值，并刷新动态主机配置协议（DHCP）和域名系统（DNS）设置。无参数使用时，为所有适配器显示Internet协议版本4和IPv6地址、子网掩码和默认网关。</p><h4 id="常用选项-4"><a href="#常用选项-4" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><code>Ipconfig /all</code>：显示所有网络适配器的所有信息</li><li><code>Ipconfig /release</code>：释放当前所有网卡的DHCP信息</li><li><code>Ipconfig /renew</code>：释放当前网卡的所有DHCP信息并重新获取</li><li><code>Ipconfig /displaydns</code>：展示当前DNS缓存信息</li><li><code>Ipconfig /flushdns</code>：清理当前DNS缓存信息</li></ul><h3 id="Netstat"><a href="#Netstat" class="headerlink" title="Netstat"></a>Netstat</h3><p>显示有源TCP连接，计算机在哪个端口被侦听，以太网统计，IP路由表，IPv4统计和IPv6统计。无参数使用时，网络显示激活TCP连接。</p><h4 id="常用选项-5"><a href="#常用选项-5" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><code>Netstat -a</code>：展示当前监听的所有网口信息</li><li><code>Netstat -n</code>：展示所有TCP&amp;UDP连接信息及端口详细信息</li><li><code>Netstat -o</code>：展示当前连接的PID</li><li><code>Netstat -p</code>：指定当前监听协议</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Windows常见目录&quot;&gt;&lt;a href=&quot;#Windows常见目录&quot; class=&quot;headerlink&quot; title=&quot;Windows常见目录&quot;&gt;&lt;/a&gt;Windows常见目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Documents and Settings/用户
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Windows Foundation" scheme="https://blank-vax.github.io/tags/Windows-Foundation/"/>
    
  </entry>
  
  <entry>
    <title>WhaleCTF 密码学wp</title>
    <link href="https://blank-vax.github.io/2020/11/09/WhaleCTF%20crypto/"/>
    <id>https://blank-vax.github.io/2020/11/09/WhaleCTF crypto/</id>
    <published>2020-11-09T02:39:34.435Z</published>
    <updated>2020-06-26T03:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>这段时间把whaleCTF的密码学部分进行了收尾,完成了部分题目,仍剩下一题亟待解决.</p><h2 id="0x01-解题记录"><a href="#0x01-解题记录" class="headerlink" title="0x01 解题记录"></a>0x01 解题记录</h2><h3 id="Death-Chain-100"><a href="#Death-Chain-100" class="headerlink" title="Death_Chain 100"></a>Death_Chain 100</h3><p>题目: 某天,夏多抛出了一张纸条.满是圆圈的纸条应该有所隐藏信息,你能够发现吗?<br>答案格式: flag{xxxx},xxx是所有的解密内容,大写  </p><p>知识点: 夏多密码</p><p>解题记录: 根据提示搜索“夏多密码”,可以得到如图所示的密码表.  </p><p><img src="http://static.zybuluo.com/B1ank/ap9i0s0t8wmlh65pxoshx7ga/Death_Chain.png" alt="Death_Chain.png-28.2kB"></p><p>把所给的密文与密码表进行对照,可以得到flag.  </p><h3 id="先有什么-100"><a href="#先有什么-100" class="headerlink" title="先有什么 100"></a>先有什么 100</h3><p>题目: 这是个值得思考的问题,到底先有什么——UFO?麦田怪圈?答案格式: key{flag},flag是解密内容.</p><p>知识点: 键盘密码</p><p>解题记录: 键盘密码,将所给的字母在键盘上连起来,找到每一部分中间所包围的字母即可.</p><h3 id="检查符号-100"><a href="#检查符号-100" class="headerlink" title="检查符号 100"></a>检查符号 100</h3><p>题目: 截取一段电波，一不小心全变成了泡泡.你能够解密吗? “o00。o。o0oo。0o0o。000。00。o。0。000。ooo0。o。0o。oo0。ooo。0o0o。0。oo0o” 答案格式: key{flag},flag是解密内容.</p><p>知识点: 摩斯电码</p><p>解题记录: 打开txt文件发现有数字0,句号和字母o构成,猜想是摩斯电码.写一个脚本解密.  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mouse</span><span class="params">(a)</span>:</span></span><br><span class="line">    result = <span class="string">''</span></span><br><span class="line">    dict = &#123;<span class="string">'.-'</span>:<span class="string">'A'</span>,</span><br><span class="line">            <span class="string">'-...'</span>:<span class="string">'B'</span>,</span><br><span class="line">            <span class="string">'-.-.'</span>:<span class="string">'C'</span>,</span><br><span class="line">            <span class="string">'-..'</span>:<span class="string">'D'</span>,</span><br><span class="line">            <span class="string">'.'</span>:<span class="string">'E'</span>,</span><br><span class="line">            <span class="string">'..-.'</span>:<span class="string">'F'</span>,</span><br><span class="line">            <span class="string">'--.'</span>:<span class="string">'G'</span>,</span><br><span class="line">            <span class="string">'....'</span>:<span class="string">'H'</span>,</span><br><span class="line">            <span class="string">'..'</span>:<span class="string">'I'</span>,</span><br><span class="line">            <span class="string">'.---'</span>:<span class="string">'J'</span>,</span><br><span class="line">            <span class="string">'-.-'</span>:<span class="string">'K'</span>,</span><br><span class="line">            <span class="string">'.-..'</span>:<span class="string">'L'</span>,</span><br><span class="line">            <span class="string">'--'</span>:<span class="string">'M'</span>,</span><br><span class="line">            <span class="string">'-.'</span>:<span class="string">'N'</span>,</span><br><span class="line">            <span class="string">'---'</span>:<span class="string">'O'</span>,</span><br><span class="line">            <span class="string">'.--.'</span>:<span class="string">'P'</span>,</span><br><span class="line">            <span class="string">'--.-'</span>:<span class="string">'Q'</span>,</span><br><span class="line">            <span class="string">'.-.'</span>:<span class="string">'R'</span>,</span><br><span class="line">            <span class="string">'...'</span>:<span class="string">'S'</span>,</span><br><span class="line">            <span class="string">'-'</span>:<span class="string">'T'</span>,</span><br><span class="line">            <span class="string">'..-'</span>:<span class="string">'U'</span>,</span><br><span class="line">            <span class="string">'...-'</span>:<span class="string">'V'</span>,</span><br><span class="line">            <span class="string">'.--'</span>:<span class="string">'W'</span>,</span><br><span class="line">            <span class="string">'-..-'</span>:<span class="string">'X'</span>,</span><br><span class="line">            <span class="string">'-.--'</span>:<span class="string">'Y'</span>,</span><br><span class="line">            <span class="string">'--..'</span>:<span class="string">'Z'</span>,</span><br><span class="line">            <span class="string">'-----'</span>:<span class="string">'0'</span>,</span><br><span class="line">            <span class="string">'.----'</span>:<span class="string">'1'</span>,</span><br><span class="line">            <span class="string">'..---'</span>:<span class="string">'2'</span>,</span><br><span class="line">            <span class="string">'...--'</span>:<span class="string">'3'</span>,</span><br><span class="line">            <span class="string">'....-'</span>:<span class="string">'4'</span>,</span><br><span class="line">            <span class="string">'.....'</span>:<span class="string">'5'</span>,</span><br><span class="line">            <span class="string">'-....'</span>:<span class="string">'6'</span>,</span><br><span class="line">            <span class="string">'--...'</span>:<span class="string">'7'</span>,</span><br><span class="line">            <span class="string">'---..'</span>:<span class="string">'8'</span>,</span><br><span class="line">            <span class="string">'----.'</span>:<span class="string">'9'</span>,</span><br><span class="line">            <span class="string">'.-.-.-'</span>:<span class="string">'.'</span>,</span><br><span class="line">            <span class="string">'---...'</span>:<span class="string">':'</span>,</span><br><span class="line">            <span class="string">'--..--'</span>:<span class="string">','</span>,</span><br><span class="line">            <span class="string">'-.-.-.'</span>:<span class="string">';'</span>,</span><br><span class="line">            <span class="string">'..--..'</span>:<span class="string">'?'</span>,</span><br><span class="line">            <span class="string">'-...-'</span>:<span class="string">'='</span>,</span><br><span class="line">            <span class="string">'.----.'</span>:<span class="string">'\''</span>,</span><br><span class="line">            <span class="string">'-..-.'</span>:<span class="string">'/'</span>,</span><br><span class="line">            <span class="string">'-.-.--'</span>:<span class="string">'!'</span>,</span><br><span class="line">            <span class="string">'-....-'</span>:<span class="string">'-'</span>,</span><br><span class="line">            <span class="string">'..--.-'</span>:<span class="string">'_'</span>,</span><br><span class="line">            <span class="string">'.-..-.'</span>:<span class="string">'"'</span>,</span><br><span class="line">            <span class="string">'-.--.'</span>:<span class="string">'('</span>,</span><br><span class="line">            <span class="string">'-.--.-'</span>:<span class="string">')'</span>,</span><br><span class="line">            <span class="string">'...-..-'</span>:<span class="string">'$'</span>,</span><br><span class="line">            <span class="string">'....'</span>:<span class="string">'&amp;'</span>,</span><br><span class="line">            <span class="string">'.--.-.'</span>:<span class="string">'@'</span></span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> a:</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">in</span> dict:</span><br><span class="line">            result += dict[item]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#重点使用replce()方法和split()方法,前者用于替换字符串中的字符,后者用于切割字符串</span></span><br><span class="line">    str1 = <span class="string">'o00。o。o0oo。0o0o。000。00。o。0。000。ooo0。o。0o。oo0。ooo。0o0o。0。oo0o'</span></span><br><span class="line">    str2 = str1.replace(<span class="string">'。'</span>,<span class="string">' '</span>)</span><br><span class="line">    str3 = str2.replace(<span class="string">'o'</span>,<span class="string">'.'</span>)</span><br><span class="line">    str4 = str3.replace(<span class="string">'0'</span>,<span class="string">'-'</span>)</span><br><span class="line">    L1 = str4.split(<span class="string">' '</span>)</span><br><span class="line">    result_1 = mouse(L1)</span><br><span class="line">    <span class="keyword">if</span> result_1 == <span class="literal">None</span>:</span><br><span class="line">        str3 = str2.replace(<span class="string">'o'</span>,<span class="string">'-'</span>)</span><br><span class="line">        str4 = str3.replace(<span class="string">'0'</span>,<span class="string">'.'</span>)</span><br><span class="line">        L2 = str4.split(<span class="string">' '</span>)</span><br><span class="line">        result_2 = mouse(L2)</span><br><span class="line">        <span class="keyword">print</span> result_2</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> result_1</span><br></pre></td></tr></table></figure><h3 id="德军密码-100"><a href="#德军密码-100" class="headerlink" title="德军密码 100"></a>德军密码 100</h3><p>题目: 二战时盟军截获德军一段密码,密文为: 000001100000000010101011011100101<br>1000101100000111001100100111100111001(密钥: helloworld),你可能会解出一个keyxxxxx的答案,请在y后面加{,结尾加},答案的格式是key{xxxxx},所以答案是</p><p>知识点: 费纳姆密码</p><p>解题记录: 打开题目后发现key以及一长串二进制数字,结合所给提示德军密码,可知是费纳姆编码,写个脚本跑一下.  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">transform1 = &#123;<span class="string">'1000001'</span>:<span class="string">'A'</span>,<span class="string">'1000010'</span>:<span class="string">'B'</span>,</span><br><span class="line">                   <span class="string">'1000011'</span>:<span class="string">'C'</span>,<span class="string">'1000100'</span>:<span class="string">'D'</span>,</span><br><span class="line">                   <span class="string">'1000101'</span>:<span class="string">'E'</span>,<span class="string">'1000110'</span>:<span class="string">'F'</span>,</span><br><span class="line">                   <span class="string">'1000111'</span>:<span class="string">'G'</span>,<span class="string">'1001000'</span>:<span class="string">'H'</span>,</span><br><span class="line">                   <span class="string">'1001001'</span>:<span class="string">'I'</span>,<span class="string">'1001010'</span>:<span class="string">'J'</span>,</span><br><span class="line">                   <span class="string">'1001011'</span>:<span class="string">'K'</span>,<span class="string">'1001100'</span>:<span class="string">'L'</span>,</span><br><span class="line">                   <span class="string">'1001101'</span>:<span class="string">'M'</span>,<span class="string">'1001110'</span>:<span class="string">'N'</span>,</span><br><span class="line">                   <span class="string">'1001111'</span>:<span class="string">'O'</span>,<span class="string">'1010000'</span>:<span class="string">'P'</span>,</span><br><span class="line">                   <span class="string">'1010001'</span>:<span class="string">'Q'</span>,<span class="string">'1010010'</span>:<span class="string">'R'</span>,</span><br><span class="line">                   <span class="string">'1010011'</span>:<span class="string">'S'</span>,<span class="string">'1010100'</span>:<span class="string">'T'</span>,</span><br><span class="line">                   <span class="string">'1010101'</span>:<span class="string">'U'</span>,<span class="string">'1010110'</span>:<span class="string">'V'</span>,</span><br><span class="line">                   <span class="string">'1010111'</span>:<span class="string">'W'</span>,<span class="string">'1011000'</span>:<span class="string">'X'</span>,</span><br><span class="line">                   <span class="string">'1011001'</span>:<span class="string">'Y'</span>,<span class="string">'1011010'</span>:<span class="string">'Z'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#反转字典,方便将key进行编码</span></span><br><span class="line">transform2 = &#123;value:key <span class="keyword">for</span> key,value <span class="keyword">in</span> transform1.items()&#125;</span><br><span class="line"></span><br><span class="line">cipher = <span class="string">'0000011000000000101010110111001011000101100000111001100100111100111001'</span></span><br><span class="line"></span><br><span class="line">key = <span class="string">'helloworld'</span></span><br><span class="line"><span class="comment">#将字母转换成01字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trans1</span><span class="params">(key)</span>:</span></span><br><span class="line">    list2 = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> key.upper():</span><br><span class="line">        list2.append(transform2[item])</span><br><span class="line">    <span class="keyword">return</span> list2</span><br><span class="line"><span class="comment">#将01字符串分割</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trans2</span><span class="params">(cipher)</span>:</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    plain = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        result.append(cipher[num:num+<span class="number">7</span>])</span><br><span class="line">        num += <span class="number">7</span></span><br><span class="line">        <span class="keyword">if</span>(num &gt; len(cipher)<span class="number">-7</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="comment">#自定义异或操作</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">XOR</span><span class="params">(text,keynew)</span>:</span></span><br><span class="line">    result = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(text)):</span><br><span class="line">        <span class="keyword">if</span> text[i] == keynew[i]:</span><br><span class="line">            result += <span class="string">'0'</span></span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            result += <span class="string">'1'</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    key1 = trans1(key)</span><br><span class="line">    cipher1 = trans2(cipher)</span><br><span class="line">    key2 = <span class="string">''</span>.join(key1)</span><br><span class="line">    cipher2 = <span class="string">''</span>.join(cipher1)</span><br><span class="line">    result = XOR(key2,cipher2)</span><br><span class="line">    result1 = trans2(result)</span><br><span class="line">    result2 =<span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> result1:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> transform1:</span><br><span class="line">            result2 += <span class="string">' '</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result2 += transform1[i]</span><br><span class="line">    <span class="keyword">print</span> result2</span><br></pre></td></tr></table></figure><p>这里介绍几个知识点:  </p><ul><li>构建字母转换成二进制的字典的时候,不需要重新构建,只需要将原来字典的key和value互换位置. </li></ul><p><code>transform2 = {value:key for key,value in transform1.items()}</code></p><ul><li><p>01字符串分组处理时,可以使用索引加7的方法进行处理.</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trans2</span><span class="params">(cipher)</span>:</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">result = []</span><br><span class="line">plain = <span class="string">''</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    result.append(cipher[num:num+<span class="number">7</span>])</span><br><span class="line">    num += <span class="number">7</span></span><br><span class="line">    <span class="keyword">if</span>(num &gt; len(cipher)<span class="number">-7</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></li></ul><p>注意最后得到的数组中有字典中没有的key,我们使用空格来进行代替,最后将空格手动替换成花括号即可.</p><h3 id="密钥生成-100"><a href="#密钥生成-100" class="headerlink" title="密钥生成 100"></a>密钥生成 100</h3><p>题目: 在一次RSA密钥对生成中,假设p=473398607161,q=4511491,e=17求解出d,格式: key{xxxx}</p><p>知识点: rsa中d的生成</p><p>解题记录: 已知p,q,e,使用模反求d的方法求出来d即可.  </p><h3 id="规则很公平-150"><a href="#规则很公平-150" class="headerlink" title="规则很公平 150"></a>规则很公平 150</h3><p>题目: vv公司称,他们给出了最为公平的游戏规则,你能猜到是什么吗?规则: CGOCPMOFEBMLUNISEOZY,附件: CULTREABDFGHIKMNOPQSVWXYZ. 答案的格式是key{xxxxx},所以答案是.</p><p>知识点: 波雷菲尔密码</p><p>解题记录: 由“公平”联想到英文“fair”,从而联想到playfair密码.我们使用造好的轮子即pycipher库中的Playfair函数来进行操作.  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pycipher <span class="keyword">import</span> Playfair</span><br><span class="line">Playfair(<span class="string">'CULTREABDFGHIKMNOPQSVWXYZ'</span>).decipher(<span class="string">'CGOCPMOFEBMLUNISEOZY'</span>)</span><br></pre></td></tr></table></figure><p>将得到的结果进行适当删减即可获得flag.</p><h3 id="数学小问题-150"><a href="#数学小问题-150" class="headerlink" title="数学小问题 150"></a>数学小问题 150</h3><p>题目: 小小的数学问题,你能搞定吗?SElWTVVSQ1FXUUlXVUhFVg, 答案的格式是key{xxxxx},所以答案是</p><p>知识点: base64+仿射密码</p><p>解题记录: 首先根据图片提示得知为仿射密码,先写了一个脚本,但跑出来发现结果没有有意义的明文,便卡了一段时间.<br>后来仔细观察密文,发现类似base64的形式,遂在其后加上==进行base解密,将得到的密文再跑仿射脚本,可以得到有意义的结果.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">cipher = <span class="string">'SElWTVVSQ1FXUUlXVUhFVg=='</span></span><br><span class="line">plain1 = base64.b64decode(cipher)</span><br><span class="line"></span><br><span class="line"><span class="comment">#只有a与26互素,a模26的逆元才存在,才可以进行解密</span></span><br><span class="line">dict = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">25</span>]</span><br><span class="line"></span><br><span class="line">plain2 = plain1.lower()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> dict:</span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">plain3 = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> plain2:</span><br><span class="line">    plain3 += chr((a*(ord(item)<span class="number">-97</span>)+b)%<span class="number">26</span>+<span class="number">97</span>)</span><br><span class="line"><span class="keyword">print</span> plain3</span><br></pre></td></tr></table></figure><h3 id="此处应写-150"><a href="#此处应写-150" class="headerlink" title="此处应写 150"></a>此处应写 150</h3><p>记录一下该问题的复杂版,即CTF-30days的填空题.  </p><p>题目: 拿到一个填空题,到底该填什么?答案的格式是key{xxxxx},所以答案是  </p><p>知识点: utf-9编码+字符匹配<br>该题目下载得到的文件名为: flag is here rfc4042,无法通过文本编辑等打开.百度查找rfc4042,发现该文件可能使用了<strong>utf-9编码</strong>.</p><p>解题记录: 写一个脚本进行译码.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> utf9</span><br><span class="line">f = open(<span class="string">'flag_is_here_rfc4042'</span>,<span class="string">'rb'</span>)</span><br><span class="line">result = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    result += line</span><br><span class="line"><span class="keyword">print</span> utf9.utf9decode(result)</span><br></pre></td></tr></table></figure><p>将得到的结果中的下划线数量转换成数字,其他符号不变.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cipher = <span class="string">'_____*((__//__+___+______-____%____)**((___%(___-_))+________+(___%___+_____+_______%__+______-(______//(_____%___)))))+__*(((________/__)+___%__+_______-(________//____))**(_*(_____+_____)+_______+_________%___))+________*(((_________//__+________%__)+(_______-_))**((___+_______)+_________-(______//__)))+_______*((___+_________-(______//___-_______%__%_))**(_____+_____+_____))+__*(__+_________-(___//___-_________%_____%__))**(_________-____+_______)+(___+_______)**(________%___%__+_____+______)+(_____-__)*((____//____-_____%____%_)+_________)**(_____-(_______//_______+_________%___)+______)+(_____+(_________%_______)*__+_)**_________+_______*(((_________%_______)*__+_______-(________//________))**_______)+(________/__)*(((____-_+_______)*(______+____))**___)+___*((__+_________-_)**_____)+___*(((___+_______-______/___+__-_________%_____%__)*(___-_+________/__+_________%_____))**__)+(_//_)*(((________%___%__+_____+_____)%______)+_______-_)**___+_____*((______/(_____%___))+_______)*((_________%_______)*__+_____+_)+___//___+_________+_________/___'</span></span><br><span class="line"></span><br><span class="line">m = cipher[<span class="number">0</span>]</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">plain = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> cipher:</span><br><span class="line"><span class="keyword">if</span> i <span class="keyword">is</span> m:</span><br><span class="line">    count += <span class="number">1</span> <span class="comment">#将短线化成数字1并加到count变量</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> count != <span class="number">0</span>:</span><br><span class="line">        plain += str(count) <span class="comment">#当碰到运算符号的时候,先将前面累计的count化成数字</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        plain += i    <span class="comment">#再将运算符号放入算式</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        plain += i  <span class="comment">#前面没有累计的count,直接将运算符号放入算式</span></span><br><span class="line"><span class="keyword">if</span> count != <span class="number">0</span>:</span><br><span class="line">plain += str(count)   <span class="comment">#将表达式最后的短线代表的数字放入算式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> plain</span><br><span class="line">result = eval(plain)</span><br><span class="line"><span class="keyword">print</span> result</span><br></pre></td></tr></table></figure><p>将运算后的结果转换成十六进制然后两个一组转换成字符即可.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="number">5287002131074331513</span></span><br><span class="line">cipher = hex(key)[<span class="number">2</span>:]</span><br><span class="line">plain = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher) / <span class="number">2</span>):</span><br><span class="line">plain += chr(int(cipher[i * <span class="number">2</span> : i * <span class="number">2</span> + <span class="number">2</span>], <span class="number">16</span>))</span><br><span class="line"><span class="keyword">print</span> plain</span><br></pre></td></tr></table></figure><h3 id="栅栏加密-150"><a href="#栅栏加密-150" class="headerlink" title="栅栏加密 150"></a>栅栏加密 150</h3><p>题目: 我家篱笆旁的栅栏被捣乱了!第一根和第二根都被换了位置…只有第三根还能站在那,缺也短了一截了.变成了这样: udJZml2VYVuWkdxXXs2Ne1DV5V9XEs2ZdZ7WlSNbVrm9eNDSlaFXG91F谁能帮我修好呢?flag格式: venusCTF{xxx}</p><p>知识点: 栅栏密码</p><p>解题记录: 按照要求写出来即可.  </p><p><img src="http://static.zybuluo.com/B1ank/qbp51pdtm0p9gi7eonwhnwie/%E6%A0%85%E6%A0%8F%E5%8A%A0%E5%AF%86.png" alt="栅栏加密.png-78.4kB"></p><h3 id="小明入侵-150"><a href="#小明入侵-150" class="headerlink" title="小明入侵 150"></a>小明入侵 150</h3><p>题目: 小明入侵网站后获得了管理员的密文,由于太高兴了手一抖把密文删除了一部分,只剩下前10位a74be8e20b,小明根据社工知道管理员的密码习惯是key{4位的数字或字母},所以管理员的密码是.  </p><p>知识点: md5解密</p><p>解题记录: 查找可知一般的网站管理员的登录密文是经过md5和sha1加密,因为只有四位,故可以使用脚本进行解题.注意构造的字典需要包含大小写字母和数字.  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">dict = [<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>,<span class="string">'j'</span>,<span class="string">'k'</span>,<span class="string">'l'</span>,<span class="string">'m'</span>,<span class="string">'n'</span>,<span class="string">'o'</span>,<span class="string">'p'</span>,<span class="string">'q'</span>,<span class="string">'r'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>,<span class="string">'u'</span>,<span class="string">'v'</span>,<span class="string">'w'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>,<span class="string">'G'</span>,<span class="string">'H'</span>,<span class="string">'I'</span>,<span class="string">'J'</span>,<span class="string">'K'</span>,<span class="string">'L'</span>,<span class="string">'M'</span>,<span class="string">'N'</span>,<span class="string">'O'</span>,<span class="string">'P'</span>,<span class="string">'Q'</span>,<span class="string">'R'</span>,<span class="string">'S'</span>,<span class="string">'T'</span>,<span class="string">'U'</span>,<span class="string">'V'</span>,<span class="string">'W'</span>,<span class="string">'X'</span>,<span class="string">'Y'</span>,<span class="string">'Z'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span><span class="params">(a)</span>:</span></span><br><span class="line">t = hashlib.md5()</span><br><span class="line">t.update(str(a).encode(<span class="string">'ascii'</span>))</span><br><span class="line">encodestr = t.hexdigest()</span><br><span class="line"><span class="keyword">return</span> encodestr</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">a=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dict:</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> dict:</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> dict:</span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> dict:</span><br><span class="line">a = <span class="string">'key&#123;'</span>+ str(i)+str(j)+str(k)+str(l)+<span class="string">'&#125;'</span></span><br><span class="line">result = cal(str(a))</span><br><span class="line"><span class="keyword">if</span> result[<span class="number">0</span>:<span class="number">10</span>] == <span class="string">'a74be8e20b'</span>:</span><br><span class="line">    <span class="keyword">print</span> a</span><br><span class="line">    <span class="keyword">print</span> result</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="RSA破解-200"><a href="#RSA破解-200" class="headerlink" title="RSA破解 200"></a>RSA破解 200</h3><p>题目: 得到了公钥，怎么才能解密呢?<br>tip分解n,答案格式ISG{flag}  </p><p>知识点: openssl的使用,n的分解</p><p>解题记录: 打开解压后的文件,发现证书和加密后的文件.使用openssl提取n.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -pubin -text -modulus -in warmup -in pem证书的路径</span><br></pre></td></tr></table></figure><p>得到下图所示的n. </p><p><img src="http://static.zybuluo.com/B1ank/1jcajtj60snn7llydbt2rm1t/rsa1.png" alt="rsa1.png-114.4kB"></p><p>得到的n显然是十六进制,所以将其转换成十进制,尽量不要使用在线进制转换.随后使用在线网站(<a href="http://factordb.com" target="_blank" rel="noopener">在线大数分解</a>)进行解密,得到p和q,然后使用rsatool.py脚本及openssl配合(同一目录)得到flag.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python rsatool.py -o private.pem -e e的值 -p p的值 -q q的值</span><br></pre></td></tr></table></figure><p>得到私钥之后使用openssl进行解密.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsautl -decrypt -in flag.enc -inkey private.pem -out flag.txt</span><br></pre></td></tr></table></figure><h3 id="RSA分解-200"><a href="#RSA分解-200" class="headerlink" title="RSA分解 200"></a>RSA分解 200</h3><p>题目: 某安全公司通过网络监听截取了某间谍连续发送的一段明文和公钥，你能够解密传输内容吗？</p><p>知识点: rsa已知密文和公钥进行解密</p><p>解题记录: 已知n和e公钥对,首先将n进行分解,再求出来d,使用解密脚本解密即可.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="number">18443</span></span><br><span class="line">q = <span class="number">49891</span></span><br><span class="line">e = <span class="number">19</span></span><br><span class="line">d = <span class="number">96849619</span></span><br><span class="line">n = <span class="number">920139713</span></span><br><span class="line">m =[</span><br><span class="line"><span class="number">704796792</span>,</span><br><span class="line"><span class="number">752211152</span>,</span><br><span class="line"><span class="number">274704164</span>,</span><br><span class="line"><span class="number">18414022</span>,</span><br><span class="line"><span class="number">368270835</span>,</span><br><span class="line"><span class="number">483295235</span>,</span><br><span class="line"><span class="number">263072905</span>,</span><br><span class="line"><span class="number">459788476</span>,</span><br><span class="line"><span class="number">483295235</span>,</span><br><span class="line"><span class="number">459788476</span>,</span><br><span class="line"><span class="number">663551792</span>,</span><br><span class="line"><span class="number">475206804</span>,</span><br><span class="line"><span class="number">459788476</span>,</span><br><span class="line"><span class="number">428313374</span>,</span><br><span class="line"><span class="number">475206804</span>,</span><br><span class="line"><span class="number">459788476</span>,</span><br><span class="line"><span class="number">425392137</span>,</span><br><span class="line"><span class="number">704796792</span>,</span><br><span class="line"><span class="number">458265677</span>,</span><br><span class="line"><span class="number">341524652</span>,</span><br><span class="line"><span class="number">483295235</span>,</span><br><span class="line"><span class="number">534149509</span>,</span><br><span class="line"><span class="number">425392137</span>,</span><br><span class="line"><span class="number">428313374</span>,</span><br><span class="line"><span class="number">425392137</span>,</span><br><span class="line"><span class="number">341524652</span>,</span><br><span class="line"><span class="number">458265677</span>,</span><br><span class="line"><span class="number">263072905</span>,</span><br><span class="line"><span class="number">483295235</span>,</span><br><span class="line"><span class="number">828509797</span>,</span><br><span class="line"><span class="number">341524652</span>,</span><br><span class="line"><span class="number">425392137</span>,</span><br><span class="line"><span class="number">475206804</span>,</span><br><span class="line"><span class="number">428313374</span>,</span><br><span class="line"><span class="number">483295235</span>,</span><br><span class="line"><span class="number">475206804</span>,</span><br><span class="line"><span class="number">459788476</span>,</span><br><span class="line"><span class="number">306220148</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(m)):</span><br><span class="line"><span class="keyword">print</span> pow(m[i],d,n)</span><br></pre></td></tr></table></figure><p>将得到的结果进行ascii转码,得到字符串.</p><h3 id="只有密文-200"><a href="#只有密文-200" class="headerlink" title="只有密文 200"></a>只有密文 200</h3><p>题目: 怎么办，已经截获了密文和模数n!能够破解吗?请分解出RSA中的两个大素数q和p.提交格式是key{x}x为两个素数中较小的那个的MD5前8位.   </p><p>知识点: 唯密文攻击.<br>rsa中只提供密文和n的时候,可以先求出来每一组密文和n的最大公约数,找出来非1的公约数,该数字即为p或者q,再结合n求出来p或q,即可还原整个加密过程.  </p><p>解题记录: 根据唯密文攻击的原理,编辑脚本进行计算.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="comment">#cipher为所给密文构成的数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(a,b)</span>:</span></span><br><span class="line">  tmp = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span>(tmp != <span class="number">0</span>):</span><br><span class="line">      tmp = a%b</span><br><span class="line">      a = b</span><br><span class="line">      b = tmp</span><br><span class="line">  <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hash</span><span class="params">(m)</span>:</span></span><br><span class="line">  t = hashlib.md5()</span><br><span class="line">  t.update(str(m).encode(<span class="string">'ascii'</span>))</span><br><span class="line">  result = t.hexdigest()</span><br><span class="line">  <span class="keyword">return</span> result[<span class="number">0</span>:<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  result = <span class="string">''</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher)):</span><br><span class="line">      <span class="keyword">if</span> gcd(n,cipher[i]) != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'The common divisor of n and '</span> + <span class="string">'cipher '</span> +str(i+<span class="number">1</span>) + <span class="string">' = '</span> + str(gcd(n ,cipher[i])))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">  p = gcd(n,cipher[i])</span><br><span class="line">  q = n/p</span><br><span class="line">  t = hashlib.md5()</span><br><span class="line">  <span class="keyword">if</span> p &gt; q:</span><br><span class="line">    result = hash(q)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    result = hash(p)</span><br><span class="line">  <span class="keyword">print</span> result</span><br></pre></td></tr></table></figure><h3 id="RSA专家"><a href="#RSA专家" class="headerlink" title="RSA专家"></a>RSA专家</h3><p>题目: 得到了私钥，破解还不简单吗？<br>格式: key{xxx}   </p><p>知识点: openssl的使用</p><p>解题记录: zip解压的到aaaa和endata,直接openssl解密.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsautl -decrypt -in endata -inkey aaaa -out flag.txt</span><br></pre></td></tr></table></figure><h2 id="0x03-others"><a href="#0x03-others" class="headerlink" title="0x03 others"></a>0x03 others</h2><p>whale的密码题还有一道”大家来解密”没有完成,给出了key和iv猜想是aes系列.”算法问题”的flag就在所给脚本中,没有什么价值.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;这段时间把whaleCTF的密码学部分进行了收尾,完成了部分题目,仍剩下一题亟待解决.&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="CTF_Writeup" scheme="https://blank-vax.github.io/categories/CTF-Writeup/"/>
    
    
      <category term="Crypto" scheme="https://blank-vax.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>Second Day in NTU</title>
    <link href="https://blank-vax.github.io/2020/11/09/NTU%20Day2/"/>
    <id>https://blank-vax.github.io/2020/11/09/NTU Day2/</id>
    <published>2020-11-09T02:39:34.429Z</published>
    <updated>2020-06-26T08:31:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-今日主题"><a href="#0x00-今日主题" class="headerlink" title="0x00 今日主题"></a>0x00 今日主题</h2><p><code>Translational R&amp;D for Smart Nation</code></p><h2 id="0x01-科研准备等级"><a href="#0x01-科研准备等级" class="headerlink" title="0x01 科研准备等级"></a>0x01 科研准备等级</h2><p>实验室环境-&gt;实际环境-&gt;生产生活应用-&gt;成品</p><h2 id="0x02-智慧国建设"><a href="#0x02-智慧国建设" class="headerlink" title="0x02 智慧国建设"></a>0x02 智慧国建设</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Smart Nation is a systems engineering technology that aims to disrupt and challenge traditional operations and decision-making processes.</span><br></pre></td></tr></table></figure><p>即旨在利用信息通信、大数据运算等技术来制造更多的智能公共器械,从而提高人民的生活水平.</p><h3 id="主要技术"><a href="#主要技术" class="headerlink" title="主要技术"></a>主要技术</h3><ul><li>传感器</li><li>IoT</li><li>云计算</li><li>移动技术</li><li>大数据分析</li><li>网络安全</li></ul><h3 id="技术阶段"><a href="#技术阶段" class="headerlink" title="技术阶段"></a>技术阶段</h3><ul><li>Perception<br>观察阶段.顾名思义,该过程是数据的获得过程,主要通过传感器实现.</li><li>Cognition<br>认知阶段.该阶段是对上一阶段获取的数据进行存储、计算与分析.根据不同的分析结果制定决策,为后面的执行阶段打下基础.</li><li>Action<br>执行阶段.这一阶段是服务器将作出的决策发送给物理终端,让物理终端做出相应的行动.</li><li>IoT<br>IoT技术是整个智慧国体系的核心技术.</li></ul><h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3><ul><li>智能法庭<br>将案件详情与数据库中存储的以前的情况进行对比分析,协助法官作出快速正确的决定.</li><li>流量控制<br>根据每个路口的人流量和车流量的实时监测,推算出各个交通信号灯最合适的时间,从而调整以防止堵塞.</li><li>ICRS<br>智能案件检索系统,提高检索的效率.</li><li>商业信息管理与决策制定</li></ul><h3 id="技术核心"><a href="#技术核心" class="headerlink" title="技术核心"></a>技术核心</h3><ul><li>传感器收集数据效率与真实性</li><li>网络安全</li><li>自然语言处理</li><li>智能的AI算法</li><li>决策偏差修正</li></ul><h3 id="问题与挑战"><a href="#问题与挑战" class="headerlink" title="问题与挑战"></a>问题与挑战</h3><ul><li>多数IoT设备缺少完善的安全协议</li><li>数据分析过程中算力不足</li><li>实际环境与实验室环境有差异</li><li>人工智能体系安全问题</li></ul><h2 id="0x03-一些思考"><a href="#0x03-一些思考" class="headerlink" title="0x03 一些思考"></a>0x03 一些思考</h2><ul><li>硕博士教育体制<br>master degree的时间为一年半.这个时间的设立一是作为一个完整的项目周期,二是作为缓冲时间来决定是否继续科研.PHD的时间为五年,培养方式为进入实验室做研究,大部分从事实用型创新型项目的研究.</li><li>SPIRIT实验室<br>这是NTU智慧国建设项目的研究实验室,取义Smart Platform Infrastructure Research on Integrative Technology.</li><li>多层次安全<br>没有一种技术可以解决所有的安全问题.安全问题是多层次的,需要对其进行整体把握,了解多个方面的知识,才能真正做好安全问题的研究.</li><li>科技改变生活<br><img src="http://static.zybuluo.com/B1ank/6qsntq9l9aw7l7o3c7fczjp0/Tech%20and%20Art.JPG" alt="Tech and Art.JPG-2029kB"><br>在国大博物馆进行参观时,发现上图所示的画卷,整幅画都是通过执笔机器人完成,体现了文化与科技的紧密结合.  </li><li>实践是检验真理的唯一标准<br>NUS的许多研究项目都是国家实战项目.学习过程应该从实际问题出发,通过问题进行学习可以避免盲目.  </li></ul><h2 id="0x04-生活奇遇"><a href="#0x04-生活奇遇" class="headerlink" title="0x04 生活奇遇"></a>0x04 生活奇遇</h2><ul><li><p>NUS校门<br><img src="http://static.zybuluo.com/B1ank/wex1fix0vtaxyroo2k25g12u/NUS%20gate.jpg" alt="NUS gate.jpg-2177kB"></p></li><li><p>经济商业项目<br><img src="http://static.zybuluo.com/B1ank/k567eb060447qrrhc0np4z8p/Finance%20and%20Business.JPG" alt="Finance and Business.JPG-3118.5kB"></p></li><li><p>NUS博物馆<br><img src="http://static.zybuluo.com/B1ank/b8v6xauxehrl8htt2mkjqgo2/NUS%20Museum.JPG" alt="NUS Museum.JPG-3235.7kB"></p></li><li><p>译名奇怪的珍珠大厦<br><img src="http://static.zybuluo.com/B1ank/6oih7e7sc6lr17yeql75haym/People%27s%20Park%20Centre.JPG" alt="People&#39;s Park Centre.JPG-2356.6kB"></p></li><li><p>克拉码头夜景<br><img src="http://static.zybuluo.com/B1ank/6bzspxrfhxotoy47gdt2a9se/The%20Night.JPG" alt="The Night.JPG-3038.8kB"></p></li><li>印度菜+风油精米饭<br><img src="http://static.zybuluo.com/B1ank/m9zawptpaod408nucqor5d5l/Indianfood1.jpg" alt="Indianfood1.jpg-4879.6kB"></li></ul><p><img src="http://static.zybuluo.com/B1ank/7hafph64bpishwtkwre6qbdw/Indianfood2.jpg" alt="Indianfood2.jpg-3664.8kB"></p><p><img src="http://static.zybuluo.com/B1ank/h86y8g0qz5xy3m64i4dt6c6l/Wind%20Medicated%20Oil%20Rice.jpg" alt="Wind Medicated Oil Rice.jpg-4982.3kB">  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-今日主题&quot;&gt;&lt;a href=&quot;#0x00-今日主题&quot; class=&quot;headerlink&quot; title=&quot;0x00 今日主题&quot;&gt;&lt;/a&gt;0x00 今日主题&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Translational R&amp;amp;D for Smart Nati
      
    
    </summary>
    
      <category term="Life" scheme="https://blank-vax.github.io/categories/Life/"/>
    
    
      <category term="NTU" scheme="https://blank-vax.github.io/tags/NTU/"/>
    
      <category term="Singapore" scheme="https://blank-vax.github.io/tags/Singapore/"/>
    
  </entry>
  
  <entry>
    <title>Third Day in NTU</title>
    <link href="https://blank-vax.github.io/2020/11/09/NTU%20Day3/"/>
    <id>https://blank-vax.github.io/2020/11/09/NTU Day3/</id>
    <published>2020-11-09T02:39:34.429Z</published>
    <updated>2020-06-26T08:34:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-引言"><a href="#0x00-引言" class="headerlink" title="0x00 引言"></a>0x00 引言</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">After all, hackers only need to succeed once, but defenders need to succeed all the time.</span><br></pre></td></tr></table></figure><h2 id="0x01-今日主题"><a href="#0x01-今日主题" class="headerlink" title="0x01 今日主题"></a>0x01 今日主题</h2><p><code>Introduction to Cyber Security</code></p><h2 id="0x02-内容概述"><a href="#0x02-内容概述" class="headerlink" title="0x02 内容概述"></a>0x02 内容概述</h2><p>本日的学习内容主要是介绍网络安全的大体情况,首先介绍了安全框架.然后引出了几个重要概念,包括APT(Advanced Persistent Threat)和risk,cost,convenience三元素体系.</p><h2 id="0x03-安全框架"><a href="#0x03-安全框架" class="headerlink" title="0x03 安全框架"></a>0x03 安全框架</h2><h3 id="安全实例"><a href="#安全实例" class="headerlink" title="安全实例"></a>安全实例</h3><ul><li>系统安全<ul><li>独立电脑+单个用户+单道程序</li><li>独立电脑+单个用户+多道程序</li><li>独立电脑+多用户</li><li>电脑网络</li></ul></li><li>电脑安全<ul><li>交流安全<br>数据篡改,发送者身份认证,数据泄漏</li><li>存储安全<br>文件控制权限,数据拥有者和使用者的身份验证</li></ul></li><li>单系统与分散系统的安全</li></ul><hr><h3 id="安全框架"><a href="#安全框架" class="headerlink" title="安全框架"></a>安全框架</h3><p>安全框架可以用下图来进行大致概括.</p><p>安全主要分为数据、信息和系统(其中系统又包括电脑和网络)三大部分.信息安全用于防止对存储信息的各种攻击行为;数据安全则关系到每一比特每一字节的安全;而系统安全则是计算机部件的安全.</p><h2 id="0x04-安全三元素体系"><a href="#0x04-安全三元素体系" class="headerlink" title="0x04 安全三元素体系"></a>0x04 安全三元素体系</h2><h3 id="Risk"><a href="#Risk" class="headerlink" title="Risk"></a>Risk</h3><p>数据所有者可能的损失以及攻击者潜在的回报.</p><h3 id="Cost"><a href="#Cost" class="headerlink" title="Cost"></a>Cost</h3><p>安全设计和落实,以及计算等方面的日常经费.</p><h3 id="Convenience"><a href="#Convenience" class="headerlink" title="Convenience"></a>Convenience</h3><p>如果安全系统设计的不方便使用,则使用者会冒险去绕过系统验证甚至攻破系统.</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>新加坡银行卡的PIN码从四位到八位到六位的变迁</p><h2 id="0x05-网络攻击"><a href="#0x05-网络攻击" class="headerlink" title="0x05 网络攻击"></a>0x05 网络攻击</h2><h3 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h3><ul><li>与公网的联系不可避免(不会有安全系统独立于公网之外)</li><li>网络攻击来源包括内部人员有意或无意造成的攻击以及外部专业或业余人员的攻击</li><li>阻止来自外部的未认证访问</li><li>攻击者拥有不对称的优势:可隐藏于各处,攻击容易且身份难以被确认</li><li>不合法的攻击途径仍然存在</li><li>干扰和恶意软件的检测非常有必要</li></ul><h3 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h3><p>APT即为Advanced Persistent Threat的缩写,意为高持续性威胁,是经验最为丰富的群组使用最为先进的操作技术实现的最复杂攻击的指代.APT是每个安全系统需要考虑的最重要的方面,它的强度决定了整个安全系统所能承受攻击的最大强度.<br>设计过程中,将APT纳入考虑,有助于提高系统的稳定性与抵御外界攻击的能力.</p><h3 id="攻击实例"><a href="#攻击实例" class="headerlink" title="攻击实例"></a>攻击实例</h3><ul><li>MitM Attacks on Banking Transactions</li><li>Large-Scale Attacks In the Cyberspace  <ul><li>Distributed Denial of Service</li><li>Zombies</li><li>Rapid and unexpected surge in attack traffic over a short period of time</li><li>Easy to launch attack but hard to identify sources</li></ul></li><li>Large-Scale Attacks on CII via Weaker Nodes</li></ul><h2 id="0x06-网络安全策略"><a href="#0x06-网络安全策略" class="headerlink" title="0x06 网络安全策略"></a>0x06 网络安全策略</h2><ul><li>立法与规则建立</li><li>对外来流量的多方面预防</li><li>对恶意软件和流量攻击进行检测</li></ul><h2 id="0x07-一些思考"><a href="#0x07-一些思考" class="headerlink" title="0x07 一些思考"></a>0x07 一些思考</h2><ul><li>安全问题<ul><li>宏观把控</li><li>各部分紧密联系</li><li>明确需要保护的东西和APT</li></ul></li><li>风险——花费——便捷思考模式</li><li>基础设施安全</li></ul><h2 id="0x08-生活奇遇"><a href="#0x08-生活奇遇" class="headerlink" title="0x08 生活奇遇"></a>0x08 生活奇遇</h2><ul><li><p>奇怪的松毛虫<br><img src="http://static.zybuluo.com/B1ank/92fi6j0q1gw3lbrtsodtgwty/Caterpillar.JPG" alt="Caterpillar.JPG-1115.7kB"></p></li><li><p>垃圾分类<br><img src="http://static.zybuluo.com/B1ank/wy8dnf4rlurboyudhepww9px/TrushClassification.JPG" alt="TrushClassification.JPG-1388.3kB"></p></li><li><p>何为华人?<br><img src="http://static.zybuluo.com/B1ank/a4jxpkakzvh3jlztwmxfy4uc/WIC.JPG" alt="WIC.JPG-1272.1kB"></p></li><li><p>Java太苦,来块糖吧<br><img src="http://static.zybuluo.com/B1ank/4wmyir7k5tjyf0ncbgbi9jh0/Sugar_of_Java.JPG" alt="Sugar_of_Java.JPG-1587.3kB"></p></li><li><p>特别高的外卖消费水平<br><img src="http://static.zybuluo.com/B1ank/m4s83xwljum347yopn4mw8p0/Expensive_Takeout.PNG" alt="Expensive_Takeout.PNG-153kB"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-引言&quot;&gt;&lt;a href=&quot;#0x00-引言&quot; class=&quot;headerlink&quot; title=&quot;0x00 引言&quot;&gt;&lt;/a&gt;0x00 引言&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="Life" scheme="https://blank-vax.github.io/categories/Life/"/>
    
    
      <category term="NTU" scheme="https://blank-vax.github.io/tags/NTU/"/>
    
      <category term="Singapore" scheme="https://blank-vax.github.io/tags/Singapore/"/>
    
  </entry>
  
</feed>
