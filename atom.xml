<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>B1ank</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blank-vax.github.io/"/>
  <updated>2021-07-16T10:32:33.276Z</updated>
  <id>https://blank-vax.github.io/</id>
  
  <author>
    <name>B1ank</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>汇编语言学习笔记（二）</title>
    <link href="https://blank-vax.github.io/2021/07/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://blank-vax.github.io/2021/07/12/汇编语言学习笔记（二）/</id>
    <published>2021-07-12T08:14:43.725Z</published>
    <updated>2021-07-16T10:32:33.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-源程序"><a href="#0x00-源程序" class="headerlink" title="0x00 源程序"></a>0x00 源程序</h2><h3 id="程序周期"><a href="#程序周期" class="headerlink" title="程序周期"></a>程序周期</h3><p>一个汇编语言程序从写出到最终执行的过程包括如下内容：</p><ul><li><p>编写汇编程序</p><p>这一步工作的结果产生存储源程序的文本文件，常以<code>.asm</code>结尾。</p></li><li><p>对源程序进行编译连接</p><p>使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件（以<code>.obj</code>结尾）。再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件（以<code>.exe</code>结尾）。这一步工作的结果产生可在操作系统中运行的可执行文件。</p><p>可执行文件包括<strong>程序</strong>、<strong>数据</strong>和<strong>相关描述信息</strong>三部分。</p></li><li><p>执行可执行文件中的程序。</p></li><li><p>程序返回</p></li></ul><p>以上过程可概括如下：</p><script type="math/tex; mode=display">编程 \rightarrow test.asm \rightarrow 编译 \rightarrow test.obj \rightarrow 连接 \rightarrow test.exe \rightarrow 加载 \rightarrow 内存中的程序 \rightarrow 运行</script><h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><p>汇编语言源程序中的指令包括汇编指令和伪指令。汇编指令有对应的机器码指令，可被编译为机器指令，最终被CPU执行。而伪指令没有对应的机器码指令，由编译器执行，编译器根据伪指令进行相关的编译工作。</p><ul><li><code>segment&amp;ends</code>：成对使用，功能为定义一个段。其中<code>segment</code>说明段的开始，<code>ends</code>说明段的结束。</li><li><code>end</code>：是一个汇编程序的结束标记，编译器碰到伪指令<code>end</code>则结束对源程序的编译。</li><li><code>assume</code>：将有特定用途的段和相关的段寄存器关联起来。</li></ul><h3 id="源程序与程序"><a href="#源程序与程序" class="headerlink" title="源程序与程序"></a>源程序与程序</h3><p>将源程序文件中的所有内容称为源程序，将源程序中最终由计算机执行、处理的指令或数据成为程序。程序最先以汇编指令的形式存在源程序中，经编译、连接后转变为机器码，存储在可执行文件中。</p><h3 id="程序加载-amp-返回"><a href="#程序加载-amp-返回" class="headerlink" title="程序加载&amp;返回"></a>程序加载&amp;返回</h3><p>一个程序结束后，将CPU的控制权交还给使它得以运行的程序，这个过程称为程序返回。可以通过在程序的末尾添加如下返回程序段实现程序返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure><p>任何通用的操作系统，都需要提供一个称为shell的程序，用户使用这个程序来操作计算机系统进行工作。DOS系统中有一个程序<code>command.com</code>，这个程序称为命令解释器，也就是DOS系统的shell。</p><p>故可执行文件在DOS中加载执行的过程可概括如下：</p><ul><li>可执行文件执行时，正在运行的command程序将该可执行文件中的程序加载入内存。</li><li>command设置CPU的<code>CS:IP</code>指向程序的第一条指令（即程序的入口），从而使程序得以运行。</li><li>程序运行结束后，返回到command中，CPU继续运行command。</li></ul><p><img src="/2021/07/12/汇编语言学习笔记（二）/1.png" alt="1"></p><p>由上图可知，程序加载后，<code>ds</code>中存放着程序所在内存区的段地址，对应的偏移地址为0.则程序所在的内存区地址为<code>ds:0</code>。这个内存区的前256个字节中存放的是PSP，DOS用来和程序进行通信。从256字节处向后的空间存放程序。故程序的物理地址为<code>SA+10H:0</code>。</p><h3 id="语法错误和逻辑错误"><a href="#语法错误和逻辑错误" class="headerlink" title="语法错误和逻辑错误"></a>语法错误和逻辑错误</h3><p>一般来说，程序在编译时被编译器发现的错误是语法错误。源程序经过编译，在运行时发生的错误是逻辑错误。</p><h2 id="0x01-编辑-amp-编译-amp-连接"><a href="#0x01-编辑-amp-编译-amp-连接" class="headerlink" title="0x01 编辑&amp;编译&amp;连接"></a>0x01 编辑&amp;编译&amp;连接</h2><p>DOS下汇编源程序的编辑、编译及连接需要的工具分别为编辑器<code>edit</code>、编译器<code>masm</code>和连接器<code>link</code>。通常来说，DOSBox中不自带这些软件，下载链接如下：<a href="https://pan.baidu.com/s/1BxI4qu-3wjPmNOB5ADYFxw" target="_blank" rel="noopener">https://pan.baidu.com/s/1BxI4qu-3wjPmNOB5ADYFxw</a> ，提取码：yxg5 。</p><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><p>在DOS命令行中输入<code>edit 文件名.asm</code>指令，进行汇编源程序编辑，界面如下：</p><p><img src="/2021/07/12/汇编语言学习笔记（二）/2.PNG" alt="2"></p><p>完成编辑后保存即可。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>在DOS命令行中输入<code>masm</code>指令进入编译模式。编译过程中，输入为源程序文件，最多可以得到三个输出即目标文件、列表文件和交叉引用文件。</p><p><img src="/2021/07/12/汇编语言学习笔记（二）/3.PNG" alt="3"></p><ul><li>Source filename：源程序名称，默认为<code>[.ASM]</code>。若待编译文件为masm所在路径下的<code>.asm</code>文件，则直接输入文件名；否则需要输入完整的路径名称及文件后缀。</li><li>Object filename：生成<code>OBJ</code>文件名称，默认为<code>[.OBJ]</code>。直接键入Enter则在当前目录下生成<code>.obj</code>文件。当然也可以指定目录。</li><li>Source listing：列表文件名称，为编译过程的中间结果，键入Enter键取消生成。</li><li>Cross-reference：交叉引用文件名称，键入Enter键取消生成。</li></ul><p>常见编译错误包含两类：</p><ul><li>程序中存在<code>Severe Errors</code>。</li><li>找不到所给出的源程序文件。</li></ul><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>连接的作用包括以下内容：</p><ul><li>分割较大的源程序，分别编译子源程序后连接在一起，形成一个可执行文件。</li><li>将库文件和目标文件连接在一起，实现对库文件中子程序的调用。</li><li>连接程序将目标文件中的内容处理为最终的可执行信息。</li></ul><p>在DOS中输入<code>link</code>指令进入连接模式。</p><p><img src="/2021/07/12/汇编语言学习笔记（二）/4.PNG" alt="4"></p><ul><li>Object Modules：待连接<code>OBJ</code>文件名称，默认为<code>[.OBJ]</code>。如果文件不以<code>.obj</code>为扩展名，则需要输入全名。</li><li>Run File：生成的可执行文件名称。</li><li>List File：映像文件的名称，为可忽略的中间结果。</li><li>Libraries：库文件名称。若程序中调用了某一个库文件中的子程序，则在连接时需要将这个库文件和目标文件连接到一起生成可执行文件。</li></ul><h3 id="简化版的编译连接"><a href="#简化版的编译连接" class="headerlink" title="简化版的编译连接"></a>简化版的编译连接</h3><ul><li>简化编译：<code>masm 文件路径+文件名;</code>，自动忽略中间文件。</li><li>简化连接：<code>link 文件路径+文件名;</code>，自动忽略中间文件。</li></ul><h2 id="0x02-BX-amp-LOOP"><a href="#0x02-BX-amp-LOOP" class="headerlink" title="0x02 [BX]&amp;LOOP"></a>0x02 [BX]&amp;LOOP</h2><p>定义描述性符号()，其中的元素包括三种类型：寄存器名、段寄存器名和内存单元的物理地址（一个20位数据）。</p><p>约定Idata表示常量。</p><h3 id="BX"><a href="#BX" class="headerlink" title="[BX]"></a>[BX]</h3><p>[bx]表示一个内存单元，偏移地址在<code>bx</code>寄存器中，段地址在<code>ds</code>寄存器中。</p><h3 id="LOOP"><a href="#LOOP" class="headerlink" title="LOOP"></a>LOOP</h3><p>使用loop指令实现循环功能，寄存器<code>cx</code>中存放循环次数。该指令的格式是：<code>loop 标号</code>，CPU执行loop指令时，首先执行<code>(cx) = (cx)-1</code>，随后判断<code>cx</code>中的值，若不为零则跳转至标号处执行程序；若为零则向下执行。</p><p>使用<code>cx</code>和LOOP指令配合实现循环功能的框架如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov cx, 循环次数</span><br><span class="line">s:</span><br><span class="line">循环执行的程序段</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><p>编写汇编程序并使用debug命令进行跟踪执行，验证loop语句的操作流程。</p><p>可以使用debug命令的g命令进行持续执行。如<code>g 0012</code>表示从当前的<code>CS:IP</code>指向的指令执行，一直到<code>(IP)=0012h</code>为止。若希望将循环一次执行完，可在遇到loop指令时，使用p命令执行。</p><p>值得注意的是，在汇编源程序中，数据不能以<strong>字母</strong>开头。</p><h3 id="Debug与masm对指令的不同处理"><a href="#Debug与masm对指令的不同处理" class="headerlink" title="Debug与masm对指令的不同处理"></a>Debug与masm对指令的不同处理</h3><p>在debug中的指令<code>mov ax,[0]</code>表示将<code>ds:0</code>处的数据送入<code>ax</code>中。但在汇编源程序中，指令<code>mov ax,[0]</code>被编译器当作指令<code>mov ax,0</code>进行处理。Debug将<code>[idata]</code>解释为一个内存单元，idata是内存单元的偏移地址；而编译器将<code>[idata]</code>解释为idata。</p><p>若希望在源程序中实现将内存单元中的数据送入寄存器中，则可以使用<code>bx</code>寄存器存储偏移地址，使用<code>[bx]</code>的方式访问内存单元。若希望直接使用idata表示偏移地址，则需要显式地给出段地址所在的段寄存器，例如<code>ds:[idata]</code>。</p><p>出现在访问内存单元的指令中，用于显式地指明内存单元的段地址的<code>ds:</code>，<code>cs:</code>，<code>ss:</code>，<code>es:</code>，在汇编语言中称为<strong>段前缀</strong>。</p><h3 id="安全段空间"><a href="#安全段空间" class="headerlink" title="安全段空间"></a>安全段空间</h3><p>在8086模式中，随意向一段内存空间写入内容是危险的，因为这段空间中可能存放着重要的系统数据或代码。故向内存空间写入数据时，需要使用操作系统分配的内存空间，而不应直接用地址任意指定内存单元，向里面写入。</p><p>DOS和其他合法的程序一般都不会使用<code>0:200~0:2ff</code>的256个字节的地址空间，故可以直接向该段空间内写入内容。</p><h2 id="0x03-多程序段程序"><a href="#0x03-多程序段程序" class="headerlink" title="0x03 多程序段程序"></a>0x03 多程序段程序</h2><p>前面内容中讨论的程序均只包含一个代码段，称为单程序段程序，下面讨论多程序段程序。</p><p>操作系统环境中，合法地通过操作系统取得的空间都是安全地，因为操作系统不会让一个程序所用的空间和其他程序以及系统自己的空间冲突。故在操作系统允许的情况下，程序可以取得<strong>任意容量的空间</strong>。</p><p>程序可以通过两种方法获取所需空间，本文重点讨论<strong>在加载程序的时候为程序分配</strong>这种方法，即通过在源程序中定义段来获取内存空间。</p><h3 id="在代码段中使用数据"><a href="#在代码段中使用数据" class="headerlink" title="在代码段中使用数据"></a>在代码段中使用数据</h3><p>考虑以下场景，我们需实现多个常数的相加，并将结果存储在特定寄存器中。这种情况下，我们可以在程序中定义希望处理的数据，这些数据就会被编译、连接程序作为程序的一部分写入可执行文件中。以下面的程序为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,8</span><br><span class="line">  s:add ax,cs:[bx]</span><br><span class="line">    add bx,2</span><br><span class="line">    loop s</span><br><span class="line">    </span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="dw-amp-db"><a href="#dw-amp-db" class="headerlink" title="dw&amp;db"></a>dw&amp;db</h4><p><code>dw</code>：即<code>define word</code>，用于定义字型数据。该语句后跟随N个字型数据，其所占空间大小为2N字节。同时，<code>dw</code>定义的数据处于代码段的头部，故偏移地址为0。</p><p><code>db</code>：即<code>define byte</code>，用于定义字节型数据。该语句后跟随N个字节型数据，其所占空间大小为N字节。</p><h4 id="start"><a href="#start" class="headerlink" title="start"></a>start</h4><p><img src="/2021/07/12/汇编语言学习笔记（二）/5.PNG" alt="5"></p><p>通过debug查看上述程序的可执行文件，可以发现代码段的前16个字节是用<code>dw</code>指令定义的数据，从第16个字节开始才是汇编指令对应的机器码。故我们需要<strong>显式地表明程序第一条指令的位置</strong>。</p><p>可以通过调试器修改<code>CS:IP</code>指向的指令单元从而标记程序的第一条指令，但更方便的做法是利用<code>start</code>标号来表明程序首条指令的位置。这个标号在伪指令end后面出现，于是end除通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。修改后的程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line"></span><br><span class="line">start:mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,8</span><br><span class="line">  s:add ax,cs:[bx]</span><br><span class="line">    add bx,2</span><br><span class="line">    loop s</span><br><span class="line">    </span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>在代码段中使用数据的程序框架如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">  :</span><br><span class="line">  :</span><br><span class="line">  数据</span><br><span class="line">  :</span><br><span class="line">  :</span><br><span class="line">start: </span><br><span class="line">:</span><br><span class="line">代码</span><br><span class="line">:</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h3 id="在代码段中使用栈"><a href="#在代码段中使用栈" class="headerlink" title="在代码段中使用栈"></a>在代码段中使用栈</h3><p>考虑以下场景，我们需要逆序输出数据段中的内容，最佳的解决办法就是在代码段中引入栈。即在程序中通过定义数据来取得一段空间，然后将这段空间当作栈来使用。以下面程序为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">; 用dw定义16个字型数据，在程序加载后，将取得16个字的内存空间，存放这16个数</span><br><span class="line">; 据。在后面的程序中将这段空间当作栈来使用。</span><br><span class="line">start:mov ax,cs</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,30h</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:  push cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s0: pop cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>将<code>CS:10~CS:2F</code>的内存空间当作栈使用，初始状态下栈为空，所以<code>SS:SP</code>要指向栈底<code>CS:30</code>。</p><h3 id="将数据、代码、栈放入不同的段"><a href="#将数据、代码、栈放入不同的段" class="headerlink" title="将数据、代码、栈放入不同的段"></a>将数据、代码、栈放入不同的段</h3><p>为避免程序结构混乱，考虑将数据、代码和栈放入不同的段，并在程序头部进行寄存器关联。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line">data segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">data ends</span><br><span class="line">stack segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,20h</span><br><span class="line"></span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:push [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s0:pop [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><ul><li><p>定义一个段的方法和定义代码段方法相同，只是不同的段要求不同的段名。</p></li><li><p>CPU如何处理定义的段中的内容完全依靠程序中具体的汇编指令，和汇编指令对<code>CS:IP</code>、<code>SS:SP</code>、<code>DS</code>等寄存器的设置来决定。以上三个寄存器分别掌管代码段、栈段和数据段。</p></li><li><p>对于如下定义的段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name segment</span><br><span class="line">...</span><br><span class="line">name ends</span><br></pre></td></tr></table></figure><p>如果段中的数据占N个字节，则程序加载后，该段实际占有的空间为<code>(N/16+1)*16</code>个字节。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-源程序&quot;&gt;&lt;a href=&quot;#0x00-源程序&quot; class=&quot;headerlink&quot; title=&quot;0x00 源程序&quot;&gt;&lt;/a&gt;0x00 源程序&lt;/h2&gt;&lt;h3 id=&quot;程序周期&quot;&gt;&lt;a href=&quot;#程序周期&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Binary" scheme="https://blank-vax.github.io/categories/Binary/"/>
    
    
      <category term="IoT Foundation" scheme="https://blank-vax.github.io/tags/IoT-Foundation/"/>
    
      <category term="Assembly" scheme="https://blank-vax.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言学习笔记（一）</title>
    <link href="https://blank-vax.github.io/2021/07/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://blank-vax.github.io/2021/07/12/汇编语言学习笔记（一）/</id>
    <published>2021-07-12T08:00:00.000Z</published>
    <updated>2021-07-16T10:32:37.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-基础知识"><a href="#0x00-基础知识" class="headerlink" title="0x00 基础知识"></a>0x00 基础知识</h2><ul><li>Central Processing Unit为中央处理单元，简称CPU。CPU是一种微处理器，计算机是指由CPU和其他受CPU直接或间接控制的芯片、器件、设备组成的计算机系统，比如常见的PC机。每一种CPU都有自己的汇编指令集。</li><li>汇编指令通过编译器翻译为机器码，供计算机直接使用。</li><li>汇编语言由汇编指令、伪指令和其他符号组成。</li><li>指令和数据在存储器中存放，也就是平时所说的内存。在内存或磁盘上，指令和数据没有任何区别，都是<strong>二进制信息</strong>。</li><li>存储器被划分成若干个存储单元，每个存储单元从0开始顺序编号，微机存储器的容量以<strong>字节</strong>为最小单位计算。</li><li>CPU通过地址总线指定存储器单元，地址总线的宽度决定了CPU的寻址能力。</li><li>CPU通过数据总线实现自身与内存或其他器件之间的数据传送，数据总线的宽度决定了CPU与其他器件进行数据传送时的一次数据传送量。8088CPU数据总线宽度为8，8086CPU数据总线宽度为16。</li><li>CPU通过控制总线实现对外部器件的控制，控制总线的宽度决定了CPU对系统中其他器件的控制能力。</li><li>每台PC机都拥有一个主板，主板上有核心器件和一些主要器件，包括CPU、存储器、外围芯片组、扩展插槽等，这些器件通过总线相连。</li><li>存储器从功能和连接上可分为三类：随机存储器RAM、装有BIOS(Basic Input/Output System，基本输入输出系统)的只读存储器ROM、接口卡上的RAM（如显存）。</li><li>PC机在实际运作过程中，所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。</li></ul><h2 id="0x01-寄存器"><a href="#0x01-寄存器" class="headerlink" title="0x01 寄存器"></a>0x01 寄存器</h2><p>一个典型的CPU由运算器、控制器、寄存器等器件构成。各器件功能如下：</p><ul><li>运算器进行信息处理。</li><li>寄存器进行信息存储。</li><li>控制器控制各种器件进行工作。</li><li>内部总线连接各种器件，在它们之间进行数据的传送。</li></ul><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>8086CPU的所有寄存器都是16位的，可存放两个字节。AX、BX、CX、DX这四个寄存器通常用来存放一般性数据，称为通用寄存器。同时，这四个寄存器可分为两个可独立使用的8位寄存器来使用。</p><p>以寄存器AX为例，AX的低8位构成AL寄存器，高8位构成AH寄存器。AH和AL寄存器是可以独立使用的8位寄存器。注意，诸如<code>mov ax,bl</code>这类的汇编语句是错误的，因为其尝试将一个8位寄存器中的值赋值至16位寄存器中。</p><p>8086CPU可以一次性处理以下两种尺寸的数据：</p><ul><li>字节：记为byte，一个字节由8个bit组成，可存在8位寄存器中。</li><li>字：记为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节（H）和低位字节（L）。</li></ul><h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><ul><li><p>在写一条汇编指令或一个寄存器的名称时，不区分大小写。</p></li><li><p>8位寄存器只能存放两位十六进制的数字，若溢出则丢弃最高位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al, C5H</span><br><span class="line">add al, 93H</span><br></pre></td></tr></table></figure><p>以上代码执行结果为：<code>158H</code>，而寄存器<code>al</code>是8位寄存器，故舍弃最高位1，保存结果<code>58H</code>。</p></li></ul><h3 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h3><p>所有的内存单元构成的存储空间是一个一维的线性空间，每个内存单元在这个空间中都有唯一的地址，将该地址称为物理地址。在CPU向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址。</p><p>8086CPU是16位结构的CPU，具有以下特性：</p><ul><li>运算器一次最多可以处理16位的数据。</li><li>寄存器的最大宽度为16位。</li><li>寄存器和运算器之间的通路为16位。</li></ul><p>8086CPU有20位地址总线，可以传送20位地址。然而，该CPU又是16位结构，在内部一次性处理、传输、暂时存储的地址均为16位。故8086CPU采用一种<strong>在内部用两个16位地址合成的方法来形成一个20位物理地址</strong>。</p><p>具体来讲，地址加法器采用<strong>物理地址=段地址*16+偏移地址</strong>的方法使用段地址和偏移地址合成物理地址。该方法的本质含义是：CPU在访问内存时，用一个基础地址（段地址<em>16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。一般来说，这种寻址功能是”<em>*基础地址+偏移地址=物理地址</em></em>“寻址模式的一种具体实现方案。</p><p>以上寻址方式有以下几个关键点：</p><ul><li>CPU可以用不同的段地址和偏移地址形成同一个物理地址。</li><li>偏移地址16位，变化范围为<code>0~FFFFH</code>，仅用偏移地址来寻址最多可寻64KB个内存单元。</li></ul><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>可以根据需要，将地址连续、起始地址为16的倍数的一组内存单元定义为一个段。8086CPU有4个段寄存器：CS、DS、SS、ES。当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。</p><p>CS和IP是8086CPU中两个最关键的寄存器，指示了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令指针寄存器。任意时刻，CPU将<code>CS:IP</code>指向的内容当作指令执行。</p><p>8086CPU工作过程如下：</p><ul><li>从<code>CS:IP</code>指向的内存单元读取指令，读取的指令进入<strong>指令缓冲器</strong>。</li><li><code>IP = IP + 所读取指令的长度</code>，指向下一条指令。</li><li>执行指令，转到第一步并重复。</li></ul><p>能够改变CS、IP内容的指令被统称为<strong>转移指令</strong>，最简单的转移指令是<code>jmp</code>指令。可以使用形如<code>jmp 段地址:偏移地址</code>的指令实现对CS、IP内容的同时修改。若只想修改IP的内容，可以使用形如<code>jmp 某一合法寄存器</code>的指令完成，该指令表示使用寄存器中的值修改IP。</p><h2 id="0x02-Debug的使用及相关指令"><a href="#0x02-Debug的使用及相关指令" class="headerlink" title="0x02 Debug的使用及相关指令"></a>0x02 Debug的使用及相关指令</h2><p>Windows10系统中已经剔除Debug相关的插件，需要下载DOSBox并手动安装debug.exe才可以使用Debug程序。安装指南链接如下：<a href="https://blog.csdn.net/mengjizhiyou/article/details/102458118" target="_blank" rel="noopener">win10环境下如何安装和运行DOSBox和debug_mengjizhiyou的博客-CSDN博客</a>。</p><p>Debug程序中重要指令如下：</p><ul><li><p>R命令</p><p>查看、修改CPU中寄存器的内容。r命令可以直接查看所有寄存器的值，使用<code>r+寄存器名称</code>语句以修改寄存器的值。</p><p><img src="/2021/07/12/汇编语言学习笔记（一）/1.PNG" alt="1"></p></li><li><p>D命令</p><p>查看内存中的内容。</p><p>直接使用d命令将列出Debug预设的地址处的内容。使用命令<code>d 段地址:偏移地址</code>的格式来指定查看内存的起始地址，随后接着使用d命令可列出后续内容。采用<code>d 段地址:起始偏移地址 结尾偏移地址</code>来规定d命令的查看范围。</p><p>Debug将输出的内容分为三部分：中间是从指定地址开始的128个内存单元的内容，以十六进制的格式输出，每行的输出从16的整数倍地址开始，最多输出16个单元的内容。左边是每行的起始地址。右边是每个内存单元中的数据对应的可显示的ASCII码字符。</p><p><img src="/2021/07/12/汇编语言学习笔记（一）/2.PNG" alt="2"></p><p>同时，D命令支持<code>d 段寄存器:偏移地址</code>指令格式。</p><p><img src="/2021/07/12/汇编语言学习笔记（一）/6.PNG" alt="6"></p></li><li><p>E命令</p><p>修改内存中的内容，可以写入数据和指令，在内存中它们实际上没有区别。</p><p>可以使用<code>e 起始地址 数据 数据 数据 ...</code>的格式修改指定内存范围中的内容。也可以直接输入<code>e 起始地址</code>，随后以询问的方式逐个修改内存单元中的内容，空格键表示指定内存单元修改完成，Enter键表示e命令执行结束。</p><p><img src="/2021/07/12/汇编语言学习笔记（一）/3.PNG" alt="3"></p></li><li><p>U命令</p><p>将内存中的内容解释为机器指令和对应的汇编指令。</p><p><img src="/2021/07/12/汇编语言学习笔记（一）/4.PNG" alt="4"></p></li><li><p>T命令</p><p>执行<code>CS:IP</code>指向的内存单元处的指令。若需要执行指定内存处存放的指令，则需要利用r命令修改寄存器CS和IP的值，随后才可使用t命令完成指令执行。</p><p>值得注意的是，T命令在修改寄存器SS的指令时，下一条指令也紧接着被执行，这涉及中断机制。</p><p><img src="/2021/07/12/汇编语言学习笔记（一）/7.PNG" alt="7"></p></li><li><p>A命令</p><p>以汇编指令的形式向内存中写入指令。</p><p><img src="/2021/07/12/汇编语言学习笔记（一）/5.PNG" alt="5"></p></li></ul><h2 id="0x03-寄存器内存访问"><a href="#0x03-寄存器内存访问" class="headerlink" title="0x03 寄存器内存访问"></a>0x03 寄存器内存访问</h2><h3 id="字的存储"><a href="#字的存储" class="headerlink" title="字的存储"></a>字的存储</h3><p>在内存中存储时，由于内存单元是字节单元，则一个字需要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。我们将起始地址为N的字单元简称为N地址字单元。</p><p>任何两个地址连续的内存单元既可被看作两个内存单元，也可 被看作一个地址为N的字单元中的高位字节单元和低位字节单元。</p><h3 id="DS-amp-address"><a href="#DS-amp-address" class="headerlink" title="DS&amp;[address]"></a>DS&amp;[address]</h3><p>8086CPU中有一个DS寄存器，通常用来存放要访问数据的段地址。</p><p>可以利用<code>mov</code>指令将一个内存单元中的内容送入一个寄存器中。寄存器通过寄存器名标识，而内存单元需要用内存单元地址指明。<code>[address]</code>表示一个内存单元，address表示内存单元的偏移地址。指令执行时，CPU自动区ds寄存器中的数字作为内存单元的段地址。</p><p>值得注意的是，8086CPU不支持将数据直接送入段寄存器的操作，故需要使用一般寄存器完成中转。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ds,1000H ;错误语句</span><br><span class="line"></span><br><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax ;正确语句</span><br></pre></td></tr></table></figure><h3 id="mov-amp-add-amp-sub"><a href="#mov-amp-add-amp-sub" class="headerlink" title="mov&amp;add&amp;sub"></a>mov&amp;add&amp;sub</h3><p>以上三个指令均支持以下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 寄存器，数据</span><br><span class="line">* 寄存器，寄存器</span><br><span class="line">* 寄存器，内存单元</span><br><span class="line">* 内存单元，寄存器</span><br></pre></td></tr></table></figure><p>其中*代表mov，add和sub三类运算。</p><h2 id="0x04-栈"><a href="#0x04-栈" class="headerlink" title="0x04 栈"></a>0x04 栈</h2><h3 id="基本概念及特性"><a href="#基本概念及特性" class="headerlink" title="基本概念及特性"></a>基本概念及特性</h3><p>栈是一种具有特殊访问方式的存储空间，具有后进先出（Last In First Out, LIFO）的特性。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>8086CPU提供入栈和出栈指令，分别为PUSH和POP，前者将一个新的元素放到栈顶，后者从栈顶去除一个元素。8086CPU的入栈出栈操作都是以字为单位进行的。</p><p>入栈时，栈顶从高地址向低地址方向增长，出栈则相反。栈顶元素出栈后，内存对应单元的元素依然存在，但已不在栈中，当再次执行PUSH指令时，写入的新数据会将其覆盖。</p><h3 id="SS-amp-SP"><a href="#SS-amp-SP" class="headerlink" title="SS&amp;SP"></a>SS&amp;SP</h3><p>8086CPU中存在段寄存器SS和栈指针 寄存器SP。栈顶的段地址存放在SS中，偏移地址存放在SP中。<strong>任意时刻，<code>SS:SP</code>指向栈顶元素</strong>。在对栈进行操作前，首先需要初始化寄存器SS和SP。</p><p>例如，若对范围为22000H~2200FH范围的栈进行操作，需首先初始化 SS指向2200H，初始化SP指向000FH+1=0100H。</p><h3 id="PUSH-amp-POP"><a href="#PUSH-amp-POP" class="headerlink" title="PUSH&amp;POP"></a>PUSH&amp;POP</h3><p>PUSH指令执行过程分为两步：首先执行<code>SP = SP-2</code>，使SP指向新的栈顶元素；随后向<code>SS:SP</code>指向的字单元中送入数据。POP指令执行过程同样分为两步：首先从<code>SS:SP</code>指向的字单元中读取数据；随后执行<code>SP = SP-2</code>移动SP指针。</p><p>可以看出，PUSH和POP等栈操作指令修改的只是SP寄存器，也就是说栈顶的变化范围最大为0~FFFFH。</p><p><strong>当栈满的时候再次使用PUSH指令入栈，或栈空的时候再次使用POP指令出栈，都将发生栈顶越界问题</strong>。</p><h2 id="0x05-段的综述"><a href="#0x05-段的综述" class="headerlink" title="0x05 段的综述"></a>0x05 段的综述</h2><p>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。根据使用者的初始化情况，一段内存可以作为代码的存储空间、数据的存储空间和栈空间，并支持这三类空间类型的组合。</p><ul><li><p>数据段</p><p>数据段的地址放在DS中，使用mov、add、sub等访问内存单元的指令时，CPU就将指定内存单元中的内容作为数据来处理。</p></li><li><p>代码段</p><p>代码段的段地址放在CS中，段中第一条指令的偏移地址放在IP中，CPU将执行指定内存单元中的指令。</p></li><li><p>栈段</p><p>栈段的段地址 放在SS中，栈顶单元的偏移地址放在SP中，CPU在执行PUSH、POP等栈操作时就将指定内存单元作为栈空间使用。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-基础知识&quot;&gt;&lt;a href=&quot;#0x00-基础知识&quot; class=&quot;headerlink&quot; title=&quot;0x00 基础知识&quot;&gt;&lt;/a&gt;0x00 基础知识&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Central Processing Unit为中央处理单元，简称CPU
      
    
    </summary>
    
      <category term="Binary" scheme="https://blank-vax.github.io/categories/Binary/"/>
    
    
      <category term="IoT Foundation" scheme="https://blank-vax.github.io/tags/IoT-Foundation/"/>
    
      <category term="Assembly" scheme="https://blank-vax.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>基于配对的密码学——基础知识及JPBC库</title>
    <link href="https://blank-vax.github.io/2021/07/05/%E5%9F%BA%E4%BA%8E%E9%85%8D%E5%AF%B9%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8AJPBC%E5%BA%93/"/>
    <id>https://blank-vax.github.io/2021/07/05/基于配对的密码学——基础知识及JPBC库/</id>
    <published>2021-07-05T03:46:00.000Z</published>
    <updated>2021-07-06T15:53:21.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本科毕业设计过程中需要使用JPBC库实现Java语言下双线性配对运算的仿真，摸索过程中遇到一些问题及特性，记录如下。本文参考李发根等编著的《基于配对的密码学》一书，首先简要介绍基于配对密码学的相关性质，随后结合JPBC文档介绍该库中部分函数的特殊性质及用法。</p><p>参考链接：</p><ul><li><p>《基于配对的密码学》</p><p>链接：<a href="https://pan.baidu.com/s/1bocycprbAUtNzCopkF1v-A" target="_blank" rel="noopener">https://pan.baidu.com/s/1bocycprbAUtNzCopkF1v-A</a>  提取码：oe09 </p></li><li><p>JPBC jar包</p><p>链接：<a href="https://pan.baidu.com/s/1MOZCaplESGF0gVk5dNeLGQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1MOZCaplESGF0gVk5dNeLGQ</a>  提取码：sa5m </p></li><li><p>JPBC DOCS</p><p>链接：<a href="http://gas.dia.unisa.it/projects/jpbc" target="_blank" rel="noopener">http://gas.dia.unisa.it/projects/jpbc</a></p></li></ul><h2 id="0x01-椭圆曲线密码体制"><a href="#0x01-椭圆曲线密码体制" class="headerlink" title="0x01 椭圆曲线密码体制"></a>0x01 椭圆曲线密码体制</h2><p>椭圆曲线密码体制（elliptic curve cryptosystem, ECC）是公钥密码体制的一个重要分支，其安全性基于椭圆曲线离散对数问题的困难性。该问题比大整数因子分解问题和有限域上的离散对数问题难得多。由于还没有找到求解椭圆曲线离散对数的亚指数算法，因此椭圆曲线密码体制可使用更短的密钥以保证相同的安全性。</p><h3 id="有限域上的椭圆曲线"><a href="#有限域上的椭圆曲线" class="headerlink" title="有限域上的椭圆曲线"></a>有限域上的椭圆曲线</h3><p>有限域上的椭圆曲线是指变量和系数均为有限域中元素的椭圆曲线。有限域$GF(p)$上的椭圆曲线是指满足方程</p><script type="math/tex; mode=display">y^2 \equiv x^3+ax+b(mod  p)</script><p>的所有点$(x,y)$及一个无穷远点O构成的集合，其中a,b,x和y均在有限域$GF(p)$上取值，p是素数。这里将该椭圆曲线记为$E_p(a,b)$，曲线上只有有限个点，其个数N由Hasse定理确定。</p><p><strong>Hasse定理</strong> 设E是有限域$GF(p)$上的椭圆曲线，N是E上点的个数，则满足</p><script type="math/tex; mode=display">p+1-2\sqrt(p) \leq N \leq p+1+2\sqrt(p)</script><p>当$4a^3+27b^2(mod p) \neq 0$时，基于集合$E_p(a,b)$可以定义一个Abel群，其加法规则与实数域上描述的代数方法一致。设$P,Q \in E_p(a,b)$，则</p><script type="math/tex; mode=display">P+O=P</script><ul><li><p>如果$P = (x,y)$，那么$(x,y) + (x,-y) = O$，即点(x,-y)是P的加法逆元，表示为-P。</p></li><li><p>设$P=(x_1,y_1)$和$Q=(x_2,y_2)$,$P \neq -Q$，则$S = P+Q = (x_3,y_3)$由以下规则确定：</p><script type="math/tex; mode=display">x_3 \equiv \lambda^2 - x_1 - x_2 (mod p)</script><script type="math/tex; mode=display">y_3 \equiv \lambda(x_1-x_3) - y_1 (mod p)</script><p>式中</p><script type="math/tex; mode=display">\lambda \equiv (y_2-y_1)/(x_2-x_1) (mod p), if P \neq Q</script><script type="math/tex; mode=display">\lambda \equiv (3x_1^2+a)/2y_1 (mod p), if P = Q</script></li><li><p>倍点运算定义为重复加法，即$3P = P+P+P$。</p></li></ul><h3 id="椭圆曲线上的ElGamal加密体制"><a href="#椭圆曲线上的ElGamal加密体制" class="headerlink" title="椭圆曲线上的ElGamal加密体制"></a>椭圆曲线上的ElGamal加密体制</h3><ul><li><p>定义1 椭圆曲线的阶</p><p>椭圆曲线$E_p(a,b)$上点P的阶是指满足</p><script type="math/tex; mode=display">nP = \sum^{n}P = O</script><p>的最小正整数，记为$ord(P)$，其中O是无穷远点。</p></li><li><p>定义2 椭圆曲线上离散对数问题</p><p>设G是椭圆曲线$E_p(a,b)$上的一个循环子群，P是G的一个生成元，$Q \in G$。已知P和Q，求满足</p><script type="math/tex; mode=display">mP = Q</script><p>的整数m，$0 \leq m \leq ord(P)-1$，称为椭圆曲线上的离散对数问题（elliptic curve discrete logarithm problem, ECDLP）。计算$mP$的过程称为点乘运算。</p></li></ul><p>EC-ElGamal密码体制包含以下四个元操作：</p><ul><li><p>编码与解码</p><p>将待发送的明文m<strong>编码</strong>为椭圆曲线上的点$P_m = (x_m, y_m)$，随后执行的加解密操作均针对点$P_m$，解密后的点$P_m$需执行<strong>逆向解码</strong>操作才可以获得明文。</p></li><li><p>密钥生成</p><p>在椭圆曲线$E_p(a,b)$上选取一个阶为大素数n的生成元P。随机选取整数x满足$1 &lt; x &lt; n$，计算$Q = xP$，将x作为私钥，Q作为公钥。</p></li><li><p>加密</p><p>为加密$P_m$，随机选取一个整数k满足$1 &lt; k &lt; n$，计算</p><script type="math/tex; mode=display">C_1 = kP, C_2 = P_m+kQ</script><p>则密文$c =(C_1, C_2)$。</p></li><li><p>解密</p><p>为解密密文$c = (C_1, C_2)$，计算</p><script type="math/tex; mode=display">C_2 - xC_1 = P_m+kQ-xkP = P_m+kxP-xkP = P_m</script><p>攻击者若妄图通过$c = (C_1,C_2)$计算出$P_m$，则必须获得k。攻击者需要通过P和kP推算出k的值，这一过程面临求解椭圆曲线上的离散对数问题。</p></li></ul><h2 id="0x02-双线性配对理论"><a href="#0x02-双线性配对理论" class="headerlink" title="0x02 双线性配对理论"></a>0x02 双线性配对理论</h2><h3 id="抽象双线性配对"><a href="#抽象双线性配对" class="headerlink" title="抽象双线性配对"></a>抽象双线性配对</h3><p>设k为安全参数，p为k比特长的素数。令$G_1$为由P生成的循环加法群，阶为p，$G_T$为具有相同阶p的循环乘法群，a，b是$Z_p^*$中的元素。0表示$G_1$中的单位元，1表示$G_T$中的单位元。假设$G_1$和$G_T$这两个群中的离散对数问题都是困难问题。双线性配对是指满足下列性质的映射$e: G_1 \times G_1 \rightarrow G_T$。</p><ul><li>双线性性（bilinearity）：对于任意的$P,Q \in G_1$和$a, b \in Z_p^*$，$e(aP, bQ) = e(P, Q)^{ab}$成立。</li><li>非退化性（non-degeneracy）：存在$P, Q \in G_1$，使得$e(P, Q) \neq 1$。同时，满足$e(0, Q) = e(Q, 0) = 1$。</li><li>可计算性（computability）：对于所有$P, Q \in G_1$，存在有效的算法计算$e(P, Q)$。</li></ul><p>双线性映射可以通过有限域上的超奇异椭圆曲线或超奇异超椭圆曲线中的Weil配对或Tate配对推导出来。</p><h3 id="非对称双线性配对"><a href="#非对称双线性配对" class="headerlink" title="非对称双线性配对"></a>非对称双线性配对</h3><p>设计密码体制时，有时会遇到非对称的配对。</p><p>令$G_1, G_2, G_T$为具有相同阶p的群，P为$G_1$的生成元，Q为$G_2$的生成元。非对称双线性配对指满足下列性质的一个映射：$e: G_1 \times G_2 \rightarrow G_T$。</p><ul><li>双线性性：对于任意$(S, T) \in G_1 \times G_2$和$a, b \in Z_p^*$，$e(aS, bT) = e(S, T)^{ab}$成立。</li><li>非退化性：存在$(S, T) \in G_1 \times G_2$，使得$e(S, T) \neq 1$。</li><li>可计算性：对于所有的$(S, T) \in G_1 \times G_2$，存在有效算法计算$e(S, T)$。</li><li>存在一个有效的、可公开计算的同构映射$\phi:G_2 \rightarrow G_1$，满足$\phi(Q) = P$。这个映射必须是不可逆的。</li></ul><p>若令$G_2 = G_1$且映射$\phi$为恒等映射，此时非对称配对就变成了对称配对。尽管对称配对比较简单且应用方便，但只能从超奇异超椭圆曲线中的Weil配对或Tate配对推导出来。非对称配对比较复杂，但不仅可以从超奇异超椭圆曲线中推导出来，还可以从普通椭圆曲线中的Weil配对或Tate配对推导出来。</p><h2 id="0x03-困难问题"><a href="#0x03-困难问题" class="headerlink" title="0x03 困难问题"></a>0x03 困难问题</h2><h3 id="计算Diffie-Hellman问题"><a href="#计算Diffie-Hellman问题" class="headerlink" title="计算Diffie-Hellman问题"></a>计算Diffie-Hellman问题</h3><p>给定一个阶为p的循环加法群$G_1$和一个生成元P，$G_1$中的计算Diffie-Hellman（computational Diffie-Hellman，CDH）问题是给定$(P, aP, bP)$，计算$abP \in G_1$。这里$a, b \in Z_p^*$是未知整数。</p><h3 id="判定Diffie-Hellman问题"><a href="#判定Diffie-Hellman问题" class="headerlink" title="判定Diffie-Hellman问题"></a>判定Diffie-Hellman问题</h3><p>给定一个阶为p的循环加法群$G_1$和一个生成元P，$G_1$中的判定Diffie-Hellman（decisional Diffie-Hellman，DDH）问题是给定$(P, aP, bP, cP)$，判断$c \equiv ab mod p$是否成立。这里$a, b, c \in Z_p^*$是未知整数。若$(P, aP, bP, cP)$满足上述条件，则称其为一个”Diffie-Hellman元组”，可采用记号$cP = DH_p(aP, bP)$来表示。</p><h3 id="间隙Diffie-Hellman问题"><a href="#间隙Diffie-Hellman问题" class="headerlink" title="间隙Diffie-Hellman问题"></a>间隙Diffie-Hellman问题</h3><p>给定一个阶为p的循环加法群$G_1$和一个生成元P，$G_1$中的间隙Diffie-Hellman（gap Diffie-Hellman，GDH）问题是在DDH预言机的帮助下，求解一个给定元组$(P, aP, bP)$的CDH问题。DDH预言机可以判断$(P, aP, bP, cP)$是否满足$c \equiv ab mod p$。</p><h3 id="q-强Diffie-Hellman问题"><a href="#q-强Diffie-Hellman问题" class="headerlink" title="q-强Diffie-Hellman问题"></a>q-强Diffie-Hellman问题</h3><p>给定一个阶为p的循环加法群$G_1$和一个生成元P，$G_1$中的q-强Diffie-Hellman（q-strong Diffie-Hellman，q-SDH）问题是给定$(P, xP, x^2P, … , x^qP)$，计算</p><script type="math/tex; mode=display">(c, P/(x+c)) \in Z_p \times G_1</script><h3 id="双线性Diffie-Hellman问题"><a href="#双线性Diffie-Hellman问题" class="headerlink" title="双线性Diffie-Hellman问题"></a>双线性Diffie-Hellman问题</h3><p>给定两个阶都为p的循环加法群$G_1$和循环乘法群$G_T$，一个双线性映射$e:G_1 \times G_1 \rightarrow G_T$和一个群$G_1$的生成元P，双线性Diffie-Hellman（bilinear Diffie-Hellman，BDH）问题是给定$(P, aP, bP, cP)$，计算$e(P, P)^{abc} \in G_T$。这里的$a, b, c \in Z_p^*$是未知整数。</p><h3 id="判定双线性Diffie-Hellman问题"><a href="#判定双线性Diffie-Hellman问题" class="headerlink" title="判定双线性Diffie-Hellman问题"></a>判定双线性Diffie-Hellman问题</h3><p>给定两个阶都为p的循环加法群$G_1$和循环乘法群$G_T$，一个双线性映射$e:G_1 \times G_1 \rightarrow G_T$和一个群$G_1$的生成元P，判定双线性Diffie-Hellman（decisional bilinear Diffie-Hellman，DBDH）问题是给定$(P, aP, bP, cP)$和$z \in G_T$，判断</p><script type="math/tex; mode=display">z = e(P, P)^{abc}</script><p>是否成立。这里的$a, b, c \in Z_p^*$是未知整数。</p><h3 id="间隙双线性Diffie-Hellman问题"><a href="#间隙双线性Diffie-Hellman问题" class="headerlink" title="间隙双线性Diffie-Hellman问题"></a>间隙双线性Diffie-Hellman问题</h3><p>给定两个阶都为p的循环加法群$G_1$和循环乘法群$G_T$，一个双线性映射$e:G_1 \times G_1 \rightarrow G_T$和一个群$G_1$的生成元P，间隙双线性Diffie-Hellman（gap bilinear Diffie-Hellman，GBDH）问题是在DBDH预言机的帮助下，求解一个给定元组$(P, aP, bP, cP)$的BDH问题。DBDH预言机可以判断一个元组$(P, aP, bP, cP, z)$是否满足</p><script type="math/tex; mode=display">z = e(P, P)^{abc}</script><p>上述问题通常被视为困难问题，但其困难程度不尽相同。显然，判定问题不比计算问题更难，即如果能够求解CDH问题，那么DDH问题就容易解决；同样如果能够求解BDH问题，那么DBDH问题就容易解决。</p><h2 id="0x04-JPBC库"><a href="#0x04-JPBC库" class="headerlink" title="0x04 JPBC库"></a>0x04 JPBC库</h2><p>PBC库（pairing-based cryptography library）是斯坦福大学研究人员开发的一个免费可移植C语言库。它通过提供一个抽象的接口，使程序设计人员可以不必考虑具体的数学细节，甚至不必考虑椭圆曲线和数论的相关知识就可以实现基于配对的密码体制。JPBC库（Java Pairing-Based Cryptography Library）是对PBC库的Java封装，常用于基于配对的密码学算法仿真程序编写中。</p><p>该库提供的各类API结构如下。</p><p><img src="/2021/07/05/基于配对的密码学——基础知识及JPBC库/5.PNG" alt="API Structure"></p><h3 id="入门教程"><a href="#入门教程" class="headerlink" title="入门教程"></a>入门教程</h3><p>除JPBC文档外，整理一些优秀视频及技术博客，链接如下：</p><p><a href="https://www.bilibili.com/video/av456320837/" target="_blank" rel="noopener">JPBC库（基于配对的密码学）入门和避坑指南</a></p><p><a href="https://www.bilibili.com/video/BV1jA41147vt" target="_blank" rel="noopener">JPBC库应用之BLS签名</a></p><p><a href="https://blog.csdn.net/qq_41359358/category_10659429.html" target="_blank" rel="noopener">CSDN JPBC Library 专栏</a></p><p><a href="https://blog.csdn.net/liuweiran900217" target="_blank" rel="noopener">刘巍然大佬的博客</a></p><h3 id="群上点的特性"><a href="#群上点的特性" class="headerlink" title="群上点的特性"></a>群上点的特性</h3><p>JPBC库共提供四个循环群，其中$G_1,G_2,G_T$均为阶为p的乘法循环群，而$Z_p$为整数域上的加法循环群。乘法循环群上的点是z值为0的椭圆曲线上的点，而整数循环群上的点是数，二者均可抽象为<code>Element</code>数据类型并用于仿真中。生成测试元素并打印，结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成测试元素</span></span><br><span class="line">Element g1 = G1.newRandomElement();</span><br><span class="line">System.out.println(g1);</span><br><span class="line">Element g2 = G2.newRandomElement();</span><br><span class="line">System.out.println(g2);</span><br><span class="line">Element gt = Gt.newRandomElement();</span><br><span class="line">System.out.println(gt);</span><br><span class="line">Element zp = Zr.newRandomElement();</span><br><span class="line">System.out.println(zp);</span><br></pre></td></tr></table></figure><p><img src="/2021/07/05/基于配对的密码学——基础知识及JPBC库/1.PNG" alt="Characteristic of point in group"></p><h3 id="群运算"><a href="#群运算" class="headerlink" title="群运算"></a>群运算</h3><p>JPBC库支持的运算如下：</p><ul><li>$G_1,G_2,G_T$中元素的模幂运算、倍乘运算以及互相之间的加法运算，运算结果均为对应群上的元素。</li><li>$Z_p$中元素的加减乘除运算及乘方运算，运算结果为整数循环群上的元素。</li></ul><p>测试相关运算，并打印对应结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相关运算</span></span><br><span class="line">Element a = Zr.newRandomElement();</span><br><span class="line">Element b = Zr.newRandomElement();</span><br><span class="line"><span class="comment">// 1. g1^a</span></span><br><span class="line">Element g1_pow_a = g1.duplicate().powZn(a);</span><br><span class="line">System.out.println(<span class="string">"g1^a"</span>);</span><br><span class="line">System.out.println(g1_pow_a);</span><br><span class="line"><span class="comment">// 2. a*g1</span></span><br><span class="line">Element g1_mul_a = g1.duplicate().mulZn(a);</span><br><span class="line">System.out.println(<span class="string">"a*g1"</span>);</span><br><span class="line">System.out.println(g1_mul_a);</span><br><span class="line"><span class="comment">// 3. g1+g2</span></span><br><span class="line">Element g1_add_g2 = g1.duplicate().add(g2);</span><br><span class="line">System.out.println(<span class="string">"g1+g2"</span>);</span><br><span class="line">System.out.println(g1_add_g2);</span><br><span class="line"><span class="comment">// 4. gt^b</span></span><br><span class="line">Element gt_pow_b = gt.duplicate().powZn(b);</span><br><span class="line">System.out.println(<span class="string">"gt^b"</span>);</span><br><span class="line">System.out.println(gt_pow_b);</span><br><span class="line"><span class="comment">// 5. b*gt</span></span><br><span class="line">Element gt_mul_b = gt.duplicate().mulZn(b);</span><br><span class="line">System.out.println(<span class="string">"b*gt"</span>);</span><br><span class="line">System.out.println(gt_mul_b);</span><br><span class="line"><span class="comment">// 6. gt+gt</span></span><br><span class="line">Element gt_add_gt = gt.duplicate().add(gt);</span><br><span class="line">System.out.println(<span class="string">"gt+gt"</span>);</span><br><span class="line">System.out.println(gt_add_gt);</span><br><span class="line"><span class="comment">// 7. a+b</span></span><br><span class="line">Element a_add_b = a.duplicate().add(b);</span><br><span class="line">System.out.println(<span class="string">"a+b"</span>);</span><br><span class="line">System.out.println(a_add_b);</span><br><span class="line"><span class="comment">// 8. a*b</span></span><br><span class="line">Element a_mul_b = a.duplicate().mulZn(b);</span><br><span class="line">System.out.println(<span class="string">"a*b"</span>);</span><br><span class="line">System.out.println(a_mul_b);</span><br></pre></td></tr></table></figure><p><img src="/2021/07/05/基于配对的密码学——基础知识及JPBC库/2.PNG" alt="2.PNG-77.4kB"></p><p><strong>值得注意的是</strong>，现在的密码学相关论文中，习惯将$G_1, G_2$设置为乘法循环群。但是基于椭圆曲线的双线性群构造中，$G_1, G_2$是加法循环群。所以在2005年以前的论文中，双线性群一般写成加法群的形式。JPBC库中将$G_1, G_2$表示成了乘法循环群，因此在加法循环群形式方案的仿真过程中，应特别注意将加法群改写为乘法群的写法再完成进一步仿真。由于加法群中的加法运算对应乘法群中的乘法运算，减法运算对应除法运算（即求逆元），乘法运算对应幂指数运算，而除法运算对应对数运算。故改写过程需要结合以上运算法则。</p><h3 id="初始化双线性群"><a href="#初始化双线性群" class="headerlink" title="初始化双线性群"></a>初始化双线性群</h3><p>双线性群（即椭圆曲线）的初始化在JPBC中表现为对Pairing对象的初始化。JPBC库支持A、A1、D、E、F、G六种椭圆曲线，对比如下。我们可以通过代码动态产生和从文件中读取相关参数这两种方法完成上述初始化过程。</p><p><img src="/2021/07/05/基于配对的密码学——基础知识及JPBC库/4.PNG" alt="4.PNG-38.7kB"></p><h4 id="代码动态产生"><a href="#代码动态产生" class="headerlink" title="代码动态产生"></a>代码动态产生</h4><p>动态产生的方法大概包括以下几个步骤：</p><ul><li>指定椭圆曲线的种类</li><li>产生椭圆曲线参数</li><li>初始化Pairing对象</li></ul><p>Type A曲线初始化过程中需要提供两个参数：<code>rBit</code>代表$Z_p$中阶数p的比特长度，<code>qBit</code>代表$G$中阶数的比特长度，生成代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TypeACurveGenerator pg = <span class="keyword">new</span> TypeACurveGenerator(rBit, qBit);</span><br><span class="line">PairingParameters typeAParams = pg.generate();</span><br><span class="line">Pairing bp = PairingFactory.getPairing(typeAParams);</span><br></pre></td></tr></table></figure><p>Type A1曲线需要提供两个参数：<code>numPrime</code>是阶数N中包含质数因子的数量，<code>qBit</code>是每个质数因子的比特长度。由于Type A1曲线涉及到的阶数较大，故参数产生的时间较长，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TypeA1CurveGenerator pg = <span class="keyword">new</span> TypeA1CurveGenerator(numPrime, qBit);</span><br><span class="line">PairingParameters typeA1Params = pg.generate();</span><br><span class="line">Pairing pairing = PairingFactory.getPairing(typeA1Params);</span><br></pre></td></tr></table></figure><h4 id="文件读取产生"><a href="#文件读取产生" class="headerlink" title="文件读取产生"></a>文件读取产生</h4><p>当然我们可以选择事先生成参数并存放至文件中。在后续初始化过程中直接从文件中读取参数，就可以快速地完成双线性群的初始化过程。</p><p>可以利用Princeton大学封装的文件输出库将初始化后的椭圆曲线对象<code>PairingParameters</code>封装至<code>x.properties</code>文件中。后续使用过程中直接从对应配置文件中读取即可还原。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type A曲线</span></span><br><span class="line">TypeACurveGenerator pg = <span class="keyword">new</span> TypeACurveGenerator(rBit, qBit);</span><br><span class="line"><span class="comment">// Type A1曲线</span></span><br><span class="line">TypeA1CurveGenerator pg = <span class="keyword">new</span> TypeA1CurveGenerator(numPrimes, qBit);</span><br><span class="line">PairingParameters typeAParams = pg.generate();</span><br><span class="line"><span class="comment">//将参数写入文件a.properties中，使用Princeton大学封装的文件输出库</span></span><br><span class="line">Out out = <span class="keyword">new</span> Out(<span class="string">"a.properties"</span>);</span><br><span class="line">out.println(typeAParams);</span><br><span class="line"><span class="comment">//从文件a.properties中读取参数初始化双线性群</span></span><br><span class="line">Pairing pairing = PairingFactory.getPairing(<span class="string">"a.properties"</span>);</span><br></pre></td></tr></table></figure><h3 id="随机数内部机制"><a href="#随机数内部机制" class="headerlink" title="随机数内部机制"></a>随机数内部机制</h3><p>重点关注椭圆曲线循环群初始化过程中的相关事项。当确定椭圆曲线参数后重复调用<code>getG1()</code>，<code>newElement()</code>和<code>newRandomElement()</code>方法，验证生成结果是否相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Group_Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Pairing bp = PairingFactory.getPairing(<span class="string">"a.properties"</span>);</span><br><span class="line">        Field G1 = bp.getG1();</span><br><span class="line">        Field G3 = bp.getG1();</span><br><span class="line"></span><br><span class="line">        Element g_1 = G1.newElement();</span><br><span class="line">        Element g_2 = G1.newElement();</span><br><span class="line"></span><br><span class="line">        Element g_3 = G1.newRandomElement();</span><br><span class="line">        Element g_4 = G1.newRandomElement();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(G1.equals(G3))&#123;</span><br><span class="line">            System.out.println(<span class="string">"YES1!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"Nope!!!"</span>);</span><br><span class="line">        <span class="keyword">if</span>(g_1.equals(g_2))&#123;</span><br><span class="line">            System.out.println(<span class="string">"YES2!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"Nope!!!"</span>);</span><br><span class="line">        <span class="keyword">if</span>(g_3.equals(g_4))&#123;</span><br><span class="line">            System.out.println(<span class="string">"YES3!!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"Nope!!!"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行以上程序，结果如下：</p><p><img src="/2021/07/05/基于配对的密码学——基础知识及JPBC库/3.PNG" alt="3.PNG-14kB"></p><p>可以看出，使用<code>PairingFactory.getPairing(filename)</code>函数导入特定参数的椭圆曲线后，每次调用<code>getG1()</code>函数生成的循环群都是相同的，故可以通过保存椭圆曲线参数至<code>xxx.properties</code>文件并导入这一操作实现循环群的保存。</p><p>对于群$G_1$，每次调用<code>G1.newElement()</code>函数生成的生成元g都是相同的。然而调用<code>G1.newRandomElement()</code>函数随机获取的群上元素则是不同的。</p><h3 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h3><p>该部分总结利用JPBC库编写算法仿真程序过程中需要用到的工具函数。代码如下：</p><h4 id="String-amp-Byte"><a href="#String-amp-Byte" class="headerlink" title="String&amp;Byte"></a>String&amp;Byte</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//16进制的byte[]数组转换为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hexBytesToString</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] hexChars = <span class="keyword">new</span> <span class="keyword">char</span>[bytes.length * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bytes.length; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = bytes[j] &amp; <span class="number">0xFF</span>;</span><br><span class="line">        hexChars[j * <span class="number">2</span>] = HEX_ARRAY[v &gt;&gt;&gt; <span class="number">4</span>];</span><br><span class="line">        hexChars[j * <span class="number">2</span> + <span class="number">1</span>] = HEX_ARRAY[v &amp; <span class="number">0x0F</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(hexChars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//16进制的字符串转换为byte[]数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] hexStringToBytes(String s) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[len / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span>) &#123;</span><br><span class="line">        data[i / <span class="number">2</span>] = (<span class="keyword">byte</span>) ((Character.digit(s.charAt(i), <span class="number">16</span>) &lt;&lt; <span class="number">4</span>)                             + Character.digit(s.charAt(i+<span class="number">1</span>), <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取特定元素"><a href="#获取特定元素" class="headerlink" title="获取特定元素"></a>获取特定元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//G1中获取随机元素，获取1，获取0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">getRandomFromG1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pairing.getG1().newRandomElement().getImmutable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">getOneFromG1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pairing.getG1().newOneElement().getImmutable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">getZeroFromG1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pairing.getG1().newZeroElement().getImmutable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Zr中获取随机元素，获取1，获取0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">getRandomFromZp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pairing.getZr().newRandomElement().getImmutable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">getOneFromZp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pairing.getZr().newOneElement().getImmutable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">getZeroFromZp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pairing.getZr().newZeroElement().getImmutable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="哈希映射"><a href="#哈希映射" class="headerlink" title="哈希映射"></a>哈希映射</h4><ul><li><p>$H_0: {0, 1}^* \rightarrow Z_p $</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">hashFromStringToZp</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pairing.getZr().newElement().setFromHash(str.getBytes(), <span class="number">0</span>, str.length()).getImmutable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">hashFromBytesToZp</span><span class="params">( <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pairing.getZr().newElement().setFromHash(bytes, <span class="number">0</span>, bytes.length).getImmutable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>$H_1: {0, 1}^* \rightarrow G_1$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">hashFromStringToG1</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pairing.getG1().newElement().setFromHash(str.getBytes(), <span class="number">0</span>, str.length()).getImmutable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">hashFromBytesToG1</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pairing.getG1().newElement().setFromHash(bytes, <span class="number">0</span>, bytes.length).getImmutable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>$H_2: G_1 \rightarrow Z_p$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">hashFromG1ToZp</span><span class="params">( Element g1_element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// h(y) : G1 -&gt; Zp</span></span><br><span class="line">    <span class="keyword">byte</span>[] g1_bytes = g1_element.getImmutable().toCanonicalRepresentation();       <span class="keyword">byte</span>[] zp_bytes = g1_bytes;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MessageDigest hasher = MessageDigest.getInstance(<span class="string">"SHA-512"</span>);</span><br><span class="line">        zp_bytes = hasher.digest(g1_bytes);   <span class="comment">//先把G1元素hash成512bits</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再把hash后的bits映射到Zp</span></span><br><span class="line">    Element hash_result = pairing.getZr().newElementFromHash(zp_bytes, <span class="number">0</span>, zp_bytes.length).getImmutable();</span><br><span class="line">    <span class="keyword">return</span> hash_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>$H_{ch}: G_T \rightarrow Z_p$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">transformFromGtToZp</span><span class="params">(Element pairing_result)</span></span>&#123;  </span><br><span class="line">    BigInteger pairing_params = pairing_result.toBigInteger();</span><br><span class="line">    <span class="keyword">return</span> pairing.getZr().newElement().set(pairing_params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Element-I-O"><a href="#Element-I-O" class="headerlink" title="Element I/O"></a>Element I/O</h4><ul><li><p>定义<code>writeElement(Element elem, String filename, Pairing pairing)</code>函数，实现将<code>Element</code>对象写入文件。该函数的三个参数分别为待写入的<code>Element</code>对象，写入文件路径以及对象所在椭圆曲线。返回结果为<code>void</code>类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeElement</span><span class="params">(Element elem, String filename, Pairing pairing)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DataOutputStream dOut = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"Parameters_file/"</span>+filename+<span class="string">".dat"</span>));  </span><br><span class="line">    dOut.writeBoolean(elem == <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (elem == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dOut.writeInt(pairing.getFieldIndex(elem.getField()));</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = elem.toBytes();</span><br><span class="line">    dOut.writeInt(bytes.length);</span><br><span class="line">    dOut.write(bytes);</span><br><span class="line">    <span class="comment">// this is a workaround because it.unisa.dia.gas.plaf.jpbc.field.curve.CurveElement does not serialize the infFlag</span></span><br><span class="line">    dOut.writeBoolean(elem <span class="keyword">instanceof</span> CurveElement &amp;&amp; elem.isZero());</span><br><span class="line">    <span class="keyword">if</span> (elem <span class="keyword">instanceof</span> CurveElement &amp;&amp; elem.isZero()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Infinite element detected. They should not happen."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义<code>readElement(String filename, Pairing pairing)</code>函数，实现从文件中读取<code>Element</code>对象。该函数的两个参数为读取文件路径和对象所在椭圆曲线，返回结果为<code>Element</code>类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Element <span class="title">readElement</span><span class="params">(String filename, Pairing pairing)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DataInputStream dIn = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"Parameters_file/"</span>+filename+<span class="string">".dat"</span>));</span><br><span class="line">    <span class="keyword">if</span> (dIn.readBoolean()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> fieldIndex = dIn.readInt(); <span class="comment">// <span class="doctag">TODO:</span> check if this is in a sensible range</span></span><br><span class="line">    <span class="keyword">int</span> length = dIn.readInt(); <span class="comment">// <span class="doctag">TODO:</span> check if this is in a sensible range</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">    dIn.readFully(bytes); <span class="comment">// throws an exception if there is a premature EOF </span></span><br><span class="line">    Element e = pairing.getFieldAt(fieldIndex).newElementFromBytes(bytes);        <span class="comment">// this is a workaround because it.unisa.dia.gas.plaf.jpbc.field.curve.CurveElement does not serialize the infFlag</span></span><br><span class="line">    <span class="keyword">boolean</span> instOfCurveElementAndInf = dIn.readBoolean();</span><br><span class="line">    <span class="keyword">if</span> (instOfCurveElementAndInf) &#123;</span><br><span class="line">        <span class="comment">//e.setToZero(); // according to the code this simply sets the infFlag to 1</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"The point is infinite. This shouldn't happen."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="函数运行效率"><a href="#函数运行效率" class="headerlink" title="函数运行效率"></a>函数运行效率</h3><p>结合文章《jPBC: java Pairing Based Cryptography》，比较jPBC和PBC之间的运算效率。用于比较效率的计算机配置为Intel@R CoreTM2 Quad CPU Q6600，2.40GHz，3 GB 内存，Ubuntu 10.04系统。JDK版本是Oracle jdk1.6.0 20。结果如下。</p><p><img src="/2021/07/05/基于配对的密码学——基础知识及JPBC库/6.PNG" alt="6.PNG-72.8kB"></p><p>可以看出，由于Java语言特性的限制，JPBC库在处理乘法循环群上运算及配对运算方面效率远低于PBC库，但在处理整数循环群上运算方面效率高于PBC库。显然，可以通过预处理的方法提高JPBC库对应函数的运行效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;本科毕业设计过程中需要使用JPBC库实现Java语言下双线性配对运算的仿真，摸索过程中遇到一些问题及
      
    
    </summary>
    
      <category term="Crypto_Knowledge" scheme="https://blank-vax.github.io/categories/Crypto-Knowledge/"/>
    
    
      <category term="JPBC" scheme="https://blank-vax.github.io/tags/JPBC/"/>
    
      <category term="Pairing Based Cryptography" scheme="https://blank-vax.github.io/tags/Pairing-Based-Cryptography/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer刷题记录（一）</title>
    <link href="https://blank-vax.github.io/2021/02/04/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://blank-vax.github.io/2021/02/04/剑指offer刷题记录（一）/</id>
    <published>2021-02-03T16:39:00.000Z</published>
    <updated>2021-07-07T12:45:55.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>寒假赋闲在家，搞科研的同时希望提升一下自己的代码水平，于是回到阔别已久的LeetCode平台开始刷题。这次选择了剑指offer系列题目，编程语言采用Java。话不多说，直接开刷。</p><h2 id="0x01-数组中重复的数字"><a href="#0x01-数组中重复的数字" class="headerlink" title="0x01 数组中重复的数字"></a>0x01 数组中重复的数字</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3</span><br></pre></td></tr></table></figure><p>限制：</p><p><code>2 &lt;= n &lt;= 100000</code></p><h3 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h3><p>题目仅要求输出一个多次出现的数字，故自然联想到使用哈希表。完成建表之后对题目提供的数组进行一次遍历即可。该方法时间复杂度为O(N)，空间复杂度为哈希表所占的额外空间O(N)。</p><p>注意题目给出的特殊条件：<strong>长度为n的数组里所有数字在0—n-1范围内</strong>。该条件说明若数组中不包含重复元素，则数组下标与元素值是一一对应的关系，即<code>nums[i]==i</code>成立。于是引入原地置换的算法，提升程序运行效率，具体算法如下：</p><p>遍历数组nums，设置初始索引为i=0：</p><ul><li>若<code>nums[i] == i</code>，说明数字与索引位置正确对应，无需交换，跳过该索引；</li><li>若<code>nums[nums[i]] == nums[i]</code>，说明索引nums[i]及索引i处元素值相同，返回该重复值即可；</li><li>否则交换索引为i和nums[i]的元素值，将此数字交换至对应索引的位置。</li></ul><p>若遍历完毕尚未返回任何值，则返回-1表示元素与索引一一对应。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] != i)&#123;</span><br><span class="line">                <span class="keyword">int</span> m = nums[i];</span><br><span class="line">                <span class="keyword">if</span>(nums[m] == m)&#123;</span><br><span class="line">                    <span class="keyword">return</span> m;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    temp = nums[m];</span><br><span class="line">                    nums[m] = nums[i];</span><br><span class="line">                    nums[i] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度$O(N)$。</li><li>空间复杂度$O(1)$：该算法提供原地置换，无需开辟新的存储空间。</li></ul><h2 id="0x02-二维数组中的查找"><a href="#0x02-二维数组中的查找" class="headerlink" title="0x02 二维数组中的查找"></a>0x02 二维数组中的查找</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>示例:</p><p>现有矩阵 matrix 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>给定 target = 5，返回<code>true</code>。</p><p>给定 target = 20，返回<code>false</code>。</p><p>限制：</p><p><code>0 &lt;= n &lt;= 1000</code></p><p><code>0 &lt;= m &lt;= 1000</code></p><h3 id="算法详解-1"><a href="#算法详解-1" class="headerlink" title="算法详解"></a>算法详解</h3><p>该题目将普通元素查找扩展至二维数组，最简单的方法为两次循环遍历，时间复杂度为O(N*M)，其中N，M分别为二维数组的行数与列数。显然该解法没有用到矩阵<strong>从上至下递增，从左至右递增</strong>的特点，故不是最优解。</p><p>我们将矩阵逆时针旋转45°，可以发现其结构类似二叉搜索树，对每个元素来说，左分支元素更小而右分支元素更大。因此我们从根节点开始搜索，遇到大于目标元素的元素则向左继续搜索，反之则向右继续搜索，最终获得目标元素。</p><p><img src="/2021/02/04/剑指offer刷题记录（一）/1.PNG" alt="剑指offer-04.PNG-107.2kB"></p><p>结合以上思想，我们进行合理转化：<strong>根节点</strong>对应矩阵<strong>右上角的元素</strong>。具体算法如下：</p><ul><li>从矩阵右上角元素开始遍历，同时与目标值target进行对比；</li><li>若<code>matrix[row_index][column_index] &gt; target</code>，消去第<code>column_index</code>列元素；</li><li>若<code>matrix[row_index][column_index] &lt; target</code>，消去第<code>row_index</code>行元素；</li><li>若<code>matrix[row_index][column_index] == target</code>，找到目标。</li></ul><p>该算法选择从右上角开始遍历，需要注意下标范围及二维数组空判断问题。</p><h3 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> column_index = matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row_index&gt;=<span class="number">0</span>&amp;&amp;row_index&lt;matrix.length&amp;&amp;column_index&gt;=<span class="number">0</span>&amp;&amp;column_index&lt;matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row_index][column_index]== target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[row_index][column_index] &gt; target)&#123;</span><br><span class="line">                column_index--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[row_index][column_index] &lt; target)&#123;</span><br><span class="line">                row_index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度$O(M+N)$：其中N和M分别代表矩阵的行数和列数，算法最多循环N+M次；</li><li>空间复杂度$O(1)$：i，j指针使用常数大小的额外空间。</li></ul><h2 id="0x03-替换空格"><a href="#0x03-替换空格" class="headerlink" title="0x03 替换空格"></a>0x03 替换空格</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure><p>限制：</p><p><code>0 &lt;= s 的长度 &lt;= 10000</code></p><h3 id="算法详解-2"><a href="#算法详解-2" class="headerlink" title="算法详解"></a>算法详解</h3><p>根据题目要求，最简单的方法是采用String类自带的替换函数<code>replaceAll()</code>，当然面试官肯定不会允许。于是就需要自己研究替换函数。注意到Java中String类型使用final关键词修饰，即String对象是不可修改的，从而考虑两种方法：</p><ul><li>方法一：引入可修改的数据类型StringBuilder，最后使用<code>toString()</code>函数转换成String类型输出即可。</li><li>方法二：引入静态数组<code>char[]</code>，首先确定数组的长度为原始字符串的三倍（假设原始字符串全部由空格组成），随后采用双指针法循环遍历原始字符串和新的字符串，完成比较与添加字符的操作。</li></ul><h3 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="Method-1"><a href="#Method-1" class="headerlink" title="Method 1"></a>Method 1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">' '</span>) sb.append(<span class="string">"%20"</span>);</span><br><span class="line">            <span class="keyword">else</span> sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method-2"><a href="#Method-2" class="headerlink" title="Method 2"></a>Method 2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] final_result = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">3</span>*length];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">' '</span>)&#123;</span><br><span class="line">                final_result[j++] = <span class="string">'%'</span>;</span><br><span class="line">                final_result[j++] = <span class="string">'2'</span>;</span><br><span class="line">                final_result[j++] = <span class="string">'0'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                final_result[j++] = s.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(final_result, <span class="number">0</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>Method1</p><ul><li>时间复杂度$O(N)$。</li><li>空间复杂度$O(N)$：Java新建StringBuilder使用了线性大小的额外空间。</li></ul></li><li><p>Method2</p><ul><li>时间复杂度$O(N)$。</li><li>空间复杂度$O(1)$：由于是原地扩展字符串s的长度，因此使用$O(1)$的额外空间。</li></ul></li></ul><h2 id="0x04-从尾到头打印链表"><a href="#0x04-从尾到头打印链表" class="headerlink" title="0x04 从尾到头打印链表"></a>0x04 从尾到头打印链表</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure><p>限制：</p><p><code>0 &lt;= 链表长度 &lt;= 10000</code></p><h3 id="算法详解-3"><a href="#算法详解-3" class="headerlink" title="算法详解"></a>算法详解</h3><p>本题目为最基础的链表逆序问题，可采用两种不同的数据结构辅助完成：</p><ul><li>方法一：不引入栈而仅使用定长数组。由于Java中数组具有长度固定的特点，故首先需要遍历链表以获得结果数组的长度。建立对应长度数组后，采用从后向前逐位填充的方法完成逆序输出。</li><li>方法二：引入栈这一数据结构。由于栈具有LIFO的特点，只需通过进出操作就能实现链表逆序输出，将输出结果按序存入结果数组即可。</li></ul><h3 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="Method-1-1"><a href="#Method-1-1" class="headerlink" title="Method 1"></a>Method 1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="comment">// First get the length of the list</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="keyword">null</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Then create a result array with fixed length</span></span><br><span class="line">        <span class="keyword">int</span>[] result_array = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        <span class="comment">// Lastly reverse the linkedlist</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = count-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            result_array[j] = head.val;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result_array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method-2-1"><a href="#Method-2-1" class="headerlink" title="Method 2"></a>Method 2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="comment">// First create stack needed</span></span><br><span class="line">        Stack&lt;Integer&gt; tmp_stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="keyword">null</span>)&#123;</span><br><span class="line">            tmp_stack.push(temp.val);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Then create result array with fixed length</span></span><br><span class="line">        <span class="keyword">int</span>[] result_array = <span class="keyword">new</span> <span class="keyword">int</span>[tmp_stack.size()];</span><br><span class="line">        <span class="comment">// Lastly pop all the elements in this stack</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; result_array.length;j++)&#123;</span><br><span class="line">            result_array[j] = tmp_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result_array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>两种方法的时间复杂度与空间复杂度均为$O(N)$。</p><h2 id="0x05-重建二叉树"><a href="#0x05-重建二叉树" class="headerlink" title="0x05 重建二叉树"></a>0x05 重建二叉树</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>例如，给出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder = [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>限制：</p><p><code>0 &lt;= 节点个数 &lt;= 5000</code></p><h3 id="算法详解-4"><a href="#算法详解-4" class="headerlink" title="算法详解"></a>算法详解</h3><p>题目中给出前序遍历和中序遍历的结果数组。树结构中前序遍历遵循<code>根节点—&gt;左节点—&gt;右节点</code>的遍历顺序，中序遍历遵循<code>左节点—&gt;根节点—&gt;右节点</code>的遍历顺序，我们需要结合两次遍历的结果数组完成二叉树重构。基本方法如下：</p><p>递归函数将前序遍历结果数组<code>preorder[]</code>和中序遍历结果数组<code>inorder[]</code>作为输入参数，显然<code>preorder[0]</code>必为根节点。随后获取根节点对应元素在<code>inorder[]</code>数组中的位置（可通过构造函数和采用哈希表存储的方法），设为<code>target_index</code>。则在中序遍历数组中，<code>inorder[:target_index]</code>即为左子树，<code>inorder[target_inex:]</code>即为右子树；在前序遍历数组中，<code>preorder[1: 1+target_index-0]</code>为左子树（其中<code>target_index-0</code>表示从<code>inorder[]</code>数组中获取的左子树的长度），<code>preorder[target_index+1:]</code>为右子树。通过以上方法可以确定更新后的<code>preorder[]</code>数组和<code>inorder[]</code>数组，随后递归调用即可。</p><p>结合基本方法的分析，我们引入分治算法，通过递归对所有子树进行划分：</p><ul><li><p>递推参数：根节点在前序遍历的索引<code>root_index</code>，子树在中序遍历的左边界<code>left_bound</code>，子树在中序遍历的右边界<code>right_bound</code>；</p></li><li><p>终止条件：当<code>left_bound &gt; right_bound</code>，代表已经越过叶节点，此时返回null；</p></li><li><p>递推流程</p><ul><li><p>建立根节点<code>node</code>，节点值为<code>preorder[root_index]</code>；</p></li><li><p>划分左右子树：查找根节点在中序遍历结果数组<code>inorder[]</code>中的索引<code>target_index_in_inorder</code>；</p></li><li><p>开启左右子树递归，关键参数如下表所示：<br><img src="/2021/02/04/剑指offer刷题记录（一）/2.PNG" alt="剑指offer-子树重构.png-45.2kB"></p></li></ul></li><li><p>返回值：回溯返回<code>node</code>，作为上一层递归中根节点的左/右子节点</p></li></ul><p>值得注意的是，参数列表中<code>target_index_in_inorder - left_bound + root_index + 1</code>含义为：<code>根节点索引+左子树长度+1</code>，在中序遍历中该位置表示右子树的根节点。</p><h3 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="Method1-Fundational-Solution"><a href="#Method1-Fundational-Solution" class="headerlink" title="Method1 Fundational Solution"></a>Method1 Fundational Solution</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function is defined to get the index of root node in inorder-list</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findIndex</span><span class="params">(<span class="keyword">int</span>[] orderlist, <span class="keyword">int</span> target_value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;orderlist.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(orderlist[i] == target_value)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((preorder.length != inorder.length)||(preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>)||(preorder == <span class="keyword">null</span> || inorder == <span class="keyword">null</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> root_value = preorder[<span class="number">0</span>];</span><br><span class="line">        TreeNode root_node = <span class="keyword">new</span> TreeNode(root_value);</span><br><span class="line">        <span class="keyword">int</span> position = findIndex(inorder, root_value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get new preorder-list</span></span><br><span class="line">        <span class="keyword">int</span>[] preorder_left = Arrays.copyOfRange(preorder, <span class="number">1</span>, <span class="number">1</span>+position);</span><br><span class="line">        <span class="keyword">int</span>[] preorder_right = Arrays.copyOfRange(preorder, <span class="number">1</span>+position, preorder.length);</span><br><span class="line"><span class="comment">// Get new inorder-list</span></span><br><span class="line">        <span class="keyword">int</span>[] inorder_left = Arrays.copyOfRange(inorder, <span class="number">0</span>, position);</span><br><span class="line">        <span class="keyword">int</span>[] inorder_right = Arrays.copyOfRange(inorder, position+<span class="number">1</span>, inorder.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recurrsion starts</span></span><br><span class="line">        TreeNode node_left = buildTree(preorder_left, inorder_left);</span><br><span class="line">        TreeNode node_right = buildTree(preorder_right, inorder_right);</span><br><span class="line"></span><br><span class="line">        root_node.left = node_left;</span><br><span class="line">        root_node.right = node_right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method2-Solution-With-Hashmap"><a href="#Method2-Solution-With-Hashmap" class="headerlink" title="Method2 Solution With Hashmap"></a>Method2 Solution With Hashmap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This method can only be used in the construction of binary tree without duplicate nodes</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记中序遍历</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 保留先序遍历</span></span><br><span class="line">    <span class="keyword">int</span>[] preorder;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将索引结果对应填入哈希表map中，方便后续查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preorder = preorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;preorder.length;i++)&#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recurrsion(<span class="number">0</span>, <span class="number">0</span>, inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">recurrsion</span><span class="params">(<span class="keyword">int</span> root_index, <span class="keyword">int</span> left_bound, <span class="keyword">int</span> right_bound)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left_bound &gt; right_bound) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[root_index]);</span><br><span class="line">        <span class="keyword">int</span> target_index_in_inorder = map.get(preorder[root_index]);</span><br><span class="line">        root.left = recurrsion(root_index+<span class="number">1</span>, left_bound, target_index_in_inorder-<span class="number">1</span>);</span><br><span class="line">        root.right = recurrsion(root_index+<span class="number">1</span>+(target_index_in_inorder-left_bound), target_index_in_inorder+<span class="number">1</span>, right_bound);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>两种方法的时间复杂度与空间复杂度均为$O(N)$。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-di-gui-fa-qin/" target="_blank" rel="noopener">重建二叉树精选题解</a></p><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/" target="_blank" rel="noopener">重建二叉树官方题解</a></p><h2 id="0x06-用两个栈实现队列"><a href="#0x06-用两个栈实现队列" class="headerlink" title="0x06 用两个栈实现队列"></a>0x06 用两个栈实现队列</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数<code>appendTail</code>和<code>deleteHead</code>，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code>操作返回 -1 )</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= values &lt;= 10000</code></li><li>最多会对<code>appendTail</code>，<code>deleteHead</code>进行 10000 次调用</li></ul><h3 id="算法详解-5"><a href="#算法详解-5" class="headerlink" title="算法详解"></a>算法详解</h3><p>题目主要考察栈和队列这两种存储结构的功能区别。栈具有LIFO的特点，即入栈与出栈都是对栈顶位置的元素进行操作。而队列可以理解为普通数组，可同时实现头部与尾部两向的操作。</p><p>结合以上特性，我们采用下面的思路解决问题：</p><ul><li>使用栈结构存储队列数据，此时栈底元素对应队首元素，其无法直接删除，需要将上方所有元素出栈；</li><li>使用双栈可以实现列表倒序。假设非空栈A与空栈B，只需要将栈A弹出的元素依次压入栈B即可实现A列表倒序；</li><li>倒序后B执行出栈操作即相当于删除了A的栈底元素，即对应的队首元素。</li></ul><p>本题中要求实现构造函数<code>CQueue()</code>，加入队尾函数<code>appendTail()</code>与删除队首函数<code>deleteHead()</code>。</p><ul><li><code>CQueue()</code>：初始化两链表结构，分别代表栈A、B，用来实现加入队尾操作与元素倒序；</li><li><code>appendTail()</code>：将新元素加入栈A即可；</li><li><code>deleteHead()</code>：删除过程中存在以下三种情况：<ul><li>当栈B不为空，此时B中仍存在已完成倒序的元素，直接返回B的栈顶元素即可；</li><li>当栈A、B均为空，无元素，返回-1；</li><li>当栈A不为空，栈B为空，代表未进行倒序操作，此时需要将A中元素全部转移至B中，实现元素倒序并返回栈B栈顶元素即可。</li></ul></li></ul><h3 id="解题代码-5"><a href="#解题代码-5" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    LinkedList &lt;Integer&gt; A, B;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Stack A is used to store the elements by the order of pushment;</span></span><br><span class="line">        <span class="comment">// Stack B is used for reversing stack A.</span></span><br><span class="line">        A = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        A.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!B.isEmpty()) <span class="keyword">return</span> B.removeLast();</span><br><span class="line">        <span class="keyword">if</span>(A.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!A.isEmpty())&#123;</span><br><span class="line">            B.addLast(A.removeLast());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：<code>appendTail()</code>函数为$O(1)$；<code>deleteHead()</code>函数在N次队首元素删除操作中共需完成N个元素的倒序；</li><li>空间复杂度$O(N)$：最差情况下，栈A和B共保存N个元素。</li></ul><h2 id="0x07-斐波那契数列"><a href="#0x07-斐波那契数列" class="headerlink" title="0x07 斐波那契数列"></a>0x07 斐波那契数列</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p>提示：</p><p><code>0 &lt;= n &lt;= 100</code></p><h3 id="算法详解-6"><a href="#算法详解-6" class="headerlink" title="算法详解"></a>算法详解</h3><p>题目给出斐波那契数列的递推公式，说明其具有递推关系，选择<code>f(n+1) = f(n) + f(n-1)</code>为转移方程，采用动态规划完成问题求解：</p><ul><li>状态定义：设dp为一维数组，其中<code>dp[i]</code>的值代表斐波那契数列第i个数字；</li><li>转移方程：<code>dp[i+1] = dp[i] + dp[i-1]</code>；</li><li>初始状态：<code>dp[0] = 0, dp[1] = 1</code>；</li><li>返回值：<code>dp[n]</code>，即返回斐波那契数列的第n个数字。</li></ul><p>这里采用循环求余法简化运算过程。随着n的增大，<code>f(n)</code>会超过<code>Int32</code>甚至<code>Int64</code>的取值范围，从而导致结果溢出，故需要采用求余运算，规则如下：</p><p>设正整数x，y，p，求余符号为<code>mod</code>，则有<code>(x+y) mod p = (x mod p + y mod p) mod p</code>，从而<code>f(n) mod p = [f(n-1) mod p + f(n-2) mod p] mod p</code>。故只需在循环中每次计算sum = (a+b) mod 1000000007即可。</p><h3 id="解题代码-6"><a href="#解题代码-6" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (a+b) % <span class="number">1000000007</span>;</span><br><span class="line">            b = a;</span><br><span class="line">            a = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度$O(N)$：计算f(n)需要循环n次，每轮循环内计算操作使用$O(1)$;</li><li>空间复杂度$O(1)$：几个标志变量使用常数大小的额外空间。</li></ul><h2 id="0x08-青蛙跳台阶问题"><a href="#0x08-青蛙跳台阶问题" class="headerlink" title="0x08 青蛙跳台阶问题"></a>0x08 青蛙跳台阶问题</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>提示：</p><p><code>0 &lt;= n &lt;= 100</code></p><h3 id="算法详解-7"><a href="#算法详解-7" class="headerlink" title="算法详解"></a>算法详解</h3><p>本题目与斐波那契数列解题方法类似，只不过初始参数不同，可以通过普通动态规划和简化版动态规划解决问题，后者占用更少的空间资源。</p><h3 id="解题代码-7"><a href="#解题代码-7" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="Method1-General-DP"><a href="#Method1-General-DP" class="headerlink" title="Method1 General DP"></a>Method1 General DP</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[i] = (dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method2-Simple-Version"><a href="#Method2-Simple-Version" class="headerlink" title="Method2 Simple Version"></a>Method2 Simple Version</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (a+b) % <span class="number">1000000007</span>;</span><br><span class="line">            b = a;</span><br><span class="line">            a = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-7"><a href="#复杂度分析-7" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>Method1</p><p>时间与空间复杂度均为$O(N)$。</p></li><li><p>Method2</p><p>时间复杂度为$O(N)$，空间复杂度为$O(1)$。</p></li></ul><h2 id="0x09-旋转数组的最小数字"><a href="#0x09-旋转数组的最小数字" class="headerlink" title="0x09 旋转数组的最小数字"></a>0x09 旋转数组的最小数字</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h3 id="算法详解-8"><a href="#算法详解-8" class="headerlink" title="算法详解"></a>算法详解</h3><p>本题显然需要使用二分法，目标元素为旋转点元素，一般情况下满足以下条件：<strong>该元素值小于右侧元素，大于左侧元素</strong>。算法设计过程中需要考虑以下两个特殊情况：</p><ul><li>输入数组部分元素相同；</li><li>输入数组旋转后的结果与初始结果相同，均为全升序序列。</li></ul><p>二分法本身分以下三种情况讨论：</p><ul><li><code>nums[mid] &gt; nums[right]</code></li><li><code>nums[mid] &lt; nums[right]</code></li><li><code>nums[mid] == nums[right]</code></li></ul><p>具体题解参考如下链接：</p><p><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/" target="_blank" rel="noopener">旋转数组的最小数字（二分法，清晰图解）</a></p><p>需要注意的是，二分法过程中经常使用<code>mid = left + (left-right) / 2</code>来防止溢出。</p><h3 id="解题代码-8"><a href="#解题代码-8" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers.length == <span class="number">1</span>) <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right-left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[mid] &gt; numbers[right])&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &lt; numbers[right])&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-8"><a href="#复杂度分析-8" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度$O(log_{2}N)$：特例情况下会退化到$ O(N) $。</li><li>空间复杂度$O(1)$：i，j等变量使用常数大小的额外空间。</li></ul><h2 id="0x0a-矩阵中的路径"><a href="#0x0a-矩阵中的路径" class="headerlink" title="0x0a 矩阵中的路径"></a>0x0a 矩阵中的路径</h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><p>示例1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= board.length &lt;= 200</span><br><span class="line">1 &lt;= board[i].length &lt;= 200</span><br></pre></td></tr></table></figure><h3 id="算法详解-9"><a href="#算法详解-9" class="headerlink" title="算法详解"></a>算法详解</h3><p>题目为典型的矩阵搜索问题，可使用<code>深度优先搜索+剪枝</code>来解决。首先介绍下这两个概念：</p><ul><li>深度优先搜索（DFS）：该算法通过递归，先朝一个方向搜索至底部，再回溯到上个节点，沿另一个方向搜索，以此类推；</li><li>剪枝：在搜索过程中，遇到<code>此路无法和目标字符串匹配成功</code>的情况（例如，此矩阵元素和目标字符不同，此元素已被访问等），则应立即返回，此种方法成为<code>可行性剪枝</code>。</li></ul><p><img src="/2021/02/04/剑指offer刷题记录（一）/3.PNG" alt="剑指offer-12.png-31.1kB"></p><p>DFS过程如下：</p><ul><li>递归参数：当前元素在矩阵<code>board</code>中的行列索引<code>i</code>和<code>j</code>，当前目标字符在字符串<code>word</code>中的索引<code>k</code>。</li><li>终止条件：<ul><li>返回<code>false</code>：1）行或列索引出现越界<strong>或</strong>(2）当前矩阵元素与目标字符不同<strong>或</strong>(3）当前矩阵元素已被访问；</li><li>返回<code>true</code>：<code>k=len(word)-1</code>，代表字符串<code>word</code>已全部完成匹配。</li></ul></li><li>递推工作<ul><li>标记当前矩阵元素：将<code>board[i][j]</code>修改为 空字符<code>&#39;\0&#39;</code> ，代表此元素已访问过，防止之后搜索时重复访问。</li><li>搜索下一单元格：朝当前元素的 上、下、左、右 四个方向开启下层递归，使用<strong>或</strong>连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至<code>res</code> 。</li><li>还原当前矩阵元素： 将<code>board[i][j]</code>元素还原至初始值，即<code>word[k]</code>。</li></ul></li><li>返回值： 返回布尔量<code>res</code>，代表是否搜索到目标字符串。</li></ul><h3 id="解题代码-9"><a href="#解题代码-9" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key parameters: i represents row index, j represents column index, and k represents wordlist index.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, words, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] words, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((i &lt; <span class="number">0</span> || i &gt;= board.length) || (j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length) || board[i][j] != words[k]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == words.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        board[i][j] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">boolean</span> result = dfs(board, words, i, j+<span class="number">1</span>, k+<span class="number">1</span>) || dfs(board, words, i, j-<span class="number">1</span>, k+<span class="number">1</span>) || dfs(board, words, i+<span class="number">1</span>, j, k+<span class="number">1</span>)|| dfs(board, words, i-<span class="number">1</span>, j, k+<span class="number">1</span>);</span><br><span class="line">        board[i][j] = words[k];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-9"><a href="#复杂度分析-9" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>假设M，N分别为矩阵的行列大小，K为字符串<code>word</code>的长度。</p><ul><li>时间复杂度$O(3^{K}MN)$：设字符串长度为K，搜索中每个字符有上、下、左、右四个方向可供选择，舍弃回头的方向，剩下三种选择，因此方案数的复杂度为$O(3^{K})$。矩阵共有MN个 起点，时间复杂度为$O(MN)$，故最差情况为二者乘积。</li><li>空间复杂度$O(K)$：搜索过程中递归深度不超过K，因此系统因函数调用累计使用的栈空间占用$O(K)$。</li></ul><h2 id="0x0b-机器人的运动范围"><a href="#0x0b-机器人的运动范围" class="headerlink" title="0x0b 机器人的运动范围"></a>0x0b 机器人的运动范围</h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 2, n = 3, k = 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 1, k = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= n,m &lt;= 100</span><br><span class="line">0 &lt;= k &lt;= 20</span><br></pre></td></tr></table></figure><h3 id="算法详解-10"><a href="#算法详解-10" class="headerlink" title="算法详解"></a>算法详解</h3><p>本题与上题类似，均为典型的搜索&amp;回溯问题。与上题不同的是，本题目的起点为<code>(0,0)</code>而非任意点，同时每次机器人运动方向只有<strong>向右</strong>和<strong>向下</strong>两个方向。可以采用广度优先搜索与深度优先搜索两种方法解题。可参考题解如下：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/mian-shi-ti-13-ji-qi-ren-de-yun-dong-fan-wei-dfs-b/" target="_blank" rel="noopener">机器人的运动范围（回溯算法，DFS/BFS）</a></p><h3 id="解题代码-10"><a href="#解题代码-10" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="Method1-DFS"><a href="#Method1-DFS" class="headerlink" title="Method1 DFS"></a>Method1 DFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> visited_position[][] = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(visited_position, m, n, <span class="number">0</span>, <span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[][] visited_position, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((i &gt;= m) || (j &gt;= n) || visited_position[i][j] || (sumCount(i) + sumCount(j) &gt; k))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        visited_position[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(visited_position, m, n, i+<span class="number">1</span>, j, k) + dfs(visited_position, m, n, i, j+<span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumCount</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index != <span class="number">0</span>)&#123;</span><br><span class="line">            sum += index % <span class="number">10</span>;</span><br><span class="line">            index /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method2-BFS"><a href="#Method2-BFS" class="headerlink" title="Method2 BFS"></a>Method2 BFS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] tmp_list = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> i = tmp_list[<span class="number">0</span>], j = tmp_list[<span class="number">1</span>], s_i = tmp_list[<span class="number">2</span>], s_j = tmp_list[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span>((i &gt;= m) || (j &gt;= n) || visited[i][j] || (s_i + s_j &gt; k)) <span class="keyword">continue</span>;</span><br><span class="line">            visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            result += <span class="number">1</span>;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j+<span class="number">1</span>, s_i, sumCount(j+<span class="number">1</span>)&#125;);</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i+<span class="number">1</span>, j, sumCount(i+<span class="number">1</span>), s_j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumCount</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum_result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index != <span class="number">0</span>)&#123;</span><br><span class="line">            sum_result += index % <span class="number">10</span>;</span><br><span class="line">            index /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum_result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-10"><a href="#复杂度分析-10" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度$O(MN)$：最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为$O(MN)$；</li><li>空间复杂度$O(MN)$：最差情况下，布尔数组<code>visited</code>内存储矩阵所有单元格的索引，使用$O(MN)$的额外空间。</li></ul><h2 id="0x0c-剪绳子I"><a href="#0x0c-剪绳子I" class="headerlink" title="0x0c 剪绳子I"></a>0x0c 剪绳子I</h2><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m-1]</code> 。请问 <code>k[0]*k[1]*...*k[m-1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 &lt;= n &lt;= 58</span><br></pre></td></tr></table></figure><h3 id="算法详解-11"><a href="#算法详解-11" class="headerlink" title="算法详解"></a>算法详解</h3><h4 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h4><p>设将长度为n的绳子切为a段，满足：$n = n_{1} + n_{2} +… + n_{a}$，则本题等价于求解$max(n_{1}*n_{2}*…*n_{a})$。提出两个假设：1）当所有绳段长度相等时，乘积最大；2）最优的绳段长度为3。进行推导如下：</p><p>根据算术几何均值不等式：</p><script type="math/tex; mode=display">\frac{(n_{1}+n_{2}+...+n_{a})}{a} \ge \sqrt[a]{n_{1}*n_{2}*...*n_{a}}</script><p>当且仅当$n_{1} = n_{2} = … = n_{a}$时成立。故<strong>将绳子以相等的长度等分为多段，得到的乘积最大</strong>。</p><p>设将绳子按照x长度等分为a段，即n=a*x，则乘积为$x^{a}$。由于n为常数，满足$x^{a} = x^{\frac{n}{x}} = (x^{\frac{1}{x}})^{n}$。</p><p>构造函数$y = x^{\frac{1}{x}}$，对x求导得：</p><script type="math/tex; mode=display">y' = \frac{1-lnx}{x^{2}}*x^{\frac{1}{x}}</script><p>令y’=0，则1-lnx=0，得驻点$x_{0} = 2.7$且该点为极大值点。由于切分长度x必须为整数，分别带入最接近e的整数2或3，比较可知x=3时乘积达到最大。故<strong>尽可能将绳子以长度3等分为多段时，乘积最大</strong>。</p><p>结合以上分析，本算法流程如下：</p><ul><li>当<code>n &lt;= 3</code>时，按照数学推导不应切分，但由于题目要求必须剪成两段及以上，故此时返回<code>n-1</code>；</li><li>当<code>n &gt; 3</code>时，n可表示为<code>n = 3*a + b</code>，分别求出整数部分a和余数部分b。<ul><li>当<code>b == 0</code>时，返回<code>pow(3, a)</code>；</li><li>当<code>b == 1</code>时，需将一个<code>3+1</code>转换成<code>2+2</code>，因此返回<code>pow(3, a-1)*4</code>；</li><li>当<code>b === 2</code>时，返回<code>pow(3, a)*2</code>。</li></ul></li></ul><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul><li>状态定义：dp[i]表示长度为i的绳子剪短后的最大乘积；</li><li>初始状态：<code>dp[0]=1</code>，<code>dp[1]=1</code>；</li><li>状态转移方程：<code>dp[i] = Math.max(dp[i], Math.max(j*dp[i-j], j*(i-j)))</code>。对于循环到的长度i，假设将其剪成两段，一段长度为j，另一段为i-j。此时需要比较<code>j*(i-j)</code>与<code>j*(dp[i-j])</code>的大小，根据比较结果决定是否继续剪下去：若<code>j*(i-j) &gt; j*(dp[i-j])</code>，说明将长度为i的绳子剪成两段得到最大结果；否则说明需要继续分段，此时将切割长度从i转化为<code>i-j</code>。</li><li>返回值：<code>dp[n]</code>。</li></ul><h3 id="解题代码-11"><a href="#解题代码-11" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="Method1-Mathematical-Solution"><a href="#Method1-Mathematical-Solution" class="headerlink" title="Method1 Mathematical Solution"></a>Method1 Mathematical Solution</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = n / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a-<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, a)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method2-DP"><a href="#Method2-DP" class="headerlink" title="Method2 DP"></a>Method2 DP</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; i;j++)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-11"><a href="#复杂度分析-11" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>Method1<ul><li>时间复杂度$O(1)$：方法一仅包含求整、求余和次方运算。</li><li>空间复杂度$O(1)$：变量均使用常数大小的额外空间。</li></ul></li><li>Method2<ul><li>时间复杂度$O(N^{2})$：该方法需要进行两层嵌套循环，故时间复杂度为平方级别。</li><li>空间复杂度$O(N)$：开辟长度为n的数组。</li></ul></li></ul><h2 id="0x0d-剪绳子II"><a href="#0x0d-剪绳子II" class="headerlink" title="0x0d 剪绳子II"></a>0x0d 剪绳子II</h2><h3 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h3><p>本题目与剪绳子I的操作过程完全相同，唯一不同的是n的范围扩展至<code>2 &lt;= n &lt;= 1000</code>。结合上题分析可知，最终乘积呈现指数式增长，故考虑部分编程语言中<code>int32</code>甚至<code>int64</code>类型数据出现溢出的情况，要求最终结果需要进行模<code>1e9+7</code>的处理。</p><h3 id="算法详解-12"><a href="#算法详解-12" class="headerlink" title="算法详解"></a>算法详解</h3><p>本题目与上题基本思路相同，唯一区别为<code>需要进行模运算</code>。故引入快速幂乘法实现该运算。然而，由于模运算的存在无法进行动态规划，于是采用贪心算法解题。</p><h3 id="解题代码-12"><a href="#解题代码-12" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="Method1-Mathematical-Solution-1"><a href="#Method1-Mathematical-Solution-1" class="headerlink" title="Method1 Mathematical Solution"></a>Method1 Mathematical Solution</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> modular = (<span class="keyword">int</span>)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = n / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)fast_power(<span class="number">3</span>, a);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)(fast_power(<span class="number">3</span>, a-<span class="number">1</span>)*<span class="number">4</span> % modular);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (<span class="keyword">int</span>)(fast_power(<span class="number">3</span>, a)*<span class="number">2</span> % modular);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function is used to calculate pow(x, a)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">fast_power</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(a &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a%<span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                result = (result * x) % <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            x %= <span class="number">1000000007</span>;</span><br><span class="line">            a /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method2-Greedy-Algorithm"><a href="#Method2-Greedy-Algorithm" class="headerlink" title="Method2 Greedy Algorithm"></a>Method2 Greedy Algorithm</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">4</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">4</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">long</span> final_result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mod_number = (<span class="keyword">int</span>)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            final_result *= <span class="number">3</span>;</span><br><span class="line">            final_result %= mod_number;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(final_result*n % mod_number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-12"><a href="#复杂度分析-12" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>Method1<ul><li>时间复杂度$O(log_{2}N)$：使用快速幂算法降低时间复杂度。</li><li>空间复杂度$O(1)$：变量使用常数大小的空间。</li></ul></li><li>Method2<ul><li>时间复杂度$O(N)$；</li><li>空间复杂度$O(1)$。</li></ul></li></ul><h2 id="0x0e-二进制中1的个数"><a href="#0x0e-二进制中1的个数" class="headerlink" title="0x0e 二进制中1的个数"></a>0x0e 二进制中1的个数</h2><h3 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &apos;1&apos;。</span><br></pre></td></tr></table></figure><p>提示：</p><p>输入必须是长度为 32 的 二进制串 。</p><h3 id="算法详解-13"><a href="#算法详解-13" class="headerlink" title="算法详解"></a>算法详解</h3><p>结合题目需求，可以采用<code>逐位判断</code>与<code>n&amp;(n-1)</code>两种方法。</p><h4 id="逐位判断"><a href="#逐位判断" class="headerlink" title="逐位判断"></a>逐位判断</h4><p>根据与运算定义，二进制数字n存在以下性质：</p><ul><li>若<code>n&amp;1 == 0</code>，则n<strong>最右一位</strong>为0；</li><li>若<code>n&amp;1 == 1</code>，则n<strong>最右一位</strong>为1。</li></ul><p>根据以上特点，考虑以下循环算法：</p><ul><li>若n最右一位是否为1，若为1则<code>count_result</code>自加1，否则<code>continue</code>；</li><li>本题要求把数字n看作无符号数，使用<strong>无符号右移一位</strong>（Java中为<code>&gt;&gt;&gt;</code>）。</li></ul><h4 id="运用n-amp-n-1"><a href="#运用n-amp-n-1" class="headerlink" title="运用n&amp;(n-1)"></a>运用n&amp;(n-1)</h4><p><code>(n-1)</code>运算：二进制数字n最右边的1变成0，随后此1右边的0都变成1;</p><p><code>n&amp;(n-1)</code>运算：二进制数字n最右边的1变成0，其余不变。</p><p>根据以上特点，考虑循环算法：</p><ul><li>循环消去最右边的1，当<code>n == 0</code>时跳出循环；</li><li>循环内部持续增加<code>count_result</code>，同时采用<code>n&amp;(n-1)</code>持续消去数字n最右边的1。</li></ul><h3 id="解题代码-13"><a href="#解题代码-13" class="headerlink" title="解题代码"></a>解题代码</h3><h4 id="Method1-Rotation-Count"><a href="#Method1-Rotation-Count" class="headerlink" title="Method1 Rotation Count"></a>Method1 Rotation Count</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count_result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">1</span>) count_result += <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count_result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method2-‘1’-Elimination"><a href="#Method2-‘1’-Elimination" class="headerlink" title="Method2 ‘1’ Elimination"></a>Method2 ‘1’ Elimination</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count_result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            count_result += <span class="number">1</span>;</span><br><span class="line">            n &amp;= (n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count_result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-13"><a href="#复杂度分析-13" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>Method1<ul><li>时间复杂度$O(log_{2}N)$：此算法循环内部仅有移位、与、加等基本运算，占用$O(1)$；逐位判断需循环$log_{2}n$次，其中$log_{2}n$代表数字n最高位1所在的位数。</li><li>空间复杂度$O(1)$。</li></ul></li><li>Method2<ul><li>时间复杂度$O(M)$：<code>n&amp;(n-1)</code>操作仅有减法和与运算，占用$O(1)$；设M为二进制数字n中1的个数，则需要循环M次，每轮消去一个1。</li><li>空间复杂度$O(1)$。</li></ul></li></ul><h2 id="0x0f-数值的整数次方"><a href="#0x0f-数值的整数次方" class="headerlink" title="0x0f 数值的整数次方"></a>0x0f 数值的整数次方</h2><h3 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>-100.0 &lt; x &lt; 100.0</li><li>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</li></ul><h3 id="算法详解-14"><a href="#算法详解-14" class="headerlink" title="算法详解"></a>算法详解</h3><p>针对幂运算问题都可以通过快速幂算法提高运算效率。快速幂实际上是二分思想的一种应用，现推导如下：</p><p>$x^{n} = x^{n/2}*x^{n/2}=(x^{2})^{n/2}$，令n/2为整数，则分奇偶两种情况讨论，设向下取整符号为<code>//</code>：</p><ul><li>当n为偶数时，$x^{n} = (x^{2})^{n//2}$；</li><li>当n为奇数时，$x^{n} = (x^{2})^{n//2}*x$。</li></ul><p>结合以上推导，通过下述方法获取幂结果：</p><ul><li>通过循环$x = x^{2}$操作，每次把幂从n降至n//2，直至将幂降为0；</li><li>设count=1，则初始状态为$x^{n} = x^{n}*count$。循环二分过程中，每当n为奇数，将多出的一项x乘入count，最终可化至$x^{n} = x^{0}*count = count$，返回count即可。</li></ul><p>为加快运算速率，将不同运算转化为位运算：</p><ul><li>向下整除<code>n//2</code>等价于有符号数右移一位<code>n&gt;&gt;1</code>；</li><li>取余数<code>n%2</code>等价于判断二进制最后一位数值<code>n&amp;1</code>。</li></ul><h3 id="解题代码-14"><a href="#解题代码-14" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> b = n;</span><br><span class="line">        <span class="keyword">double</span> final_result = <span class="number">1.0000</span>;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            final_result = fast_power(x, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            final_result = <span class="number">1.00000</span>/fast_power(x, -b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> final_result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">fast_power</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1.00000</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n&amp;<span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                result *= x;</span><br><span class="line">            &#125;</span><br><span class="line">            x *= x;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-14"><a href="#复杂度分析-14" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度$O(log_{2}N)$：二分法的时间复杂度为对数级别；</li><li>空间复杂度$O(1)$：结果变量及临时变量等占用常数大小的额外空间。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;寒假赋闲在家，搞科研的同时希望提升一下自己的代码水平，于是回到阔别已久的LeetCode平台开始刷题
      
    
    </summary>
    
      <category term="Data Structure and Algorithm" scheme="https://blank-vax.github.io/categories/Data-Structure-and-Algorithm/"/>
    
    
      <category term="LeetCode" scheme="https://blank-vax.github.io/tags/LeetCode/"/>
    
      <category term="Java" scheme="https://blank-vax.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Euler-Project(V)</title>
    <link href="https://blank-vax.github.io/2020/11/22/Euler-Project(V)/"/>
    <id>https://blank-vax.github.io/2020/11/22/Euler-Project(V)/</id>
    <published>2020-11-22T03:36:00.000Z</published>
    <updated>2020-12-03T14:44:43.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="41-Pandigital-prime"><a href="#41-Pandigital-prime" class="headerlink" title="41. Pandigital prime"></a>41. Pandigital prime</h2><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>We shall say that an <em>n</em>-digit number is pandigital if it makes use of all the digits 1 to <em>n</em> exactly once. For example, 2143 is a 4-digit pandigital and is also prime.</p><p>What is the largest <em>n</em>-digit pandigital prime that exists?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># What is the largest n-digit pandigital prime that exists?</span></span><br><span class="line"><span class="comment"># The maximum pandigital prime may be located in range 123456789 to 987654321</span></span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllPermutations</span><span class="params">(n)</span>:</span></span><br><span class="line">    original_list = list(permutations(range(<span class="number">1</span>, n+<span class="number">1</span>)))</span><br><span class="line">    final_list = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> original_list:</span><br><span class="line">        tmp_result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> tuple_object <span class="keyword">in</span> item:</span><br><span class="line">            tmp_result += str(tuple_object)</span><br><span class="line">        final_list.append(tmp_result)</span><br><span class="line">    <span class="keyword">return</span> final_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPrime</span><span class="params">(combinations_result)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> reversed(combinations_result):</span><br><span class="line">        <span class="keyword">if</span> sympy.isprime(int(item)):</span><br><span class="line">            <span class="keyword">return</span> int(item)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    max_result = <span class="number">0</span></span><br><span class="line">    <span class="comment"># After some computation, we can find the aiming number is located in 7654321 to 1234567, which is a 7-digit pandigital prime</span></span><br><span class="line">    combinations_result = getAllPermutations(<span class="number">7</span>)</span><br><span class="line">    final_result = findPrime(combinations_result)</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h2 id="42-Coded-triangle-numbers"><a href="#42-Coded-triangle-numbers" class="headerlink" title="42. Coded triangle numbers"></a>42. Coded triangle numbers</h2><h3 id="Problem-Description-1"><a href="#Problem-Description-1" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The $ n^{th} $ term of the sequence of triangle numbers is given by, $ t_{n} = 1/2*n*(n+1)$; so the first ten triangle numbers are:</p><p>1, 3, 6, 10, 15, 21, 28, 36, 45, 55, …</p><p>By converting each letter in a word to a number corresponding to its alphabetical position and adding these values we form a word value. For example, the word value for SKY is $ 19 + 11 + 25 = 55 = t_{10} $. If the word value is a triangle number then we shall call the word a triangle word.</p><p>Using <a href="https://projecteuler.net/project/resources/p042_words.txt" target="_blank" rel="noopener">words.txt</a> (right click and ‘Save Link/Target As…’), a 16K text file containing nearly two-thousand common English words, how many are triangle words?</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How many are triangle words?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateTriangleNumbers</span><span class="params">(upper_bound)</span>:</span></span><br><span class="line">    triangle_number_set = [<span class="number">1</span>]</span><br><span class="line">    generator_element = <span class="number">1</span></span><br><span class="line">    generatedNumber = triangle_number_set[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> generatedNumber &lt; upper_bound:</span><br><span class="line">        generatedNumber = generator_element * (generator_element+<span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        triangle_number_set.append(generatedNumber)</span><br><span class="line">        generator_element += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> triangle_number_set</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countWordValue</span><span class="params">(word_string)</span>:</span></span><br><span class="line">    count_result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> word_string:</span><br><span class="line">        count_result += ord(item) - <span class="number">64</span></span><br><span class="line">    <span class="keyword">return</span> count_result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    triangle_word_count = <span class="number">0</span></span><br><span class="line">    triangle_number_set = generateTriangleNumbers(<span class="number">520</span>)</span><br><span class="line">    file_pointer = p042_word_path</span><br><span class="line">    word_list = file_pointer.read().replace(<span class="string">"\""</span>, <span class="string">""</span>).split(<span class="string">","</span>)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> word_list:</span><br><span class="line">        <span class="keyword">if</span> countWordValue(word) <span class="keyword">in</span> triangle_number_set:</span><br><span class="line">            triangle_word_count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> triangle_word_count</span><br></pre></td></tr></table></figure><h2 id="43-Sub-string-divisibility"><a href="#43-Sub-string-divisibility" class="headerlink" title="43. Sub-string divisibility"></a>43. Sub-string divisibility</h2><h3 id="Problem-Description-2"><a href="#Problem-Description-2" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The number, 1406357289, is a 0 to 9 pandigital number because it is made up of each of the digits 0 to 9 in some order, but it also has a rather interesting sub-string divisibility property.</p><p>Let $ d_{1} $ be the $ 1^{st} $ digit,$ d_{2} $ be the $ 2^{nd} $ digit, and so on. In this way, we note the following:</p><ul><li>$ d_{2}*d_{3}*d_{4} = 406 $ is divisible by 2</li><li>$ d_{3}*d_{4}*d_{5} = 063 $ is divisible by 3</li><li>$ d_{4}*d_{5}*d_{6}=635 $ is divisible by 5</li><li>$ d_{5}*d_{6}*d_{7}=357 $ is divisible by 7</li><li>$ d_{6}*d_{7}*d_{8}=572 $ is divisible by 11</li><li>$ d_{7}*d_{8}*d_{9} = 728 $ is divisible by 13</li><li>$ d_{8}*d_{9}*d_{10} = 289 $ is divisible by 17</li></ul><p>Find the sum of all 0 to 9 pandigital numbers with this property.</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>题解引入<code>sympy.nextprime(n)</code>函数以持续不断地获取素数，从而用于性质判断。该函数返回大于参数n的第一个素数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of all 0 to 9 pandigital numbers with this property</span></span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasProperty</span><span class="params">(input_string)</span>:</span></span><br><span class="line">    generated_prime = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> index_number <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">8</span>):</span><br><span class="line">        generated_prime = sympy.nextprime(generated_prime)</span><br><span class="line">        <span class="keyword">if</span> int(input_string[index_number: index_number+<span class="number">3</span>]) % generated_prime != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllPermutations</span><span class="params">(n)</span>:</span></span><br><span class="line">    original_list = list(permutations(range(n)))</span><br><span class="line">    final_list = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> original_list:</span><br><span class="line">        tmp_result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> tuple_object <span class="keyword">in</span> item:</span><br><span class="line">            tmp_result += str(tuple_object)</span><br><span class="line">        final_list.append(tmp_result)</span><br><span class="line">    <span class="keyword">return</span> final_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sum_result = <span class="number">0</span></span><br><span class="line">    combination_result = getAllPermutations(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> combination_result:</span><br><span class="line">        <span class="keyword">if</span> hasProperty(item):</span><br><span class="line">            sum_result += int(item)</span><br><span class="line">    <span class="keyword">print</span> sum_result</span><br></pre></td></tr></table></figure><h2 id="44-Pentagon-numbers"><a href="#44-Pentagon-numbers" class="headerlink" title="44. Pentagon numbers"></a>44. Pentagon numbers</h2><h3 id="Problem-Description-3"><a href="#Problem-Description-3" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Pentagonal numbers are generated by the formula,$ P_{n} = n(3n−1)/2 $. The first ten pentagonal numbers are:</p><p>1, 5, 12, 22, 35, 51, 70, 92, 117, 145, …</p><p>It can be seen that $ P_{4} + P_{7} = 22 + 70 = 92 = P_{8} $. However, their difference, 70 − 22 = 48, is not pentagonal.</p><p>Find the pair of pentagonal numbers, $ P_{j} $ and$ P_{k} $, for which their sum and difference are pentagonal and $ D = |P_{k} − P_{j}| $ is minimised; what is the value of D?</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>题解引入operator函数库，运用其中的底层函数提高运算效率，该库内函数说明如下：</p><p>operator库函数说明：<a href="https://docs.python.org/zh-cn/3/library/operator.html。" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/operator.html。</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the pair of pentagonal numbers, Pj and Pk</span></span><br><span class="line"><span class="comment"># The sum of these two number and the difference of these are both pentagonal</span></span><br><span class="line"><span class="comment"># Output the minimum D = |Pk - Pj|</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPentagonalNumbers</span><span class="params">(upper_bound)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> set(n*(<span class="number">3</span>*n<span class="number">-1</span>)//<span class="number">2</span> <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>, upper_bound+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    result_list = []</span><br><span class="line">    pentagonal_number_set = getPentagonalNumbers(<span class="number">3000</span>)</span><br><span class="line">    combination_result = combinations(pentagonal_number_set, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> combination_result:</span><br><span class="line">        <span class="keyword">if</span> add(item[<span class="number">0</span>], item[<span class="number">1</span>]) <span class="keyword">in</span> pentagonal_number_set <span class="keyword">and</span> abs(sub(item[<span class="number">0</span>], item[<span class="number">1</span>])) <span class="keyword">in</span> pentagonal_number_set:</span><br><span class="line">            result_list.append(abs(item[<span class="number">0</span>]-item[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">print</span> min(result_list)</span><br></pre></td></tr></table></figure><h2 id="45-Triangular-pentagonal-and-hexagonal"><a href="#45-Triangular-pentagonal-and-hexagonal" class="headerlink" title="45. Triangular, pentagonal, and hexagonal"></a>45. Triangular, pentagonal, and hexagonal</h2><h3 id="Problem-Description-4"><a href="#Problem-Description-4" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:</p><div class="table-container"><table><thead><tr><th>NumberType</th><th>Formulae</th><th>Example</th></tr></thead><tbody><tr><td>Triangle</td><td>$ T_{n} = n*(n+1) / 2 $</td><td>1, 3, 6, 10, 15, …</td></tr><tr><td>Pentagonal</td><td>$ P_{n} = n*(3*n-1) / 2 $</td><td>1, 5, 12, 22, 35, …</td></tr><tr><td>Hexagonal</td><td>$ H_{n} = n*(2*n-1) $</td><td>1, 6, 15, 28, 45</td></tr></tbody></table></div><p>It can be verified that $ T_{285} = P_{165} = H_{143} = 40755 $.</p><p>Find the next triangle number that is also pentagonal and hexagonal.</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><p>根据题意，以1—60000为生成元构造三角形数、五边形数和六边形数对应的集合，随后求交集并输出大于40755的第一个数字即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the next triangle number bigger than 40755 that is also pentagonal and hexagonal</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTriangleNumber</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> set(generator*(generator+<span class="number">1</span>)//<span class="number">2</span> <span class="keyword">for</span> generator <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPentagonalNumber</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(generator*(<span class="number">3</span>*generator<span class="number">-1</span>)//<span class="number">2</span> <span class="keyword">for</span> generator <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHexagonalNumber</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(generator*(<span class="number">2</span>*generator<span class="number">-1</span>) <span class="keyword">for</span> generator <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    triangle_set = getTriangleNumber(<span class="number">60000</span>)</span><br><span class="line">    pentagonal_set = getPentagonalNumber(<span class="number">60000</span>)</span><br><span class="line">    hexagonal_set = getHexagonalNumber(<span class="number">60000</span>)</span><br><span class="line">    result = set(triangle_set) &amp; set(pentagonal_set) &amp; set(hexagonal_set)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> result:</span><br><span class="line">        <span class="keyword">if</span> item &gt; <span class="number">40755</span>:</span><br><span class="line">            <span class="keyword">print</span> item</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h3><p>通过观察这三类数字的生成表达式可以获得三角形数、五边形数和六边形数的判断方法：</p><ul><li>若数字x是一个三角形数，则$ (\sqrt{(8*x+1)}-1) / 2 $必为一个整数；</li><li>若数字x是一个五边形数，则$ (\sqrt{(24*x+1)}+1) / 6 $必为一个整数；</li><li>若数字x是一个六边形数，则$ (\sqrt{(8*x+1)}+1) / 4 $必为一个整数 </li></ul><p>同时，这三类数的生成过程满足性质：$ H(n) = T(2n-1) $，即生成元n得到的六边形数一定对应更大生成元得到的三角形数。于是可以从第144个六边形数开始逐个验证其是否可表示为五边形数即可。暴力代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the next triangle number bigger than 40755 that is also pentagonal and hexagonal</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPentagonalNumber</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    integer_n = (math.sqrt(<span class="number">24</span>*input_number+<span class="number">1</span>)+<span class="number">1</span>) / <span class="number">6</span></span><br><span class="line">    <span class="keyword">if</span> integer_n % <span class="number">1</span> &gt; <span class="number">0</span> <span class="keyword">and</span> integer_n % <span class="number">1</span> &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHexagonalNumber</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n*(<span class="number">2</span>*n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    origin_generator = <span class="number">144</span></span><br><span class="line">    hexagonal_number = getHexagonalNumber(origin_generator)</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">print</span> origin_generator</span><br><span class="line">        <span class="keyword">if</span> isPentagonalNumber(hexagonal_number):</span><br><span class="line">            <span class="keyword">print</span> hexagonal_number</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        origin_generator += <span class="number">1</span></span><br><span class="line">        hexagonal_number = getHexagonalNumber(origin_generator)</span><br></pre></td></tr></table></figure><h2 id="46-Goldbach’s-other-conjecture"><a href="#46-Goldbach’s-other-conjecture" class="headerlink" title="46. Goldbach’s other conjecture"></a>46. Goldbach’s other conjecture</h2><h3 id="Problem-Description-5"><a href="#Problem-Description-5" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>It was proposed by Christian Goldbach that every odd composite number can be written as the sum of a prime and twice a square.</p><script type="math/tex; mode=display">9 = 7 + 2×1^{2}</script><script type="math/tex; mode=display">15 = 7 + 2×2^{2}</script><script type="math/tex; mode=display">21 = 3 + 2×3^{2}</script><script type="math/tex; mode=display">25 = 7 + 2×3^{2}</script><script type="math/tex; mode=display">27 = 19 + 2×2^{2}</script><script type="math/tex; mode=display">33 = 31 + 2×1^{2}</script><p>It turns out that the conjecture was false.</p><p>What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?</span></span><br><span class="line"><span class="comment"># odd_composite = odd_prime + 2 * square_number</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPrimes</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sorted(list(sympy.primerange(<span class="number">3</span>, n+<span class="number">1</span>)))</span><br><span class="line"><span class="comment"># Get the odd composites</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getOddComposite</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sorted(list(set(list(i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n+<span class="number">1</span>, <span class="number">2</span>))) - set(getPrimes(n))))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSquare</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    possible_square = math.sqrt(input_number / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> possible_square % <span class="number">1</span> &gt; <span class="number">0</span> <span class="keyword">and</span> possible_square % <span class="number">1</span> &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    odd_composite = getOddComposite(<span class="number">6000</span>)</span><br><span class="line">    prime_set = getPrimes(<span class="number">6000</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> odd_composite:</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> prime <span class="keyword">in</span> prime_set:</span><br><span class="line">            <span class="keyword">if</span> prime &gt;= item:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> isSquare(item - prime):</span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">print</span> item</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="47-Distinct-primes-factors"><a href="#47-Distinct-primes-factors" class="headerlink" title="47. Distinct primes factors"></a>47. Distinct primes factors</h2><h3 id="Problem-Description-6"><a href="#Problem-Description-6" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The first two consecutive numbers to have two distinct prime factors are:</p><script type="math/tex; mode=display">14 = 2 × 7</script><script type="math/tex; mode=display">15 = 3 × 5</script><p>The first three consecutive numbers to have three distinct prime factors are:</p><script type="math/tex; mode=display">644 = 2^{2} × 7 × 23</script><script type="math/tex; mode=display">645 = 3 × 5 × 43</script><script type="math/tex; mode=display">646 = 2 × 17 × 19</script><p>Find the first four consecutive integers to have four distinct prime factors each. What is the first of these numbers?</p><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the first four consecutive integers to have four distinct prime factors each.</span></span><br><span class="line"><span class="comment"># What is the first of these numbers?</span></span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPrimeFactorSet</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> set(sympy.primerange(a, b+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countPrimeFactors</span><span class="params">(n, factor_set, prime_set)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> prime_set:</span><br><span class="line">        <span class="keyword">if</span> n % item == <span class="number">0</span>:</span><br><span class="line">            factor_set.add(item)</span><br><span class="line">            <span class="keyword">return</span> countPrimeFactors(n/item, factor_set, prime_set)</span><br><span class="line">    <span class="keyword">return</span> factor_set</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    prime_set = getPrimeFactorSet(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">for</span> item_object <span class="keyword">in</span> range(<span class="number">100000</span>, <span class="number">150000</span>):</span><br><span class="line">        <span class="keyword">if</span> len(countPrimeFactors(item_object, set(), prime_set)) == <span class="number">4</span> <span class="keyword">and</span> len(countPrimeFactors(item_object+<span class="number">1</span>, set(), prime_set)) == <span class="number">4</span> <span class="keyword">and</span> len(countPrimeFactors(item_object+<span class="number">2</span>, set(), prime_set)) == <span class="number">4</span> <span class="keyword">and</span> len(countPrimeFactors(item_object+<span class="number">3</span>, set(), prime_set)) == <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">print</span> item_object</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="comment"># Program running time: The function run time is : 0.384 seconds.</span></span><br></pre></td></tr></table></figure><h2 id="48-Self-powers"><a href="#48-Self-powers" class="headerlink" title="48. Self powers"></a>48. Self powers</h2><h3 id="Problem-Description-7"><a href="#Problem-Description-7" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The series, $ 1^{1} + 2^{2} + 3^{3} + … + 10^{10} = 10405071317 $.</p><p>Find the last ten digits of the series, $ 1^{1} + 2^{2} + 3^{3} + … + 1000^{1000} $.</p><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the last ten digits of the series, sum(pow(n, n) for n in range(1, 1000))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    result_digits = str(sum(list(pow(i, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">1000</span>))))[<span class="number">-10</span>:]</span><br><span class="line">    <span class="keyword">print</span> result_digits</span><br></pre></td></tr></table></figure><h2 id="49-Prime-permutations"><a href="#49-Prime-permutations" class="headerlink" title="49. Prime permutations"></a>49. Prime permutations</h2><h3 id="Problem-Description-8"><a href="#Problem-Description-8" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The arithmetic sequence, 1487, 4817, 8147, in which each of the terms increases by 3330, is unusual in two ways: (i) each of the three terms are prime, and, (ii) each of the 4-digit numbers are permutations of one another.</p><p>There are no arithmetic sequences made up of three 1-, 2-, or 3-digit primes, exhibiting this property, but there is one other 4-digit increasing sequence.</p><p>What 12-digit number do you form by concatenating the three terms in this sequence?</p><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># What 12-digit number do you form by concatenating the three terms in this sequence?</span></span><br><span class="line"><span class="comment"># Brute force in Python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPrimeSet</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(sympy.primerange(a, b+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPermutations</span><span class="params">(input_list)</span>:</span></span><br><span class="line">    result_list = []</span><br><span class="line">    permutation_list = list(permutations(input_list, <span class="number">4</span>))</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> permutation_list:</span><br><span class="line">        result_list.append(item[<span class="number">0</span>]*<span class="number">1000</span>+item[<span class="number">1</span>]*<span class="number">100</span>+item[<span class="number">2</span>]*<span class="number">10</span>+item[<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">return</span> set(permutations(result_list, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrimePermutations</span><span class="params">(input_item, prime_set)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> input_item[<span class="number">0</span>] == input_item[<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> input_item[<span class="number">2</span>] + input_item[<span class="number">0</span>] != <span class="number">2</span>*input_item[<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> input_item[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> prime_set <span class="keyword">or</span> input_item[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> prime_set <span class="keyword">or</span> input_item[<span class="number">2</span>] <span class="keyword">not</span> <span class="keyword">in</span> prime_set:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getEachDigitList</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    result_list = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> str(input_number):</span><br><span class="line">        result_list.append(eval(item))</span><br><span class="line">    <span class="keyword">return</span> result_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    prime_set = getPrimeSet(<span class="number">1000</span>, <span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">for</span> possible_number <span class="keyword">in</span> prime_set:</span><br><span class="line">        possible_number_list = getEachDigitList(possible_number)</span><br><span class="line">        final_result_list = getPermutations(possible_number_list)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> final_result_list:</span><br><span class="line">            item = sorted(item)</span><br><span class="line">            <span class="keyword">if</span> isPrimePermutations(item, prime_set):</span><br><span class="line">                <span class="keyword">print</span> str(item[<span class="number">0</span>]) + str(item[<span class="number">1</span>]) + str(item[<span class="number">2</span>])</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="50-Consecutive-prime-sum"><a href="#50-Consecutive-prime-sum" class="headerlink" title="50. Consecutive prime sum"></a>50. Consecutive prime sum</h2><h3 id="Problem-Description-9"><a href="#Problem-Description-9" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The prime 41, can be written as the sum of six consecutive primes:</p><p>41 = 2 + 3 + 5 + 7 + 11 + 13</p><p>This is the longest sum of consecutive primes that adds to a prime below one-hundred.</p><p>The longest sum of consecutive primes below one-thousand that adds to a prime, contains 21 terms, and is equal to 953.</p><p>Which prime, below one-million, can be written as the sum of the most consecutive primes?</p><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Which prime, below one-million, can be written as the sum of the most consecutive primes?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPrimeSet</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(sympy.primerange(a, b+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllSumResult</span><span class="params">(upper_bound, prime_set)</span>:</span></span><br><span class="line">    result_list = []</span><br><span class="line">    <span class="keyword">for</span> index_number <span class="keyword">in</span> range(len(prime_set)):</span><br><span class="line">        sum_result = sum(prime_set[:index_number])</span><br><span class="line">        <span class="keyword">if</span> sum_result &lt; upper_bound:</span><br><span class="line">            result_list.append(sum_result)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> result_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">originalSumResultJudge</span><span class="params">(stored_dict, prime_set, sum_result)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index_number <span class="keyword">in</span> range(len(sum_result)<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> sum_result[index_number] <span class="keyword">in</span> prime_set:</span><br><span class="line">            stored_dict[index_number] = sum_result[index_number]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> stored_dict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getConsecutivePrimeRange</span><span class="params">(prime_set, sum_result)</span>:</span></span><br><span class="line">    stored_dict = &#123;&#125;</span><br><span class="line">    first_processed_dict = originalSumResultJudge(stored_dict, prime_set, sum_result)</span><br><span class="line">    <span class="keyword">for</span> index_number1 <span class="keyword">in</span> range(len(sum_result)<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> index_number2 <span class="keyword">in</span> range(len(sum_result)):</span><br><span class="line">            <span class="keyword">if</span> sum_result[index_number1] - sum_result[index_number2] <span class="keyword">in</span> prime_set:</span><br><span class="line">                first_processed_dict[index_number1-index_number2] = sum_result[index_number1] - sum_result[index_number2]</span><br><span class="line">                <span class="keyword">return</span> first_processed_dict</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    prime_set = getPrimeSet(<span class="number">2</span>, <span class="number">1000000</span>)</span><br><span class="line">    result_list = getAllSumResult(<span class="number">1000000</span>, prime_set)</span><br><span class="line">    final_result = getConsecutivePrimeRange(prime_set, result_list)</span><br><span class="line">    sorted_dict = sorted(final_result.iteritems(), key=<span class="keyword">lambda</span> d: d[<span class="number">0</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">print</span> sorted_dict[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;41-Pandigital-prime&quot;&gt;&lt;a href=&quot;#41-Pandigital-prime&quot; class=&quot;headerlink&quot; title=&quot;41. Pandigital prime&quot;&gt;&lt;/a&gt;41. Pandigital prime&lt;/h2&gt;&lt;h3
      
    
    </summary>
    
      <category term="Mathematics" scheme="https://blank-vax.github.io/categories/Mathematics/"/>
    
    
      <category term="Euler-Project" scheme="https://blank-vax.github.io/tags/Euler-Project/"/>
    
  </entry>
  
  <entry>
    <title>Euler-Project(IV)</title>
    <link href="https://blank-vax.github.io/2020/11/17/Euler-Project(IV)/"/>
    <id>https://blank-vax.github.io/2020/11/17/Euler-Project(IV)/</id>
    <published>2020-11-17T06:40:00.000Z</published>
    <updated>2021-07-07T04:11:36.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="31-Coin-sums"><a href="#31-Coin-sums" class="headerlink" title="31. Coin sums"></a>31. Coin sums</h2><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>In the United Kingdom the currency is made up of pound (£) and pence (p). There are eight coins in general circulation:</p><blockquote><p>1p, 2p, 5p, 10p, 20p, 50p, £1 (100p), and £2 (200p).</p></blockquote><p>It is possible to make £2 in the following way:</p><blockquote><p>1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p</p></blockquote><p>How many different ways can £2 be made using any number of coins?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>题目本质为经典的找零问题，可以通过动态规划的方法解决。</p><p>以本题给出的条件为例进行详细说明。题目给出1，2，5，10，20，50，100，200这八种面额的便士类型，要求通过组合获得200便士并求出所有组合的数量。首先将问题进行分解，结果为200便士的组合可分为以下三种：</p><ul><li>不引入100便士而是使用其他便士进行组合（单体最多为200便士）</li><li>引入一个100便士，剩余的100便士由其他便士组合（单体最多为100便士）</li><li>引入两个100便士完成组合</li></ul><p>故可得以下递推公式：</p><p><img src="/2020/11/17/Euler-Project(IV)/Euler-Project(IV" alt="31_problem1.PNG-20.5kB">\1.PNG)</p><p>各字符含义如下：</p><ul><li>t表示目标量；</li><li>c表示最大可用的硬币面值；</li><li>s(c)表示除c外更小的硬币面值；</li><li>w(t, c)表示使用面值为c或更小的硬币组成目标量的所有方法数。</li></ul><p>根据以上递推公式采用动态规划的方法，将大问题分割成多个小问题并进行分类讨论处理，该方法为第一类动态规划，遵循自顶向下的问题划分原则。同时引入二维数组记录不同(t, c)组对应的方法数，以提高程序运行效率。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How many different ways can 2 pound be made using any number of coins?</span></span><br><span class="line"><span class="comment"># 2 pound equals to 200p</span></span><br><span class="line"><span class="comment"># There are eight coins in general circulation: 1p, 2p, 5p, 10p, 20p, 50p, 100p, 200p</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countWays</span><span class="params">(target, avc)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> avc &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    t = target</span><br><span class="line">    <span class="keyword">if</span> memoset[t<span class="number">-1</span>][avc<span class="number">-1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> memoset[t<span class="number">-1</span>][avc<span class="number">-1</span>]</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> target &gt;= <span class="number">0</span>:</span><br><span class="line">        result += countWays(target, avc<span class="number">-1</span>)</span><br><span class="line">        target = target - coins[avc<span class="number">-1</span>]</span><br><span class="line">    memoset[t<span class="number">-1</span>][avc<span class="number">-1</span>] = result</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span>]</span><br><span class="line">    amount_result = <span class="number">200</span></span><br><span class="line">    memoset = [[<span class="number">0</span> <span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">9</span>)] <span class="keyword">for</span> row <span class="keyword">in</span> range(amount_result+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">print</span> countWays(amount_result, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>以上算法还可以进一步优化。首先我们观察(t, c)取值不同时w(t, c)的运算结果，对应如下表：</p><p><img src="/2020/11/17/Euler-Project(IV)/Euler-Project(IV" alt="31_solution1.PNG-44.5kB">\2.PNG)</p><p>根据以上对应关系归纳递推公式如下：</p><p><img src="/2020/11/17/Euler-Project(IV)/Euler-Project(IV" alt="31_formula.PNG-25.2kB">\3.PNG)</p><p>经过深入分析，我们可以得出w’(t, c)函数不同参数对应结果之间的关系图如下所示：</p><p><img src="/2020/11/17/Euler-Project(IV)/Euler-Project(IV" alt="31_solution2.PNG-44kB">\4.PNG)</p><p>可以看出第一行和第一列的数值1达到最终目的地需要较长的加和路径。除此之外其他所有元素都可由最多另外两个元素相加得到。从而每个w’(t, c)的值最多决定于另外两个数值，即：</p><ul><li>同列c的前一个元素；</li><li>同行t，前一列c-1对应的元素；</li></ul><p>该方法为第二种动态规划方法，遵循自底向上的问题划分原则，从较小的问题开始解决，逐步解决更大的子问题。此类方法在处理以下问题时具有更高的效率：</p><ul><li>每个元素可以通过至多两个其他元素相加获得；</li><li>要求较低的时间复杂度及空间复杂度；</li><li>使用循环而非函数调用解决问题；</li></ul><p>结合以上分析，对应代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How many different ways can 2 pound be made using any number of coins?</span></span><br><span class="line"><span class="comment"># 2 pound equals to 200p</span></span><br><span class="line"><span class="comment"># There are eight coins in general circulation: 1p, 2p, 5p, 10p, 20p, 50p, 100p, 200p</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countWays</span><span class="params">(upper_bound, coins, aim_amount, final_ways)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(upper_bound):</span><br><span class="line">        j = coins[i]</span><br><span class="line">        <span class="keyword">print</span> final_ways</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(j, aim_amount+<span class="number">1</span>):</span><br><span class="line">            final_ways[k] += final_ways[k-j]</span><br><span class="line">    <span class="keyword">return</span> final_ways</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span>]</span><br><span class="line">    amount_result = <span class="number">200</span></span><br><span class="line">    answer = [<span class="number">1</span>] + [<span class="number">0</span>]*amount_result</span><br><span class="line">    final_result = countWays(<span class="number">8</span>, coins, amount_result, answer)</span><br><span class="line">    <span class="keyword">print</span> final_result[amount_result]</span><br></pre></td></tr></table></figure><h3 id="找零问题参考资料"><a href="#找零问题参考资料" class="headerlink" title="找零问题参考资料"></a>找零问题参考资料</h3><p>Euler-Project-Problem31-Overview：<a href="https://projecteuler.net/overview=031" target="_blank" rel="noopener">https://projecteuler.net/overview=031</a></p><p>动态规划2：<a href="https://www.jianshu.com/p/e515efee2310" target="_blank" rel="noopener">https://www.jianshu.com/p/e515efee2310</a></p><p>硬币找零问题：<a href="https://www.cnblogs.com/anzhengyu/p/11176134.html" target="_blank" rel="noopener">https://www.cnblogs.com/anzhengyu/p/11176134.html</a></p><h2 id="32-Pandigital-products"><a href="#32-Pandigital-products" class="headerlink" title="32. Pandigital products"></a>32. Pandigital products</h2><h3 id="Problem-Description-1"><a href="#Problem-Description-1" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once; for example, the 5-digit number, 15234, is 1 through 5 pandigital.</p><p>The product 7254 is unusual, as the identity, 39 × 186 = 7254, containing multiplicand, multiplier, and product is 1 through 9 pandigital.</p><p>Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.</p><p>HINT: Some products can be obtained in more than one way so be sure to only include it once in your sum.</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.</span></span><br><span class="line"><span class="comment"># Example: 39 x 186 = 7254,</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPandigital</span><span class="params">(result_string)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(result_string) == <span class="number">9</span> <span class="keyword">and</span> <span class="string">"123456789"</span>.strip(result_string) == <span class="string">""</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    result_set = set()</span><br><span class="line">    <span class="keyword">for</span> multiplicand <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">        <span class="keyword">for</span> multiplier <span class="keyword">in</span> range(<span class="number">123</span>, <span class="number">9880</span>):</span><br><span class="line">            <span class="keyword">if</span> isPandigital(str(multiplicand)+str(multiplier)+str(multiplicand*multiplier)):</span><br><span class="line">                result_set.add(multiplicand*multiplier)</span><br><span class="line">    <span class="keyword">print</span> sum(result_set)</span><br></pre></td></tr></table></figure><h2 id="33-Digit-cancelling-fractions"><a href="#33-Digit-cancelling-fractions" class="headerlink" title="33. Digit cancelling fractions"></a>33. Digit cancelling fractions</h2><h3 id="Problem-Description-2"><a href="#Problem-Description-2" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The fraction 49/98 is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe that 49/98 = 4/8, which is correct, is obtained by cancelling the 9s.</p><p>We shall consider fractions like, 30/50 = 3/5, to be trivial examples.</p><p>There are exactly four non-trivial examples of this type of fraction, less than one in value, and containing two digits in the numerator and denominator.</p><p>If the product of these four fractions is given in its lowest common terms, find the value of the denominator.</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If the product of these four fractions is given in its lowest common terms, find the value of the denominator.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The mean of sign '/' equals to '//' in Python2, so if we wanna get the deimal, we could import such sentence:</span></span><br><span class="line"><span class="comment"># from __future__ import division</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isCuriousFraction</span><span class="params">(numerator, denominator)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> numerator%<span class="number">10</span> == denominator//<span class="number">10</span> <span class="keyword">and</span> (numerator//<span class="number">10</span>)/(denominator%<span class="number">10</span>) == numerator/denominator:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reductionFraction</span><span class="params">(numerator, denominator)</span>:</span></span><br><span class="line">    certain_range = denominator</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">2</span>, certain_range):</span><br><span class="line">        <span class="keyword">if</span> numerator == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> numerator % item == <span class="number">0</span> <span class="keyword">and</span> denominator % item == <span class="number">0</span>:</span><br><span class="line">            numerator /= item</span><br><span class="line">            denominator /= item</span><br><span class="line">    <span class="keyword">return</span> denominator</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    final_numerator = <span class="number">1</span></span><br><span class="line">    final_denominator = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> numerator <span class="keyword">in</span> range(<span class="number">10</span>, <span class="number">100</span>):</span><br><span class="line">        <span class="keyword">if</span> numerator % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> denominator <span class="keyword">in</span> range(numerator+<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">            <span class="keyword">if</span> denominator % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> isCuriousFraction(numerator, denominator):</span><br><span class="line">                final_numerator *= numerator//<span class="number">10</span></span><br><span class="line">                final_denominator *= denominator%<span class="number">10</span></span><br><span class="line">    final_result = reductionFraction(final_numerator, final_denominator)</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h2 id="34-Digit-factorials"><a href="#34-Digit-factorials" class="headerlink" title="34. Digit factorials"></a>34. Digit factorials</h2><h3 id="Problem-Description-3"><a href="#Problem-Description-3" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.</p><p>Find the sum of all numbers which are equal to the sum of the factorial of their digits.</p><p>Note: As 1! = 1 and 2! = 2 are not sums they are not included.</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of all numbers which are equal to the sum of the factorial of their digits</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFactorial</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> input_number == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y: x*y, range(<span class="number">1</span>, input_number+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSum</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    sum_result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> input_number != <span class="number">0</span>:</span><br><span class="line">        sum_result += getFactorial(input_number%<span class="number">10</span>)</span><br><span class="line">        input_number /= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> sum_result</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    final_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">100000</span>):</span><br><span class="line">        <span class="keyword">if</span> getSum(item) == item:</span><br><span class="line">            final_sum += item</span><br><span class="line">    <span class="keyword">print</span> final_sum</span><br></pre></td></tr></table></figure><h2 id="35-Circular-primes"><a href="#35-Circular-primes" class="headerlink" title="35. Circular primes"></a>35. Circular primes</h2><h3 id="Problem-Description-4"><a href="#Problem-Description-4" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The number, 197, is called a circular prime because all rotations of the digits: 197, 971, and 719, are themselves prime.</p><p>There are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97.</p><p>How many circular primes are there below one million?</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>首先引入python的sympy库筛选出10到1000000之间的所有素数，随后对其进行第二次筛选操作。由于需要对每个素数进行顺序位移，故第一批剔除任意数位为偶数的素数。第三次筛选题目要求进行顺序位移并判断结果是否在第一步获得的素数池内。最后计算长度并作差即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How many circular primes are there below one million</span></span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="comment"># First we should get all the prime numbers</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllPrimes</span><span class="params">(lower_bound ,upper_bound)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> list(sympy.sieve.primerange(lower_bound, upper_bound))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sieveEvenElements</span><span class="params">(prime_set)</span>:</span></span><br><span class="line">    PossiblePrime_set = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> prime_set:</span><br><span class="line">        item_string = str(item)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'0'</span> <span class="keyword">not</span> <span class="keyword">in</span> item_string <span class="keyword">and</span> <span class="string">'2'</span> <span class="keyword">not</span> <span class="keyword">in</span> item_string <span class="keyword">and</span> <span class="string">'4'</span> <span class="keyword">not</span> <span class="keyword">in</span> item_string <span class="keyword">and</span> <span class="string">'6'</span> <span class="keyword">not</span> <span class="keyword">in</span> item_string <span class="keyword">and</span> <span class="string">'8'</span> <span class="keyword">not</span> <span class="keyword">in</span> item_string:</span><br><span class="line">            PossiblePrime_set.append(item)</span><br><span class="line">    <span class="keyword">return</span> PossiblePrime_set</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testRotationResult</span><span class="params">(SetAfterSieve)</span>:</span></span><br><span class="line">    SetAfterSecondSieve = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> SetAfterSieve:</span><br><span class="line">        item_string = str(item)</span><br><span class="line">        <span class="keyword">for</span> index_number <span class="keyword">in</span> range(len(item_string)):</span><br><span class="line">            <span class="keyword">if</span> int(item_string[index_number:] + item_string[:index_number]) <span class="keyword">not</span> <span class="keyword">in</span>  SetAfterSieve:</span><br><span class="line">                SetAfterSecondSieve.append(item)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> SetAfterSecondSieve</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    original_primeset = getAllPrimes(<span class="number">10</span>, <span class="number">1000000</span>)</span><br><span class="line">    FirstSieveSet = sieveEvenElements(original_primeset)</span><br><span class="line">    SecondSieveSet = testRotationResult(FirstSieveSet)</span><br><span class="line">    final_circular_prime_number = <span class="number">4</span> + len(FirstSieveSet) - len(SecondSieveSet)</span><br><span class="line">    <span class="keyword">print</span> final_circular_prime_number</span><br></pre></td></tr></table></figure><h2 id="36-Double-base-palindromes"><a href="#36-Double-base-palindromes" class="headerlink" title="36. Double-base palindromes"></a>36. Double-base palindromes</h2><h3 id="Problem-Description-5"><a href="#Problem-Description-5" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The decimal number, $ 585 = 1001001001_{2}$ (binary), is palindromic in both bases.</p><p>Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2.</p><p>(Please note that the palindromic number, in either base, may not include leading zeros.)</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindromes</span><span class="params">(input_string)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> input_string == input_string[::<span class="number">-1</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sum_result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">1000000</span>):</span><br><span class="line">        <span class="keyword">if</span> isPalindromes(str(item)) <span class="keyword">and</span> isPalindromes(bin(item)[<span class="number">2</span>:]):</span><br><span class="line">            <span class="keyword">print</span> item</span><br><span class="line">            sum_result += item</span><br><span class="line">    <span class="keyword">print</span> sum_result</span><br></pre></td></tr></table></figure><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h3><p>除借助python特有的字符串逆序特性方便地解决问题外，我们设计任意进制下判定某个数字是否为回文数字的函数<code>isPalindromes()</code>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(input_number, base)</span>:</span></span><br><span class="line">    reverse_result = <span class="number">0</span></span><br><span class="line">    k = input_number</span><br><span class="line">    <span class="keyword">while</span> k != <span class="number">0</span>:</span><br><span class="line">        reverse_result = base*reverse_result + k % base</span><br><span class="line">        k /= base</span><br><span class="line">    <span class="keyword">return</span> input_number == reverse_result</span><br></pre></td></tr></table></figure><p>注意在二进制运算中，可以使用<code>&amp;1</code>代替模运算，使用<code>&lt;&lt;1</code>代替乘法运算。</p><p>由于题目需要在二进制下保持回文状态且不考虑前导零的存在，故排除所有的偶数，即循环过程中以奇数起始，步长选择为2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sum_result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">1000000</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> isPalindrome(item, <span class="number">10</span>) <span class="keyword">and</span> isPalindrome(item, <span class="number">2</span>):</span><br><span class="line">            sum_result += item</span><br><span class="line">    <span class="keyword">print</span> sum_result</span><br></pre></td></tr></table></figure><h3 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h3><p>在题目给出的限制范围内，解法二可保持较高的效率，但随着数字上限的扩大，程序运行时间会大大增长。故考虑”生成+判定”的方法：假设在b进制下存在回文数字xyzzyx，取前三个数字xyz为回文结，则该六位数字由三位回文结xyz定义。同时xyz亦可定义五位回文数字xyzyx。故我们可得出如下结论：</p><p><strong>对于任意b进制，任意小于$b^{n}$的整数可作为回文结生成两个小于$b^{2n}$的回文数字，这两个回文数字的位数一奇一偶。</strong></p><p>应用以上结论，我们选择在二进制下生成两个回文数字并检验十进制下该数字是否为回文数字。如果需要得到奇数位数的回文数字，则设置标志位为true，并进行运算<code>生成元n/进制b</code>，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(input_number, base)</span>:</span></span><br><span class="line">    reverse_result = <span class="number">0</span></span><br><span class="line">    k = input_number</span><br><span class="line">    <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">        reverse_result = base*reverse_result + k % base</span><br><span class="line">        k /= base</span><br><span class="line">    <span class="keyword">return</span> input_number == reverse_result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makePalindromeBase2</span><span class="params">(n, oddflag)</span>:</span></span><br><span class="line">    result = n</span><br><span class="line">    <span class="keyword">if</span> oddflag:</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        result = (result &lt;&lt; <span class="number">1</span>) + (n &amp; <span class="number">1</span>)</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    upper_bound = <span class="number">1000000</span></span><br><span class="line">    sum_result = <span class="number">0</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    generated_result = makePalindromeBase2(i, <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">while</span> generated_result &lt; upper_bound:</span><br><span class="line">        <span class="keyword">if</span> isPalindrome(generated_result, <span class="number">10</span>):</span><br><span class="line">            sum_result += generated_result</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        generated_result = makePalindromeBase2(i, <span class="literal">True</span>)</span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    generated_result2 = makePalindromeBase2(j, <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">while</span> generated_result2 &lt; upper_bound:</span><br><span class="line">        <span class="keyword">if</span> isPalindrome(generated_result2, <span class="number">10</span>):</span><br><span class="line">            sum_result += generated_result2</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        generated_result2 = makePalindromeBase2(j, <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">print</span> sum_result</span><br></pre></td></tr></table></figure><h2 id="37-Truncatable-primes"><a href="#37-Truncatable-primes" class="headerlink" title="37. Truncatable primes"></a>37. Truncatable primes</h2><h3 id="Problem-Description-6"><a href="#Problem-Description-6" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The number 3797 has an interesting property. Being prime itself, it is possible to continuously remove digits from left to right, and remain prime at each stage: 3797, 797, 97, and 7. Similarly we can work from right to left: 3797, 379, 37, and 3.</p><p>Find the sum of the only eleven primes that are both truncatable from left to right and right to left.</p><p>NOTE: 2, 3, 5, and 7 are not considered to be truncatable primes.</p><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of the only eleven primes that are both truncatable from left to right and right to left</span></span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rightToLeft</span><span class="params">(given_prime, primeSet)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> given_prime != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> given_prime <span class="keyword">not</span> <span class="keyword">in</span> primeSet:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        given_prime /= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leftToRight</span><span class="params">(given_prime, primeSet)</span>:</span></span><br><span class="line">    given_prime_string = str(given_prime)</span><br><span class="line">    <span class="keyword">for</span> index_number <span class="keyword">in</span> range(len(given_prime_string)):</span><br><span class="line">        <span class="keyword">if</span> int(given_prime_string[index_number:]) <span class="keyword">not</span> <span class="keyword">in</span> primeSet:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isTruncatablePrimes</span><span class="params">(given_prime, primeSet)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> given_prime == <span class="number">2</span> <span class="keyword">or</span> given_prime == <span class="number">3</span> <span class="keyword">or</span> given_prime == <span class="number">5</span> <span class="keyword">or</span> given_prime == <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> rightToLeft(given_prime, primeSet) <span class="keyword">and</span> leftToRight(given_prime, primeSet)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sum_result = <span class="number">0</span></span><br><span class="line">    final_result = []</span><br><span class="line">    primeSet = list(sympy.sieve.primerange(<span class="number">2</span>, <span class="number">1000000</span>))</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> primeSet:</span><br><span class="line">        <span class="keyword">if</span> isTruncatablePrimes(item, primeSet):</span><br><span class="line">            final_result.append(item)</span><br><span class="line">            sum_result += item</span><br><span class="line">    <span class="keyword">print</span> sum_result</span><br></pre></td></tr></table></figure><h2 id="38-Pandigital-multiples"><a href="#38-Pandigital-multiples" class="headerlink" title="38. Pandigital multiples"></a>38. Pandigital multiples</h2><h3 id="Problem-Description-7"><a href="#Problem-Description-7" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Take the number 192 and multiply it by each of 1, 2, and 3:</p><blockquote><p>192 × 1 = 192<br>192 × 2 = 384<br>192 × 3 = 576</p></blockquote><p>By concatenating each product we get the 1 to 9 pandigital, 192384576. We will call 192384576 the concatenated product of 192 and (1,2,3)</p><p>The same can be achieved by starting with 9 and multiplying by 1, 2, 3, 4, and 5, giving the pandigital, 918273645, which is the concatenated product of 9 and (1,2,3,4,5).</p><p>What is the largest 1 to 9 pandigital 9-digit number that can be formed as the concatenated product of an integer with (1,2, … , n) where n &gt; 1?</p><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># What is the largest 1 to 9 pandigital 9-digit number that can be formed as the concatenated product of an integer with (1,2, ... , n) where n &gt; 1?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getConcatenatedResult</span><span class="params">(multiple_time, max_result, final_item)</span>:</span></span><br><span class="line">    upper_bound = <span class="number">6</span> - multiple_time</span><br><span class="line">    lower_bound = <span class="number">5</span> - multiple_time</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">10</span>**lower_bound, <span class="number">10</span>**upper_bound):</span><br><span class="line">        concatenated_result = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> time <span class="keyword">in</span> range(<span class="number">1</span>, multiple_time+<span class="number">1</span>):</span><br><span class="line">            concatenated_result += str(item*time)</span><br><span class="line">        tmp_result = comparisonFunction(concatenated_result, max_result, item)</span><br><span class="line">        max_result = tmp_result[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> tmp_result[<span class="number">1</span>] != <span class="number">0</span>:</span><br><span class="line">            final_item = tmp_result[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> (max_result, final_item)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">comparisonFunction</span><span class="params">(concatenated_result, max_result, item)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> judgePandigitalNumber(concatenated_result) <span class="keyword">and</span> int(concatenated_result) &gt; max_result:</span><br><span class="line">        <span class="keyword">return</span> (int(concatenated_result), item)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> (max_result, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judgePandigitalNumber</span><span class="params">(input_number_string)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(input_number_string) == <span class="number">9</span> <span class="keyword">and</span> len(set(input_number_string)) == <span class="number">9</span> <span class="keyword">and</span> <span class="string">'0'</span> <span class="keyword">not</span> <span class="keyword">in</span> input_number_string:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    final_item, max_result = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> multiply_factor <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">6</span>):</span><br><span class="line">        concatenated_result = getConcatenatedResult(multiply_factor, max_result, final_item)</span><br><span class="line">        max_result = concatenated_result[<span class="number">0</span>]</span><br><span class="line">        final_item = concatenated_result[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">print</span> max_result</span><br></pre></td></tr></table></figure><h2 id="39-Integer-right-triangles"><a href="#39-Integer-right-triangles" class="headerlink" title="39. Integer right triangles"></a>39. Integer right triangles</h2><h3 id="Problem-Description-8"><a href="#Problem-Description-8" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>If <em>p</em> is the perimeter of a right angle triangle with integral length sides, {<em>a</em>,<em>b</em>,<em>c</em>}, there are exactly three solutions for <em>p</em> = 120.</p><p>{20,48,52}, {24,45,51}, {30,40,50}</p><p>For which value of <em>p</em> ≤ 1000, is the number of solutions maximised?</p><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For which value of p &lt;= 1000, is the numnber of solutions maximised?</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">judgeTriangle</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> a**<span class="number">2</span> + b**<span class="number">2</span> == c**<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSolutions</span><span class="params">(p)</span>:</span></span><br><span class="line">    solution_number = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">2</span>, int(p/<span class="number">2</span>)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> range(<span class="number">1</span>, a+<span class="number">1</span>):</span><br><span class="line">            c = p - a - b</span><br><span class="line">            <span class="keyword">if</span> judgeTriangle(a, b, c):</span><br><span class="line">                solution_number += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> solution_number</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    maximum_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> range(<span class="number">12</span>, <span class="number">1001</span>):</span><br><span class="line">        count_result = getSolutions(p)</span><br><span class="line">        <span class="keyword">if</span> count_result &gt; maximum_count:</span><br><span class="line">            maximum_count = count_result</span><br><span class="line">            maximum_count_p = p</span><br><span class="line">    <span class="keyword">print</span> maximum_count_p</span><br></pre></td></tr></table></figure><h2 id="40-Champernowne’s-constant"><a href="#40-Champernowne’s-constant" class="headerlink" title="40. Champernowne’s constant"></a>40. Champernowne’s constant</h2><h3 id="Probelm-Description"><a href="#Probelm-Description" class="headerlink" title="Probelm Description"></a>Probelm Description</h3><p>An irrational decimal fraction is created by concatenating the positive integers:</p><p>0.12345678910<strong>1</strong>112131415161718192021…</p><p>It can be seen that the $12^{th}$ digit of the fractional part is 1.</p><p>If $d_{n}$ represents the $n^{th}$ digit of the fractional part, find the value of the following expression.</p><script type="math/tex; mode=display">d_{1} × d_{10} × d_{100} × d_{1000} × d_{10000} × d_{100000} × d_{1000000}</script><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the value of the following expression</span></span><br><span class="line"><span class="comment"># d1 x d10 x d100 x d1000 x d10000 x d100000 x d1000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDecimalFraction</span><span class="params">()</span>:</span></span><br><span class="line">    positive_integer = <span class="number">1</span></span><br><span class="line">    decimalfraction_string = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> len(decimalfraction_string) &lt; <span class="number">1000000</span>:</span><br><span class="line">        decimalfraction_string += str(positive_integer)</span><br><span class="line">        positive_integer += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> decimalfraction_string</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    final_fraction = getDecimalFraction()</span><br><span class="line">    result = int(final_fraction[<span class="number">0</span>])*int(final_fraction[<span class="number">9</span>])*int(final_fraction[<span class="number">99</span>])*int(final_fraction[<span class="number">999</span>])*int(final_fraction[<span class="number">9999</span>])*int(final_fraction[<span class="number">99999</span>])*int(final_fraction[<span class="number">999999</span>])</span><br><span class="line">    <span class="keyword">print</span> result</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;31-Coin-sums&quot;&gt;&lt;a href=&quot;#31-Coin-sums&quot; class=&quot;headerlink&quot; title=&quot;31. Coin sums&quot;&gt;&lt;/a&gt;31. Coin sums&lt;/h2&gt;&lt;h3 id=&quot;Problem-Description&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="Mathematics" scheme="https://blank-vax.github.io/categories/Mathematics/"/>
    
    
      <category term="Euler-Project" scheme="https://blank-vax.github.io/tags/Euler-Project/"/>
    
  </entry>
  
  <entry>
    <title>Euler-Project(III)</title>
    <link href="https://blank-vax.github.io/2020/11/10/Euler-Project(III)/"/>
    <id>https://blank-vax.github.io/2020/11/10/Euler-Project(III)/</id>
    <published>2020-11-09T16:20:00.000Z</published>
    <updated>2021-07-07T04:08:23.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="21-Amicable-numbers"><a href="#21-Amicable-numbers" class="headerlink" title="21. Amicable numbers"></a>21. Amicable numbers</h2><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Let d(<em>n</em>) be defined as the sum of proper divisors of <em>n</em> (numbers less than <em>n</em> which divide evenly into <em>n</em>).<br>If d(<em>a</em>) = <em>b</em> and d(<em>b</em>) = <em>a</em>, where <em>a</em> ≠ <em>b</em>, then <em>a</em> and <em>b</em> are an amicable pair and each of <em>a</em> and <em>b</em> are called amicable numbers.</p><p>For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220.</p><p>Evaluate the sum of all the amicable numbers under 10000.</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><p>根据题目抓住关键点：</p><ul><li>本题需要统计满足<code>d(a) == b and d(b) == a, while a != b</code>条件的数字对(a, b) ，故需要关注<code>d(a) == a</code>的情况；</li><li>统计因子之和的函数中，引入set数据结构，在结果中排除重复添加的情况，最后加上1。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSumOfDivisors</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> input_number == <span class="number">1</span> <span class="keyword">or</span> input_number == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    important_set = set()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">2</span>, int(input_number/<span class="number">2</span>)):</span><br><span class="line">        <span class="keyword">if</span> input_number % item == <span class="number">0</span>:</span><br><span class="line">            important_set.add(item)</span><br><span class="line">            important_set.add(input_number/item)</span><br><span class="line">    <span class="keyword">return</span> sum(important_set)+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    blank_list = []</span><br><span class="line">    <span class="keyword">for</span> index_number <span class="keyword">in</span> xrange(<span class="number">10000</span>):</span><br><span class="line">        <span class="keyword">if</span> index_number <span class="keyword">in</span> blank_list:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        tmp_result = getSumOfDivisors(index_number)</span><br><span class="line">        <span class="keyword">if</span> tmp_result == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> (index_number == getSumOfDivisors(tmp_result)) <span class="keyword">and</span> (index_number != tmp_result) :</span><br><span class="line">            blank_list.append(tmp_result)</span><br><span class="line">            blank_list.append(index_number)</span><br><span class="line">    <span class="keyword">print</span> sum(blank_list)</span><br></pre></td></tr></table></figure><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h3><p>从第十题的分析可以看出，任何一个数字都可以表示成素数幂乘积的形式。下面对素数幂的因子之和进行推导分析：</p><p>设p为任意素数，由于素数只包含1和其本身两个因子，则：$\sigma(p) = p + 1$；</p><p>考虑p的a次幂，$\sigma(p^{a}) = 1 + p + p^{2} + p^{3} + … + p^{a}$ (1)；</p><p>式子(1)两侧同乘p，有$p*\sigma(p^{a}) = p + p^{2} + p^{3} + p^{4} + … + p^{a+1} (2)$;</p><p>(2) - (1)得，$p<em>\sigma(p^{a}) - \sigma(p^{a}) = (p-1) </em> \sigma(p^{a}) = p^{a+1} - 1$；</p><p>因此$\sigma(p^{a}) = (p^{a+1} - 1) / (p - 1)$</p><p>使用该公式并结合数字的素数幂分解即可较快求出因子之和，代码实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SumOfDivisors</span><span class="params">(n)</span>:</span></span><br><span class="line">    sum_result = <span class="number">1</span></span><br><span class="line">    p = <span class="number">2</span></span><br><span class="line">    <span class="comment"># Prevents from checking prime factors greater than sqrt(n).</span></span><br><span class="line">    <span class="keyword">while</span> p**<span class="number">2</span> &lt;= n <span class="keyword">and</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> n % p == <span class="number">0</span>:</span><br><span class="line">            j = p**<span class="number">2</span></span><br><span class="line">            n /= p</span><br><span class="line">            <span class="keyword">while</span> n % p == <span class="number">0</span>:</span><br><span class="line">                j *= p</span><br><span class="line">                n /= p</span><br><span class="line">            sum_result *= (j<span class="number">-1</span>)</span><br><span class="line">            sum_result /= (p<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> p == <span class="number">2</span>:</span><br><span class="line">            p = <span class="number">3</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p += <span class="number">2</span></span><br><span class="line">    <span class="comment"># Covers the case that one prime factor greater than sqrt(n) remains.</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        sum_result *= (n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> sum_result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SumOfProperDivisors</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> SumOfDivisors(input_number) - input_number</span><br></pre></td></tr></table></figure><p>与解法一对比，该方法将运算时间 从3s降低到0.3s。</p><h2 id="22-Names-score"><a href="#22-Names-score" class="headerlink" title="22. Names score"></a>22. Names score</h2><h3 id="Problem-Description-1"><a href="#Problem-Description-1" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Using <a href="https://projecteuler.net/project/resources/p022_names.txt" target="_blank" rel="noopener">names.txt</a> (right click and ‘Save Link/Target As…’), a 46K text file containing over five-thousand first names, begin by sorting it into alphabetical order. Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list to obtain a name score.</p><p>For example, when the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. So, COLIN would obtain a score of 938 × 53 = 49714.</p><p>What is the total of all the name scores in the file?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Count the total scores of names</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SortContentAsAlphabeticalPosition</span><span class="params">(txtlocation)</span>:</span></span><br><span class="line">    file = open(txtlocation, <span class="string">"r"</span>)</span><br><span class="line">    content_string = file.read()</span><br><span class="line">    content_list = content_string.replace(<span class="string">"\""</span>, <span class="string">""</span>).split(<span class="string">","</span>)</span><br><span class="line">    <span class="keyword">return</span> sorted(content_list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetWordScore</span><span class="params">(input_word)</span>:</span></span><br><span class="line">    word_Score = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> input_word:</span><br><span class="line">        word_Score += ord(item) - <span class="number">65</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> word_Score</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CountTotalScore</span><span class="params">(content_list)</span>:</span></span><br><span class="line">    total_score = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> xrange(len(content_list)):</span><br><span class="line">        total_score += GetWordScore(content_list[index]) * (index+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> total_score</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    txt_location = given_txt_path</span><br><span class="line">    Sorted_list = SortContentAsAlphabeticalPosition(txt_location)</span><br><span class="line">    total_score = CountTotalScore(Sorted_list)</span><br><span class="line">    <span class="keyword">print</span> total_score</span><br></pre></td></tr></table></figure><h2 id="23-Non-abundant-sums"><a href="#23-Non-abundant-sums" class="headerlink" title="23. Non-abundant sums"></a>23. Non-abundant sums</h2><h3 id="Problem-Description-2"><a href="#Problem-Description-2" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>A perfect number is a number for which the sum of its proper divisors is exactly equal to the number. For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.</p><p>A number n is called deficient if the sum of its proper divisors is less than n and it is called abundant if this sum exceeds n.</p><p>As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be written as the sum of two abundant numbers is 24. By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers. However, this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit.</p><p>Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SumOfDivisors</span><span class="params">(n)</span>:</span></span><br><span class="line">    sum_result = <span class="number">1</span></span><br><span class="line">    p = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> p**<span class="number">2</span> &lt;= n <span class="keyword">and</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> n % p == <span class="number">0</span>:</span><br><span class="line">            j = p**<span class="number">2</span></span><br><span class="line">            n /= p</span><br><span class="line">            <span class="keyword">while</span> n % p == <span class="number">0</span>:</span><br><span class="line">                j *= p</span><br><span class="line">                n /= p</span><br><span class="line">            sum_result *= (j<span class="number">-1</span>)</span><br><span class="line">            sum_result /= (p<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> p == <span class="number">2</span>:</span><br><span class="line">            p = <span class="number">3</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p += <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        sum_result *= (n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> sum_result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SumOfProperDivisors</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> SumOfDivisors(input_number) - input_number</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    final_sum = <span class="number">28123</span>*<span class="number">28124</span>/<span class="number">2</span></span><br><span class="line">    least_abundant_number = <span class="number">12</span></span><br><span class="line">    possible_abundant_number_list = []</span><br><span class="line">    <span class="keyword">while</span> least_abundant_number &lt;= <span class="number">28123</span>:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> possible_abundant_number_list:</span><br><span class="line">            <span class="keyword">if</span> least_abundant_number - item <span class="keyword">in</span> possible_abundant_number_list:</span><br><span class="line">                final_sum -= least_abundant_number</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> SumOfProperDivisors(least_abundant_number) &gt; least_abundant_number:</span><br><span class="line">            possible_abundant_number_list.append(least_abundant_number)</span><br><span class="line">        least_abundant_number += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> final_sum</span><br></pre></td></tr></table></figure><p>使用上述暴力遍历的方法统计结果需要的时间较长，大概为160-180s左右。</p><h2 id="24-Lexicographic-permutations"><a href="#24-Lexicographic-permutations" class="headerlink" title="24. Lexicographic permutations"></a>24. Lexicographic permutations</h2><h3 id="Problem-Description-3"><a href="#Problem-Description-3" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>A permutation is an ordered arrangement of objects. For example, 3124 is one possible permutation of the digits 1, 2, 3 and 4. If all of the permutations are listed numerically or alphabetically, we call it lexicographic order. The lexicographic permutations of 0, 1 and 2 are:</p><p>012  021  102  120  201  210</p><p>What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9?</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>偷懒调用了python的itertools库，其中包含<code>permutations()</code>即排列函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    result_string = <span class="string">""</span></span><br><span class="line">    result_list = list(permutations(<span class="string">'0123456789'</span>))</span><br><span class="line">    final_result = sorted(result_list)[<span class="number">999999</span>]</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> final_result:</span><br><span class="line">        result_string += item</span><br><span class="line">    <span class="keyword">print</span> eval(result_string)</span><br></pre></td></tr></table></figure><h2 id="25-1000-digit-Fibonacci-number"><a href="#25-1000-digit-Fibonacci-number" class="headerlink" title="25. 1000-digit Fibonacci number"></a>25. 1000-digit Fibonacci number</h2><h3 id="Problem-Description-4"><a href="#Problem-Description-4" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The Fibonacci sequence is defined by the recurrence relation:</p><script type="math/tex; mode=display">F_{n} = F_{n−1} + F_{n−2}, where F_{1} = 1 and F_{2} = 1</script><p>Hence the first 12 terms will be:</p><script type="math/tex; mode=display">F_{1} = 1</script><script type="math/tex; mode=display">F_{2} = 1</script><script type="math/tex; mode=display">F_{3} = 2</script><script type="math/tex; mode=display">F_{4} = 3</script><script type="math/tex; mode=display">F_{5} = 5</script><script type="math/tex; mode=display">F_{6} = 8</script><script type="math/tex; mode=display">F_{7} = 13</script><script type="math/tex; mode=display">F_{8} = 21</script><script type="math/tex; mode=display">F_{9} = 34</script><script type="math/tex; mode=display">F_{10} = 55</script><script type="math/tex; mode=display">F_{11} = 89</script><script type="math/tex; mode=display">F_{12} = 144</script><p>The 12th term, $F_{12}$, is the first term to contain three digits.</p><p>What is the index of the first term in the Fibonacci sequence to contain 1000 digits?</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># What is the index of the first term in the Fibonacci sequence to contain 1000 digits</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetIndexOfFibonacci</span><span class="params">()</span>:</span></span><br><span class="line">    f = <span class="number">1</span></span><br><span class="line">    g = <span class="number">1</span></span><br><span class="line">    g_count = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> len(str(g)) &lt; <span class="number">1000</span>:</span><br><span class="line">        f, g = g, f+g</span><br><span class="line">        g_count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> g_count</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    final_result = GetIndexOfFibonacci()</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h2 id="26-Reciprocal-cycles"><a href="#26-Reciprocal-cycles" class="headerlink" title="26. Reciprocal cycles"></a>26. Reciprocal cycles</h2><h3 id="Problem-Description-5"><a href="#Problem-Description-5" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>A unit fraction contains 1 in the numerator. The decimal representation of the unit fractions with denominators 2 to 10 are given:</p><blockquote><div class="table-container"><table><thead><tr><th>1/2</th><th>=</th><th>0.5</th></tr></thead><tbody><tr><td>1/3</td><td>=</td><td>0.(3)</td></tr><tr><td>1/4</td><td>=</td><td>0.25</td></tr><tr><td>1/5</td><td>=</td><td>0.2</td></tr><tr><td>1/6</td><td>=</td><td>0.1(6)</td></tr><tr><td>1/7</td><td>=</td><td>0.(142857)</td></tr><tr><td>1/8</td><td>=</td><td>0.125</td></tr><tr><td>1/9</td><td>=</td><td>0.(1)</td></tr><tr><td>1/10</td><td>=</td><td>0.1</td></tr></tbody></table></div></blockquote><p>Where 0.1(6) means 0.166666…, and has a 1-digit recurring cycle. It can be seen that 1/7 has a 6-digit recurring cycle.</p><p>Find the value of <em>d</em> &lt; 1000 for which 1/<em>d</em> contains the longest recurring cycle in its decimal fraction part.</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>本题为经典的循环节计算问题。</p><p>设分母为n，若n为合数，则必可以表示成多个素数的乘积，其循环节与这些分解素数中最大的循环节保持一致。故只需要讨论所给范围内所有素数分母其倒数的循环节即可。值得注意的是，1/2与1/5都是有限小数，故2和5这两个素数需要排除。</p><p>确定循环的范围后下面进行循环节计算：通过查阅资料可知，循环节问题可以等价为大整数分解问题。给定大整数n，求使得$10^{k} \equiv 1 (mod n)$成立的最小的k，该数值即为1/n循环节的长度。根据以上分析采取<code>10**k-1 % n == 0</code>作为限制条件求解。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the value of d &lt; 1000 for which 1/d contains the longest recurring cycle in its decimal fraction part</span></span><br><span class="line"><span class="comment"># Brute force to find the longest recurring cycle</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># Judge whether n is prime</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(math.sqrt(n))+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetRecurringCycle</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    L = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">10</span>**L<span class="number">-1</span>) % input_number == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        L += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    max_recurring_length = <span class="number">1</span></span><br><span class="line">    result_n = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">1001</span>):</span><br><span class="line">        <span class="keyword">if</span> isPrime(i) <span class="keyword">and</span> i != <span class="number">2</span> <span class="keyword">and</span> i != <span class="number">5</span>:</span><br><span class="line">            recurring_length = GetRecurringCycle(i)</span><br><span class="line">            <span class="keyword">if</span> recurring_length &gt; max_recurring_length:</span><br><span class="line">                max_recurring_length = recurring_length</span><br><span class="line">                result_n = i</span><br><span class="line">    <span class="keyword">print</span> (result_n, max_recurring_length)</span><br></pre></td></tr></table></figure><h3 id="Mathematical-Analysis"><a href="#Mathematical-Analysis" class="headerlink" title="Mathematical Analysis"></a>Mathematical Analysis</h3><p>考虑上面提到的一般化问题：求最小的k使得$a^{k} \equiv 1(mod n)$，若n与a互素，求出分母n的欧拉函数值$\Phi(n)$，则循环节长度k必为其约数；若n与a存在公因子则无解。由此可见通过暴力遍历的方法可以求出约数k，从而得出循环节。</p><p>在RSA加密中，给定n=p<em>q，则p，q均为大质数，此时1/n循环节的长度length为gcd(p-1, q-1)的约数。假定已知length的因数分解$length = l<em>{1}^{c</em>{1}}</em>l<em>{2}^{c</em>{2}}<em>l<em>{3}^{c</em>{3}}</em>……*l<em>{k}^{c</em>{k}}$，则length共有$\prod[c_{i}+1]$个约数。将这些约数分别加上1，若某个约数y(j)加1后是质数，则y(j)+1可能是大整数n的约数。对所有小于$\sqrt{n}-1$的y(j)进行检验，必能找到一个恰好满足y(j)+1 = min(p, q)的数字。通过此种方法可以将大整数分解问题转换为求循环节的问题。在最坏的情况下，一个300位的大整数只需通过小于500次转换完成分解。</p><p>关于循环节长度计算公式存在如下改进：</p><p><img src="/2020/11/10/Euler-Project(III)/Euler-Project(III" alt="26_recurring_cycle.PNG-34.7kB">\1.PNG)</p><p>该公式的应用如下：</p><p><img src="/2020/11/10/Euler-Project(III)/Euler-Project(III" alt="26_recurring_cycle2.PNG-47.8kB">\2.PNG)</p><p>参考论文：关于循环节长度计算公式的改进：<a href="https://www.ixueshu.com/document/6d924626ac37b4ee318947a18e7f9386.html" target="_blank" rel="noopener">https://www.ixueshu.com/document/6d924626ac37b4ee318947a18e7f9386.html</a></p><h2 id="27-Quadratic-primes"><a href="#27-Quadratic-primes" class="headerlink" title="27. Quadratic primes"></a>27. Quadratic primes</h2><h3 id="Problem-Description-6"><a href="#Problem-Description-6" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Euler discovered the remarkable quadratic formula:</p><script type="math/tex; mode=display">n^{2} + n + 41</script><p>It turns out that the formula will produce 40 primes for the consecutive integer values 0≤n≤39. However, when$ n=40, 40^{2}+40+41=40*(40+1)+41$ is divisible by 41, and certainly when $ n=41,41^{2}+41+41 $is clearly divisible by 41.</p><p>The incredible formula $n^{2}−79*n+1601$ was discovered, which produces 80 primes for the consecutive values 0≤n≤79. The product of the coefficients, −79 and 1601, is −126479.</p><p>Considering quadratics of the form:</p><script type="math/tex; mode=display">n^{2}+a*n+b , where|a|<1000 , |b|≤1000</script><p>where |n| is the modulus/absolute value of n<br>e.g. |11|=11 and |−4|=4</p><p>Find the product of the coefficients, a and b, for the quadratic expression that produces the maximum number of primes for consecutive values of n, starting with n=0.</p><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>根据题目，可以仅通过数学推导的方法求解（条件极值问题+二次图像平移），参考链接如下：<a href="https://zhuanlan.zhihu.com/p/62137330。除此之外，还可以按照题意暴力求解，由于本题提供的a" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/62137330。除此之外，还可以按照题意暴力求解，由于本题提供的a</a>, b范围较小，故可以在较短时间内完成计算。根据题目给出的二次多项式$f(n) = n^{2} + a*n + b$可得出以下性质：</p><ul><li>由f(0) = b可知参数b必为素数，故将b的遍历范围缩小为2—999；</li><li>由f(1) = a+b+1且该多项式为素数，可得结论a &gt; -b-1，据此适当缩小a的遍历范围；</li><li>当gcd(a, b) = d且d != 1时，一定存在一个数n’ = minP(d)使得f(n’)为合数，其中minP(d)表示d的最小素因子。从而若a, b不互素，最多生成minP(d)个连续素数，从而在遍历过程中排除a, b不互素的情况即可。（需要用到math.gcd()函数且偷懒不想自己构造，故以下代码需选择Python3.5+版本运行）</li></ul><p>遍历代码具有两个版本，记录如下：</p><h4 id="Version1"><a href="#Version1" class="headerlink" title="Version1"></a>Version1</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the product of the coefficients,a and b, for the quadratic expression that produces the maximum number of primes for consecutive values of n, starting with n = 0</span></span><br><span class="line"><span class="comment"># Some properties:</span></span><br><span class="line">    <span class="comment"># f(0) = b, so b must be a prime</span></span><br><span class="line">    <span class="comment"># a &gt; -b-1</span></span><br><span class="line">    <span class="comment"># if gcd(a, b) = d and d != 1, we could only get as many as the least prime factor of d continuous primes</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(math.sqrt(n))+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    prime_counter = <span class="number">0</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> isPrime(n*n+a*n+b):</span><br><span class="line">            prime_counter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> prime_counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    result_set = []</span><br><span class="line">    max_result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">-995</span>, <span class="number">999</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">1000</span>):</span><br><span class="line">            <span class="keyword">if</span> isPrime(b) <span class="keyword">and</span> math.gcd(a, b) == <span class="number">1</span>:</span><br><span class="line">                count = countPrimes(a, b)</span><br><span class="line">                <span class="keyword">if</span> count &gt; max_result:</span><br><span class="line">                    max_result = count</span><br><span class="line">                    result_set.append(a*b)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">    print(result_set[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h4 id="Version2"><a href="#Version2" class="headerlink" title="Version2"></a>Version2</h4><p>引入python中的数学运算库sympy，该库继承多种数学运算，包括大量素数操作的接口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">isprime(n)              <span class="comment"># Test if n is a prime number (True) or not (False).</span></span><br><span class="line"> </span><br><span class="line">primerange(a, b)        <span class="comment"># Generate a list of all prime numbers in the range [a, b).</span></span><br><span class="line">randprime(a, b)         <span class="comment"># Return a random prime number in the range [a, b).</span></span><br><span class="line">primepi(n)              <span class="comment"># Return the number of prime numbers less than or equal to n.</span></span><br><span class="line"> </span><br><span class="line">prime(nth)              <span class="comment"># Return the nth prime, with the primes indexed as prime(1) = 2. The nth prime is approximately n*log(n) and can never be larger than 2**n.</span></span><br><span class="line">prevprime(n, ith=<span class="number">1</span>)     <span class="comment"># Return the largest prime smaller than n</span></span><br><span class="line">nextprime(n)            <span class="comment"># Return the ith prime greater than n</span></span><br><span class="line"> </span><br><span class="line">sieve.primerange(a, b)  <span class="comment"># Generate all prime numbers in the range [a, b), implemented as a dynamically growing sieve of Eratosthenes.</span></span><br></pre></td></tr></table></figure><p>代码如下，其中应用到<code>sympy.isprime()</code>函数进行素数判断，应用<code>sieve.primerange(a, b)</code>函数生成1—1000内的所有素数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"></span><br><span class="line"><span class="comment"># This function is used to collect all the primes between 1 and 1000</span></span><br><span class="line">Prime = list(sympy.sieve.primerange(<span class="number">1</span>, <span class="number">1000</span>))</span><br><span class="line">dic = &#123;&#125;</span><br><span class="line">dic[<span class="string">'n'</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">-995</span>, <span class="number">999</span>, <span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> Prime:</span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        c = n*n + a*n + b</span><br><span class="line">        <span class="keyword">while</span> sympy.isprime(c):</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            c = n*n + a*n + b</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; dic[<span class="string">'n'</span>]:</span><br><span class="line">            dic[<span class="string">'n'</span>] = n</span><br><span class="line">            dic[<span class="string">'a*b'</span>] = a*b</span><br><span class="line"><span class="keyword">print</span> dic[<span class="string">'a*b'</span>]</span><br></pre></td></tr></table></figure><p>sympy库函数文档：<a href="http://docs.sympy.org/latest/modules/ntheory.html?highlight=prime#ntheory-functions-reference" target="_blank" rel="noopener">http://docs.sympy.org/latest/modules/ntheory.html?highlight=prime#ntheory-functions-reference</a></p><h2 id="28-Number-spiral-diagonals"><a href="#28-Number-spiral-diagonals" class="headerlink" title="28. Number spiral diagonals"></a>28. Number spiral diagonals</h2><h3 id="Problem-Description-7"><a href="#Problem-Description-7" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Starting with the number 1 and moving to the right in a clockwise direction a 5 by 5 spiral is formed as follows:</p><p><img src="/2020/11/10/Euler-Project(III)/Euler-Project(III" alt="28_problem.PNG-10.2kB">\3.PNG)</p><p>It can be verified that the sum of the numbers on the diagonals is 101.</p><p>What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way?</p><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gridA: 5*5 there are 3 circles</span></span><br><span class="line"><span class="comment"># gridB: 7*7 there are 4 circles</span></span><br><span class="line"><span class="comment"># gridN: N*N there must be (N+1)/2 circles</span></span><br><span class="line"><span class="comment"># Arithmetic progression</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCircles</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (n+<span class="number">1</span>) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSum</span><span class="params">(circle_number)</span>:</span></span><br><span class="line">    final_sum = <span class="number">0</span></span><br><span class="line">    step = <span class="number">2</span></span><br><span class="line">    origin_number = <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(circle_number<span class="number">-1</span>):</span><br><span class="line">        final_sum += <span class="number">4</span>*origin_number + <span class="number">6</span>*step</span><br><span class="line">        origin_number += <span class="number">4</span>*step + <span class="number">2</span></span><br><span class="line">        step += <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> final_sum</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    final_result = countSum(getCircles(<span class="number">1001</span>))</span><br><span class="line">    <span class="keyword">print</span> final_result+<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="29-Distinct-powers"><a href="#29-Distinct-powers" class="headerlink" title="29. Distinct powers"></a>29. Distinct powers</h2><h3 id="Problem-Description-8"><a href="#Problem-Description-8" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Consider all integer combinations of $a^{b}$ for 2 ≤ <em>a</em> ≤ 5 and 2 ≤ <em>b</em> ≤ 5:</p><script type="math/tex; mode=display">2^{2}=4, 2^{3}=8, 2^{4}=16, 2^{5}=32</script><script type="math/tex; mode=display">3^{2}=9, 3^{3}=27, 3^{4}=81, 3^{5}=243</script><script type="math/tex; mode=display">4^{2}=16, 4^{3}=64, 4^{4}=256, 4^{5}=1024</script><script type="math/tex; mode=display">5^{2}=25, 5^{3}=125, 5^{4}=625, 5^{5}=3125</script><p>If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:</p><p>4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125</p><p>How many distinct terms are in the sequence generated by $a^{b}$ for 2 ≤ <em>a</em> ≤ 100 and 2 ≤ <em>b</em> ≤ 100?</p><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final_set = set()</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">101</span>):</span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">101</span>):</span><br><span class="line">tmp_a_b = a**b</span><br><span class="line">        tmp_b_a = b**a</span><br><span class="line">        <span class="keyword">if</span> tmp_a_b <span class="keyword">not</span> <span class="keyword">in</span> final_set:</span><br><span class="line">            final_set.add(tmp_a_b)</span><br><span class="line">        <span class="keyword">if</span> tmp_b_a <span class="keyword">not</span> <span class="keyword">in</span> final_set:</span><br><span class="line">            final_set.add(tmp_b_a)</span><br><span class="line"><span class="keyword">print</span> len(final_set)</span><br></pre></td></tr></table></figure><h2 id="30-Digit-fifth-powers"><a href="#30-Digit-fifth-powers" class="headerlink" title="30. Digit fifth powers"></a>30. Digit fifth powers</h2><h3 id="Problem-Description-9"><a href="#Problem-Description-9" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Surprisingly there are only three numbers that can be written as the sum of fourth powers of their digits:</p><script type="math/tex; mode=display">1634 = 1^{4} + 6^{4} + 3^{4} + 4^{4}</script><script type="math/tex; mode=display">8208 = 8^{4} + 2^{4} + 0^{4} + 8^{4}</script><script type="math/tex; mode=display">9474 = 9^{4} + 4^{4} + 7^{4} + 4^{4}</script><p>As$ 1 = 1^{4} $is not a sum it is not included.</p><p>The sum of these numbers is 1634 + 8208 + 9474 = 19316.</p><p>Find the sum of all the numbers that can be written as the sum of fifth powers of their digits.</p><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><p>该问题的关键为确定枚举的上界：设满足题设条件的数字为n位数，取其每位都为9的情况，构造不等式$ 10^{n} &lt;= 9^{5}*n $，计算满足条件n的最小值即可找出上界。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the sum of all the numbers that can be written as the sum of fifth powers of their powers</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSum</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    sum_result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> input_number != <span class="number">0</span>:</span><br><span class="line">        sum_result += (input_number % <span class="number">10</span>)**<span class="number">5</span></span><br><span class="line">        input_number /= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> sum_result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    final_result = <span class="number">0</span></span><br><span class="line">    <span class="comment"># Work out the upper bound of the enumeration range</span></span><br><span class="line">    <span class="comment"># 10^n &lt;= 9^5*n =&gt; we can get the minimum value of n is 5</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">9</span>**<span class="number">5</span>*<span class="number">6</span>):</span><br><span class="line">        <span class="keyword">if</span> item == getSum(item):</span><br><span class="line">            final_result += item</span><br><span class="line">            <span class="keyword">print</span> item</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;21-Amicable-numbers&quot;&gt;&lt;a href=&quot;#21-Amicable-numbers&quot; class=&quot;headerlink&quot; title=&quot;21. Amicable numbers&quot;&gt;&lt;/a&gt;21. Amicable numbers&lt;/h2&gt;&lt;h3
      
    
    </summary>
    
      <category term="Mathematics" scheme="https://blank-vax.github.io/categories/Mathematics/"/>
    
    
      <category term="Euler-Project" scheme="https://blank-vax.github.io/tags/Euler-Project/"/>
    
  </entry>
  
  <entry>
    <title>Euler-Project(II)</title>
    <link href="https://blank-vax.github.io/2020/10/25/Euler-Project(II)/"/>
    <id>https://blank-vax.github.io/2020/10/25/Euler-Project(II)/</id>
    <published>2020-10-25T04:16:00.000Z</published>
    <updated>2021-07-07T04:04:38.306Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11-Largest-product-in-a-grid"><a href="#11-Largest-product-in-a-grid" class="headerlink" title="11. Largest product in a grid"></a>11. Largest product in a grid</h2><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>In the 20×20 grid below, four numbers along a diagonal line have been marked in bold.</p><p>08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08<br>49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00<br>81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65<br>52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91<br>22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80<br>24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50<br>32 98 81 28 64 23 67 10 <strong>26</strong> 38 40 67 59 54 70 66 18 38 64 70<br>67 26 20 68 02 62 12 20 95 <strong>63</strong> 94 39 63 08 40 91 66 49 94 21<br>24 55 58 05 66 73 99 26 97 17 <strong>78</strong> 78 96 83 14 88 34 89 63 72<br>21 36 23 09 75 00 76 44 20 45 35 <strong>14</strong> 00 61 33 97 34 31 33 95<br>78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92<br>16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57<br>86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58<br>19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40<br>04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66<br>88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69<br>04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36<br>20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16<br>20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54<br>01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48</p><p>The product of these numbers is 26 × 63 × 78 × 14 = 1788696.</p><p>What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Simply rotation and comparison in four types of direction</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">grid_given =<span class="string">'''08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08</span></span><br><span class="line"><span class="string">49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00</span></span><br><span class="line"><span class="string">81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65</span></span><br><span class="line"><span class="string">52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91</span></span><br><span class="line"><span class="string">22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80</span></span><br><span class="line"><span class="string">24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50</span></span><br><span class="line"><span class="string">32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70</span></span><br><span class="line"><span class="string">67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21</span></span><br><span class="line"><span class="string">24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72</span></span><br><span class="line"><span class="string">21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95</span></span><br><span class="line"><span class="string">78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92</span></span><br><span class="line"><span class="string">16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57</span></span><br><span class="line"><span class="string">86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58</span></span><br><span class="line"><span class="string">19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40</span></span><br><span class="line"><span class="string">04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66</span></span><br><span class="line"><span class="string">88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69</span></span><br><span class="line"><span class="string">04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36</span></span><br><span class="line"><span class="string">20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16</span></span><br><span class="line"><span class="string">20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54</span></span><br><span class="line"><span class="string">01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48'''</span></span><br><span class="line"><span class="comment"># Alist variable is used to slice the given grid</span></span><br><span class="line">alist = [re.split(<span class="string">' '</span>, everyrow) <span class="keyword">for</span> everyrow <span class="keyword">in</span> re.split(<span class="string">'\n'</span>, grid_given)]</span><br><span class="line">result_list = []</span><br><span class="line"><span class="comment"># rows</span></span><br><span class="line"><span class="keyword">for</span> row_index <span class="keyword">in</span> range(len(alist)):</span><br><span class="line">    <span class="keyword">for</span> columns_index <span class="keyword">in</span> xrange(len(alist[row_index])<span class="number">-3</span>):</span><br><span class="line">        result_list.append(int(alist[row_index][columns_index])*int(alist[row_index][columns_index+<span class="number">1</span>])*int(alist[row_index][columns_index+<span class="number">2</span>])*int(alist[row_index][columns_index+<span class="number">3</span>]))</span><br><span class="line"><span class="comment"># columns</span></span><br><span class="line"><span class="keyword">for</span> columns_index <span class="keyword">in</span> range(len(alist[<span class="number">0</span>])):</span><br><span class="line">    <span class="keyword">for</span> row_index <span class="keyword">in</span> xrange(len(alist)<span class="number">-3</span>):</span><br><span class="line">        result_list.append(int(alist[row_index][columns_index])*int(alist[row_index+<span class="number">1</span>][columns_index])*int(alist[row_index+<span class="number">2</span>][columns_index])*int(alist[row_index+<span class="number">3</span>][columns_index]))</span><br><span class="line"><span class="comment"># diagonal</span></span><br><span class="line"><span class="keyword">for</span> row_index <span class="keyword">in</span> range(len(alist)<span class="number">-3</span>):</span><br><span class="line">    <span class="keyword">for</span> columns_index <span class="keyword">in</span> range(len(alist[row_index])<span class="number">-3</span>):</span><br><span class="line">        <span class="comment"># main diagonal</span></span><br><span class="line">        result_list.append(int(alist[row_index][columns_index])*int(alist[row_index+<span class="number">1</span>][columns_index+<span class="number">1</span>])*int(alist[row_index+<span class="number">2</span>][columns_index+<span class="number">2</span>])*int(alist[row_index+<span class="number">3</span>][columns_index+<span class="number">3</span>]))</span><br><span class="line">        <span class="comment"># vice diagonal</span></span><br><span class="line">        result_list.append(int(alist[row_index+<span class="number">3</span>][columns_index])*int(alist[row_index+<span class="number">2</span>][columns_index+<span class="number">1</span>])*int(alist[row_index+<span class="number">1</span>][columns_index+<span class="number">2</span>])*int(alist[row_index][columns_index+<span class="number">3</span>]))</span><br><span class="line"><span class="keyword">print</span> max(result_list)</span><br></pre></td></tr></table></figure><h2 id="12-Highly-divisible-triangular-number"><a href="#12-Highly-divisible-triangular-number" class="headerlink" title="12. Highly divisible triangular number"></a>12. Highly divisible triangular number</h2><h3 id="Problem-Description-1"><a href="#Problem-Description-1" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:</p><p>1, 3, 6, 10, 15, 21, 28, 36, 45, 55, …</p><p>Let us list the factors of the first seven triangle numbers:</p><blockquote><p> <strong>1</strong>: 1<br> <strong>3</strong>: 1,3<br> <strong>6</strong>: 1,2,3,6<br><strong>10</strong>: 1,2,5,10<br><strong>15</strong>: 1,3,5,15<br><strong>21</strong>: 1,3,7,21<br><strong>28</strong>: 1,2,4,7,14,28</p></blockquote><p>We can see that 28 is the first triangle number to have over five divisors.</p><p>What is the value of the first triangle number to have over five hundred divisors?</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><p>通过观察可以发现，数字N的全部因子可分为大于$\sqrt{N}$和小于$\sqrt{N}$两部分，且这两部分的因子数量相等。故以$\sqrt{N}$为界限，统计前半部分因子数量，当大于250时跳出循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Triangular number</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">basic = <span class="number">1</span></span><br><span class="line">step = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    basic += step</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= int(math.sqrt(basic)):</span><br><span class="line">        <span class="keyword">if</span> basic % i == <span class="number">0</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> count &gt;= <span class="number">250</span>:</span><br><span class="line">        <span class="keyword">print</span> basic</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        step += <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h3><p>每个整数N可以分解为如下模式：</p><script type="math/tex; mode=display">N = p_{1}^{a1} * p_{2}^{a2} * p_{3}^{a3} * ...</script><p>此处$p<em>{n}$必为素数，$a</em>{n}$是其对应的幂指数。例如$28 = 2^{2} * 7^{1}$。继续推广下去，对于任意正整数N，其因子的数量D(N)可用如下式子表示：</p><script type="math/tex; mode=display">D(N) = (a_{1}+1) * (a_{2}+1) * (a_{3}+1) * ...</script><p>故首先采用埃氏筛法构造大素数表，随后对循环内每个数字进行分解以获得$a<em>{1}，a</em>{2}，a_{3}$等参数，连乘可得D(N)。对该常规方法进行改进，首先对三角形数进行等差数列求和，结果为$t = n * (n+1) / 2$，此处n和n+1必互素。随后采用如下公式分解D(t)：</p><p>$D(t) = D(n/2) * D(n+1)$, if n is even</p><p>$D(t) = D(n) * D((n+1)/2)$, if n is odd</p><p>实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Highly divisible triangular number</span></span><br><span class="line"><span class="comment"># First get the possible prime facotrs below 1000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPossiblePrimeFactors</span><span class="params">(upper_bound)</span>:</span></span><br><span class="line">    L = range(<span class="number">2</span>, upper_bound)</span><br><span class="line">    primes_list = findPrime(L)</span><br><span class="line">    <span class="keyword">return</span> primes_list</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPrime</span><span class="params">(L)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> L[i]**<span class="number">2</span> &lt; L[<span class="number">-1</span>]:</span><br><span class="line">        <span class="comment"># Eratosthenes algorithm</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(L)):</span><br><span class="line">            <span class="keyword">if</span> L[j] % L[i] == <span class="number">0</span>:</span><br><span class="line">                L[j] = <span class="number">0</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        L.sort()</span><br><span class="line">        L = L[count:]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countD</span><span class="params">(n, Dn, count_range, primes_list)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count &lt;= count_range:</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        n1 = n</span><br><span class="line">        <span class="keyword">if</span> n1 % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            n1 /= <span class="number">2</span></span><br><span class="line">        Dn1 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, primes_list[<span class="number">-1</span>]):</span><br><span class="line">            <span class="keyword">if</span> primes_list[i]**<span class="number">2</span> &gt; n1:</span><br><span class="line">                <span class="string">'''</span></span><br><span class="line"><span class="string">                When the prime divisor would be greater than the residual n1, that residual n1 is the last prime factor with an exponent = 1</span></span><br><span class="line"><span class="string">                '''</span></span><br><span class="line">                Dn1 = <span class="number">2</span>*Dn1</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># ause D(n) = (a1+1)*(a2+1)*(a3+1)*...., so initialize the exponent to 1</span></span><br><span class="line">            exponent = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> n1 % primes_list[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># resolve n1 to the form of multiplication, count a1, a2, a3, ...</span></span><br><span class="line">                exponent += <span class="number">1</span></span><br><span class="line">                n1 = n1 // primes_list[i]</span><br><span class="line">            <span class="keyword">if</span> exponent &gt; <span class="number">1</span>:</span><br><span class="line">                Dn1 = Dn1*exponent</span><br><span class="line">            <span class="keyword">if</span> n1 == <span class="number">1</span>: <span class="keyword">break</span></span><br><span class="line">        count = Dn*Dn1</span><br><span class="line">        Dn = Dn1</span><br><span class="line">    <span class="keyword">return</span> n*(n<span class="number">-1</span>) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">Dn = <span class="number">2</span></span><br><span class="line">primes_list = getPossiblePrimeFactors(<span class="number">1000</span>)</span><br><span class="line">final_result = countD(n, Dn, <span class="number">500</span>, primes_list)</span><br><span class="line"><span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><p>理解上述代码过程中，值得注意的是countD()函数的返回结果为n*(n-1) / 2而非n*(n+1) / 2，从而代码每次迭代计算的D(t)由传入while循环之前的n值表示，与上面提到的性质对应。</p><h2 id="13-Large-sum"><a href="#13-Large-sum" class="headerlink" title="13. Large sum"></a>13. Large sum</h2><h3 id="Problem-Description-2"><a href="#Problem-Description-2" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.</p><p>37107287533902102798797998220837590246510135740250<br>46376937677490009712648124896970078050417018260538<br>74324986199524741059474233309513058123726617309629<br>91942213363574161572522430563301811072406154908250<br>23067588207539346171171980310421047513778063246676<br>89261670696623633820136378418383684178734361726757<br>28112879812849979408065481931592621691275889832738<br>44274228917432520321923589422876796487670272189318<br>47451445736001306439091167216856844588711603153276<br>70386486105843025439939619828917593665686757934951<br>62176457141856560629502157223196586755079324193331<br>64906352462741904929101432445813822663347944758178<br>92575867718337217661963751590579239728245598838407<br>58203565325359399008402633568948830189458628227828<br>80181199384826282014278194139940567587151170094390<br>35398664372827112653829987240784473053190104293586<br>86515506006295864861532075273371959191420517255829<br>71693888707715466499115593487603532921714970056938<br>54370070576826684624621495650076471787294438377604<br>53282654108756828443191190634694037855217779295145<br>36123272525000296071075082563815656710885258350721<br>45876576172410976447339110607218265236877223636045<br>17423706905851860660448207621209813287860733969412<br>81142660418086830619328460811191061556940512689692<br>51934325451728388641918047049293215058642563049483<br>62467221648435076201727918039944693004732956340691<br>15732444386908125794514089057706229429197107928209<br>55037687525678773091862540744969844508330393682126<br>18336384825330154686196124348767681297534375946515<br>80386287592878490201521685554828717201219257766954<br>78182833757993103614740356856449095527097864797581<br>16726320100436897842553539920931837441497806860984<br>48403098129077791799088218795327364475675590848030<br>87086987551392711854517078544161852424320693150332<br>59959406895756536782107074926966537676326235447210<br>69793950679652694742597709739166693763042633987085<br>41052684708299085211399427365734116182760315001271<br>65378607361501080857009149939512557028198746004375<br>35829035317434717326932123578154982629742552737307<br>94953759765105305946966067683156574377167401875275<br>88902802571733229619176668713819931811048770190271<br>25267680276078003013678680992525463401061632866526<br>36270218540497705585629946580636237993140746255962<br>24074486908231174977792365466257246923322810917141<br>91430288197103288597806669760892938638285025333403<br>34413065578016127815921815005561868836468420090470<br>23053081172816430487623791969842487255036638784583<br>11487696932154902810424020138335124462181441773470<br>63783299490636259666498587618221225225512486764533<br>67720186971698544312419572409913959008952310058822<br>95548255300263520781532296796249481641953868218774<br>76085327132285723110424803456124867697064507995236<br>37774242535411291684276865538926205024910326572967<br>23701913275725675285653248258265463092207058596522<br>29798860272258331913126375147341994889534765745501<br>18495701454879288984856827726077713721403798879715<br>38298203783031473527721580348144513491373226651381<br>34829543829199918180278916522431027392251122869539<br>40957953066405232632538044100059654939159879593635<br>29746152185502371307642255121183693803580388584903<br>41698116222072977186158236678424689157993532961922<br>62467957194401269043877107275048102390895523597457<br>23189706772547915061505504953922979530901129967519<br>86188088225875314529584099251203829009407770775672<br>11306739708304724483816533873502340845647058077308<br>82959174767140363198008187129011875491310547126581<br>97623331044818386269515456334926366572897563400500<br>42846280183517070527831839425882145521227251250327<br>55121603546981200581762165212827652751691296897789<br>32238195734329339946437501907836945765883352399886<br>75506164965184775180738168837861091527357929701337<br>62177842752192623401942399639168044983993173312731<br>32924185707147349566916674687634660915035914677504<br>99518671430235219628894890102423325116913619626622<br>73267460800591547471830798392868535206946944540724<br>76841822524674417161514036427982273348055556214818<br>97142617910342598647204516893989422179826088076852<br>87783646182799346313767754307809363333018982642090<br>10848802521674670883215120185883543223812876952786<br>71329612474782464538636993009049310363619763878039<br>62184073572399794223406235393808339651327408011116<br>66627891981488087797941876876144230030984490851411<br>60661826293682836764744779239180335110989069790714<br>85786944089552990653640447425576083659976645795096<br>66024396409905389607120198219976047599490197230297<br>64913982680032973156037120041377903785566085089252<br>16730939319872750275468906903707539413042652315011<br>94809377245048795150954100921645863754710598436791<br>78639167021187492431995700641917969777599028300699<br>15368713711936614952811305876380278410754449733078<br>40789923115535562561142322423255033685442488917353<br>44889911501440648020369068063960672322193204149535<br>41503128880339536053299340368006977710650566631954<br>81234880673210146739058568557934581403627822703280<br>82616570773948327592232845941706525094512325230608<br>22918802058777319719839450180888072429661980811197<br>77158542502016545090413245809786882778948721859617<br>72107838435069186155435662884062257473692284509516<br>20849603980134001723930671666823555245252804609722<br>53503534226472524250874054075591789781264330331690</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">all_numbers = given_50_digit_numbers</span><br><span class="line">sum_result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> all_numbers.split(<span class="string">'\n'</span>):</span><br><span class="line">    <span class="keyword">if</span> item == <span class="string">''</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sum_result += int(item)</span><br><span class="line"><span class="keyword">print</span> str(sum_result)[<span class="number">0</span>:<span class="number">10</span>]</span><br></pre></td></tr></table></figure><h2 id="14-Longest-Collatz-sequence"><a href="#14-Longest-Collatz-sequence" class="headerlink" title="14. Longest Collatz sequence"></a>14. Longest Collatz sequence</h2><h3 id="Problem-Description-3"><a href="#Problem-Description-3" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The following iterative sequence is defined for the set of positive integers:</p><p>n → n/2 (n is even)<br>n → 3n + 1 (n is odd)</p><p>Using the rule above and starting with 13, we generate the following sequence:</p><p>13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1</p><p>It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.</p><p>Which starting number, under one million, produces the longest chain?</p><p><strong>NOTE:</strong> Once the chain starts the terms are allowed to go above one million.</p><h3 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1"></a>Solution1</h3><p>按照题意直接进行暴力遍历，可以采用递归和迭代的方法。采用靠近计算机底层的位运算代替普通运算可以适当提高效率：n &amp; 1 代替 n % 2，n &gt;&gt; 1代替 n / 2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Iteration</span></span><br><span class="line"><span class="comment"># Longest Collatz Sequence</span></span><br><span class="line"><span class="comment"># Which starting number, under one million, produces the longest chain</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCollatzSquence</span><span class="params">(n)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> n &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            n = <span class="number">3</span>*n+<span class="number">1</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    maxlength = <span class="number">1</span></span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>, <span class="number">1000000</span>):</span><br><span class="line">        count_number = getCollatzSquence(i)</span><br><span class="line">        <span class="keyword">if</span> count_number &gt; maxlength:</span><br><span class="line">            maxlength = count_number</span><br><span class="line">            flag = i</span><br><span class="line">    <span class="keyword">print</span> (maxlength, flag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Recursion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countCollatzChain</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + countCollatzChain(n &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + countCollatzChain(<span class="number">3</span> * n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    longest_chain = <span class="number">0</span></span><br><span class="line">    result = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> range(<span class="number">100</span>, <span class="number">10</span>**<span class="number">6</span><span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> countCollatzChain(number) &gt; longest_chain:</span><br><span class="line">            longest_chain = countCollatzChain(number)</span><br><span class="line">            result = number</span><br><span class="line">    <span class="keyword">print</span> result</span><br></pre></td></tr></table></figure><p>二者效率对比如下，可以看出迭代调用所需时间明显小于递归调用。</p><p><img src="/2020/10/25/Euler-Project(II)/Euler-Project(II" alt="14_sufficiency.PNG-10.6kB">\1.PNG)</p><h3 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2"></a>Solution2</h3><p>无论采用递归或是迭代的方法进行暴力遍历，我们都可以明确看出有部分数值经过重复计算，导致运算时间过长。于是进行以下优化：</p><ul><li>引入字典存储已经计算过的考拉兹链长度；</li><li>根据考拉兹猜想提出的运算规则，我们可以得到Collatz(n) = Collatz(n/2) + 1。因此对于所有整数k，Collatz(2k) &gt; Collatz(k)必定成立，所以我们不必计算小于LIMIT/2的所有k值，本例中即无需计算低于500000的k的考拉兹链长度；</li><li>若n是奇数，则3*n+1必定为偶数，从而n经过考拉兹变换后最终得到(3*n+1) / 2。故当n是奇数时，采用以下公式简化运算过程：Collatz(n) = Collatz((3*n+1) / 2) + 2。</li></ul><p>代码复现如下，但效率无法达到相关题解中提及的1.5s。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the longest Collatz sequence chain</span></span><br><span class="line"><span class="comment"># Which starting number, under one million, produces the longest chain</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countCollatzChain</span><span class="params">(n, values)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> values.keys():</span><br><span class="line">        <span class="keyword">return</span> values[n]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> n &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">        values[n] = <span class="number">1</span> + countCollatzChain(n &gt;&gt; <span class="number">1</span>, values)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        values[n] = <span class="number">2</span> + countCollatzChain((<span class="number">3</span> * n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, values)</span><br><span class="line">    <span class="keyword">return</span> values[n] </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    longest_chain = <span class="number">0</span></span><br><span class="line">    final_result = <span class="number">-1</span></span><br><span class="line">    values = &#123;<span class="number">1</span>: <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> range(<span class="number">500000</span>, <span class="number">10</span>**<span class="number">6</span> - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> countCollatzChain(number, values) &gt; longest_chain:</span><br><span class="line">            longest_chain = countCollatzChain(number, values)</span><br><span class="line">            final_result = number</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h2 id="15-Lattice-paths"><a href="#15-Lattice-paths" class="headerlink" title="15. Lattice paths"></a>15. Lattice paths</h2><h3 id="Problem-Description-4"><a href="#Problem-Description-4" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner.</p><p><img src="/2020/10/25/Euler-Project(II)/Euler-Project(II" alt="4.png-9.7kB">\2.PNG)</p><p>How many such routes are there through a 20×20 grid?</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>本题目为简单格子路径问题，可以采用迭代、递归与组合数三种方法求解。</p><h4 id="Recursive-Solution"><a href="#Recursive-Solution" class="headerlink" title="Recursive Solution"></a>Recursive Solution</h4><p>将题目所给信息转换为一般问题，即求从(0, 0)点运动到(m, n)点的所有路径数量，该数量等于(0, 0)点到点(m-1, n)和(0, 0)点到点(m, n-1)的路径数量之和。以此类推，当m或n等于0时，(0, 0)点到达该点只存在一直向右或向下两条道路，此时递归算法返回1。值得注意的是，该方法存在重复计算问题，故可引入大容量数组存储可能需要的计算结果。</p><h4 id="Iterative-Solution"><a href="#Iterative-Solution" class="headerlink" title="Iterative Solution"></a>Iterative Solution</h4><p>递归法较易编写，但需要消耗较多计算资源，故考虑结合动态规划进行迭代求解。如果说递归法是”执果索因”，动态规划就是”由因导果”。首先建立20x20数组，由于第一行和第一列所有元素到达点(0, 0)只有一条路径，故数组中对应位置全部设置为1。随后从第二行第二列开始按照<code>grid[i][j] = grid[i][j-1] + grid[i-1][j]</code>进行数组赋值，目标位置<code>grid[m][n]</code>即为待求结果。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Lattice paths problem</span></span><br><span class="line"><span class="comment"># Simple dynamic programming</span></span><br><span class="line"><span class="comment"># Solution1 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllPaths</span><span class="params">(m, n)</span>:</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp[k][l] = dp[k<span class="number">-1</span>][l] + dp[k][l<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">print</span> dp</span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># Get all possible paths of 20 x 20 grids</span></span><br><span class="line">    final_result = getAllPaths(<span class="number">21</span>, <span class="number">21</span>)</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h4 id="Combinatorial-Solution"><a href="#Combinatorial-Solution" class="headerlink" title="Combinatorial Solution"></a>Combinatorial Solution</h4><p>以上两种方法时间复杂度均为O(mn)，我们可以使用组合数学以提高效率。</p><p>首先分析一般问题的本质，即从点(0, 0)到点(m, n)共需要走m+n步，其中需要向下走m步，向右走n步。于是引出简单无顺序组合问题即$\binom{m+n}{m}$。然而本题给出m=n=20，从而得到如下公式：</p><p><img src="/2020/10/25/Euler-Project(II)/Euler-Project(II" alt="15_formula.PNG-20.8kB">\3.PNG)</p><p>至此我们得到复杂度为O(n)的算法，实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Solution2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAllPaths2</span><span class="params">(n)</span>:</span></span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        result = result * (n+i) / i</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># Get all possible paths of 20 x 20 grids</span></span><br><span class="line">    final_result2 = getAllPaths2(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">print</span> final_result2</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>方格问题升级之路（详细讨论格子路径问题）：<a href="https://blog.csdn.net/cookieZZ/article/details/70306757" target="_blank" rel="noopener">https://blog.csdn.net/cookieZZ/article/details/70306757</a></p><p>格子路径问题+组合数学：<a href="https://www.cnblogs.com/yhm138/p/13610626.html#102-lattice-paths-without-restrictions-无限制格子路径" target="_blank" rel="noopener">https://www.cnblogs.com/yhm138/p/13610626.html#102-lattice-paths-without-restrictions-无限制格子路径</a></p><h2 id="16-Power-digit-sum"><a href="#16-Power-digit-sum" class="headerlink" title="16. Power digit sum"></a>16. Power digit sum</h2><h3 id="Problem-Description-5"><a href="#Problem-Description-5" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>$2^{15} = 32768$ and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.</p><p>What is the sum of the digits of the number $2^{1000}$?</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Power digit sum</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDigitSum</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    digitsum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> input_number != <span class="number">0</span>:</span><br><span class="line">        digitsum += input_number % <span class="number">10</span></span><br><span class="line">        input_number /= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> digitsum</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    final_result = getDigitSum(<span class="number">2</span>**<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h2 id="17-Number-letter-counts"><a href="#17-Number-letter-counts" class="headerlink" title="17. Number letter counts"></a>17. Number letter counts</h2><h3 id="Problem-Description-6"><a href="#Problem-Description-6" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.</p><p>If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?</p><p><strong>NOTE:</strong> Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. The use of “and” when writing out numbers is in compliance with British usage.</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><p>最简单的方法为建立三个字典，分别存储个位数字1-9，十位数字1-9（即10-90）以及11-19，然后判断输入数字的位数并进行相关处理。该方法需要讨论的情况较多，例如三位数字便需要讨论100，1X0，10X，11X，1XX五种情况，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Count the letters of numbers 1 to 1000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countLetters</span><span class="params">(input_number, length, dict1, dict2, dict3)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> length == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> dict1[input_number]</span><br><span class="line">    <span class="keyword">elif</span> length == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> input_number / <span class="number">10</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> dict2[input_number]</span><br><span class="line">        <span class="keyword">elif</span> input_number % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> dict3[input_number/<span class="number">10</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> dict3[input_number/<span class="number">10</span>] + dict1[input_number%<span class="number">10</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> input_number % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> dict1[input_number/<span class="number">100</span>] + <span class="number">7</span></span><br><span class="line">        <span class="keyword">elif</span> input_number % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> dict1[input_number/<span class="number">100</span>] + dict3[input_number%<span class="number">100</span>/<span class="number">10</span>] + <span class="number">10</span></span><br><span class="line">        <span class="keyword">elif</span> input_number / <span class="number">10</span> % <span class="number">10</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> dict1[input_number/<span class="number">100</span>] + <span class="number">10</span> + dict2[input_number%<span class="number">100</span>]</span><br><span class="line">        <span class="keyword">elif</span> input_number / <span class="number">10</span> % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> dict1[input_number/<span class="number">100</span>] + <span class="number">10</span> + dict1[input_number%<span class="number">10</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> dict1[input_number/<span class="number">100</span>] + dict3[input_number%<span class="number">100</span>/<span class="number">10</span>] + dict1[input_number%<span class="number">10</span>] + <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># digits</span></span><br><span class="line">    dict1 = &#123;<span class="number">1</span>:<span class="number">3</span>, <span class="number">2</span>:<span class="number">3</span>, <span class="number">3</span>:<span class="number">5</span>, <span class="number">4</span>:<span class="number">4</span>, <span class="number">5</span>:<span class="number">4</span>, <span class="number">6</span>:<span class="number">3</span>, <span class="number">7</span>:<span class="number">5</span>, <span class="number">8</span>:<span class="number">5</span>, <span class="number">9</span>:<span class="number">4</span>&#125;</span><br><span class="line">    <span class="comment"># 10-tens</span></span><br><span class="line">    dict2 = &#123;<span class="number">10</span>:<span class="number">3</span>, <span class="number">11</span>:<span class="number">6</span>, <span class="number">12</span>:<span class="number">6</span>, <span class="number">13</span>:<span class="number">8</span>, <span class="number">14</span>:<span class="number">8</span>, <span class="number">15</span>:<span class="number">7</span>, <span class="number">16</span>:<span class="number">7</span>, <span class="number">17</span>:<span class="number">9</span>, <span class="number">18</span>:<span class="number">8</span>, <span class="number">19</span>:<span class="number">8</span>&#125;</span><br><span class="line">    <span class="comment"># tens</span></span><br><span class="line">    dict3 = &#123;<span class="number">1</span>:<span class="number">3</span>, <span class="number">2</span>:<span class="number">6</span>, <span class="number">3</span>:<span class="number">6</span>, <span class="number">4</span>:<span class="number">5</span>, <span class="number">5</span>:<span class="number">5</span>, <span class="number">6</span>:<span class="number">5</span>, <span class="number">7</span>:<span class="number">7</span>, <span class="number">8</span>:<span class="number">6</span>, <span class="number">9</span>:<span class="number">6</span>&#125;</span><br><span class="line">    total_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">1000</span>):</span><br><span class="line">        <span class="keyword">print</span> item</span><br><span class="line">        item_length = len(str(item))</span><br><span class="line">        <span class="comment"># print item_length</span></span><br><span class="line">        total_sum += countLetters(item, item_length, dict1, dict2, dict3)</span><br><span class="line">    </span><br><span class="line">    total_sum += <span class="number">11</span></span><br><span class="line">    <span class="keyword">print</span> total_sum</span><br></pre></td></tr></table></figure><p>由于三位数字与两位数字相比仅增加了对百位数字的讨论，本质为增加<code>X hundred and</code>这几个字符。故可以1-99为基础进行适当求和，从而省略了三位数字包含字符数量的判断，节约了运算时间，关键代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">        item_length = len(str(item))</span><br><span class="line">        total_sum += countLetters(item, item_length, dict1, dict2, dict3)</span><br><span class="line">    block_sum = total_sum</span><br><span class="line">    <span class="keyword">for</span> hundredstype <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        total_sum += dict1[hundredstype] + <span class="number">7</span> + (dict1[hundredstype] + <span class="number">10</span>) * <span class="number">99</span> + block_sum</span><br><span class="line">    total_sum += <span class="number">11</span></span><br><span class="line">    <span class="keyword">print</span> total_sum</span><br></pre></td></tr></table></figure><h2 id="18-Maximum-path-sum-I"><a href="#18-Maximum-path-sum-I" class="headerlink" title="18. Maximum path sum I"></a>18. Maximum path sum I</h2><h3 id="Problem-Description-7"><a href="#Problem-Description-7" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.</p><p><img src="/2020/10/25/Euler-Project(II)/Euler-Project(II" alt="18_problem_1.PNG-2.4kB">\4.PNG)</p><p>That is, 3 + 7 + 4 + 9 = 23.</p><p>Find the maximum total from top to bottom of the triangle below:</p><p><img src="/2020/10/25/Euler-Project(II)/Euler-Project(II" alt="18_problem_2.PNG-29.6kB">\5.PNG)</p><p><strong>NOTE:</strong> As there are only 16384 routes, it is possible to solve this problem by trying every route. However, <a href="https://projecteuler.net/problem=67" target="_blank" rel="noopener">Problem 67</a>, is the same challenge with a triangle containing one-hundred rows; it cannot be solved by brute force, and requires a clever method! ;o)</p><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><p>根据题目说明采用动态规划进行逐级递归。</p><p>首先将所给的字符串类型转换为二维数组，随后进行分析，核心思想为<strong>将上一行的数字更新为其本身与下一行相邻两数字中较大数字之和</strong>：以倒数第二行元素为例，63可更新为63+max(04, 62)即125，66可更新为66+max(62, 98)即164…以此类推，更新结束后二维数组第一个元素即为所求最长路径。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the maximum total from top to bottom of the triangle below:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transformToList</span><span class="params">(grid_string)</span>:</span></span><br><span class="line">    <span class="comment"># First transform the string to list</span></span><br><span class="line">    tmp_list = [item.split(<span class="string">' '</span>) <span class="keyword">for</span> item <span class="keyword">in</span> grid_string.split(<span class="string">'\n'</span>)]</span><br><span class="line">    <span class="comment"># print tmp_list</span></span><br><span class="line">    list_length = len(tmp_list)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(list_length):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>):</span><br><span class="line">            tmp_list[i][j] = int(tmp_list[i][j])</span><br><span class="line">    <span class="keyword">return</span> tmp_list</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dynamicProgramming</span><span class="params">(grid_list)</span>:</span></span><br><span class="line">    list_length = len(grid_list)</span><br><span class="line">    <span class="comment"># Start from the last but one line</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(list_length<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>):</span><br><span class="line">            grid_list[i][j] = grid_list[i][j] + max(grid_list[i+<span class="number">1</span>][j], grid_list[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> grid_list[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    grid = <span class="string">'''75</span></span><br><span class="line"><span class="string">95 64</span></span><br><span class="line"><span class="string">17 47 82</span></span><br><span class="line"><span class="string">18 35 87 10</span></span><br><span class="line"><span class="string">20 04 82 47 65</span></span><br><span class="line"><span class="string">19 01 23 75 03 34</span></span><br><span class="line"><span class="string">88 02 77 73 07 63 67</span></span><br><span class="line"><span class="string">99 65 04 28 06 16 70 92</span></span><br><span class="line"><span class="string">41 41 26 56 83 40 80 70 33</span></span><br><span class="line"><span class="string">41 48 72 33 47 32 37 16 94 29</span></span><br><span class="line"><span class="string">53 71 44 65 25 43 91 52 97 51 14</span></span><br><span class="line"><span class="string">70 11 33 28 77 73 17 78 39 68 17 57</span></span><br><span class="line"><span class="string">91 71 52 38 17 14 91 43 58 50 27 29 48</span></span><br><span class="line"><span class="string">63 66 04 68 89 53 67 30 73 16 69 87 40 31</span></span><br><span class="line"><span class="string">04 62 98 27 23 09 70 98 73 93 38 53 60 04 23'''</span></span><br><span class="line">    result_list = transformToList(grid)</span><br><span class="line">    final_result = dynamicProgramming(result_list)</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h2 id="19-Counting-Sundays"><a href="#19-Counting-Sundays" class="headerlink" title="19. Counting Sundays"></a>19. Counting Sundays</h2><h3 id="Problem-Description-8"><a href="#Problem-Description-8" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>You are given the following information, but you may prefer to do some research for yourself.</p><ul><li>1 Jan 1900 was a Monday.</li><li>Thirty days has September,<br>April, June and November.<br>All the rest have thirty-one,<br>Saving February alone,<br>Which has twenty-eight, rain or shine.<br>And on leap years, twenty-nine.</li><li>A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.</li></ul><p>How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?</p><h3 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1"></a>Solution1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?</span></span><br><span class="line"><span class="comment"># First we need to find the sum of the days from Febrary to December every year from 1901 to 2000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countSundaysPerYear</span><span class="params">(input_year, first_day)</span>:</span></span><br><span class="line">    <span class="comment"># 31 days per month</span></span><br><span class="line">    month_list1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br><span class="line">    <span class="comment"># 30 days per month</span></span><br><span class="line">    month_list2 = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">11</span>]</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    month = <span class="number">1</span></span><br><span class="line">    <span class="comment"># input the location of the first day in this year as variable first_day</span></span><br><span class="line">    <span class="keyword">while</span> month &lt;= <span class="number">12</span>:</span><br><span class="line">        <span class="keyword">if</span> first_day % <span class="number">7</span> == <span class="number">0</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> month <span class="keyword">in</span> month_list1:</span><br><span class="line">            first_day += <span class="number">31</span></span><br><span class="line">        <span class="keyword">elif</span> month <span class="keyword">in</span> month_list2:</span><br><span class="line">            first_day += <span class="number">30</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> (input_year % <span class="number">4</span> == <span class="number">0</span> <span class="keyword">and</span> input_year % <span class="number">100</span> != <span class="number">0</span>) <span class="keyword">or</span> (input_year % <span class="number">400</span> == <span class="number">0</span>):</span><br><span class="line">                first_day += <span class="number">29</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                first_day += <span class="number">28</span></span><br><span class="line">        month += <span class="number">1</span></span><br><span class="line">    <span class="comment"># print count</span></span><br><span class="line">    <span class="keyword">return</span> (first_day % <span class="number">7</span>, count)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_day = <span class="number">2</span></span><br><span class="line">    final_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> year <span class="keyword">in</span> xrange(<span class="number">1901</span>, <span class="number">2001</span>):</span><br><span class="line">        <span class="comment"># print (year, start_day)</span></span><br><span class="line">        <span class="comment"># print "-------"</span></span><br><span class="line">        result_tuple = countSundaysPerYear(year, start_day)</span><br><span class="line">        start_day = result_tuple[<span class="number">0</span>]</span><br><span class="line">        final_count += result_tuple[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">print</span> final_count</span><br></pre></td></tr></table></figure><h3 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2"></a>Solution2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line">result_list = [calendar.weekday(year,month,<span class="number">1</span>) <span class="keyword">for</span> year <span class="keyword">in</span> range(<span class="number">1901</span>, <span class="number">2001</span>) <span class="keyword">for</span> month <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">13</span>)]</span><br><span class="line"><span class="keyword">print</span> result_list.count(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>python提供<code>calendar</code>模块实现日历功能，提供对日期的操作函数，常用函数说明如下：<a href="https://www.cnblogs.com/liuxiaowei/p/7263888.html。" target="_blank" rel="noopener">https://www.cnblogs.com/liuxiaowei/p/7263888.html。</a></p><h2 id="20-Factorial-digit-sum"><a href="#20-Factorial-digit-sum" class="headerlink" title="20. Factorial digit sum"></a>20. Factorial digit sum</h2><h3 id="Problem-Description-9"><a href="#Problem-Description-9" class="headerlink" title="Problem Description"></a>Problem Description</h3><p><em>n</em>! means <em>n</em> × (<em>n</em> − 1) × … × 3 × 2 × 1</p><p>For example, 10! = 10 × 9 × … × 3 × 2 × 1 = 3628800,<br>and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.</p><p>Find the sum of the digits in the number 100!</p><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Count the sum of digits of 100!</span></span><br><span class="line"><span class="keyword">import</span> math </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countDigitSum</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    sum_number = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> input_number != <span class="number">0</span>:</span><br><span class="line">        sum_number += input_number % <span class="number">10</span></span><br><span class="line">        input_number /= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> sum_number</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    final_result = countDigitSum(math.factorial(<span class="number">100</span>))</span><br><span class="line">    <span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;11-Largest-product-in-a-grid&quot;&gt;&lt;a href=&quot;#11-Largest-product-in-a-grid&quot; class=&quot;headerlink&quot; title=&quot;11. Largest product in a grid&quot;&gt;&lt;/a&gt;1
      
    
    </summary>
    
      <category term="Mathematics" scheme="https://blank-vax.github.io/categories/Mathematics/"/>
    
    
      <category term="Euler-Project" scheme="https://blank-vax.github.io/tags/Euler-Project/"/>
    
  </entry>
  
  <entry>
    <title>Euler-Project(I)</title>
    <link href="https://blank-vax.github.io/2020/10/13/Euler-Project(I)/"/>
    <id>https://blank-vax.github.io/2020/10/13/Euler-Project(I)/</id>
    <published>2020-10-13T13:40:00.000Z</published>
    <updated>2021-07-07T03:59:28.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Multiples-of-3-and-5"><a href="#1-Multiples-of-3-and-5" class="headerlink" title="1. Multiples of 3 and 5"></a>1. Multiples of 3 and 5</h2><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p><p>Find the sum of all the multiples of 3 or 5 below 1000.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># below 1000 </span></span><br><span class="line"><span class="comment"># multiples of 3 and 5</span></span><br><span class="line"><span class="comment"># 3*(1+2+3+...+999/3) + 5*(1+2+3+...+999/5) - 15*(1+2+3+...+999/15)</span></span><br><span class="line"><span class="comment"># Note that 1+2+3+...+p = 1/2*p*(p+1)</span></span><br><span class="line"></span><br><span class="line">count_result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">1000</span>, <span class="number">3</span>):</span><br><span class="line">    count_result += item</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item2 <span class="keyword">in</span> range(<span class="number">5</span>, <span class="number">1000</span>, <span class="number">5</span>):</span><br><span class="line">    <span class="keyword">if</span> item2 % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        count_result += item2</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> count_result</span><br></pre></td></tr></table></figure><h2 id="2-Even-Fibonacci-numbers"><a href="#2-Even-Fibonacci-numbers" class="headerlink" title="2. Even Fibonacci numbers"></a>2. Even Fibonacci numbers</h2><h3 id="Problem-Description-1"><a href="#Problem-Description-1" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:</p><p>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …</p><p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</span></span><br><span class="line"><span class="comment"># odd even odd odd even odd odd even odd odd even</span></span><br><span class="line"><span class="comment"># Find the total number of the Fibonacci numbers below four million</span></span><br><span class="line">origin1 = <span class="number">1</span></span><br><span class="line">origin2 = <span class="number">2</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">final_result = <span class="number">2</span></span><br><span class="line">origin_new = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> origin_new &lt; <span class="number">4000000</span>:</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    origin_new = origin1 + origin2</span><br><span class="line">    <span class="keyword">if</span> count % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        final_result += origin_new</span><br><span class="line">    origin1, origin2 = origin2, origin_new</span><br><span class="line"><span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><p><img src="/2020/10/13/Euler-Project(I)/Euler-Project(I" alt="image-20200905003907639.png-85.4kB">\1.png)</p><p><img src="/2020/10/13/Euler-Project(I)/Euler-Project(I" alt="image-20200905003924792.png-79.6kB">\2.png)</p><h2 id="3-Largest-prime-factor"><a href="#3-Largest-prime-factor" class="headerlink" title="3. Largest prime factor"></a>3. Largest prime factor</h2><h3 id="Problem-Description-2"><a href="#Problem-Description-2" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The prime factors of 13195 are 5, 7, 13 and 29.</p><p>What is the largest prime factor of the number 600851475143 ?</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Largest prime factor of designated number 600851475143</span></span><br><span class="line"><span class="comment"># Note the key word: prime factor</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Those numbers who are some times of evens or some odd must be composite numbers</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">3</span>, int(math.sqrt(n))+<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> n % item == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime2</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    All numbers can be shown as such numbers:6n, 6n+1, 6n+2, 6n+3, 6n+4, 6n+5</span></span><br><span class="line"><span class="string">    In these numbers, besides 2 and 3, only 6n+1 and 6n+5 may be primes.</span></span><br><span class="line"><span class="string">    For those who can be shown by 6n+1 and 6n+5 but aren't primes, they can be some times of 6n+1 or 6n+5</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span> <span class="keyword">or</span> n == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">6</span> != <span class="number">1</span> <span class="keyword">and</span> n % <span class="number">6</span> != <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(math.sqrt(n))+<span class="number">1</span>):</span><br><span class="line">        division = <span class="number">5</span> + (i+<span class="number">1</span>)*<span class="number">6</span> </span><br><span class="line">        <span class="keyword">if</span> (n // division &gt; <span class="number">1</span>) <span class="keyword">or</span> (n // (division+<span class="number">2</span>) &gt; <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># division == 6n+5, division+2 == 6n+1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">possible_result = []</span><br><span class="line">final_number = <span class="number">600851475143</span></span><br><span class="line">item = int(math.sqrt(final_number))+<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> item &gt;= <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> final_number % item == <span class="number">0</span>:</span><br><span class="line">        possible_result.append(item)</span><br><span class="line">    item -= <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> possible_result:</span><br><span class="line">    <span class="keyword">if</span> isPrime(result):</span><br><span class="line">        <span class="keyword">print</span> result</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h3><p>本题也可以使用厄拉多塞筛法寻找输入数字范围内所有的素数。因为素数的倍数一定不是素数，所以我们找到一个素数时可以将其倍数从所给范围内排除。这种方法称为素数筛。例如求100以内的素数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">100</span></span><br><span class="line">L = list(range(<span class="number">2</span>, n))</span><br><span class="line">ans = set()</span><br><span class="line"><span class="keyword">while</span> L:</span><br><span class="line">    x = L.pop(<span class="number">0</span>)</span><br><span class="line">    ans.add(x)</span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> i*x &lt; n:</span><br><span class="line">        <span class="keyword">if</span> i*x <span class="keyword">in</span> L:</span><br><span class="line">            L.remove(i*x)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">print(ans)</span><br><span class="line"><span class="comment"># ans = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97&#125;</span></span><br></pre></td></tr></table></figure><p>基于以上思想，在找输入数字因数时可以将合数筛出，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ans = []</span><br><span class="line">n = <span class="number">600851475143</span></span><br><span class="line">iter_max = int(n ** <span class="number">0.5</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">2</span>,iter_max):</span><br><span class="line">    <span class="keyword">if</span> n%num == <span class="number">0</span>:</span><br><span class="line">        ans.append(num)</span><br><span class="line">        n/=num</span><br><span class="line">        <span class="keyword">while</span> n%num == <span class="number">0</span>:</span><br><span class="line">            n/=num <span class="comment"># 保证n已被num除尽，此时n不会再有num*i的因数</span></span><br><span class="line">print(ans)</span><br><span class="line">ans = [<span class="number">71</span>, <span class="number">839</span>, <span class="number">1471</span>, <span class="number">6857</span>]</span><br></pre></td></tr></table></figure><h3 id="素数判别法"><a href="#素数判别法" class="headerlink" title="素数判别法"></a>素数判别法</h3><h4 id="根号判别法"><a href="#根号判别法" class="headerlink" title="根号判别法"></a>根号判别法</h4><p>设输入的数字为n，则可以通过遍历方法暴力搜索其素因子，若出现非1及其本身的素因子，则可断定该数字为素数。常见的遍历范围为1—n-1，其实将遍历范围调节至1—$\sqrt{n}$亦可实现素数判定的目的。</p><h4 id="奇偶判别法"><a href="#奇偶判别法" class="headerlink" title="奇偶判别法"></a>奇偶判别法</h4><p>对于所有可能成为数字x素因子的n-1个数字，偶数中除了2均不是质数，且奇数的因数没有偶数，因此可以继续优化。首先将n与2进行比较，其次判断2是否为n的素因子，最后从3开始以2为增幅逐次判断数字n是否包含奇数因子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Those numbers who are some times of evens or some odd must be composite numbers</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> range(<span class="number">3</span>, int(math.sqrt(n))+<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> n % item == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="6n系判别"><a href="#6n系判别" class="headerlink" title="6n系判别"></a>6n系判别</h4><p>所有数字均可表示为6n，6n+1，6n+2，6n+3，6n+4，6n+5的形式，除2和3以外，所有的素数都可以表示为6n+1和6n+5的形式，如果输入数字x是6n+1和6n+5的整数倍，则必为合数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime2</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    All numbers can be shown as such numbers:6n, 6n+1, 6n+2, 6n+3, 6n+4, 6n+5</span></span><br><span class="line"><span class="string">    In these numbers, besides 2 and 3, only 6n+1 and 6n+5 may be primes.</span></span><br><span class="line"><span class="string">    For those who can be shown by 6n+1 and 6n+5 but aren't primes, they can be some times of 6n+1 or 6n+5</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span> <span class="keyword">or</span> n == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">6</span> != <span class="number">1</span> <span class="keyword">and</span> n % <span class="number">6</span> != <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(math.sqrt(n))+<span class="number">1</span>):</span><br><span class="line">        division = <span class="number">5</span> + (i+<span class="number">1</span>)*<span class="number">6</span> </span><br><span class="line">        <span class="keyword">if</span> (n // division &gt; <span class="number">1</span>) <span class="keyword">or</span> (n // (division+<span class="number">2</span>) &gt; <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># division == 6n+5, division+2 == 6n+1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="Miller-Rabin素数判别法"><a href="#Miller-Rabin素数判别法" class="headerlink" title="Miller-Rabin素数判别法"></a>Miller-Rabin素数判别法</h4><p>该素数判别方法应用费马小定理对素数进行概率判定，若输入数字N通过t次测试，则N不是素数的概率仅为$(1/4)^{t}$，随着通过测试次数的增加，N是素数的概率无穷逼近于1。在实际运用中，可首先用300—500个小素数对N进行测试，以提高测试通过的概率与算法的速度。</p><p>具体步骤如下：</p><ul><li>计算奇数M，使得N=$2^{r}*M+1$；</li><li>选择随机数A&lt;N；</li><li>对于任意i&lt;r，若$A^{(2^{i}*M)}mod N=N-1$，则N通过随机数A的测试；</li><li>或者若$A^{M}modN=1$，则N通过随机数A的测试；</li><li>改变随机数A的值对N进行多次测试（一般为5—10次，较高需求的情况下可进行20—30次），若全部通过则判定N为素数。</li></ul><p>相关代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fast_power</span><span class="params">(base, power, n)</span>:</span></span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    tmp = base</span><br><span class="line">    <span class="keyword">while</span> power &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> power&amp;<span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">            result = (result * tmp) % n</span><br><span class="line">        tmp = (tmp * tmp) % n </span><br><span class="line">        power = power&gt;&gt;<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Miller_Rabin</span><span class="params">(n, iter_num)</span>:</span></span><br><span class="line">    <span class="comment"># 2 is prime</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="comment"># if n is even or less than 2, then n is not a prime</span></span><br><span class="line">    <span class="keyword">if</span> n&amp;<span class="number">1</span> == <span class="number">0</span> <span class="keyword">or</span> n&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># n-1 = (2^s)m</span></span><br><span class="line">    <span class="comment"># get random odd m</span></span><br><span class="line">    m,s = n - <span class="number">1</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> m&amp;<span class="number">1</span>==<span class="number">0</span>:</span><br><span class="line">        m = m&gt;&gt;<span class="number">1</span></span><br><span class="line">        s += <span class="number">1</span></span><br><span class="line">    <span class="comment"># M-R </span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(iter_num):</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        key algorithm</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        b = fast_power(random.randint(<span class="number">2</span>,n<span class="number">-1</span>), m, n)</span><br><span class="line">        <span class="keyword">if</span> b==<span class="number">1</span> <span class="keyword">or</span> b== n<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> __ <span class="keyword">in</span> range(s<span class="number">-1</span>):</span><br><span class="line">            b = fast_power(b, <span class="number">2</span>, n)</span><br><span class="line">            <span class="keyword">if</span> b == n<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># example</span></span><br><span class="line">    print(Miller_Rabin(<span class="number">49139</span>, <span class="number">10</span>))</span><br><span class="line">    print(Miller_Rabin(<span class="number">561</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><h4 id="素数筛查"><a href="#素数筛查" class="headerlink" title="素数筛查"></a>素数筛查</h4><p>除了上述的高级试除法外，还可以使用素数筛查的方法。常见的素数筛查包括埃拉托斯特尼筛法和欧拉筛法。</p><p>埃氏筛法由希腊数学家埃拉托斯特尼提出，用以简单鉴定素数，方法如下：要获取自然数n（上界）内的全部素数，必须剔除所有小于等于sqrt(n)的素数的倍数，经过此种筛查后，剩下的就是素数。</p><p>欧拉筛法是埃氏筛法的改进。采用欧拉筛法进行筛选过程中，对于含多个因子的数字需要进行多次筛选，耗费部分运行时间。例如，对于合数20，可分解为2*10，4*5，故至少需要筛选两次。欧拉筛过程中引入语句<code>if i%prime[j] == 0: break</code>，保证每个合数只被这个合数最小的质因子筛除，而且不出现重复筛除。</p><p>代码实现可参考：<a href="https://blog.csdn.net/FeilingGong/article/details/83660779?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">素数筛法详解（欧拉筛&amp;埃氏筛）</a>。</p><h2 id="4-Largest-palindrome-product"><a href="#4-Largest-palindrome-product" class="headerlink" title="4. Largest palindrome product"></a>4. Largest palindrome product</h2><h3 id="Problem-Description-3"><a href="#Problem-Description-3" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.</p><p>Find the largest palindrome made from the product of two 3-digit numbers.</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    Suppose that P = a*b = 100000*x+10000*y+1000*z+100*z+10*y+x = 11*(9091*x+910*y+100*z)</span></span><br><span class="line"><span class="string">    The range of a and b are both 100 to 999</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    reversed = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> input_number &gt; <span class="number">0</span>:</span><br><span class="line">        reversed = reversed*<span class="number">10</span> + input_number % <span class="number">10</span></span><br><span class="line">        input_number /= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> reversed</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> input_number == reverse(input_number)</span><br><span class="line"></span><br><span class="line">largest_number = <span class="number">0</span></span><br><span class="line">a = <span class="number">999</span></span><br><span class="line"><span class="keyword">while</span> a &gt;= <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">if</span> a % <span class="number">11</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># Then b doesn't need to contain prime factor 11</span></span><br><span class="line">        b = <span class="number">999</span></span><br><span class="line">        b_down = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># b needs to contain prime factor 11</span></span><br><span class="line">        b = <span class="number">990</span></span><br><span class="line">        b_down = <span class="number">11</span></span><br><span class="line">    <span class="keyword">while</span> b &gt;= <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">if</span> a*b &lt;= largest_number:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> isPalindrome(a*b):</span><br><span class="line">            largest_number = a*b</span><br><span class="line">        b = b - b_down</span><br><span class="line">    a = a - <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> largest_number</span><br></pre></td></tr></table></figure><h2 id="5-Smallest-multiple"><a href="#5-Smallest-multiple" class="headerlink" title="5. Smallest multiple"></a>5. Smallest multiple</h2><h3 id="Problem-Description-4"><a href="#Problem-Description-4" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.</p><p>What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    The factors are 20 numbers from 1 to 20</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    All numbers can be shown as such numbers:6n, 6n+1, 6n+2, 6n+3, 6n+4, 6n+5</span></span><br><span class="line"><span class="string">    In these numbers, besides 2 and 3, only 6n+1 and 6n+5 may be primes.</span></span><br><span class="line"><span class="string">    For those who can be shown by 6n+1 and 6n+5 but aren't primes, they can be some times of 6n+1 or 6n+5</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span> <span class="keyword">or</span> n == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">6</span> != <span class="number">1</span> <span class="keyword">and</span> n % <span class="number">6</span> != <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(math.sqrt(n))+<span class="number">1</span>):</span><br><span class="line">        division = <span class="number">5</span> + (i+<span class="number">1</span>)*<span class="number">6</span> </span><br><span class="line">        <span class="keyword">if</span> (n // division &gt; <span class="number">1</span>) <span class="keyword">or</span> (n // (division+<span class="number">2</span>) &gt; <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># division == 6n+5, division+2 == 6n+1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">factors_list = []</span><br><span class="line">original_list = [x+<span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">20</span>)]</span><br><span class="line"><span class="keyword">print</span> original_list</span><br><span class="line"><span class="comment"># Get all primes</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> original_list:</span><br><span class="line">    <span class="keyword">if</span> isPrime(item):</span><br><span class="line">        factors_list.append(item)</span><br><span class="line"></span><br><span class="line">k = <span class="number">20</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">N = <span class="number">1</span></span><br><span class="line">edge_number = math.sqrt(k)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> i == len(factors_list):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> factors_list[i] &lt;= edge_number:</span><br><span class="line">        N = N*pow(factors_list[i], math.floor(math.log(k)/math.log(factors_list[i])))</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> N</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        N = N*factors_list[i]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> N</span><br><span class="line"><span class="keyword">print</span> N</span><br></pre></td></tr></table></figure><p>分析题目，首先以1—10之间的数字为例，我们进行以下操作：</p><ul><li>Step1：寻找2—10内所有素数，即2、3、5、7，则剩余合数均可以素数的幂乘积的形式表示；待求的最小倍数可以表示为$min_multiply = 2^a<em>3^b</em>5^c*7^d$。</li><li>Step2：分解剩余合数，均表示为min_multiply所示形式。</li><li>Step3：取最大指数作为待求参数a，b，c，d的值。</li></ul><p>现令N为可被2—k间所有数字整除的最小数字，分析求解N的过程。参考上述k=10时的分析，首先确定所有小于k的素数，存入列表P。随后确定列表中每个元素的次数，令$P[i]^{a[i]} = k$，两侧同时进行对数运算并向下取整，得$a[i] = floor(log(k) / log(P[i]))$。值得注意的是，当$P[i]^{2} &gt; k$时，a[i]==1，故只需要计算满足$P[i] &lt;= \sqrt(k)$对应素数的次数a[i]。最终$N=P[0]^{a[0]}<em>P[1]^{a[1]}</em>P[2]^{a[2]}*……..$</p><h2 id="6-Sum-square-difference"><a href="#6-Sum-square-difference" class="headerlink" title="6. Sum square difference"></a>6. Sum square difference</h2><h3 id="Problem-Description-5"><a href="#Problem-Description-5" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The sum of the squares of the first ten natural numbers is,</p><script type="math/tex; mode=display">1^2 + 2^2 + ... + 10^2 = 385</script><p>The square of the sum of the first ten natural numbers is,</p><script type="math/tex; mode=display">(1 + 2 + ... + 10)^2 = 55^2 = 3025</script><p>Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is $3025 - 385 = 2640$.</p><p>Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    sum1 = 1+2+3+..+n = n*(n+1)/2</span></span><br><span class="line"><span class="string">    sum2 = 1**2 + 2**2 + 3**2 +...+ n**2 = n*(n+1)*(2*n+1)/6</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">sum1 = <span class="number">100</span>*<span class="number">101</span>/<span class="number">2</span></span><br><span class="line">sum2 = <span class="number">100</span>*<span class="number">101</span>*<span class="number">201</span>/<span class="number">6</span></span><br><span class="line"><span class="keyword">print</span> sum2-sum1</span><br></pre></td></tr></table></figure><h2 id="7-10001st-prime"><a href="#7-10001st-prime" class="headerlink" title="7. 10001st prime"></a>7. 10001st prime</h2><h3 id="Problem-Description-6"><a href="#Problem-Description-6" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.</p><p>What is the 10 001st prime number?</p><h3 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1"></a>Solution1</h3><p>题目只给出素数的个数，最简单的思路就是循环计数与素数判断相结合。素数判断过程中，现补充事实如下：</p><ul><li>1不是素数</li><li>除2以外的所有素数均为奇数</li><li>所有比3大的素数均可以写成6k+/-1的形式，k为整数</li><li>如果我们无法找到小于等于sqrt(n)并能够整除n的数字f，则可以判定n为素数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Method1: Round and prime judgement</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(input_number)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> input_number == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> input_number &lt; <span class="number">4</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">    <span class="keyword">elif</span> input_number % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> input_number &lt; <span class="number">9</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> input_number % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        limit = math.floor(math.sqrt(input_number))</span><br><span class="line">        f = <span class="number">5</span></span><br><span class="line">        <span class="keyword">while</span> f &lt;= limit:</span><br><span class="line">            <span class="comment"># Which means 6n-1</span></span><br><span class="line">            <span class="keyword">if</span> input_number % f == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># We must plus 2 to get 6n+1</span></span><br><span class="line">            <span class="keyword">if</span> input_number % (f+<span class="number">2</span>) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            f += <span class="number">6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">final_number = <span class="number">3</span></span><br><span class="line">count = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">10001</span>:</span><br><span class="line">    final_number += <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> isPrime(final_number):</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">print</span> final_number</span><br></pre></td></tr></table></figure><h3 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2"></a>Solution2</h3><p>本题也可以采用埃拉托斯特尼筛法进行求解，求解的关键是确定第10001个素数的上界。为确保一定会出现第10001个素数，取较大的上界为1000000。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Method2: a sieve of Eratosthenes</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPrime</span><span class="params">(L)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> L[i]**<span class="number">2</span> &lt; L[<span class="number">-1</span>]:</span><br><span class="line">        <span class="comment"># Eratosthenes algorithm</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(L)):</span><br><span class="line">            <span class="keyword">if</span> L[j] % L[i] == <span class="number">0</span>:</span><br><span class="line">                L[j] = <span class="number">0</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        L.sort()</span><br><span class="line">        L = L[count:]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"><span class="comment"># L = (2,3,4,...,1000000)</span></span><br><span class="line">L = range(<span class="number">2</span>, <span class="number">1000000</span>)</span><br><span class="line">primes_list = findPrime(L)</span><br><span class="line">print(primes_list[<span class="number">10000</span>])</span><br></pre></td></tr></table></figure><h2 id="8-Largest-product-in-a-series"><a href="#8-Largest-product-in-a-series" class="headerlink" title="8. Largest product in a series"></a>8. Largest product in a series</h2><h3 id="Problem-Description-7"><a href="#Problem-Description-7" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.</p><p>73167176531330624919225119674426574742355349194934<br>96983520312774506326239578318016984801869478851843<br>85861560789112949495459501737958331952853208805511<br>12540698747158523863050715693290963295227443043557<br>66896648950445244523161731856403098711121722383113<br>62229893423380308135336276614282806444486645238749<br>30358907296290491560440772390713810515859307960866<br>70172427121883998797908792274921901699720888093776<br>65727333001053367881220235421809751254540594752243<br>52584907711670556013604839586446706324415722155397<br>53697817977846174064955149290862569321978468622482<br>83972241375657056057490261407972968652414535100474<br>82166370484403199890008895243450658541227588666881<br>16427171479924442928230863465674813919123162824586<br>17866458359124566529476545682848912883142607690042<br>24219022671055626321111109370544217506941658960408<br>07198403850962455444362981230987879927244284909188<br>84580156166097919133875499200524063689912560717606<br>05886116467109405077541002256983155200055935729725<br>71636269561882670428252483600823257530420752963450</p><p>Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?</p><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    Find the thirteen adjacent digits in the 1000-digits number</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">input_number = given_string</span><br><span class="line"><span class="comment"># Transform the 1000-digits number to number list in order to get each number seperately</span></span><br><span class="line">input_number_list = [eval(input_number[i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(input_number))]</span><br><span class="line">maximum_number = <span class="number">0</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt;= len(input_number) - <span class="number">13</span>:</span><br><span class="line">    <span class="comment"># Combination of function reduce() and lambda function</span></span><br><span class="line">    result_number = reduce(<span class="keyword">lambda</span> x, y: x*y, input_number_list[count:count+<span class="number">13</span>])</span><br><span class="line">    <span class="keyword">if</span> result_number &gt; maximum_number:</span><br><span class="line">        maximum_number = result_number</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> maximum_number</span><br></pre></td></tr></table></figure><h2 id="9-Special-Pythagorean-triplet"><a href="#9-Special-Pythagorean-triplet" class="headerlink" title="9. Special Pythagorean triplet"></a>9. Special Pythagorean triplet</h2><h3 id="Problem-Description-8"><a href="#Problem-Description-8" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>A Pythagorean triplet is a set of three natural numbers, a &lt; b &lt; c, for which,</p><script type="math/tex; mode=display">a^{2} + b^{2} = c^{2}</script><p>For example, $3^{2} + 4^{2} = 9 + 16 = 25 = 5^{2}$.</p><p>There exists exactly one Pythagorean triplet for which a + b + c = 1000.<br>Find the product abc.</p><h3 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1"></a>Solution1</h3><p>可以采用放缩的方法，以题目所给的1000为例，设$ a=m1<em>k，b=m2</em>k，c=m3*k$，这里m1，m2，m3为小于50的勾股数。故只需要寻找满足1000 % (m1+m2+m3) == 0的勾股数并相应扩大k倍，使其满足a+b+c == 1000即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    1. a+b+c = 1000</span></span><br><span class="line"><span class="string">    2. Suppose a&lt;b&lt;c,then we get a^2 + b^2 = c^2</span></span><br><span class="line"><span class="string">    3. Find a,b,c and calculate abc</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># First find all the Pythagorean triplet number under 50</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">50</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">50</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">50</span>):</span><br><span class="line">            <span class="keyword">if</span> i**<span class="number">2</span>+j**<span class="number">2</span> == k**<span class="number">2</span> <span class="keyword">and</span> <span class="number">1000</span>%(i+j+k) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">print</span> i*j*k*(<span class="number">1000</span>/(i+j+k))**<span class="number">3</span></span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2"></a>Solution2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the only Pythagorean triplet(a, b, c), for which a+b+c = 1000</span></span><br><span class="line"><span class="comment"># a^2+b^2=(s-a-b)^2, cause a&lt;b&lt;c, then a&lt;=(s-3)/3 and b &lt;(s-a)/2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPythagorean</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">3</span>, (s<span class="number">-3</span>)//<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> range(a+<span class="number">1</span>, (s<span class="number">-1</span>-a)//<span class="number">2</span>):</span><br><span class="line">            c = s-a-b</span><br><span class="line">            <span class="keyword">if</span> c*c == a*a + b*b:</span><br><span class="line">                <span class="keyword">print</span> (a,b,c)</span><br><span class="line">                <span class="keyword">return</span> a*b*c</span><br><span class="line"></span><br><span class="line">final_multiply = getPythagorean(<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">print</span> final_multiply</span><br></pre></td></tr></table></figure><h3 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h3><p>下面通过勾股数的一些性质简化解法二中的代码，提高程序运行效率。</p><p>如果勾股数(a, b, c)满足gcd(a, b, c) = 1，定义该类勾股数具有素数性质。同时，任意组勾股数(a, b, c)可表示为：</p><script type="math/tex; mode=display">a = m^{2}-n^{2}，b = 2*m*n，c = m^{2}+n^{2}，m>n>0 (9.1)</script><p>由于勾股数可通过倍乘进行放缩，故可对(a, b, c)进行运算，得到以下结果：</p><script type="math/tex; mode=display">a = (m^{2}-n^{2})*d，b = 2*m*n*d，c = (m^{2}+n^{2})*d, m>n>0 (9.2)</script><p>使用以上性质，我们可得：</p><script type="math/tex; mode=display">a+b+c = 2*m*(m+n)*d (9.3)</script><p>所以想要找到勾股数组合(a, b, c)满足a+b+c = s，我们需要在1—s/2之间寻找除数m，并寻找s/2m的奇除数k（此处k=m+n，k满足m &lt; k &lt; 2m，并且m，k互素）。随后令n = k - m，d = s/2mk，将该结果插入式(9.2)中，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">euclid_gcd</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> a &lt; b:</span><br><span class="line">        a, b = b, a</span><br><span class="line">    <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">        a, b = b, a%b</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPythagorean</span><span class="params">(s2, mlimit)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">2</span>, mlimit):</span><br><span class="line">        <span class="keyword">if</span> s2 % m == <span class="number">0</span>:</span><br><span class="line">            sm = s2 // m</span><br><span class="line">            <span class="keyword">while</span> sm % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                sm = sm // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> m % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                k = m+<span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                k = m+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> k &lt; <span class="number">2</span>*m <span class="keyword">and</span> k &lt;= sm:</span><br><span class="line">                <span class="keyword">if</span> sm % k == <span class="number">0</span> <span class="keyword">and</span> euclid_gcd(k, m) == <span class="number">1</span>:</span><br><span class="line">                    d = s2 // (k*m)</span><br><span class="line">                    n = k - m</span><br><span class="line">                    a = d*(m*m-n*n)</span><br><span class="line">                    b = <span class="number">2</span>*d*m*n</span><br><span class="line">                    c = d*(m*m+n*n)</span><br><span class="line">                    <span class="keyword">print</span> (a, b, c)</span><br><span class="line">                    <span class="keyword">return</span> a*b*c</span><br><span class="line">                k += <span class="number">2</span></span><br><span class="line">s = <span class="number">1000</span></span><br><span class="line">s2 = s // <span class="number">2</span></span><br><span class="line">mlimit = int(math.ceil(math.sqrt(s2))) - <span class="number">1</span></span><br><span class="line">final_result = getPythagorean(s2, mlimit)</span><br><span class="line"><span class="keyword">print</span> final_result</span><br></pre></td></tr></table></figure><h2 id="10-Sum-all-primes-below-N-million"><a href="#10-Sum-all-primes-below-N-million" class="headerlink" title="10. Sum all primes below N million"></a>10. Sum all primes below N million</h2><h3 id="Problem-Description-9"><a href="#Problem-Description-9" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.</p><p>Find the sum of all the primes below two million.</p><h3 id="Solution1-3"><a href="#Solution1-3" class="headerlink" title="Solution1"></a>Solution1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sum after the sieve of Eratosthenes</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPrime</span><span class="params">(L)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> L[i]**<span class="number">2</span> &lt; L[<span class="number">-1</span>]:</span><br><span class="line">        <span class="comment"># Eratosthenes algorithm</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(L)):</span><br><span class="line">            <span class="keyword">if</span> L[j] % L[i] == <span class="number">0</span>:</span><br><span class="line">                L[j] = <span class="number">0</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        L.sort()</span><br><span class="line">        L = L[count:]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line">L = range(<span class="number">2</span>, <span class="number">2000000</span>)</span><br><span class="line">primes_list = findPrime(L)</span><br><span class="line"><span class="keyword">print</span> reduce(<span class="keyword">lambda</span> x,y:x+y, primes_list)</span><br></pre></td></tr></table></figure><h3 id="Solution2-3"><a href="#Solution2-3" class="headerlink" title="Solution2"></a>Solution2</h3><p>除2以外的所有偶数均为合数，故只需要对所给范围2—N内的奇数进行素性判断。我们建立下标i与奇数2*i+1的对应关系。首先建立布尔类型数组，其长度为(N-1)/2，初始值均为False，表示全为素数。设p=2*i+1，则$p^{2}=4<em>i^{2}+4</em>i+1$，其对应的数组下标为2*i+1；设m=k*p，则m+2*p对应的下标为j+p。</p><p>同样参考埃氏筛的思路，下一步需要找外部循环的下标范围、内部循环的初始值以及步进参数。结合以上分析进行讨论。由$2<em>i_max+1&lt;= \sqrt(N)$可得i的范围为$(\lfloor N\rfloor -1) / 2$，该范围是外部循环的下标范围。对于奇数p，所有小于p^2的数字中若为合数则必可被小于p的素数整除，故内部循环的初始值设定为p^2，对应下标为2\</em>i*(i+1)。又$p^{2}+p = 4<em>i^{2}+4</em>i+1+2<em>i+1 = 4</em>i^{2}+6<em>i+2 = 2</em>(2<em>i^{2}+3</em>i+1)$，可知若以p为步进，则得到的结果必为合数，无需进行判断。同时$p^{2}+2<em>p = 2</em>(2<em>i+1)+1 = 4</em>i^{2}+8*i+3 $，可以看出该结果必为合数，同时该结果为p的倍数，将数组对应下标位置标记为True。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Some imporvement of the sieve of Eratosthenes</span></span><br><span class="line"><span class="comment"># Only consider the odd numbers, do some index-arithmetics</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPrimes</span><span class="params">(sievebound, sieve_set, input_number)</span>:</span></span><br><span class="line">    crosslimit = int(math.floor(math.sqrt(input_number)<span class="number">-1</span> // <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, crosslimit):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sieve_set[i]:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>*i*(i+<span class="number">1</span>), sievebound, <span class="number">2</span>*i+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 2*j+1 is compositive</span></span><br><span class="line">                sieve_set[j] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> sieve_set</span><br><span class="line">input_number = <span class="number">2000000</span></span><br><span class="line">sievebound = int(math.floor((input_number<span class="number">-1</span>) // <span class="number">2</span>))</span><br><span class="line">sieve_set = [<span class="literal">False</span>]*input_number</span><br><span class="line">sieve_set_after_deal = findPrimes(sievebound, sieve_set, input_number)</span><br><span class="line">sum_result = <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, sievebound):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sieve_set[k]:</span><br><span class="line">        sum_result += <span class="number">2</span>*k+<span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> sum_result</span><br></pre></td></tr></table></figure><p>以题中所给的2000000为例，解法一运行速度为8s左右，解法二运行速度大大提升，只需要0.417s。</p><p><img src="/2020/10/13/Euler-Project(I)/Euler-Project(I" alt="10_sufficiency.PNG-11.2kB">\3.png)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Multiples-of-3-and-5&quot;&gt;&lt;a href=&quot;#1-Multiples-of-3-and-5&quot; class=&quot;headerlink&quot; title=&quot;1. Multiples of 3 and 5&quot;&gt;&lt;/a&gt;1. Multiples of 3 a
      
    
    </summary>
    
      <category term="Mathematics" scheme="https://blank-vax.github.io/categories/Mathematics/"/>
    
    
      <category term="Euler-Project" scheme="https://blank-vax.github.io/tags/Euler-Project/"/>
    
  </entry>
  
  <entry>
    <title>21深信服秋招面试</title>
    <link href="https://blank-vax.github.io/2020/09/26/21%E7%A7%8B%E6%8B%9B%E6%B7%B1%E4%BF%A1%E6%9C%8D%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F/"/>
    <id>https://blank-vax.github.io/2020/09/26/21秋招深信服秋招面经/</id>
    <published>2020-09-25T16:27:00.000Z</published>
    <updated>2020-11-09T03:40:59.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近日考研期间，适逢深信服”翔鹰计划”线上实习结束，公司给了秋招提前批的面试机会，准备了大概两天就去面试了，岗位是<strong>技服工程师</strong>。由于前期通过笔试，故直接进入技术面、业务面和HR面。</p><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><ul><li>7.19 2020年”翔鹰计划”结束，成绩考核通过，简历转入公司秋招简历池；</li><li>7.23 技服工程师线上技术（一面）面试</li><li>7.30 技服工程师线上业务（二面）面试</li><li>8.4 技服工程师线上HR面试</li><li>9.18 offer沟通</li><li>9.22 签订三方协定（虽然最后没签</li></ul><h2 id="技术面（一面）"><a href="#技术面（一面）" class="headerlink" title="技术面（一面）"></a>技术面（一面）</h2><p>邮件中面试官约定的事件是上午11：00，大概提前两分钟左右进入房间调试设备，不过不知道是牛客网平台原因还是公司网络原因，面试官声音一直断断续续，中间还出现突然静音的情况，于是后期换了腾讯会议。</p><p>面试时间为45分钟，首先进行自我介绍，然后面试官进行提问。问题包括技术问题和非技术问题合计共十个左右，具体如下。</p><h3 id="技术问题"><a href="#技术问题" class="headerlink" title="技术问题"></a>技术问题</h3><ul><li><p>简要介绍VLAN</p><p>回答了VLAN的定义，虚拟局域网。主要作用为将同一网段根据功能划分成不同的虚拟子网。以公司为例，为保证主管、业务、销售、技术等各个部门之间网络的专有通信，引入VLAN技术，实现各部门人员之间在对应虚拟子网内部的高效安全通信，不会产生业务互相影响的情况。</p></li><li><p>简要介绍交换机</p><p>交换机是二层设备，位于数据链路层，主要作用为端口数据帧转发。提到了ARP协议，提出每个交换机维护一个ARP表，以保证不同主机之间的正常通信。顺便讲了一下ARP广播单播，以及相同网段之间主机如何进行通信。</p></li><li><p>针对ARP协议的攻击</p><p>简单讲了ARP欺骗和ARP洪泛攻击，重点介绍了攻击手法及危害。</p></li><li><p>ARP欺骗的防御方法</p><p>由于对ARP欺骗的防御掌握不深入，所以当时简单提到了修改帧结构及增加校验部分，以及进行相关检测。面试官追问哪个设备进行相关检测，然后就没有答上来。面试结束后，参考FreeBuf上的一篇文章：<a href="https://www.freebuf.com/articles/network/210852.html" target="_blank" rel="noopener">浅谈ARP欺骗的实现与防御</a>，归纳两个防御手段：</p><ul><li>主机欺骗：在本机添加一条静态的ARP映射，这样就无需询问网关MAC地址；</li><li>网关欺骗：在网关中也添加一条到主机的静态ARP映射。</li></ul></li><li><p>对路由选择协议的认识</p><p>回答了路由优先级顺序：<strong>直连路由&gt;静态路由&gt;动态路由&gt;默认路由</strong>。静态路由部分只提到需要在路由器上手动配置。动态路由部分提到了内部网关协议与外部网关协议。外部网关协议包括BGP，内部网关协议又分为基于距离矢量的协议和基于链路状态的协议。详细介绍了RIP协议和OSPF协议的工作原理，重点介绍<strong>衡量路径优劣</strong>的标准。</p></li><li><p>网络排查问题：公司中一楼无法正常连网，二楼可正常连网但网速较慢，三楼可正常上网，针对此种情况如何排查解决。</p><p>由于公司和个人网络的排查有所差别，同时我也没有了解过公司的网络排查标准，于是按照个人网络问题进行排查。首先讲了个人PC无法正常联网的排查步骤：</p><ul><li>ping 127.0.0.1，检查TCP/IP协议是否正常配置；</li><li>ping 本机地址，检查网络适配器是否正常配置；</li><li>ping 网关地址，检查网关是否正常配置；</li><li>ping 外网地址，排查重点放在hosts文件中DNS解析是否正常。</li></ul><p>网速较慢这个问题没怎么关注过，简单提到了猜想——公司访问流量限速，当然这是在胡说八道，但是可以用来缓解尴尬，委婉地告诉面试官不怎么会。</p></li><li><p>攻击网站的常见手段</p><p>回答了SQL注入、XSS、CSRF、一句话木马，然后追问一句话木马的工作原理，笼统地回答了一下。</p></li><li><p>了解磁盘冗余阵列RAID吗？</p><p>由于昨天准备的时候刚看到RAID的相关知识，简要回答了RAID 0，RAID 1，RAID 3，RAID 5，RAID p+q等组合方式的特点及优缺点。RAID p+q以RAID 10为例进行详细介绍。</p></li><li><p>了解虚拟化技术吗？</p><p>将虚拟化与云计算技术结合起来回答，大致提到了SaaS，PaaS，IaaS，公有云，私有云，混合云等名词并进行解释。面试官让说出自己对虚拟化的理解，结合aDesk云桌面产品进行了相关说明（感觉自己讲的语无伦次）。本来还想加上虚拟现实技术，后来面试官话锋转到下个问题，只好作罢。</p></li><li><p>常见的加密算法</p><p>终于问到密码学了！（不是）分成对称加密和非对称加密两部分进行回答。对称加密主要介绍了DES，AES，RC4，RC5。非对称加密介绍了三大困难问题及对应的RSA，DH交换和ECC密码体制。顺带提到了消息摘要算法和数字签名算法。</p></li><li><p>以上提到的算法的实际应用</p><p>刚开始想回答数字证书等知识，后来确定回答主题为<strong>非对称加密+对称加密</strong>：对称加密具有加密效率高的特点，相应地安全性较低；非对称加密无法处理大量数据，但安全性较高。故流行的通信方式为通信双方使用非对称加密算法对对称加密密钥进行加解密，从而实现密钥共享，随后使用该密钥结合对称加解密算法进行消息传输。围绕该主题并结合HTTPS加密过程客户端与服务器的相应操作进行作答。</p></li></ul><h3 id="非技术问题"><a href="#非技术问题" class="headerlink" title="非技术问题"></a>非技术问题</h3><ul><li><p>有没有考过网络认证证书+计算机网络知识学习途径</p><p>没考过证书，计网知识除”翔鹰计划”培训外，还上过学校的对应课程，进行过系统学习。</p></li><li><p>经历的压力较大的事情</p><p>聊了聊”美亚杯”比赛的事情（现在感觉当时的回答驴唇不对马嘴）</p></li><li><p>“基于数字水印与神经网络的图像攻击检测系统”项目相关</p><ul><li><p>这个项目中负责的部分</p><p>水印的提取与嵌入算法的实现，水印置乱算法实现，信噪比检验。</p></li><li><p>项目中遇到哪些难题，如何解决？</p><p>只提到当时嵌入提取算法matlab转python实现过程中出现的问题，即无论怎么调整参数，使用python语言实现的算法嵌入水印后的图像都具有明显的水印标记，无法通过信噪比测试。解决方法就是python调matlab脚本（说出来我自己都觉得low，但是当时这个bug调了大概一晚上，所以印象很深刻）。</p></li><li><p>项目中学到了什么？</p><p>从技术和团队合作两方面进行回答。结合自己负责的技术部分简单讲了一下这些算法，同时提到了matlab和python编程。团队合作方面，首先提到了模块化即各司其职，相互配合，以写代码为例提出即使补充注释，方便后期代码整合；然后提到积极讨论，制定多个方案并进行测试。</p></li><li><p>合作过程中，如果发生冲突或受到质疑如何解决？</p><p>这种问题就非常简单了，首先强调团队精神即荣辱与共，大家为共同目标奋斗；然后回答鼓励大家积极讨论，针对同一解决方案各抒己见；最后就是提出质疑需要有理有据。</p></li></ul></li><li><p>热爱读书吗？读过印象最深刻的书是什么？</p><p>这个问题就俨然成为一股清流。先问了问是技术书还是其他书，得到回答是都可以。后来好像也没怎么介绍看的书，这个问题就奇奇怪怪地一扫而过了。</p></li></ul><h2 id="业务面（二面）"><a href="#业务面（二面）" class="headerlink" title="业务面（二面）"></a>业务面（二面）</h2><p>邮件约定面试时间为上午11：00，大概提前五分钟进入面试房间，11：20左右结束，共面试25分钟左右。主要问题包含自我介绍及相关问题。</p><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>简单介绍了一下自己的学校、专业及学习情况，日常爱好，相关技术栈，参加的比赛及获奖情况，实习经历等。‘</p><h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><ul><li><p>简要介绍印象深刻的项目经历（扮演角色，工作内容，学习内容，结果）</p><p>把参与20年作品赛的项目拿出来详细讲了讲，感觉面试官对合作而非技术细节感兴趣。</p></li><li><p>团队合作时有没有受到质疑？如何解决的？</p><p>结合项目经历简单讲了一下解决办法（其实没什么质疑</p></li><li><p>参加过什么实习？聊一下实习经历</p><p>啊这…显然没参加过什么实习，提到了”翔鹰计划”但是面试官没让继续说下去，这个问题就结束了（感觉不是很满意？</p></li><li><p>大学有没有和人发生过冲突？评价下自己的性格，最讨厌什么样的人？</p><p>这三个问题感觉是对面试者人际交往能力和性格的把握吧，就正常回答了一下。</p></li><li><p>你本科学的是网络空间安全，和网络安全有什么区别？</p><p>这个问题算是遇到的比较有趣的非常规问题了，简单讲了一下国家讲网络空间作为”第五空间”的发展战略，以及这个专业广阔的发展前景，还聊了聊网络空间安全和信息安全的区别与联系。</p></li><li><p>网络空间安全对口的公司有什么？</p><p>举了BAT，360，奇安信，绿盟，安恒等经典公司，当然提到了深信服的网络安全、超融合、云计算等标杆。</p></li><li><p>在学校参加过何种比赛？</p><p>由于校园经历偏作品赛比较多，CTF比赛没拿到什么好成绩，所以就简要介绍了几个本专业作品赛的情况。</p></li><li><p>课余时间如何安排生活？</p><p>看技术书+保持几个爱好。</p></li><li><p>看过哪些技术书籍+日常逛哪些论坛？</p><p>举了几个密码学技术书籍，外加计算机网络自顶向下、深入理解计算机系统、软件测试等。论坛聊了Freebuf、先知社区等。</p></li><li><p>简单聊了下技服工程师跨省调度的政策，就是不能回原籍省份工作也不能在学校所在省份工作。</p></li></ul><h2 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h2><p>邮件约定时间为下午16：45，进入房间大概等到17：00开始面试，整个时长为25min。首先进行自我介绍，然后面试官了解情况，大概问了如下几个问题：</p><ul><li><p>概括本科三年生活。</p><p>从技术和日常生活的角度进行概括，技术上提到了CTF比赛和参加的项目，生活角度没怎么提。</p></li><li><p>本科最有挑战和最有成就的事情。</p><p>最有挑战的事情选择了其中一个做过的项目，最有成就的事情选择了”美亚杯”比赛经历。</p></li><li><p>为什么选择”翔鹰计划”实习？</p><p>一是为了了却去年的遗憾，二是线上实习的形式比较安全高效，结合开学时间与暑假安排的考虑，最终选择了”翔鹰计划”。</p></li><li><p>技服工程师这个岗位是做什么的，为什么选择这个岗位？</p><p>简单介绍了一下自己对技术服务的理解。选择原因确定为两点：个人代码水平不高+热爱与人打交道。</p></li><li><p>追问：为什么不选择售前经理？</p><p>个人还是比较热爱技术。（感觉这个岗位和技术关系不大）</p></li><li><p>概括一下自己的优点和缺点（各两条）。</p></li><li><p>评价一下自己是个怎么样的人？</p></li><li><p>有没有长时间坚持的事情？</p><p>运动。</p></li><li><p>确定不考研了吗，为什么？</p><p>总感觉说正在备考拿不到offer，于是胡乱编造了一些理由。</p></li><li><p>期望岗位是什么？想去什么样的公司？</p><p>这个问题回答的比较粗略，给面试官一种没有准备好进入工作+对未来没有明确规划的感觉。可能是因为真的没有准备好本科毕业直接工作吧。事后仔细想想，个人期望岗位还是管理岗，对专注安全的乙方公司没什么向往，对大厂还是比较向往的（阿里、百度、腾讯、字节）。除此之外当个测试工程师或者去公司实验室进行安全研究感觉也挺好。现阶段还是一门心思学习，重点还是提升下学历吧。</p></li><li><p>还有没有投递其他公司？收到过其他offer吗？</p><p>实话实说，并没有，甚至连华为提前批都没打算投。。。</p></li><li><p>工作情况相关</p><ul><li><p>随机工作省份可以接受吗？偏远地区呢？</p><p>个人不能接受过于偏远的地区，对其他工作地点没有太大的执念。不回原籍和学校所在地倒是无所谓。</p></li><li><p>家庭状况：独生子女？父母同意吗？女朋友呢？</p><p>啊这…</p></li></ul></li><li><p>最后简单聊了一下拿到offer的后续安排以及薪资问题。</p></li></ul><h2 id="目前状态"><a href="#目前状态" class="headerlink" title="目前状态"></a>目前状态</h2><ul><li>7.23 等业务面通知中…</li><li>7.30 等HR面通知中…</li><li>8.4 HR面试结束，等offer中，大概率凉…</li><li>9.18 offer沟通</li><li>9.22 没有去签三方协定，选择继续考研</li></ul><h2 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h2><p>各种意义上来说这次面试都是人生中经历的第一次完整的企业面试，不仅体验了整套面试流程，还发现了一些重点问题，并且引发一些思考。</p><ul><li>仔细回顾大学本科真的没有做什么惊天动地的事情，技术水平也比较平庸，这种状态下直接工作感觉难度较大。倒不是说找不到工作，但是能进的公司个人不太喜欢。当然也不想当拿钱少的用爱发电的社畜。</li><li>技术方面：大学阅读的技术书籍太少了，对于Web安全的掌握并不到位，这两点需要后续加强。不管从事哪一个与安全相关的岗位，应聘时技术短板都是致命的。</li><li>应聘技巧：针对不同内容进行准备，多刷面经，提高算法及代码能力。面试时扬长避短，努力主导谈论的话题。该掩饰的时候千万不要实话实说。</li><li>认识到自己的平凡，好好学习，未来可期。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;近日考研期间，适逢深信服”翔鹰计划”线上实习结束，公司给了秋招提前批的面试机会，准备了大概两天就去面试了，岗位是&lt;strong&gt;技服工程师&lt;
      
    
    </summary>
    
      <category term="Interview" scheme="https://blank-vax.github.io/categories/Interview/"/>
    
    
      <category term="Sangfor" scheme="https://blank-vax.github.io/tags/Sangfor/"/>
    
  </entry>
  
  <entry>
    <title>Windows基础及常用命令</title>
    <link href="https://blank-vax.github.io/2020/07/23/Windows%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://blank-vax.github.io/2020/07/23/Windows基础及常用命令/</id>
    <published>2020-07-22T16:20:00.000Z</published>
    <updated>2021-07-07T12:43:49.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows常见目录"><a href="#Windows常见目录" class="headerlink" title="Windows常见目录"></a>Windows常见目录</h2><ul><li><p>Documents and Settings/用户</p><p>存储用户设置，包括用户文档、上网浏览信息、配置文件等数据</p></li><li><p>Windows目录</p><p>Windows安装目录，用来放置Windows程序的使用数据、设置等文件。不建议修改此目录下数据，易造成Windows系统使用异常</p></li><li><p>Program File</p><p>应用程序文件夹，一般软件默认安装位置。当然此处也包含系统自带的应用程序。Windows10系统中，64位用户多出一个Program Files(x86)文件夹，用作系统中32位软件的安装目录</p></li><li><p>Temp目录 临时文件目录</p><p>文件路径：C:\Users\user\AppData\Local\Temp</p><p>上面存在许多垃圾文件，包括使用压缩软件等解压的临时文件。此目录也是病毒检测过程中快速扫描的位置。</p></li></ul><h2 id="Windows注册表"><a href="#Windows注册表" class="headerlink" title="Windows注册表"></a>Windows注册表</h2><p>注册表是Windows操作系统中的一个核心数据库，其中存放各种参数，直接控制Windows的启动、硬件驱动程序的装装载以及一些Windows应用程序的运行。</p><p>恶意病毒通常通过修改注册表的键<strong>HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\Main Start Page</strong>项对应的URL值来修改IE起始页面。</p><h2 id="系统启动项"><a href="#系统启动项" class="headerlink" title="系统启动项"></a>系统启动项</h2><p>开机时系统会在前台或后台自动运行的程序。查看方式为msconfig命令。</p><p>将文件、程序等放入位于<strong>C:\Users\user\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</strong>的启动文件夹中即可实现开机自启动。</p><h2 id="设备管理器"><a href="#设备管理器" class="headerlink" title="设备管理器"></a>设备管理器</h2><p>设备管理器常被用来查看和更改设备属性、更新设备驱动程序、配置设备设置和卸载设备。所有设备通过<strong>设备驱动程序</strong>与Windows进行通信。</p><ul><li>超融合迁移（虚拟机网卡网络适配器）</li><li>云桌面外设（USB白名单）</li></ul><p>使用设备管理器可以安装和更新硬件设备的驱动程序、修改这些设备的硬件设置以及通过查看硬件设备状态信息来排查问题。</p><h2 id="任务管理器"><a href="#任务管理器" class="headerlink" title="任务管理器"></a>任务管理器</h2><p>Windows任务管理器提供了有关计算机性能的信息，并显示了计算机上所运行的程序和进程的详细信息（哪个用户创建了哪个进程或程序，该进程或程序占用了多少CPU及其他系统资源）。</p><ul><li>应用程序</li><li>进程（*32代表32位系统进程）</li><li>服务</li><li>性能（详细Windows系统资源占用情况）</li><li>联网（网卡流量）</li><li>用户（当前运行的用户名）</li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是正在运行的程序实例。每个进程存在属于自己的地址空间，一般包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储<strong>处理器执行的代码</strong>；数据区域存储<strong>变量和进程执行期间使用的动态分配的内存</strong>；堆栈区域存储<strong>活动过程调用的指令和本地变量</strong>。</p><ul><li>虚拟机出现CPU、内存异常偏高时，可以通过任务管理器查看进程的资源利用率</li><li>病毒常伪装成<strong>svchost.exe</strong>，<strong>explorer.exe</strong>和<strong>rundll32.exe</strong>等系统进程，当发现这些进程CPU及内存资源占用异常时，需要重点查杀</li></ul><h2 id="组策略"><a href="#组策略" class="headerlink" title="组策略"></a>组策略</h2><p>组策略在部分意义上可控制用户可以或无法在计算机上执行什么操作，提供了操作系统、应用程序和活动目录中用户设置的集中化管理和配置。在运行模式下输入<strong>gpedit.msc</strong>可以打开组策略配置。</p><h3 id="刷新时间"><a href="#刷新时间" class="headerlink" title="刷新时间"></a>刷新时间</h3><p>默认情况下，Mircosoft Windows每90分钟刷新一次组策略，随机偏移为30分钟。在域控制器上，Microsoft Windows每隔5分钟刷新一次。</p><h3 id="处理顺序"><a href="#处理顺序" class="headerlink" title="处理顺序"></a>处理顺序</h3><ul><li>本地——任何在本地计算机的设置。在Windows Vista和之后的Windows版本中，允许每个用户账户分别拥有组策略</li><li>站点——任何与计算机所在的活动目录站点关联的组策略。活动目录站点旨在管理促进物理上接近的计算机的一种逻辑分组。如果多个策略链接到一个站点，将按照管理员设置的顺序处理</li><li>域——任何与计算机所在Windows域关联的组策略。如果多个策略链接到一个域，将按照管理员设置的顺序处理</li><li>组织单元——任何与计算机或用户所在的活动目录组织单元（OU）关联的组策略。OU是帮助组织和管理一组用户、计算机或其他活动目录对象的逻辑单元。如果多个策略链接到一个OU，将按照管理员设置的顺序处理</li></ul><h2 id="安全组"><a href="#安全组" class="headerlink" title="安全组"></a>安全组</h2><p>可以列出用于定义资源和对象权限的任意访问控制列表（DACL）中的组。Windows安全组策略其实是组策略中关于安全设置的部分，囊括了账户安全策略、Windows防火墙配置等配置目录。</p><p>在运行任务栏输入<strong>secpol.msc</strong>，修改安全组相关配置之后，需要重新登录Windows用户方可生效。</p><h2 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h2><p>工作组就是将不同的电脑按功能分别列入不同的组中，以方便管理。</p><p>Windows 9x/NT/2000引入工作组概念后，若要访问某个系列的资源，需要在网上邻居内找到对应的工作组名，即可找到该系列资源。</p><h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2><p>工作组中一切设置在本机上进行，包括各种策略、用户登录等过程，对应密码也存放在本机数据库中进行验证。</p><p>域作为工作组的升级版，计算机的各种策略通过域控制器统一设定，用户名和密码的验证过程也在域控制器中完成。因此，用户信息可以实现在域中电脑上的漫游。</p><h3 id="域控制器"><a href="#域控制器" class="headerlink" title="域控制器"></a>域控制器</h3><p>在域模式下，至少有一台服务器负责每台联入网络的电脑和用户的验证工作，被称为<strong>域控制器（Domain Controller，DC）</strong>。域控制器包含由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。</p><h2 id="安全日志"><a href="#安全日志" class="headerlink" title="安全日志"></a>安全日志</h2><p>Windows用户所有的登录注销、安全策略更改都会以安全日志的形式记录。</p><p>日志位置：计算机管理—&gt;系统工具—&gt;事件查看器—&gt;Windows日志—&gt;安全</p><ul><li>溯源黑客入侵行为</li><li>通过事件ID快速检索日志</li></ul><h2 id="常用网络排查命令"><a href="#常用网络排查命令" class="headerlink" title="常用网络排查命令"></a>常用网络排查命令</h2><h3 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h3><p>通过发送Internet控制消息协议（ICMP）验证与其他TCP/IP计算机的IP级连接回显请求消息。显示相应的回音回复信息的接受以及往返时间。该命令可用于解决连接、可访问性和名称解析等问题。</p><h4 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><code>Ping IP/域名 -t</code>：长时间执行Ping命令，以推断连接健壮性</li><li><code>Ping IP/域名 -n number</code>： 指定发送数据包的数量</li><li><code>Ping IP/域名 -l length</code>： 指定发送数据包的长度（默认长度为32Bytes）</li></ul><p>一般使用<code>Ping IP/域名 -l big-number -n big-number</code>探测连接稳定性，其中big-number为大于1000的数字，需要多次尝试以找到合适的数据包长度。</p><h4 id="错误提示"><a href="#错误提示" class="headerlink" title="错误提示"></a>错误提示</h4><ul><li>找不到主机：排查DNS是否正确解析指定域名</li><li>请求超时：目标地址禁止Ping/目标地址不存在</li><li>传输失败：主机网络存在问题</li></ul><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>显示和修改地址解析协议缓存中的条目，其中包含一个或多个用于存储IP地址及其解析结果的以太网或令牌环物理地址的表。计算机上安装的每个以太网或令牌环网络适配器都存在单独的表。</p><h4 id="常用选项-1"><a href="#常用选项-1" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><code>Arp -a</code>：显示所有的地址信息及接口信息</li><li><code>Arp -s ip_addr mac_addr</code>：静态配置ARP地址表项</li><li><code>Arp -d</code>：用于删除当前ARP信息</li></ul><h3 id="Tracert"><a href="#Tracert" class="headerlink" title="Tracert"></a>Tracert</h3><p>确定通过发送Internet控制消息协议（ICMP）回显请求或以递增的生存时间（TTL）字段值向目标发送消息。路径显示源主机和目标之间路径中路由器的近/侧路由器接口列表。无参数使用。</p><h4 id="常用选项-2"><a href="#常用选项-2" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><p><code>Tracert -d</code>：不将地址解析成主机名</p></li><li><p><code>Tracert -h maximum_hops</code>：搜索目标的最大跃点数</p></li></ul><h3 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h3><p>显示并修改本地IP路由表中的输入。无参数使用。需要<strong>以管理员身份打开</strong>以进行相关配置。常用命令结构：<code>Route command ip_addr mask mask_number gateway_addr</code>。</p><h4 id="常用选项-3"><a href="#常用选项-3" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><p>command</p><ul><li><code>Route PRINT</code>：打印路由表</li><li><code>Route ADD</code>：添加静态路由（临时，重启后消失）</li><li><code>Route DELETE</code>：删除路由信息</li><li><code>Route CHANGE</code>：修改现有路由的网关和跃点数</li></ul></li><li><p><code>Route -p</code>：使得对路由表的添加操作永久生效</p></li></ul><h3 id="Ipconfig"><a href="#Ipconfig" class="headerlink" title="Ipconfig"></a>Ipconfig</h3><p>显示所有当前TCP/IP网络配置值，并刷新动态主机配置协议（DHCP）和域名系统（DNS）设置。无参数使用时，为所有适配器显示Internet协议版本4和IPv6地址、子网掩码和默认网关。</p><h4 id="常用选项-4"><a href="#常用选项-4" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><code>Ipconfig /all</code>：显示所有网络适配器的所有信息</li><li><code>Ipconfig /release</code>：释放当前所有网卡的DHCP信息</li><li><code>Ipconfig /renew</code>：释放当前网卡的所有DHCP信息并重新获取</li><li><code>Ipconfig /displaydns</code>：展示当前DNS缓存信息</li><li><code>Ipconfig /flushdns</code>：清理当前DNS缓存信息</li></ul><h3 id="Netstat"><a href="#Netstat" class="headerlink" title="Netstat"></a>Netstat</h3><p>显示有源TCP连接，计算机在哪个端口被侦听，以太网统计，IP路由表，IPv4统计和IPv6统计。无参数使用时，网络显示激活TCP连接。</p><h4 id="常用选项-5"><a href="#常用选项-5" class="headerlink" title="常用选项"></a>常用选项</h4><ul><li><code>Netstat -a</code>：展示当前监听的所有网口信息</li><li><code>Netstat -n</code>：展示所有TCP&amp;UDP连接信息及端口详细信息</li><li><code>Netstat -o</code>：展示当前连接的PID</li><li><code>Netstat -p</code>：指定当前监听协议</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Windows常见目录&quot;&gt;&lt;a href=&quot;#Windows常见目录&quot; class=&quot;headerlink&quot; title=&quot;Windows常见目录&quot;&gt;&lt;/a&gt;Windows常见目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Documents and Settings/用户
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Windows Foundation" scheme="https://blank-vax.github.io/tags/Windows-Foundation/"/>
    
  </entry>
  
  <entry>
    <title>云计算基础</title>
    <link href="https://blank-vax.github.io/2020/07/15/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80/"/>
    <id>https://blank-vax.github.io/2020/07/15/云计算基础/</id>
    <published>2020-07-14T16:09:00.000Z</published>
    <updated>2021-07-07T12:58:28.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="云计算基础"><a href="#云计算基础" class="headerlink" title="云计算基础"></a>云计算基础</h2><h3 id="云计算定义"><a href="#云计算定义" class="headerlink" title="云计算定义"></a>云计算定义</h3><ul><li>技术角度：云计算是一种基于互联网的计算方式，通过这种方式，共享的软硬件资源和信息可以按需求提供给计算机和其他设备。</li><li><p>经济学角度：云计算依赖资源的共享以达成规模经济，类似基础设施如电力网等。</p></li><li><p>云计算现阶段的发展还远远未达到基础设施建设水平。</p></li></ul><p><img src="/2020/07/15/云计算基础/1.png" alt="image-20200711112223579.png-264.8kB"></p><ul><li>滴滴打车</li></ul><h3 id="云计算本质"><a href="#云计算本质" class="headerlink" title="云计算本质"></a>云计算本质</h3><p>云计算是新技术+IT业务模式的创新，随着数字化时代的发展，IT消费模式产生重大转变：云计算通过技术将IT资源池化和服务化，通过互联网提供IT服务，而用户由网络浏览器或轻量级终端软件来获取和使用这些IT服务。整个IT市场商业模式正实现<strong>“从产品到服务”</strong>的转型。</p><h3 id="云计算特性"><a href="#云计算特性" class="headerlink" title="云计算特性"></a>云计算特性</h3><ul><li>按需自助</li><li>可度量服务</li><li>快速灵活</li><li>资源池</li><li>广阔网络访问</li></ul><h3 id="相关分类"><a href="#相关分类" class="headerlink" title="相关分类"></a>相关分类</h3><h4 id="服务模型分类"><a href="#服务模型分类" class="headerlink" title="服务模型分类"></a>服务模型分类</h4><ul><li><p>IaaS（Infrastructure as a Service）：基础架构即服务</p><p>用户通过网络使用计算机（物理机或虚拟机）、存储空间、网络连接等完善的计算机基础设施服务。</p></li><li><p>PaaS（Platform as a Service）：平台即服务</p><p>将软件研发的平台作为一种服务提交给用户，意在加快SaaS应用的开发速度。</p></li><li><p>SaaS（Software as a Service）：软件即服务</p><p>通过Internet提供软件的模式，用户无需购买软件，而是向提供商租用基于Web的软件来管理企业经营活动。</p></li></ul><h4 id="部署模型分类"><a href="#部署模型分类" class="headerlink" title="部署模型分类"></a>部署模型分类</h4><ul><li>公有云</li><li>私有云</li><li>混合云</li></ul><h3 id="公有云"><a href="#公有云" class="headerlink" title="公有云"></a>公有云</h3><p>通过Internet为外部客户提供服务的云。典型公有云包括Amazon EC2、阿里云、腾讯云等。</p><ul><li><p>优点</p><p>所有应用服务数据等均存放在公有云提供商处，客户无需硬件投资与建设，使用成本低；</p></li><li><p>缺点</p><p>数据存放在供应商处，安全性存在风险。公有云的可用性不受使用者控制，存在不确定性。</p></li></ul><h3 id="私有云"><a href="#私有云" class="headerlink" title="私有云"></a>私有云</h3><p>由企业或机构独享使用和掌控的云，仅供自己内部人员或分支机构使用，一般部署在企业或机构的数据中心。</p><ul><li><p>优点</p><p>数据安全性和系统可用性可控，对现有IT流程管理影响小、IT资源利用率高；</p></li><li><p>缺点</p><p>投资较大。</p></li></ul><h3 id="混合云"><a href="#混合云" class="headerlink" title="混合云"></a>混合云</h3><p>同一份数据、同一套应用，同时采用私有云技术构建自己的IT服务平台，同时又采购了公有云服务商提供的IT服务。为保证数据安全，企业将核心数据和关键技术存放于私有云上，而将面向用户的服务托管在公有云上，具有较高的弹性。一般是需要具备可控的前提下，具备一定的弹性或可靠性。多应用于潮汐应用及混合云灾备。</p><ul><li><p>优点</p><p>具备较大弹性，并且可以在保障可控性的同时兼顾建设成本；</p></li><li><p>缺点</p><p>IT业务管理界面不统一，需要投入相应的混合云管理成本。</p></li></ul><h2 id="数据中心基础"><a href="#数据中心基础" class="headerlink" title="数据中心基础"></a>数据中心基础</h2><h3 id="重要组成要素"><a href="#重要组成要素" class="headerlink" title="重要组成要素"></a>重要组成要素</h3><ul><li>处理资源请求和资源分发的云平台</li><li>网络管道</li><li>终端用户</li></ul><h3 id="数据中心"><a href="#数据中心" class="headerlink" title="数据中心"></a>数据中心</h3><p>数据中心是云计算后端基础设施的承载体，云计算依托数据中心提供各种云计算服务。数据中心内部除包含基础物理设施外，还包含网络、安全、优化、存储、服务器、操作系统、虚拟机及应用软件等成分。</p><h3 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h3><p><img src="/2020/07/15/云计算基础/2.png" alt="云计算逻辑架构.png-140.1kB"></p><h2 id="计算基础"><a href="#计算基础" class="headerlink" title="计算基础"></a>计算基础</h2><h3 id="服务器分类"><a href="#服务器分类" class="headerlink" title="服务器分类"></a>服务器分类</h3><p>随着云计算技术的发展与并行计算思想的出现，未来x86服务器在市场中将占据主导地位。</p><h4 id="x86服务器"><a href="#x86服务器" class="headerlink" title="x86服务器"></a>x86服务器</h4><p>又称CISC（复杂指令集）架构服务器，即通常所讲的PC服务器，它基于PC机体系结构，使用Intel或其它兼容x86指令集的处理器芯片和Windows/Linux操作系统的服务器。</p><h4 id="非x86服务器"><a href="#非x86服务器" class="headerlink" title="非x86服务器"></a>非x86服务器</h4><p>包括大型机、小型机和UNIX服务器，它们是使用RISC（精简指令集）或EPIC（并行指令代码）的处理器，并且主要采用UNIX和其他专用操作系统的服务器。</p><h3 id="小型机"><a href="#小型机" class="headerlink" title="小型机"></a>小型机</h3><p>中国业内习惯上称UNIX服务器为小型机，其最引以为傲的特点就是高RAS——高可靠性、高可用性与高服务性。随着CPU和虚拟化技术的发展，x86服务器的可靠性与可用性不再是问题，为用户提供更多选择，小型机的竞争力逐渐下降。</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>Central Process Unit，是一块超大规模的集成电路，是一台计算机的运算核心和控制核心。常见参数如下：</p><ul><li>主频：表示CPU的处理频率，常见的频率为1.7-3.1GHz。数值越高，处理的速度越快。超频表示CPU可以超越主频规定的处理频率进行运算处理。当计算机进入节能模式时，为提高电量续航，采用降频策略，主动下调CPU的计算效率。</li><li>核数：表示CPU的并行处理能力。核数越多则并行处理速度越快。超线程表示CPU可以高负荷处理数据。</li></ul><p>为适应信息化发展，Intel推出VT（Virtualization Technology，虚拟化技术）系列以满足不同的上层操作系统对底层处理器的调用，如VT-x、VT-d、VT-c。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>Memory，也被称为内存储器，用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。内存主频与CPU主频一样，习惯上被用来表示内存的速度，代表着该内存所能达到的最高工作频率。可分为ROM只读存储器、RAM随机存储器和Cache高速缓存三类。</p><h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><p>Disk，数据的最终归属地。可分为机械硬盘HDD与固态硬盘SSD。</p><h3 id="常见卡"><a href="#常见卡" class="headerlink" title="常见卡"></a>常见卡</h3><ul><li>网卡：通过网络连接线与网络交换机连接。</li><li>存储卡：通过网络连接线和存储设备对接。</li><li>RAID卡：通过总线和硬盘连接。</li></ul><p>常见接口为PCI、PCI-X和PCI-E。</p><h3 id="光模块"><a href="#光模块" class="headerlink" title="光模块"></a>光模块</h3><p>光模块的作用为光电转换，发送端将电信号转换为光信号，通过光纤传送后，接收端再将光信号转换为电信号。光模块具有传输速率高，传输距离远的特点。</p><h3 id="光纤跳线"><a href="#光纤跳线" class="headerlink" title="光纤跳线"></a>光纤跳线</h3><p>用来做从设备到光纤布线链路的跳接线。常见LC接口的光模块为：SFF、SFP、SFP+和XFP。常见SC接口的光明模块为GBIC。而FC、ST接口多用于光纤配线架。</p><h3 id="操作系统OS"><a href="#操作系统OS" class="headerlink" title="操作系统OS"></a>操作系统OS</h3><p>管理和控制计算机硬件与软件资源的计算机程序，具有承上启下的功能：对上有效管理系统资源，为应用软件提供基础的底层环境，提高系统资源使用效率。对下屏蔽硬件物理特性和操作细节，为用户使用计算机提供便利。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;云计算基础&quot;&gt;&lt;a href=&quot;#云计算基础&quot; class=&quot;headerlink&quot; title=&quot;云计算基础&quot;&gt;&lt;/a&gt;云计算基础&lt;/h2&gt;&lt;h3 id=&quot;云计算定义&quot;&gt;&lt;a href=&quot;#云计算定义&quot; class=&quot;headerlink&quot; title=&quot;云计算
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Cloud Computing" scheme="https://blank-vax.github.io/tags/Cloud-Computing/"/>
    
  </entry>
  
  <entry>
    <title>终端安全检测及防御技术</title>
    <link href="https://blank-vax.github.io/2020/07/06/%E7%BB%88%E7%AB%AF%E5%AE%89%E5%85%A8%E6%A3%80%E6%B5%8B%E5%8F%8A%E9%98%B2%E5%BE%A1%E6%8A%80%E6%9C%AF/"/>
    <id>https://blank-vax.github.io/2020/07/06/终端安全检测及防御技术/</id>
    <published>2020-07-06T01:20:00.000Z</published>
    <updated>2020-11-09T03:39:33.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="终端安全风险"><a href="#终端安全风险" class="headerlink" title="终端安全风险"></a>终端安全风险</h2><p>黑客可以利用僵尸网络展开更多的危害行为，如APT攻击最常采用的跳板就是僵尸网络。黑客利用僵尸网络来实现渗透、监视、窃取敏感数据等目的，造成严重危害。</p><p>僵尸网络主要危害有：</p><ul><li>未知风险</li><li>高级持续威胁</li><li>本地渗透扩散</li><li>敏感信息窃取</li><li>脆弱信息收集</li></ul><h2 id="终端上网安全可视可控技术"><a href="#终端上网安全可视可控技术" class="headerlink" title="终端上网安全可视可控技术"></a>终端上网安全可视可控技术</h2><p>基于七层应用的深度数据包检测可实现终端安全可控。AF中实现了可视化的应用管控与全面的应用安全。可视化应用管控中包含<strong>应用识别</strong>与<strong>流量管控</strong>两大模块。</p><h3 id="应用控制策略"><a href="#应用控制策略" class="headerlink" title="应用控制策略"></a>应用控制策略</h3><p>应用控制策略可对应用/服务的访问做双向控制，AF存在一条默认拒绝所有应用/服务的控制策略。</p><ul><li>基于应用的控制策略：通过匹配数据包特征来进行过滤动作，需要一定数量的包通行后才能判断应用类型，然后进行拦截动作的判断。</li><li>基于服务的控制策略：通过匹配数据包的五元组（源/目的IP地址+源/目的端口号+协议类型）来进行过滤动作，对任何包可以立即进行拦截动作判断。</li></ul><h3 id="Web过滤"><a href="#Web过滤" class="headerlink" title="Web过滤"></a>Web过滤</h3><p>Web过滤指针对符合设定条件的访问网页数据进行过滤，包括URL过滤与文件过滤，同时可以针对HTTPS URL进行过滤。</p><h2 id="网关杀毒技术"><a href="#网关杀毒技术" class="headerlink" title="网关杀毒技术"></a>网关杀毒技术</h2><h3 id="计算机病毒"><a href="#计算机病毒" class="headerlink" title="计算机病毒"></a>计算机病毒</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>隐蔽性</li><li>破坏性</li><li>潜伏性</li><li>不可预见性</li><li>繁殖性</li><li>传染性</li></ul><h4 id="工作步骤"><a href="#工作步骤" class="headerlink" title="工作步骤"></a>工作步骤</h4><p><img src="http://static.zybuluo.com/B1ank/q220r9z8dhph5x9jbd066ox3/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92%E5%B7%A5%E4%BD%9C%E6%AD%A5%E9%AA%A4.png" alt="计算机病毒工作步骤.png-233.6kB"></p><h3 id="网关杀毒实现方式"><a href="#网关杀毒实现方式" class="headerlink" title="网关杀毒实现方式"></a>网关杀毒实现方式</h3><h4 id="代理扫描方式"><a href="#代理扫描方式" class="headerlink" title="代理扫描方式"></a>代理扫描方式</h4><p>将所有经过网关的需要进行病毒检测的数据报文透明地转交给网关自身的协议栈，通过网关自身的协议栈将文件全部缓存下来后，再送入病毒检测引擎进行病毒检测。</p><h4 id="流扫描方式"><a href="#流扫描方式" class="headerlink" title="流扫描方式"></a>流扫描方式</h4><p>依赖于状态检测技术以及协议解析技术，简单地提取文件的特征与本地签名库进行匹配。由于流扫描方式只针对部分数据进行扫描，故查准率低于代理扫描方式，属于轻量级检测技术。</p><h3 id="AF网关杀毒实现方式"><a href="#AF网关杀毒实现方式" class="headerlink" title="AF网关杀毒实现方式"></a>AF网关杀毒实现方式</h3><p><img src="http://static.zybuluo.com/B1ank/bkkhf877533ca6ulcqgasvnr/AF%E7%BD%91%E5%85%B3%E6%9D%80%E6%AF%92%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.png" alt="AF网关杀毒实现方式.png-430.3kB"></p><p>该杀毒体系具有以下特点：</p><ul><li>防火墙AF提供捕获文件能力和拦截处置能力。</li><li>SAVE提供本地无规则的检测能力。</li><li>云脑提供安全能力的更新和云端威胁情报查杀的能力。</li><li>具备威胁情报、本地引擎SAVE查杀、云沙箱能力。</li></ul><h3 id="网关杀毒配置思路"><a href="#网关杀毒配置思路" class="headerlink" title="网关杀毒配置思路"></a>网关杀毒配置思路</h3><ul><li>新建模块</li><li>选择杀毒协议</li><li>选择文件类型</li><li>新增安全策略</li></ul><h2 id="僵尸网络检测与防御技术"><a href="#僵尸网络检测与防御技术" class="headerlink" title="僵尸网络检测与防御技术"></a>僵尸网络检测与防御技术</h2><h3 id="僵尸网络"><a href="#僵尸网络" class="headerlink" title="僵尸网络"></a>僵尸网络</h3><p>僵尸网络（Botnet）是指骇客利用自己编写的分布式拒绝服务攻击程序将数万个沦陷的机器组织成一个个控制节点用来发送伪造包或垃圾数据包，使预定攻击目标瘫痪并拒绝服务。通常蠕虫病毒也可以被用来组成僵尸网络。</p><h3 id="僵尸网络感染过程"><a href="#僵尸网络感染过程" class="headerlink" title="僵尸网络感染过程"></a>僵尸网络感染过程</h3><ul><li>僵尸主控传播木马到网络中的感染终端。</li><li>主机受到感染，连接C&amp;C服务器，获取指令。</li><li>C&amp;C服务器下发指令给受感染主机，扫描网络并感染更多主机。</li><li>更多主机被感染并组成僵尸网络，连接C&amp;C服务器并获取操作指令。</li></ul><h3 id="异常流量检测"><a href="#异常流量检测" class="headerlink" title="异常流量检测"></a>异常流量检测</h3><p>通过对当前的网络层及应用层行为与安全模型进行偏离度分析，能够发现隐藏的网络异常行为，并根据行为特征确定攻击类型，发现特征匹配无法发现的攻击。</p><p>外发流量异常功能是一种启发式的DOS攻击检测手段，能够检测源IP不变的SYN Flood、UDP Flood等泛洪攻击。该功能原理为：当特定协议的外发包pps超过配置的阈值时，基于5分钟左右的抓包样本检测数据包是否为单向流量、是否有正常响应内容，得出分析结论并将发现的攻击提交日志显示。</p><h3 id="误判排除"><a href="#误判排除" class="headerlink" title="误判排除"></a>误判排除</h3><h4 id="AF僵尸网络防护排除"><a href="#AF僵尸网络防护排除" class="headerlink" title="AF僵尸网络防护排除"></a>AF僵尸网络防护排除</h4><p>AF僵尸网络防护排除方式具有以下三种：</p><ul><li>在僵尸网络功能模块下排除指定IP。</li><li>若误判由拦截规则引起，则可在【安全防护对象】-【僵尸网络规则库】找到并禁用指定规则。</li><li>可以在内置数据中心中，查询僵尸网络日志后使用【添加例外】排除。</li></ul><h4 id="DNS场景误判排除"><a href="#DNS场景误判排除" class="headerlink" title="DNS场景误判排除"></a>DNS场景误判排除</h4><p>通过蜜罐技术解决内网存在DNS服务器时，用于定位内网感染僵尸网络主机的真实IP地址。防止配置过程中忽略蜜罐设置，导致后续无法溯源的问题，策略配置界面新增DNS服务器服务界面。</p><h3 id="杀毒通知推送"><a href="#杀毒通知推送" class="headerlink" title="杀毒通知推送"></a>杀毒通知推送</h3><p>AF检测到的风险主机可以推送杀毒通知。重定向页面支持自定义，同时支持下载病毒查杀软件。</p><p>注意：杀毒通知推送设定的时间内，风险主机下载工具并查杀后也无法直接上网，需要等待指定时间，或管理员取消推送才可正常访问网站。重定向页面只对HTTP生效，HTTPS及NAT场景均不生效。</p><h2 id="勒索病毒防护"><a href="#勒索病毒防护" class="headerlink" title="勒索病毒防护"></a>勒索病毒防护</h2><h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>勒索病毒是一种新型电脑病毒，主机感染勒索病毒文件后，会自动运行勒索程序，遍历本地所有磁盘指定类型文件进行加密操作，加密后文件无法读取。随后生成勒索通知，要求受害者支付虚拟货币作为赎金。主要包含两种场景：</p><ul><li>服务器文件被加密</li><li>内网主机成片出现蓝屏现象，蓝屏代码提示<code>srv.sys驱动出现问题</code></li></ul><h3 id="防护措施"><a href="#防护措施" class="headerlink" title="防护措施"></a>防护措施</h3><ul><li>事前加固：勒索病毒风险评估，精准评估勒索病毒进入点风险，配置勒索病毒专项策略，全面防护勒索风险。</li><li>事中积极防御：通过配置的勒索病毒专项策略，全面防护勒索风险。</li><li>事后快速响应与处置：隔离识别已失陷的主机，采用专项工具进行杀毒。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;终端安全风险&quot;&gt;&lt;a href=&quot;#终端安全风险&quot; class=&quot;headerlink&quot; title=&quot;终端安全风险&quot;&gt;&lt;/a&gt;终端安全风险&lt;/h2&gt;&lt;p&gt;黑客可以利用僵尸网络展开更多的危害行为，如APT攻击最常采用的跳板就是僵尸网络。黑客利用僵尸网络来实现渗透、
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Terminal Security" scheme="https://blank-vax.github.io/tags/Terminal-Security/"/>
    
  </entry>
  
  <entry>
    <title>信息安全概述</title>
    <link href="https://blank-vax.github.io/2020/07/01/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/"/>
    <id>https://blank-vax.github.io/2020/07/01/信息安全概述/</id>
    <published>2020-07-01T03:50:00.000Z</published>
    <updated>2021-07-07T12:57:01.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安全背景"><a href="#安全背景" class="headerlink" title="安全背景"></a>安全背景</h2><ul><li>数字化时代威胁升级</li><li>传统安全防护在数字化转型中逐渐失效</li><li>安全风险能见度不足<ul><li>资产更替较快，无法全方位把握所有资产，导致安全加固操作不到位；</li><li>缺乏对水坑攻击、鱼叉邮件攻击、0day漏洞等新型威胁的及时全面的探测；</li><li>缺乏对预留后门、合法用户伪装等潜藏风险的把控；</li></ul></li><li>缺乏自动化防御手段</li><li>网络安全监管标准愈发严苛</li></ul><h2 id="常见网络安全术语"><a href="#常见网络安全术语" class="headerlink" title="常见网络安全术语"></a>常见网络安全术语</h2><ul><li>漏洞：可能被一个或多个威胁利用的资产或控制的弱点，包括软件漏洞、硬件漏洞、协议漏洞、算法漏洞等。</li><li>0day漏洞：亟待官方发现及开发安全补丁的漏洞。0day漏洞公开后称为Nday漏洞。</li><li>WEBSHELL：以asp、php、jsp或cgi等网页文件形式存在的一种命令执行环境。攻击者利用服务器本身开设的80端口采用POST请求上传WEBSHELL，绕过防火墙的检测，达到入侵服务器并提升用户权限的目的，最终实现完全控制服务器。针对这一攻击，可以通过设置白名单的方式限制文件上传。</li><li>exploit：漏洞利用即exp。本地攻击与远程攻击。</li><li>APT攻击：高级持续性威胁（Advanced Persistent Thread），利用先进的攻击手段对特定目标进行长期持续性网络攻击的攻击形式。</li></ul><h2 id="协议栈自身脆弱性及常见攻击"><a href="#协议栈自身脆弱性及常见攻击" class="headerlink" title="协议栈自身脆弱性及常见攻击"></a>协议栈自身脆弱性及常见攻击</h2><h3 id="协议栈脆弱性"><a href="#协议栈脆弱性" class="headerlink" title="协议栈脆弱性"></a>协议栈脆弱性</h3><ul><li>缺乏数据源验证机制</li><li>缺乏机密性保障机制</li><li>缺乏完整性检验机制</li></ul><h3 id="网络攻击基本模式"><a href="#网络攻击基本模式" class="headerlink" title="网络攻击基本模式"></a>网络攻击基本模式</h3><p>网络攻击包括被动威胁和主动威胁。其中被动威胁主要指截获这一手段，主动威胁包括篡改、中断和伪造这三种手段。</p><ul><li>截获—&gt;机密性：包括嗅探（Sniffing）和监听（Eavesdropping）；</li><li>篡改—&gt;完整性：主要指数据包篡改（Tampering）；</li><li>中断—&gt;可用性：常见的有拒绝服务（Dosing）；</li><li>伪造—&gt;真实性：通过欺骗（Spoofing）的方法破坏信息真实性；</li></ul><h3 id="常见攻击手段"><a href="#常见攻击手段" class="headerlink" title="常见攻击手段"></a>常见攻击手段</h3><ul><li>物理层：设备破坏、线路侦听</li><li>数据链路层：MAC欺骗、MAC泛洪、ARP欺骗</li><li>网络层：IP欺骗、Smurf攻击、ICMP攻击、地址扫描</li><li>传输层：TCP欺骗、TCP DOS、UDP DOS、端口扫描</li><li>应用层：漏洞、缓冲区溢出攻击、WEB应用攻击、病毒木马</li></ul><h4 id="物理层——物理攻击"><a href="#物理层——物理攻击" class="headerlink" title="物理层——物理攻击"></a>物理层——物理攻击</h4><ul><li>物理设备破坏：设备破坏攻击的目的主要是为了中断网络服务；</li><li>物理设备窃听：包括光纤监听和红外监听。</li><li>自然灾害：为尽量减少突发自然灾害对重要数据的破坏，常建设异地灾备数据中心。</li></ul><h4 id="数据链路层——MAC泛洪攻击"><a href="#数据链路层——MAC泛洪攻击" class="headerlink" title="数据链路层——MAC泛洪攻击"></a>数据链路层——MAC泛洪攻击</h4><p>泛洪攻击中，攻击者利用交换机中存储的MAC地址表的自动学习机制不断发送不同MAC地址给交换机，从而填满整个MAC表，此时交换机只能进行数据广播，攻击者凭此获得信息。由于交换机之间具有级联机制，故与受感交换机相连的所有交换机MAC地址表均被填满，整个网络出现数据发送缓慢、丢包甚至瘫痪的情况。可以在交换机上设置相应的端口保护机制以限制单个端口最大MAC数据接收条目数量。</p><h4 id="数据链路层——ARP欺骗"><a href="#数据链路层——ARP欺骗" class="headerlink" title="数据链路层——ARP欺骗"></a>数据链路层——ARP欺骗</h4><p>当A、B需要通讯时，A发送ARP请求询问B的MAC地址。攻击者冒充B持续发送ARP响应给A，并传递攻击者主机MAC地址，随后A发送给B的正常数据包都会被转发到攻击者主机处。</p><h4 id="网络层——ICMP攻击"><a href="#网络层——ICMP攻击" class="headerlink" title="网络层——ICMP攻击"></a>网络层——ICMP攻击</h4><p>ICMP具有多个控制报文如重定向和网络不可达等，常用于指导数据包的正确路由。</p><ul><li>ICMP重定向攻击中，攻击者主动向受害者发送ICMP重定向报文，改变受害者数据包传输路由，使其发送到不存在的网关，从而使得网关无法收到数据包，实现拒绝服务攻击。</li><li>ICMP不可达攻击中，攻击者向网关发送特定IP地址主机ICMP不可达报文，网关收到后便将受害者主机标记为不可达，从而导致受害者无法收到数据包。</li></ul><p>解决方法：通过修改注册表关闭ICMP不可达报文及重定向报文的处理功能。</p><h4 id="传输层——TCP-SYN-Flood攻击"><a href="#传输层——TCP-SYN-Flood攻击" class="headerlink" title="传输层——TCP SYN Flood攻击"></a>传输层——TCP SYN Flood攻击</h4><p>SYN报文是TCP连接的第一个报文，攻击者通过大量发送SYN报文，造成大量未完全建立的TCP连接，从而占用被攻击者的资源，以达到拒绝服务攻击的目的。</p><h4 id="应用层——DNS欺骗攻击"><a href="#应用层——DNS欺骗攻击" class="headerlink" title="应用层——DNS欺骗攻击"></a>应用层——DNS欺骗攻击</h4><p>攻击者通过篡改DNS服务器上的DNS数据破坏域名与IP地址的对应关系，当用户输入访问网站的URL后，该域名被解析成攻击者事先设置好的钓鱼网站对应的IP地址，随后用户主机会访问该IP地址进入钓鱼网站。</p><h3 id="DDoS攻击风险防护方案"><a href="#DDoS攻击风险防护方案" class="headerlink" title="DDoS攻击风险防护方案"></a>DDoS攻击风险防护方案</h3><ul><li><p>网络设备性能充裕</p><p>防火墙、路由器、交换机性能富余。</p></li><li><p>网络带宽资源充裕</p><p>保持一定比例的网络带宽余量。</p></li><li><p>异常流量清洗</p><p>通过抗D设备清洗异常流量。</p></li><li><p>通过CDN分流</p><p>多节点分担DDoS攻击流量。</p></li><li><p>分布式集群</p><p>每个节点分配足够资源数据回发瘫痪攻击源。</p></li></ul><h2 id="操作系统的脆弱性及常见攻击"><a href="#操作系统的脆弱性及常见攻击" class="headerlink" title="操作系统的脆弱性及常见攻击"></a>操作系统的脆弱性及常见攻击</h2><h3 id="操作系统漏洞分类"><a href="#操作系统漏洞分类" class="headerlink" title="操作系统漏洞分类"></a>操作系统漏洞分类</h3><ul><li>人为原因：开发者在程序代码中故意隐藏后门。</li><li>客观原因：受开发者能力、经验及当时安全技术限制，程序设计过程中存在不足之处，导致权限提升等后果。</li><li>硬件原因：编程人员无法弥补硬件自身的安全漏洞，从而使硬件问题通过软件体现。</li></ul><h3 id="缓冲区溢出攻击"><a href="#缓冲区溢出攻击" class="headerlink" title="缓冲区溢出攻击"></a>缓冲区溢出攻击</h3><p>缓冲区溢出攻击利用编写不够严谨的程序，通过向程序的缓冲区写入超过预定长度的数据，造成缓存溢出，从而破坏程序的堆栈结构，导致程序执行流程的改变，达到破坏系统或提取关键信息的目的。攻击者如果可以精确控制内存跳转地址，就可以执行指定代码，获得权限或破坏系统。</p><p><img src="/2020/07/01/信息安全概述/1.PNG" alt="缓冲区溢出.png-160.9kB"></p><p>缓冲区溢出的防范可以通过以下方面考虑：</p><ul><li>用户层面需要及时更新系统及软件补丁，并保持防火墙常开。</li><li>开发人员开发程序过程中，需要编写安全代码，对输入数据进行验证，如限制输入数据的长度。同时需要使用相对安全的函数，如C语言在字符串处理过程中提供大量安全函数，如<code>strcat_s()</code>，<code>strcpy_s()</code>，<code>gets_s()</code>等。</li><li>系统层面可以运用缓冲区不可执行技术来防止缓冲区恶意代码执行，也可以采用虚拟化技术来防止缓冲区溢出漏洞的产生。</li></ul><p>由于现阶段大量程序执行过程中均会由操作系统分配随机起始地址，故对于攻击者来说获取准确的函数返回地址并实现恶意代码执行较为困难。</p><h2 id="终端的脆弱性及常见攻击"><a href="#终端的脆弱性及常见攻击" class="headerlink" title="终端的脆弱性及常见攻击"></a>终端的脆弱性及常见攻击</h2><h3 id="勒索病毒"><a href="#勒索病毒" class="headerlink" title="勒索病毒"></a>勒索病毒</h3><p>作为一种恶意程序，勒索病毒可以感染设备、网络与数据中心并使其瘫痪，直至用户支付赎金使系统解锁。该类病毒执行过程如下：受害者主机植入勒索病毒后，病毒本身调用加密算法库解密自身数据并回连服务器，随后通过脚本文件执行HTTP GET请求并下载加密后的文件，随后在受害者主机环境中进行文件解密并将该文件封装成动态链接库，随后通过wscript执行DLL文件通过遍历系统文件的方法收集计算机信息。勒索病毒会将电脑中的各类文档进行加密，让用户无法打开，并弹窗限时勒索付款提示信息，达到勒索赎金的目的。</p><h4 id="发展阶段"><a href="#发展阶段" class="headerlink" title="发展阶段"></a>发展阶段</h4><ul><li>第一阶段：2008年以前，只锁定用户设备不加密数据，以LockScreen为代表家族。</li><li>第二阶段：2013年以前，采用高强度对称和非对称加密算法加密用户数据，以CTB-Locker、TeslaCrypt、Cerber为代表家族。</li><li><p>第三阶段：2017年前后，通过系统漏洞或弱口令等方式发起蠕虫式攻击，攻陷单点设备后还会在内网中横向扩散，以WannaCry和Satan为代表。</p></li><li><p>第四阶段：加密货币的出现改变勒索格局，加密货币具有匿名性与去中心化的特点，解决攻击者的传统问题，脱离货币交易链的追查与监管，黑色产业因此蓬勃发展。</p></li><li>第五阶段：勒索软件服务化，RaaS模式初见规模。</li></ul><h4 id="勒索病毒感染与传播方式"><a href="#勒索病毒感染与传播方式" class="headerlink" title="勒索病毒感染与传播方式"></a>勒索病毒感染与传播方式</h4><p><img src="/2020/07/01/信息安全概述/2.PNG" alt="勒索病毒感染与传播方式.png-798.9kB"></p><h4 id="勒索病毒攻击链"><a href="#勒索病毒攻击链" class="headerlink" title="勒索病毒攻击链"></a>勒索病毒攻击链</h4><p><strong>感染媒介—&gt;C&amp;C通信—&gt;文件加密—&gt;横向移动</strong></p><h4 id="高效勒索病毒协同防护体系"><a href="#高效勒索病毒协同防护体系" class="headerlink" title="高效勒索病毒协同防护体系"></a>高效勒索病毒协同防护体系</h4><p><img src="/2020/07/01/信息安全概述/3.PNG" alt="构建高效勒索病毒协同防护体系.png-1277.5kB"></p><h3 id="挖矿病毒"><a href="#挖矿病毒" class="headerlink" title="挖矿病毒"></a>挖矿病毒</h3><p>作为一种恶意程序，挖矿程序可以自动传播，在未授权的情况下占用系统资源，为攻击者牟利，使得受害者机器性能明显下降，影响正常使用。挖矿病毒占用CPU或GPU等计算资源，自动创建后门与混淆进程，同时该病毒定期改变进程名与PID并检测系统中是否存在对应的挖矿软件，若被查杀则再次从远端服务器上获取资源。同时该病毒通过扫描SSH文件感染其他机器，实现横向传播。</p><h3 id="特洛伊木马"><a href="#特洛伊木马" class="headerlink" title="特洛伊木马"></a>特洛伊木马</h3><p>完整的木马程序一般由服务器程序与控制器程序两部分组成，当受害者主机安装了木马的服务器程序后，拥有控制器程序的攻击者就可以通过网络控制受害者主机。木马程序通常注入正常程序中，当用户执行正常程序时启动。同时，木马程序自动在任务管理器中隐藏，并以”系统服务”的方式欺骗操作系统，包含具有未公开并且可能产生危险后果的功能的程序，具备自动恢复与打开特殊端口的功能。</p><h3 id="蠕虫病毒"><a href="#蠕虫病毒" class="headerlink" title="蠕虫病毒"></a>蠕虫病毒</h3><p>蠕虫是一种可以自我复制并通过网络传播的代码，通常无需人为干预即可实现传播。蠕虫病毒入侵并完全控制一台计算机后，就会把这台主机作为宿主，进而扫描并感染其他计算机。蠕虫病毒具有不依赖宿主程序、利用漏洞主动攻击、通过蠕虫网络隐藏攻击者位置的特点。该类病毒易造成拒绝服务与隐私信息丢失。</p><h3 id="宏病毒"><a href="#宏病毒" class="headerlink" title="宏病毒"></a>宏病毒</h3><p>宏病毒是一种寄存在文档或模板的宏中的计算机病毒，具有感染文档、传播速度快、病毒制作周期短、可实现多平台交叉感染的特点。宏病毒通过调用系统命令造成系统破坏，除此之外，感染宏病毒的文档无法正常打印，并具有封闭或改变文件存储路径、非法复制文件等行为。</p><h3 id="僵尸网络"><a href="#僵尸网络" class="headerlink" title="僵尸网络"></a>僵尸网络</h3><p>采用一种或多种传播手段，将大量主机感染僵尸程序，从而在控制者和被感染主机之间形成一个一对多控制网络。僵尸网络的形成过程包含<strong>加入、传播和控制</strong>三个阶段。</p><p>僵尸程序多指实现恶意控制功能的程序代码，控制服务器多指控制和通信的中心服务器。</p><h2 id="其他常见攻击"><a href="#其他常见攻击" class="headerlink" title="其他常见攻击"></a>其他常见攻击</h2><h3 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h3><p>社会工程攻击通常被认为是一种欺诈他人以收集信息、行骗和入侵计算机系统的行为，可以通过定期更换各种系统账号密码或使用高强度密码等防御该类攻击。</p><h3 id="人为因素"><a href="#人为因素" class="headerlink" title="人为因素"></a>人为因素</h3><ul><li>无意行为：如工作失误、经验问题、体制不健全等；</li><li>恶意行为：攻击者出于政治、经济、商业或个人目的制造病毒及破坏性程序，攻击企业信息系统并获取重要资料。</li><li>防范措施<ul><li>提升安全意识</li><li>最低权限访问模式</li><li>完善和落地管理措施</li><li>利用已有安全手段对核心资产进行安全保护</li></ul></li></ul><h3 id="拖库洗库撞库"><a href="#拖库洗库撞库" class="headerlink" title="拖库洗库撞库"></a>拖库洗库撞库</h3><p>拖库是指黑客入侵有价值的网络站点并将注册用户的资料数据库全部盗走的行为。</p><p>洗库指在获取大量用户数据后，黑客通过一系列的技术手段和黑色产业链将有价值的用户数据变现的行为。</p><p>撞库指黑客利用获得的私密数据在其他网站上进行登录尝试的行为。</p><h3 id="跳板攻击"><a href="#跳板攻击" class="headerlink" title="跳板攻击"></a>跳板攻击</h3><p>攻击者通常不直接通过自己的系统向目标发动攻击，而是先攻破若干中间系统并将其作为”跳板”，借助这些计算机完成攻击行动。用户可以通过安装防火墙以控制流量进出、更改系统默认登录用户为普通用户并做好权限控制等手段抵御此类攻击。</p><h3 id="钓鱼式攻击"><a href="#钓鱼式攻击" class="headerlink" title="钓鱼式攻击"></a>钓鱼式攻击</h3><p>钓鱼攻击是一种企图从电子通讯中，通过伪装成信誉卓著的法人媒体以获得如用户名、密码和信用卡明细等个人敏感信息的犯罪诈骗过程。鱼叉式钓鱼攻击指针对特定受害公司或组织的钓鱼攻击，其钓鱼页面设计与整体操作流程具有定制化、精准化的特点，成功率较高。可以通过保证网络站点与用户之间的安全传输、加强网络站点的认证过程与监管等方式防御此类攻击。</p><h3 id="水坑攻击"><a href="#水坑攻击" class="headerlink" title="水坑攻击"></a>水坑攻击</h3><p>攻击者首先通过观察或猜测确定特定目标经常访问的网站，并入侵其中一个或多个网站，植入恶意软件。当目标组织或组织中部分成员访问该类网站时会被重定向到恶意网址，导致恶意软件执行，最终造成该组织机器的大量感染。为抵御此类攻击，运维人员通常在浏览器或软件上进行安全杀毒和检测工作，若检测到恶意内容，则持续监控该网站流量并阻止恶意流量。此外，运维人员可以通过定期更新补丁的方式减少浏览器漏洞。</p><h2 id="信息安全要素"><a href="#信息安全要素" class="headerlink" title="信息安全要素"></a>信息安全要素</h2><ul><li><p>保密性Confidentiality</p><p>确保信息不暴露给未授权的实体或进程。</p></li><li><p>完整性Integrity</p><p>只有得到允许的用户才能修改实体或进程，并且能够判别出实体或进程是否被篡改。</p></li><li><p>可用性Availability</p><p>得到授权的实体可获得服务，攻击者不能占用所有资源而阻碍授权者的工作。</p></li><li><p>可控性Controllability</p><p>可控性主要指对危害国家信息（包括利用加密的非法通信活动）的监视审计。</p></li><li><p>不可否认性Non-repudiation</p><p>为出现的安全问题提供调查的依据和手段，使用审计、监控、防抵赖等安全机制使得攻击者无法否认相关操作。</p></li></ul><h2 id="安全解决方案"><a href="#安全解决方案" class="headerlink" title="安全解决方案"></a>安全解决方案</h2><h3 id="企业安全解决方案构建"><a href="#企业安全解决方案构建" class="headerlink" title="企业安全解决方案构建"></a>企业安全解决方案构建</h3><h4 id="企业信息安全建设规划目标"><a href="#企业信息安全建设规划目标" class="headerlink" title="企业信息安全建设规划目标"></a>企业信息安全建设规划目标</h4><ul><li>风险可视化Visibility</li><li>防御主动话Proactive</li><li>运行自动化Automation</li><li>安全智能化Intelligent</li></ul><h4 id="传统安全方案痛点"><a href="#传统安全方案痛点" class="headerlink" title="传统安全方案痛点"></a>传统安全方案痛点</h4><ul><li>产品堆叠为主</li><li>边界防护为主</li><li>被动防守为主</li></ul><h4 id="APDRO智安全架构"><a href="#APDRO智安全架构" class="headerlink" title="APDRO智安全架构"></a>APDRO智安全架构</h4><ul><li>智能Artificial Intelligence</li><li>防御Protect</li><li>检测Detect</li><li>响应Respond</li><li>运营Operate</li></ul><h4 id="安全域划分"><a href="#安全域划分" class="headerlink" title="安全域划分"></a>安全域划分</h4><p>将企业数据区域进行安全等级划分，分成<strong>非安全区</strong>、<strong>半安全区</strong>、<strong>安全区</strong>和<strong>核心安全区</strong>四个部分。</p><ul><li>非安全区是数据中心等关键区域与外部直接连接的区域，属于非信任区域。</li><li>半安全区是非安全区与安全区之间的过渡区域，用于分割它们之间的直接联系，隐藏安全区的内部资源。</li><li>安全区是安全级别次高的区域。</li><li>核心安全区是安全级别最高的区域。</li></ul><p>各安全域访问原则如下：</p><p><img src="/2020/07/01/信息安全概述/4.PNG" alt="安全区域划分.png-118.4kB"></p><h3 id="上网行为安全解决方案-AC"><a href="#上网行为安全解决方案-AC" class="headerlink" title="上网行为安全解决方案 AC"></a>上网行为安全解决方案 AC</h3><h4 id="上网行为可视"><a href="#上网行为可视" class="headerlink" title="上网行为可视"></a>上网行为可视</h4><ul><li>用户可视</li><li>流量&amp;应用可视</li><li>内容可视</li></ul><h4 id="上网行为可控"><a href="#上网行为可控" class="headerlink" title="上网行为可控"></a>上网行为可控</h4><ul><li>工作效率提升</li><li>流量可视可控</li><li>规避法律法规法风险</li></ul><h3 id="纵深边界安全解决方案-Firewall"><a href="#纵深边界安全解决方案-Firewall" class="headerlink" title="纵深边界安全解决方案 Firewall"></a>纵深边界安全解决方案 Firewall</h3><h4 id="精细化资产攻击面管理"><a href="#精细化资产攻击面管理" class="headerlink" title="精细化资产攻击面管理"></a>精细化资产攻击面管理</h4><ul><li>资产可视</li><li>高危端口可视</li><li>策略智能调优</li></ul><h4 id="场景化安全防护实践"><a href="#场景化安全防护实践" class="headerlink" title="场景化安全防护实践"></a>场景化安全防护实践</h4><ul><li>防黑客渗透</li><li>防内网病毒扩散</li><li>办公环境安全性&amp;连续性保障</li><li>资产失陷外连泄密防护</li></ul><h3 id="移动接入安全解决方案"><a href="#移动接入安全解决方案" class="headerlink" title="移动接入安全解决方案"></a>移动接入安全解决方案</h3><h4 id="端到端移动安全"><a href="#端到端移动安全" class="headerlink" title="端到端移动安全"></a>端到端移动安全</h4><ul><li>精确身份认证</li><li>角色授权与URL级别授权</li><li>支持1024、2028位商密或国密算法</li><li>主从账号绑定、服务器地址伪装、应用隐藏</li></ul><h4 id="创新移动终端安全"><a href="#创新移动终端安全" class="headerlink" title="创新移动终端安全"></a>创新移动终端安全</h4><ul><li>移动终端个人域与工作域隔离</li><li>防中间人攻击、客户端安全检查</li><li>SSL专线、客户端痕迹清除</li></ul><h3 id="端点安全"><a href="#端点安全" class="headerlink" title="端点安全"></a>端点安全</h3><h4 id="方案优势"><a href="#方案优势" class="headerlink" title="方案优势"></a>方案优势</h4><ul><li>支持多个操作系统</li><li>实现跨平台</li><li>集中管控</li><li>轻量级</li></ul><h4 id="加固"><a href="#加固" class="headerlink" title="加固"></a>加固</h4><p>用于业务域内部及业务域之间，基于应用策略，实现主机东西向流量访问控制。</p><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><p>全面探测服务器主机和网络上的威胁活动，进行入侵行为主动IP封堵与恶意文件隔离。</p><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><p>结合传统技术与人工智能，采用机器学习模型实现针对病毒木马、僵尸网络及暴力破解行为的检测。</p><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><p>采用IP黑白名单机制及文件隔离机制，监控进程的可疑行为，以即时拦阻恶意代码。</p><h3 id="网络安全拓扑参考"><a href="#网络安全拓扑参考" class="headerlink" title="网络安全拓扑参考"></a>网络安全拓扑参考</h3><p><img src="/2020/07/01/信息安全概述/5.PNG" alt="网络安全拓扑参考.png-1531.1kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安全背景&quot;&gt;&lt;a href=&quot;#安全背景&quot; class=&quot;headerlink&quot; title=&quot;安全背景&quot;&gt;&lt;/a&gt;安全背景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数字化时代威胁升级&lt;/li&gt;
&lt;li&gt;传统安全防护在数字化转型中逐渐失效&lt;/li&gt;
&lt;li&gt;安全风险能见度不足&lt;
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Information Security" scheme="https://blank-vax.github.io/tags/Information-Security/"/>
    
  </entry>
  
  <entry>
    <title>服务器安全检测和防御技术</title>
    <link href="https://blank-vax.github.io/2020/06/26/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%A3%80%E6%B5%8B%E5%92%8C%E9%98%B2%E5%BE%A1%E6%8A%80%E6%9C%AF/"/>
    <id>https://blank-vax.github.io/2020/06/26/服务器安全检测和防御技术/</id>
    <published>2020-06-26T02:32:00.000Z</published>
    <updated>2020-11-09T03:39:09.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DoS攻击检测与防御"><a href="#DoS攻击检测与防御" class="headerlink" title="DoS攻击检测与防御"></a>DoS攻击检测与防御</h2><h3 id="DoS攻击"><a href="#DoS攻击" class="headerlink" title="DoS攻击"></a>DoS攻击</h3><p>Denial of Service，是一种拒绝服务攻击，常用来使服务器或网络瘫痪。</p><p>Distributed Denial of Service，简称为DDoS攻击，是一种分布式拒绝服务攻击。</p><h3 id="DoS类型"><a href="#DoS类型" class="headerlink" title="DoS类型"></a>DoS类型</h3><ul><li>发送大量所属协议的数据包达到占据服务端带宽并堵塞线路的目的<ul><li>ICMP洪水攻击</li><li>UDP洪水攻击</li><li>SYN洪水攻击</li></ul></li><li>利用TCP三次握手特性，大量发起请求包以占用服务器资源，最终实现服务器资源耗尽<ul><li>SYN洪水攻击</li></ul></li><li>畸形数据包攻击<ul><li>PingofDeath</li><li>TearDrop</li></ul></li><li>CC攻击（主要用来攻击页面）</li><li>慢速攻击</li></ul><h3 id="SYN洪水防护"><a href="#SYN洪水防护" class="headerlink" title="SYN洪水防护"></a>SYN洪水防护</h3><h4 id="每目的IP激活阈值"><a href="#每目的IP激活阈值" class="headerlink" title="每目的IP激活阈值"></a>每目的IP激活阈值</h4><p>每目的IP激活阈值指当针对策略设置的目的IP组内某IP发起的SYN请求速率数据包超过设定值，则触发AF的SYN代理功能。</p><h4 id="每目的IP丢包阈值"><a href="#每目的IP丢包阈值" class="headerlink" title="每目的IP丢包阈值"></a>每目的IP丢包阈值</h4><p>每目的IP丢包阈值指当针对策略设置的目的IP组内某IP发起的SYN请求速率数据包超过设定值，则AF不再启用SYN代理，直接丢弃SYN包。</p><h2 id="漏洞攻击防护入侵检测与防御"><a href="#漏洞攻击防护入侵检测与防御" class="headerlink" title="漏洞攻击防护入侵检测与防御"></a>漏洞攻击防护入侵检测与防御</h2><h3 id="IDS"><a href="#IDS" class="headerlink" title="IDS"></a>IDS</h3><p>Intrusion Detection Systems，即入侵检测系统，对网络、系统的运行状况进行监视，尽可能发现各种攻击企图、攻击行为或攻击结果。通过旁路镜像模式部署，多用于被动检测。</p><h3 id="IPS"><a href="#IPS" class="headerlink" title="IPS"></a>IPS</h3><p>Intrusion Prevention Systems，即入侵防御系统，可对网络、系统的运行状况进行监视，并可发现阻止各种攻击企图、攻击行为。通过路由模式、透明模式及并联模式部署，多用于主动检测。</p><h3 id="常见漏洞攻击手段"><a href="#常见漏洞攻击手段" class="headerlink" title="常见漏洞攻击手段"></a>常见漏洞攻击手段</h3><h4 id="Worm蠕虫"><a href="#Worm蠕虫" class="headerlink" title="Worm蠕虫"></a>Worm蠕虫</h4><p><img src="http://static.zybuluo.com/B1ank/cd1w8ekz3l3d1zdqn5flqy5x/worm%E8%A0%95%E8%99%AB.png" alt="worm蠕虫.png-291.6kB"></p><h4 id="口令暴力破解"><a href="#口令暴力破解" class="headerlink" title="口令暴力破解"></a>口令暴力破解</h4><p>常见的暴力破解方法包括<strong>字典法</strong>与<strong>规则破解法</strong>。</p><ul><li>字典法：黑客通过各种手段获取一些网络用户经常使用的弱密码，集合在一起形成文本文件，并使用该文件进行口令爆破。</li><li>规则破解法：通过账户相关信息或用户个人信息进行破解。</li></ul><h3 id="漏洞攻击防护原理"><a href="#漏洞攻击防护原理" class="headerlink" title="漏洞攻击防护原理"></a>漏洞攻击防护原理</h3><p>漏洞攻击防护通过对数据包应用层里的数据内容进行威胁特征检查，并与漏洞攻击防护规则库进行比对，如果匹配则拒绝该数据包，从而实现应用层漏洞攻击的防护。</p><h3 id="误判处置"><a href="#误判处置" class="headerlink" title="误判处置"></a>误判处置</h3><ul><li>配置漏洞攻击防护规则时，在漏洞攻击防护日志中勾选”记录”。</li><li>根据数据中心的日志，查询到误判规则的漏洞ID。</li><li>【对象】-【安全防护规则库】-【安全规则库】-漏洞特征识别库中，修改相应漏洞ID的动作。</li><li>白名单添加例外。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>配置漏洞攻击防护保护客户端和服务器时，源区域为数据连接发起的区域。</li><li>漏洞攻击防护保护客户端与保护服务器中的客户端漏洞和服务器漏洞规则是不同的。</li></ul><h2 id="Web攻击检测与防御"><a href="#Web攻击检测与防御" class="headerlink" title="Web攻击检测与防御"></a>Web攻击检测与防御</h2><h3 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h3><p>Web Application Firewall，即Web应用防护，主要用于保护Web服务器不受攻击，而导致软件服务中断或被远程控制。WAF常见攻击手段包括：</p><ul><li>SQL注入</li><li>XSS攻击</li><li>网页木马</li><li>网站扫描</li><li>WEBSHELL</li><li>跨站请求伪造</li><li>系统命令注入</li><li>文件包含攻击</li><li>目录遍历攻击</li><li>信息泄漏攻击</li></ul><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>通过将SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意SQL命令的目的。</p><h4 id="GET与POST请求"><a href="#GET与POST请求" class="headerlink" title="GET与POST请求"></a>GET与POST请求</h4><p>GET请求提交的内容经过URL编码直接在URL栏中显示。</p><p>POST提交的内容不会直接显示在URL部分，而是呈现在POST包的DATA字段中。</p><h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><p>Cross Site Request Fogery，即跨站请求伪造，攻击者盗用受害用户的身份，以其名义发送恶意请求，对服务器来说这个请求是合法的，但完成了攻击者所期望的操作，如以受害用户的名义发送邮件和信息，盗取账号，添加系统管理员等非法操作。</p><h3 id="误判处置-1"><a href="#误判处置-1" class="headerlink" title="误判处置"></a>误判处置</h3><ul><li><p>在【策略】-【安全策略】-【安全防护策略】-【高级设置】中新增URL参数排除后，Web应用防护的网站攻击检测将跳过这些参数的检查。主要用于正常业务下某些请求参数因携带特征串而被检测为攻击的情况，可以只针对这类参数进行排除。</p></li><li><p>在【内置数据中心】-【日志查询】-【WEB应用防护】中查询日志，找出误判日志然后点击日志后面的”添加例外”。</p></li></ul><h2 id="联动封锁技术"><a href="#联动封锁技术" class="headerlink" title="联动封锁技术"></a>联动封锁技术</h2><h3 id="联动封锁类型"><a href="#联动封锁类型" class="headerlink" title="联动封锁类型"></a>联动封锁类型</h3><p>高危行为联动封锁：仅封锁具有高危行为特征的IP，优先保证用户流畅上网、业务稳定；</p><p>任意攻击行为联动封锁：对任意具有攻击特征的IP执行访问封锁，最大化业务和用户的安全防御能力。</p><h3 id="联动封锁机制"><a href="#联动封锁机制" class="headerlink" title="联动封锁机制"></a>联动封锁机制</h3><ul><li>高危行为联动封锁功能仅关联。</li><li>任意攻击行为联动功能关联。</li><li>策略触发的联动封锁是针对数据包的会话五元组进行拦截。</li></ul><h2 id="网页防篡改技术"><a href="#网页防篡改技术" class="headerlink" title="网页防篡改技术"></a>网页防篡改技术</h2><p>深信服网页防篡改解决方案采用<strong>文件保护系统+下一代防火墙</strong>紧密结合，<strong>文件监控+二次认证</strong>功能紧密联动，保证网站内容不被篡改，其中文件保护系统采用业界防篡改技术中最先进的文件过滤驱动技术。</p><h3 id="管理员认证流程"><a href="#管理员认证流程" class="headerlink" title="管理员认证流程"></a>管理员认证流程</h3><p><img src="http://static.zybuluo.com/B1ank/3y4y65j05h0g5asinforhet8/%E7%BD%91%E9%A1%B5%E9%98%B2%E7%AF%A1%E6%94%B9.png" alt="网页防篡改.png-328.4kB"></p><ul><li>访问网站后台</li><li>AF重定向提交管理员邮箱地址的认证页面</li><li>提交接收验证码的管理员邮箱</li><li>发送带有验证码的邮件至上述管理员邮箱</li><li>管理员登录邮箱获取验证码</li><li>管理员提交验证码通过认证</li><li>通过验证后自动跳转到后台页面</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>防篡改客户端必须连接防火墙并匹配防篡改策略后才会生效，防篡改客户端生效后，即使防火墙不在线，功能依然生效。</li><li>若网站本身有webshell未删除，则防篡改客户端无法拦截webshell的文件篡改行为。</li><li>Windows系统中，防篡改客户端无法通过控制面板-卸载程序进行卸载，需要使用安装目录中的<code>tamper.exe</code>进行卸载，卸载时需要输入客户端密码。</li><li>Linux系统中，针对防篡改功能开启前已经建立的会话或连接，防篡改功能不会生效。</li><li>Linux系统中，已经被防篡改保护的会话或连接在防篡改进程停止的情况下依然会生效。</li><li>Linux系统中，开启防篡改的服务器，如果需要完全消除防篡改的影响，则需要先卸载防篡改程序后重启所有服务或直接重启服务器。</li><li>Linux系统中，Agent自身存在bypass机制，当服务器内存系统资源超过70%时，功能可以生效但无法向AF同步安全日志。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DoS攻击检测与防御&quot;&gt;&lt;a href=&quot;#DoS攻击检测与防御&quot; class=&quot;headerlink&quot; title=&quot;DoS攻击检测与防御&quot;&gt;&lt;/a&gt;DoS攻击检测与防御&lt;/h2&gt;&lt;h3 id=&quot;DoS攻击&quot;&gt;&lt;a href=&quot;#DoS攻击&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Server Security" scheme="https://blank-vax.github.io/tags/Server-Security/"/>
    
  </entry>
  
  <entry>
    <title>数字证书</title>
    <link href="https://blank-vax.github.io/2020/06/21/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"/>
    <id>https://blank-vax.github.io/2020/06/21/数字证书/</id>
    <published>2020-06-21T10:13:00.000Z</published>
    <updated>2020-11-09T03:38:52.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h2><h3 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h3><ul><li>对称加密过程中，Alice和Bob使用相同的密钥进行数据加密</li><li>非对称加密过程中，密钥由（公钥，私钥）密钥对构成。<ul><li><strong>非对称密钥加解密</strong>：Alice与Bob通信过程中，Alice首先在公开信道上发送公钥。Bob使用Alice的公钥加密信息，随后Alice使用自己的私钥进行解密。</li><li><strong>非对称密钥签名</strong>：Alice使用私钥加密签名消息，Bob使用Alice的公钥对签名进行相关验证，以确认Alice的身份。</li></ul></li></ul><h3 id="特点及应用场景"><a href="#特点及应用场景" class="headerlink" title="特点及应用场景"></a>特点及应用场景</h3><p>由于对称加密具有更快的数据传输速度，而非对称加密具有更高的安全性，故实际应用过程中常常通过非对称加密的公钥对对称加密的密钥进行加密处理，随后接收方使用私钥进行解密，至此双方实现密钥共享。之后二者便可以用相同的对称加密密钥实现对大量数据的对称加解密过程。</p><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>数字证书（Digital Certificate or Public Key Certificate）指在互联网通讯中标志通讯各方身份信息的数字认证，在网络中使用其识别对方身份，本质上是一种身份证明电子文档。</p><p>证书授权中心CA（Certificate Authority）负责发放和管理数字证书，具有足够的权威性。</p><h3 id="证书分类"><a href="#证书分类" class="headerlink" title="证书分类"></a>证书分类</h3><p>按照持有者可分为个人证书、单位证书及系统证书。</p><p>按照证书用途可分为签名证书及加密证书，具体区别如下：</p><ul><li>签名证书用于签名和验证签名，为确保密钥安全，一般在客户端产生和保存密钥对。</li><li>加密证书用于加密，密钥对由CA产生，通过保护算法和协议发送给用户使用，同时CA中心对该密钥进行备份处理。</li></ul><h3 id="证书格式"><a href="#证书格式" class="headerlink" title="证书格式"></a>证书格式</h3><p>证书具有PEM和DER两种编码格式，其中PEM采用Base64编码字符保存，而DER格式采用二进制保存。</p><p>一张证书包含非对称加密密钥对，通常用.crt后缀标识公钥，用.key后缀标识私钥。还有一种将公钥与私钥捆绑保存的方法，其后缀通常为.pfx或.p12。</p><h3 id="证书内容"><a href="#证书内容" class="headerlink" title="证书内容"></a>证书内容</h3><p>证书公钥除保存公钥内容外，通常包含颁发者、使用者、有效期和签名等信息。</p><p>证书私钥中包含公钥信息以及所有非对称加密算法的参数。</p><h3 id="证书信任链"><a href="#证书信任链" class="headerlink" title="证书信任链"></a>证书信任链</h3><ul><li>CA：数字证书认证中心的简称。</li><li>根CA：处在信任链的顶端，其证书公钥默认导入各种操作系统和浏览器中。</li><li>中级CA：处于信任链的中部，由根CA或其他中级CA颁发的证书，本身还可以继续颁发子证书。</li><li><p>个人证书：处在信任链末端，由中级CA或根CA颁发的证书。</p></li><li><p>证书之间的信任关系可以嵌套。只要信任链上的头部证书，则后续证书均可信任。证书链的存在作用为降低中级CA私钥泄露造成的影响。</p></li></ul><p><img src="http://static.zybuluo.com/B1ank/td398udjr4yvi1054ybyl3wg/CA%E9%93%BE.png" alt="CA链.png-189.8kB"></p><h3 id="证书吊销列表"><a href="#证书吊销列表" class="headerlink" title="证书吊销列表"></a>证书吊销列表</h3><p>为防止证书持有者泄露证书私钥造成的身份冒用，各CA都维护一张CRL列表，内部标记虽处于有效期内但无法正常使用的证书。</p><h3 id="证书工作原理"><a href="#证书工作原理" class="headerlink" title="证书工作原理"></a>证书工作原理</h3><h4 id="数字证书生成"><a href="#数字证书生成" class="headerlink" title="数字证书生成"></a>数字证书生成</h4><p>服务器给客户端发送公钥的过程中，将公钥与服务器的个人信息通过哈希算法生成消息摘要。为防止摘要被人调换，服务器还会用CA提供的私钥对消息摘要进行加密，从而形成数字签名。最后服务器将未经哈希处理的信息与数字签名合并在一起形成数字证书。</p><p><img src="http://static.zybuluo.com/B1ank/6oq68hu6r9u1u5q3sepxub6y/certificate_generation.png" alt="certificate_generation.png-47.7kB"></p><h4 id="数字证书验证"><a href="#数字证书验证" class="headerlink" title="数字证书验证"></a>数字证书验证</h4><p>客户端收到数字证书后，使用CA提供的公钥对数字证书内部的数字签名进行解密得到消息摘要，随后对数字证书内部服务器的公钥和个人信息进行哈希计算以获取另外一份消息摘要。对比这两份摘要，若吻合则通过服务器身份验证，否则不通过验证。</p><p><img src="http://static.zybuluo.com/B1ank/hru2f9uxqjlulau1qtwurf3j/certificate_verification.png" alt="certificate_verification.png-108.7kB"></p><h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><p>SSL（Secure Sockets Layer，安全套接层）是HTTPS下的协议加密层，建立在可靠的传输协议上，为高层协议提供数据封装、压缩、加密等基本功能，主要分为以下两层：</p><h4 id="SSL记录协议层"><a href="#SSL记录协议层" class="headerlink" title="SSL记录协议层"></a>SSL记录协议层</h4><p>SSL记录协议层为高层协议提供基本的安全服务，记录封装各种高层协议，具体实施压缩解压缩、加密解密、计算和校验MAC等与安全有关的操作。</p><h4 id="SSL握手协议层"><a href="#SSL握手协议层" class="headerlink" title="SSL握手协议层"></a>SSL握手协议层</h4><p>SSL握手协议层包括SSL握手协议（SSL HandShake Protocol）、SSL密码参数修改协议（SSL Change Cipher Spec Protocol）、应用数据协议（Application Data Protocol）和SSL告警协议（SSL Alert Protocol）。这些协议用于SSL管理信息的交换，允许应用协议传送数据之前相互验证，执行协商加密算法和生成密钥等操作，以建立同步状态。</p><h4 id="SSL单向认证过程"><a href="#SSL单向认证过程" class="headerlink" title="SSL单向认证过程"></a>SSL单向认证过程</h4><p><img src="http://static.zybuluo.com/B1ank/exmuhynb7xl7tt7n8qirtmc4/SSL%E5%8D%95%E5%90%91%E8%AE%A4%E8%AF%81.png" alt="SSL单向认证.png-260kB"></p><p>单向认证过程中只进行客户端对服务器的认证。客户端首先向服务器发送<code>Client Hello</code>数据包，包含随机数A以及可供选择的加密套件与加密算法参数。服务器收到后回复<code>Server Hello</code>数据包，包含随机数B及服务器选择的加密套件，随后回复证书链并完成服务器数据发送。客户端收到后验证服务器证书链并发送使用服务器公钥加密后的随机数C，服务器端使用私钥对客户端发送信息进行解密以获取随机数C。至此双方均获得随机数A、B、C，使用这三个随机数并结合服务器选择的加密套件，对数据流进行对称加密，实现安全传输。</p><h4 id="SSL双向认证过程"><a href="#SSL双向认证过程" class="headerlink" title="SSL双向认证过程"></a>SSL双向认证过程</h4><p><img src="http://static.zybuluo.com/B1ank/s7e55r8ztxga58iz3er1qqrt/SSL%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81.png" alt="SSL双向认证.png-325.8kB"></p><p>与单向认证相比，双向认证过程中除进行客户端对服务器证书链的验证外，还包含服务器对客户端的证书链验证操作，从而实现双向安全认证。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;密码学基础&quot;&gt;&lt;a href=&quot;#密码学基础&quot; class=&quot;headerlink&quot; title=&quot;密码学基础&quot;&gt;&lt;/a&gt;密码学基础&lt;/h2&gt;&lt;h3 id=&quot;对称加密与非对称加密&quot;&gt;&lt;a href=&quot;#对称加密与非对称加密&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Digital Certificate" scheme="https://blank-vax.github.io/tags/Digital-Certificate/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础及常用命令</title>
    <link href="https://blank-vax.github.io/2020/06/17/Linux%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://blank-vax.github.io/2020/06/17/Linux基础及常用命令/</id>
    <published>2020-06-17T01:25:00.000Z</published>
    <updated>2021-07-07T07:52:57.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux系统基础"><a href="#Linux系统基础" class="headerlink" title="Linux系统基础"></a>Linux系统基础</h2><p>Linux系统是一个类Unix操作系统，设计初衷为替代Unix系统。系统命令实际上是一个在用户编程接口上的可执行程序，内部引用API来实现相应的功能。</p><p>与Windows系统不同，Linux系统中所有部件（包括硬件）均使用文件保存，且不存在多个并列驱动器盘符，即不存在多个并列根目录，而是所有目录均在同一根目录下。Windows系统使用扩展名区分文件，而Linux系统中不存在扩展名概念，为方便区分使用部分扩展。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul><li><strong>/bin</strong>：存放二进制可执行文件，常用命令一般存放在此处。</li><li><strong>/etc</strong>：存放系统管理和配置文件。</li><li><strong>/home</strong>：存放所有用户文件的根目录，是用户主目录的基点，可使用<code>~</code>表示。</li><li><strong>/usr</strong>：用于存放系统应用程序，比较重要的目录<code>/usr/local</code>是本地系统管理员软件安装目录，用于存放系统级应用。</li><li><strong>/opt</strong>：额外安装的可选应用程序包存放的位置。</li><li><strong>/proc</strong>：此目录的数据如系统核心、外部设备、网络状态等均存放于内存中，不占用磁盘空间。较为重要的目录有：<code>/proc/cpuinfo</code>，<code>/proc/interrupts</code>，<code>/proc/dma</code>，<code>/proc/net/*</code>等。</li><li><strong>/root</strong>：系统管理员root的家目录。</li><li><strong>/sbin、/usr/sbin、/usr/local/sbin</strong>：放置系统管理员使用的可执行命令，如<code>fdsk</code>、<code>shutdown</code>、<code>mount</code>等。由于这些目录存放root用户可使用的命令，故一般用户只能查看而无法设置和使用。</li><li><strong>/tmp</strong>：一般用户或正在执行的程序临时存放文件的目录，任何人均可访问。</li><li><strong>/var</strong>：放置系统执行过程中经常变化的文件，如随时更改的日志文件<code>/var/log</code>，所有登录文件存放目录<code>/var/log/message</code>，邮件存放目录<code>/var/spool/mail</code>，程序或服务启动后PID存放目录<code>/var/run</code>。</li></ul><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="命令基础知识"><a href="#命令基础知识" class="headerlink" title="命令基础知识"></a>命令基础知识</h4><ul><li>Linux系统命令区分大小写，而Windows系统命令对大小写不敏感</li><li>Tab补全</li></ul><h4 id="进出目录命令-cd"><a href="#进出目录命令-cd" class="headerlink" title="进出目录命令 cd"></a>进出目录命令 cd</h4><ul><li><code>.</code>代表当前目录，<code>..</code>代表父目录，<code>~</code>代表用户的个人主目录。</li><li>常用选项<ul><li><code>cd ~</code>：进入当前用户主目录</li><li><code>cd -</code>：返回进入此目录之前所在的目录</li><li><code>cd !$</code>：将上个命令的参数作为cd参数使用</li></ul></li></ul><h4 id="查看目录信息-ls"><a href="#查看目录信息-ls" class="headerlink" title="查看目录信息 ls"></a>查看目录信息 ls</h4><p>ls命令列出文件或目录信息，常用参数如下：</p><ul><li>-a：显示包含以”.”开头的隐藏文件。</li><li>-A：显示指定目录下所有的子目录及文件，包括隐藏文件，但不显示”.”和”..”。</li><li>-c：按文件的修改时间排序。</li><li>-C：分成多列显示各行。</li><li>-d：如果参数为目录，只显示其名称而不显示其下的各个文件。</li><li>-l：以长格形式显示文件的详细信息</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="查看文件命令"><a href="#查看文件命令" class="headerlink" title="查看文件命令"></a>查看文件命令</h3><h4 id="Linux系统文件概述"><a href="#Linux系统文件概述" class="headerlink" title="Linux系统文件概述"></a>Linux系统文件概述</h4><p><img src="/2020/06/17/Linux基础及常用命令/1.png" alt="文件系统.png-570.2kB"></p><h4 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h4><p>该命令主要用于滚屏显示文件内容。常用选项参数如下：</p><ul><li><code>-b</code>：对输出内容中的非空行标注行号。</li><li><code>-n</code>：对输出内容中的所有行标注行号。</li></ul><h4 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h4><p>使用more命令可以实现分屏显示文件内容。按下【Enter】键可以向下移动一行，按下【Space】键可以向下移动一页，按【q】键可以退出more命令。常用选项参数如下：</p><ul><li><code>-num</code>：用来指定分页显示时每页的行数。</li><li><code>+num</code>：指定从文件的第num行开始显示。</li></ul><h4 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h4><p>作为more命令的改进版，具有更加强大的功能， 可以实现向上向下翻页以及前后左右移动。</p><p>进入less状态后可执行以下操作：</p><ul><li>按【Enter】键向下移动一行</li><li>按【Space】键向下移动一页</li><li>按【b】键向上移动一页</li><li>使用光标键向前后左右移动</li><li>按【q】键退出less命令</li><li>按下【/】后输入待查找的单词可实现快速查找</li></ul><h4 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h4><p>该命令用于显示文件的开头部分，默认情况下只显示前10行的内容。常用选项参数如下：</p><ul><li><code>-n num</code>：显示指定文件的前num行</li><li><code>-c num</code>：显示指定文件的前num个字符</li></ul><h4 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h4><p>该命令用于显示文件的末尾部分，默认情况下只显示文件的末尾10行内容。常用选项参数如下：</p><ul><li><code>-n num</code>：显示指定文件的末尾num行</li><li><code>-c num</code>：显示指定文件的末尾num个字符</li><li><code>+num</code>：从第num行开始显示指定文件的内容</li></ul><h3 id="查找文件或目录命令"><a href="#查找文件或目录命令" class="headerlink" title="查找文件或目录命令"></a>查找文件或目录命令</h3><h4 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h4><p>find命令支持多种查找模式匹配，具有强大的查找功能。语法为<code>find path [parameter]</code>。常用选项参数如下：</p><ul><li><p><code>-name &lt;表达式&gt;</code>：根据文件名查找文件</p></li><li><p><code>-user &lt;用户名&gt;</code>：按归属用户查找文件</p></li><li><p><code>-type &lt;文件类型&gt;</code>：根据文件类型查找文件（b块设备、c字符设备、d目录、p管道文件、f普通文件、l链接、s端口文件）</p></li><li><p><code>-size &lt;大小&gt;</code>：根据文件大小进行查找</p></li><li><code>|xargs tar cvzf &lt;文件名&gt;</code>：将查询结果压缩</li></ul><h4 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h4><p>grep命令用于查找文件中包含指定字符串的行。语法为<code>grep [parameter] aimed_string filename</code>。常用选项参数如下：</p><ul><li><code>-v</code>：列出不匹配的行</li><li><code>-c</code>：对匹配的行计数</li><li><code>-l</code>：只显示包含匹配模式的文件名</li><li><code>-h</code>：抑制包含匹配模式的文件名的显示</li><li><code>-n</code>：每个匹配行只按照相对行号显示</li><li><code>-i</code>：匹配模式不区分大小写</li></ul><h4 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h4><p>该命令主要用于文件或目录的复制。常用选项参数如下：</p><ul><li><code>-f</code>：如果目标文件或目录存在，则执行覆盖操作，并且不进行用户提示。</li><li><code>-i</code>：如果目标文件或目录存在，提示是否覆盖已有文件。</li><li><code>-R</code>：递归复制目录，即包含目录下的各级子目录。</li></ul><h4 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h4><p>在不同目录之间进行操作，则该命令用于文件或目录的移动。在相同目录之间进行操作，则该命令用于文件或目录的改名。常用选项参数如下：</p><ul><li><code>-i</code>：如果目标文件或目录存在，提示是否覆盖。</li><li><code>-f</code>：无论目标文件或目录是否存在，均直接覆盖并不进行提示。</li></ul><h4 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h4><p>该命令主要用来查看文件系统各个分区的占用情况。命令列出系统上所有已挂载的分区大小、已占用的空间、可用空间以及占有率。</p><h4 id="du命令"><a href="#du命令" class="headerlink" title="du命令"></a>du命令</h4><p>该命令主要用来查看某个目录中的各级子目录所使用的硬盘空间数。常用选项参数如下：</p><ul><li><code>-a</code>：显示目录中个别文件的大小。</li><li><code>-c</code>：除显示个别目录或文件大小外，同时显示所有目录或文件的总和。</li><li><code>-k</code>/<code>-m</code>：以KB/MB为单位输出结果。</li><li><code>-s</code>：仅显示总计。</li><li><code>-h</code>：以K，M，G为单位，提高信息的可读性。</li><li><code>--max-depth=k</code>：显示k级目录的情况。</li></ul><h3 id="常用Linux命令及作用"><a href="#常用Linux命令及作用" class="headerlink" title="常用Linux命令及作用"></a>常用Linux命令及作用</h3><h4 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h4><p>该命令常用来测试与目标主机的连通性。通过发送ICMP ECHO_REQUEST数据包到网络主机并显示响应情况来判断连通状态。常用选项参数如下：</p><ul><li><code>-c packet_number</code>：在发送指定数目的数据包后停止。</li><li><code>-s byte_number</code>：指定发送的数据字节数，预设值为56，加上8字节ICMP头共构成64字节ICMP数据。一般设定为千数量级来探测大包的发送能力。</li><li><code>-i time</code>：设定间隔几秒发送一个网络封包给一台机器，预设值为1s。</li><li><code>-t TTL</code>：设置存活数值TTL的大小。</li></ul><h4 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h4><p>该命令用来配置或查看网卡接口。单独使用ifconfig时，只显示激活状态的网络设备信息。常用参数选项如下：</p><ul><li><code>up</code>：启动指定网络设备/网卡。</li><li><code>down</code>：关闭指定网络设备/网卡。只起到临时阻止指定接口IP信息流的作用，若需永久关闭则需要从核心路由表中删除接口全部信息。</li><li><code>-a</code>：显示全部接口信息。</li><li><code>-s</code>：显示摘要信息。</li><li><code>add</code>：给指定网卡配置IP。</li><li><code>del</code>：删除指定网卡地址。</li></ul><h4 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>该命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat作为在内核中访问网络及相关信息的程序，提供TCP连接，TCP和UDP监听，进程内存管理的相关报告等功能。常用参数选项如下：</p><ul><li><code>-a</code>：显示所有连线中的socket。</li><li><code>-n</code>：不通过域名服务器直接使用IP地址。</li><li><code>-t</code>/<code>-u</code>：显示TCP/UDP传输协议的连线状况。</li><li><code>-p</code>：显示正在使用socket的程序识别码和程序名称。</li><li><code>-c</code>：持续列出网络状态。</li></ul><h4 id="route命令"><a href="#route命令" class="headerlink" title="route命令"></a>route命令</h4><p>该命令用于显示和操作IP路由表。常用参数选项如下：</p><ul><li><code>add</code>/<code>del</code>：添加/删除一条路由规则。</li><li><code>-net</code>/<code>-host</code>：目的地址是一个网络/主机。</li><li><code>target</code>：目的网络或主机。</li><li><code>netmask</code>：目的地址网络掩码。</li><li><code>gw</code>：指定路由数据包通过的网关。</li><li><code>dev</code>：为路由指定的网络接口。</li></ul><h4 id="tcpdump命令"><a href="#tcpdump命令" class="headerlink" title="tcpdump命令"></a>tcpdump命令</h4><p>该命令将网络中传输的数据包报头信息完全截获以供分析，支持针对网络层、协议、主机、网络或端口的过滤，提供and、or、not等连接词用以构建完整过滤逻辑。常用参数选项如下：</p><ul><li><code>-i</code>：指定监听的网络接口。</li><li><code>-v</code>：输出稍微详细的报文信息。</li><li><code>-vv</code>：输出详细报文信息。</li><li><code>-c</code>：指定数据包数量，收到该数量的数据包后，tcpdump停止。</li><li><code>-e</code>：在输出行打印出数据链路层的头部信息，包括源mac和目的mac，以及网络层协议。</li><li><code>-f</code>：将外部的Internet地址以数字的形式打印出来。</li><li><code>-w</code>：直接将包写入文件，不进行分析和打印。</li><li><code>-X</code>：将原始协议头和包内容显示出来（默认以十六进制和ASCII形式显示）。</li></ul><h4 id="iptables命令"><a href="#iptables命令" class="headerlink" title="iptables命令"></a>iptables命令</h4><p>iptables服务不是真正的防火墙，只作为用来定义防火墙规则功能的管理工具，其将定义好的规则交由内核中的netfilter即网络过滤器进行读取，从而实现防火墙功能。我们经常使用以下两条命令：</p><ul><li><code>iptables -L -n</code>：显示当前所有防火墙过滤规则。</li><li><code>service iptables stop</code>：关闭防火墙过滤规则，实现全连通。</li></ul><h4 id="iperf命令"><a href="#iperf命令" class="headerlink" title="iperf命令"></a>iperf命令</h4><p>iperf作为网络性能测试工具，可以测试最大TCP和UDP的带宽性能，具有多种参数和UDP特性，可以根据需要进行调整，多用以报告带宽、延迟抖动和数据包丢失。该命令结合C/S架构进行使用。</p><h4 id="ethtool命令"><a href="#ethtool命令" class="headerlink" title="ethtool命令"></a>ethtool命令</h4><p>该命令用于查询及设置网卡参数。常用选项：</p><ul><li><code>ethtool -i ethX</code>：查询ethX网口的相关信息。</li><li><code>ethtool -d ethX</code>：查询ethX网口注册性信息。</li><li><code>ethtool -r ethX</code>：重置ethX网口到自适应模式。</li><li><code>ethtool -S ethX</code>：查询ethX网口收发包统计。</li><li><code>ethtool -s ethX [speed 10|100|1000]</code>：设置网口速率为10/100/1000M。</li></ul><h4 id="telnet命令"><a href="#telnet命令" class="headerlink" title="telnet命令"></a>telnet命令</h4><p>该命令通常由于远程登录，还可用于确定远程服务的状态即某个端口是否开放访问。但由于telnet协议报文采用明文传输，故安全性较差，Linux系统中telnet服务多被ssh取代。</p><h4 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h4><p>该命令主要用来查看系统内存和虚拟机内存的大小及占用情况。常用选项参数如下：</p><ul><li><code>-b</code>/<code>-k</code>/<code>-m</code>/<code>-g</code>：以Byte/KB/MB/GB为单位显示内存使用情况。</li><li><code>-s &lt;gap seconds&gt;</code>：持续观察内存使用状况。</li><li><code>-t</code>：显示内存总和列。</li></ul><h4 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h4><p>该命令主要用于查看系统的进程。常用以下参数选项：</p><ul><li><code>-a</code>：显示当前控制终端的进程。</li><li><code>-u</code>：显示进程的用户名和启动时间等信息。</li><li><code>-x</code>：显示没有控制终端的进程。</li></ul><h4 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h4><p>前台进程运行时，可以使用【Ctrl+C】的组合来终止它，后台进程则使用kill命令向进程发送强制终止信号，以达到终止进程的目的。</p><h4 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h4><p>该命令用于实时监控进程的状况，默认5s刷新一次，可以使用<code>top -d time</code>设定top屏幕刷新的时间间隔。</p><p><img src="/2020/06/17/Linux基础及常用命令/2.png" alt="top演示.PNG-88.3kB"></p><h4 id="关机命令"><a href="#关机命令" class="headerlink" title="关机命令"></a>关机命令</h4><ul><li>shutdown <ul><li><code>shutdown -h</code>：关闭计算机。</li><li><code>shutdown -r</code>：重新启动。</li></ul></li><li>reboot == <code>shutdown -r now</code></li><li>poweroff == <code>shutdown -h now</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux系统基础&quot;&gt;&lt;a href=&quot;#Linux系统基础&quot; class=&quot;headerlink&quot; title=&quot;Linux系统基础&quot;&gt;&lt;/a&gt;Linux系统基础&lt;/h2&gt;&lt;p&gt;Linux系统是一个类Unix操作系统，设计初衷为替代Unix系统。系统命令实际上是
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="Linux Foundation" scheme="https://blank-vax.github.io/tags/Linux-Foundation/"/>
    
  </entry>
  
  <entry>
    <title>LDAP协议及AD域</title>
    <link href="https://blank-vax.github.io/2020/06/13/LDAP%E5%8D%8F%E8%AE%AE%E5%8F%8AAD%E5%9F%9F/"/>
    <id>https://blank-vax.github.io/2020/06/13/LDAP协议及AD域/</id>
    <published>2020-06-12T17:29:00.000Z</published>
    <updated>2021-07-07T07:17:08.036Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LDAP协议"><a href="#LDAP协议" class="headerlink" title="LDAP协议"></a>LDAP协议</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ul><li>集中管理，更易维护和优化，降低运维成本的需求。</li><li>实现使用PUSH和PULL的方法复制部分或全部数据的需求。</li><li><p>使用者根据需要使用ACL控制数据的读写权限的需求。</p></li><li><p>数据从不同地点读取但无需经常更新的需求。</p></li></ul><h3 id="LDAP概述"><a href="#LDAP概述" class="headerlink" title="LDAP概述"></a>LDAP概述</h3><p><strong>Light Access Protocol</strong>，即轻量级目录访问协议。与目录访问协议X.500相比，LDAP略去X.500中许多不常使用的功能，以TCP/IP协议为基础，使用389端口进行数据传输。LDAP只是一个协议。</p><p>与数据库类似，目录服务引入键—值类型格式存储、整理及表达数据。与数据库不同的是，目录服务专门进行了读优化设计，采用树状结构组织数据，面向<strong>查找、搜索及读取操作</strong>做出优化。目录服务具有优异的读性能，而写性能较差，并且没有事务处理、回滚等复杂功能，不适用于存储修改频繁的数据。</p><h3 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h3><p><img src="/2020/06/13/LDAP协议及AD域/1.PNG" alt="20181110215227340.png-27.2kB"></p><h4 id="常见描述——以果园中的苹果为例"><a href="#常见描述——以果园中的苹果为例" class="headerlink" title="常见描述——以果园中的苹果为例"></a>常见描述——以果园中的苹果为例</h4><blockquote><p>假设你需要树上的一个苹果（一条记录），如何向园丁准确描述它的位置呢？首先需要说明它存在于哪棵树上（dc，相当于MYSQL的DB），然后说明从树根到那个苹果所在位置经过的所有树杈（ou），最后就是这个苹果的名字（uid，相当于MYSQL表主键id）。例如，LDAP的具体位置记录如下：</p><ul><li>树（dc=ljheeee）</li><li>分叉（ou=bei，ou=xi，ou=dong）</li><li>苹果（cn=honglv）</li></ul><p>至此，honglvApple的位置可以表示为：<code>dn：cn=honglv，ou=bei，ou=xi，ou=dong，dcljheee</code>。我们告诉园丁该苹果就是位于果园内那棵老歪脖树的东边分叉上靠西边那个分叉的再靠北边的分叉上半红半绿的那个苹果。其中dn标识一条记录，描述一条数据的详细路径。</p></blockquote><h4 id="LDAP关键字"><a href="#LDAP关键字" class="headerlink" title="LDAP关键字"></a>LDAP关键字</h4><ul><li><p>Domain Component（dc）</p><p>域名的部分，表示过程中将完整域名以点号为界限进行分割（一条记录的所属位置）。例如：Domain Name：example.com&lt;—&gt;DC Format：dc=example，dc=com。</p></li><li><p>User Id（uid）</p><p>用户ID（一条记录的ID），例如：test.wu。</p></li><li><p>Organization Unit（ou）</p><p>组织单位，包括其他各种对象（一条记录的所属组织），例如：oa组。</p></li><li><p>Common Name（cn）</p><p>公共名称（一条记录的名称），例如：Thomas Muller。</p></li><li><p>Surname（sn）姓氏</p></li><li><p>Distinguished Name（dn）</p><p>一条记录的位置（唯一），例如：”uid=songtao.xu, ou=oa组, dc=example.com”。</p></li><li><p>Relative dn（rdn）</p><p>相对辨别名，类似于文件系统中的相对路径，与目录树结构无关。例如：”uid=Tom”或”cn=Thomas Muller”。</p></li></ul><h4 id="四大基本模型"><a href="#四大基本模型" class="headerlink" title="四大基本模型"></a>四大基本模型</h4><ul><li>信息模型</li></ul><p><img src="/2020/06/13/LDAP协议及AD域/2.PNG" alt="信息模型.png-65.7kB"></p><ul><li>命名模型</li></ul><p><img src="/2020/06/13/LDAP协议及AD域/3.PNG" alt="命名模型.png-45.2kB"></p><ul><li>功能模型</li></ul><p><img src="/2020/06/13/LDAP协议及AD域/4.PNG" alt="功能模型.png-65.4kB"></p><ul><li>安全模型</li></ul><p><img src="/2020/06/13/LDAP协议及AD域/5.PNG" alt="安全模型.png-31.8kB"></p><h3 id="LDAP使用"><a href="#LDAP使用" class="headerlink" title="LDAP使用"></a>LDAP使用</h3><p>统一身份认证改变原有认证策略，使用LDAP对所有需要认证的软件进行认证。完成统一身份认证之后，用户的所有信息都存储在AD Server中。终端用户在需要使用公司内部服务的时候，都需要通过AD服务器的认证。</p><h3 id="LDAP认证过程"><a href="#LDAP认证过程" class="headerlink" title="LDAP认证过程"></a>LDAP认证过程</h3><p>LDAP采用C/S架构进行认证，常采用MD5认证方式，具体步骤如下：</p><h4 id="客户端发送绑定请求"><a href="#客户端发送绑定请求" class="headerlink" title="客户端发送绑定请求"></a>客户端发送绑定请求</h4><p><img src="/2020/06/13/LDAP协议及AD域/6.PNG" alt="client_bind.png-11.4kB"></p><p>初始化认证阶段，客户端发送绑定请求（bindRequest），具体内容如下：</p><ul><li>协议版本：3</li><li>认证机制：sasl</li><li>认证方式：DIGEST-MD5</li></ul><h4 id="服务器响应绑定结果"><a href="#服务器响应绑定结果" class="headerlink" title="服务器响应绑定结果"></a>服务器响应绑定结果</h4><p><img src="/2020/06/13/LDAP协议及AD域/7.PNG" alt="server_bind_result.png-52.5kB"></p><p>与HTTPS通信过程类似，服务器返回一段十六进制加密内容serverSaslCreds，该内容主要包括服务器支持的加密方式、认证方式、算法标准以及验证时间戳等信息，要求客户端选择对应的加密标准并使用相同的sasl机制发送新的绑定请求以继续认证过程。对十六进制数据解码后结果如下：</p><ul><li>服务器支持的摘要认证qop：auth，auth-int，auth-conf</li><li>服务器支持的加密方式cipher：3des，cr4</li><li>服务器支持的加密算法algorithm：md5-sess</li><li>服务器的验证时间戳nonce：一串随机数，用于防御重放攻击与选择明文攻击，提高数据安全性</li><li>Charset编码：utf-8</li><li>Realm：xxx.com</li></ul><p>可以看到，LDAP多采用对称密码与消息摘要算法结合的方式实现身份认证与敏感数据传输。</p><h4 id="客户端发送Response"><a href="#客户端发送Response" class="headerlink" title="客户端发送Response"></a>客户端发送Response</h4><p><img src="/2020/06/13/LDAP协议及AD域/8.PNG" alt="client_response.png-338.9kB"></p><p>客户端收到服务器的响应之后，从服务器提供的各类标准中选择本次认证使用的标准，返回一段十六进制加密数据credentials，用以请求查询绑定的用户是否存在，发送内容经解码后如下：</p><ul><li>请求查询的用户登录名：test6</li><li>查询的整个域realm：xxx.com</li><li>服务器发来的nonce</li><li>客户端的验证时间戳cnonce：客户端产生的用于对称校验的随机数</li><li>客户端发送的请求次数cn：00000001（表示只会发送一次请求）</li><li>客户端要求使用的qop：auth-conf</li><li>客户端要求使用的加密方式：rc4</li><li>客户端支持的最大字节流长度：16777215</li><li>本次请求的资源位置digest-url：ldap.com</li><li>最终摘要response：根据以上信息和所用密码，通过预设规律计算出的md5码</li></ul><h4 id="服务器返回查询结果"><a href="#服务器返回查询结果" class="headerlink" title="服务器返回查询结果"></a>服务器返回查询结果</h4><p>服务器会返回查询结果，若绑定成功，则报文解码如下：</p><p><img src="/2020/06/13/LDAP协议及AD域/9.PNG" alt="bind_success.png-32.1kB"></p><p>绑定失败则发送错误消息：</p><p><img src="/2020/06/13/LDAP协议及AD域/10.PNG" alt="bind_fail.png-50.2kB"></p><h2 id="AD域"><a href="#AD域" class="headerlink" title="AD域"></a>AD域</h2><h3 id="AD域概述"><a href="#AD域概述" class="headerlink" title="AD域概述"></a>AD域概述</h3><p>活动目录<strong>Active Directory</strong>的缩写，面向微软服务器的目录服务，LDAP协议下的一种产品。它为用户管理网络环境各个组成要素的标识和关系提供了一种有力的手段。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>实现集中式管理。</li><li>回收并管理普通用户对客户机的权限。</li><li>AD域作为大安全边界，用户只需一次登录身份验证，便可直接访问域林中所有允许访问资源，无需多次身份验证，从而提高效率，减少维护成本。</li><li>通过文件夹重定向，可将所有用户桌面的”我的文档”重定向到文件服务器上。</li></ul><h3 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h3><ul><li>用户账号管理</li><li>权限管理</li><li>软件/补丁推送</li></ul><h3 id="域信任关系"><a href="#域信任关系" class="headerlink" title="域信任关系"></a>域信任关系</h3><p>域信任关系具有方向性，域之间的信任方向决定了资源访问方向。</p><p>域的信任关系主动权掌握在被信任域手中。但是如果信任域不对被信任域进行资源分配，则被信任域无法获取任何资源。在Windows2000之后，域树和域林之间的信任关系具有传递特性。</p><h4 id="域树"><a href="#域树" class="headerlink" title="域树"></a>域树</h4><p>域树的父域和子域之间由于使用了层次分明的DNS域名，使用者可根据域名判断出两个域之间的隶属关系从而方便域之间建立和传递相互信任关系。</p><h3 id="组策略"><a href="#组策略" class="headerlink" title="组策略"></a>组策略</h3><p>组策略是一个允许执行针对用户或计算机进行配置的基础架构。与注册表相似，组策略也是一项可以修改用户或计算机设置的技术；但与注册表不同的是，注册表只能针对一个用户或一台计算机进行设置，而组策略却可以针对多个用户和多台计算机进行设置。</p><p>组策略和AD结合使用，可以部署在OU，站点和域级别上，不同级别之间具有以下优先级：本地计算机 &lt; 站点 &lt; 域 &lt; OU，使用者可根据管理任务，为组策略选择合适的部署级别。</p><h4 id="组策略对象"><a href="#组策略对象" class="headerlink" title="组策略对象"></a>组策略对象</h4><p>组策略通过组策略对象（GPO）进行设定，只要将GPO连接到指定站点、域或OU，该GPO内的设定值就会影响到对应级别内的全部用户与计算机。</p><h4 id="组策略存储位置"><a href="#组策略存储位置" class="headerlink" title="组策略存储位置"></a>组策略存储位置</h4><ul><li>链接GPO的AD容器</li><li>域控制器上的Sysvol文件夹</li></ul><h4 id="GPO组成"><a href="#GPO组成" class="headerlink" title="GPO组成"></a>GPO组成</h4><ul><li>组策略容器GPC</li><li>组策略模板GPT</li></ul><h4 id="组策略管理"><a href="#组策略管理" class="headerlink" title="组策略管理"></a>组策略管理</h4><p>组策略管理可以通过组策略编辑器和组策略管理控制台（GPMC）。组策略编辑器是Windows操作系统中自带的组策略管理工具，而GPMC则具有创建、管理和部署GPO等更强大的功能的组策略编辑工具。</p><h4 id="组策略应用"><a href="#组策略应用" class="headerlink" title="组策略应用"></a>组策略应用</h4><ul><li><p>账户策略的设定</p><p>设定用户密码长度、复杂度、使用期限和账号锁定策略等。</p></li><li><p>本地策略的设定</p><p>审核策略的设定、用户权限的指派、安全性的设定等。</p></li><li><p>部署软件</p><p>通过将待部署软件存储在文件服务器的共享文件夹中并运用组策略告知用户或计算机进行下载安装的方法实现软件的批量部署。</p></li></ul><h3 id="搭建AD域"><a href="#搭建AD域" class="headerlink" title="搭建AD域"></a>搭建AD域</h3><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>配置完成后，使用命令<strong>Gpresult或gpresult /r</strong>获取组策略结果，检查客户端电脑是否加入域，以及加入域之后获取的组策略结果。</li><li>每次在域服务器上面修改组策略后，若需要组策略立即生效，则需要在域服务器及客户端电脑上执行命令<strong>Gpupdate /force</strong>强制更新组策略。</li></ul><h4 id="常见问题排查"><a href="#常见问题排查" class="headerlink" title="常见问题排查"></a>常见问题排查</h4><ul><li><strong>域用户认证失败</strong><ul><li>检查用户所属OU是否存在于桌面云设备上配置的搜索入口范围内</li><li>检查用户是否满足相关过滤条件</li><li>检查VDC设备与AD域服务器之间网络是否连通</li><li>检查域用户本身是否存在异常</li></ul></li><li><strong>虚拟机加入域失败</strong><ul><li>检查VDC上虚拟机加入域的配置</li><li>检查虚拟机到域控路由的可达性以及DNS是否能够解析域名</li><li>尝试将虚拟机手动加入域</li></ul></li><li><strong>虚拟机用户登录失败</strong><ul><li>虚拟机未加入域</li><li>检查虚拟机到域控路由的可达性以及DNS是否能够解析域名</li><li>检查域内是否存在针对用户的计算机绑定</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;LDAP协议&quot;&gt;&lt;a href=&quot;#LDAP协议&quot; class=&quot;headerlink&quot; title=&quot;LDAP协议&quot;&gt;&lt;/a&gt;LDAP协议&lt;/h2&gt;&lt;h3 id=&quot;需求分析&quot;&gt;&lt;a href=&quot;#需求分析&quot; class=&quot;headerlink&quot; title=&quot;需
      
    
    </summary>
    
      <category term="Computer Foundation" scheme="https://blank-vax.github.io/categories/Computer-Foundation/"/>
    
    
      <category term="LDAP" scheme="https://blank-vax.github.io/tags/LDAP/"/>
    
  </entry>
  
  <entry>
    <title>2020华为勇敢星实习面试记录</title>
    <link href="https://blank-vax.github.io/2020/06/01/2020%E5%8D%8E%E4%B8%BA%E5%8B%87%E6%95%A2%E6%98%9F%E5%AE%9E%E4%B9%A0%E8%AE%A1%E5%88%92%E9%9D%A2%E8%AF%95/"/>
    <id>https://blank-vax.github.io/2020/06/01/2020华为勇敢星实习计划面试/</id>
    <published>2020-05-31T16:50:00.000Z</published>
    <updated>2021-07-06T17:23:19.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-投递流程"><a href="#0x00-投递流程" class="headerlink" title="0x00 投递流程"></a>0x00 投递流程</h2><p>由于专业对口原因，选择的岗位是<strong>网络安全与隐私保护工程师</strong>。这一大岗位分成网络安全与隐私保护两个方向，网络安全方向对渗透测试及Web安全知识要求较高，而隐私保护方向对隐私保护、准入权限等标准要求较高，附带要求一些密码学的知识。</p><p>在投递实习生申请的时候需要选择第一意向部门和第二意向部门，第一次投递时选择流程出现了问题，导致只通过了笔试和性格测试，迟迟没有接到面试的通知。大概在五月底第二次重新投递了<strong>公共开发部</strong>，过了大概十天左右就收到了面试通知。所以整体流程如下：</p><blockquote><p>4.11 第一次投递网络安全与隐私保护工程师 未选择意向部门</p><p>4.15 在线笔试</p><p>4.16 性格测试</p><p>5.20 第二次投递网络安全与隐私保护工程师 第一意向部门 公共开发部 第二意向部门 2012实验室</p><p>6.9 签署《知识产权和商业秘密保护承诺书》</p><p>6.10 技术面试</p><p>6.11 主管面试</p><p>6.12——至今 泡池子</p><p>6.28 入职通知</p></blockquote><h2 id="0x01-在线笔试及性格测试"><a href="#0x01-在线笔试及性格测试" class="headerlink" title="0x01 在线笔试及性格测试"></a>0x01 在线笔试及性格测试</h2><p>刚收到在线笔试通知的时候开始疯狂准备编程题目，收到笔试链接邮件后发现考试没有编程题目，转而去刷安全基础知识。结果笔试题目考察的全部是涉及隐私保护协议及标准的选择题，甚至还有许多涉及用户隐私的正常逻辑推理题（错误选项显而易见）。笔试时间限制为19：00——20：00一个小时，大概用了半小时左右完成了所有的题目。隔壁网络安全的笔试考察比较全面，以Web安全为主题，还会涉及到恶意病毒及密码学的相关知识，还有一道编程题目，大概这个岗位对技术要求比较高吧。</p><p>笔试结束的第二天就收到了性格测试的邮件，然后开始在线测试。性格测试大概是每页六道题目，每个题目包含六个选项（从非常不符合到非常符合），大概有十几页的样子。每页六道题中如果多个题目选择同一选项，需要在这些题目中间选择<strong>最适合</strong>和<strong>最不适合</strong>的选项。经过翻阅网上的大量资料，总结出性格测试的几个要点：</p><ul><li>针对同一问题，前后答案的态度需要保持一致</li><li>需要符合华为公司的文化</li><li>华为比较喜欢平庸的员工，除非自己特别喜欢或特别排斥，尽量少选择<strong>非常不符合</strong>和<strong>非常符合</strong>这两部分</li></ul><p>剩下的攻略在网上也可以找到，一般来说性格测试比较好过，不过也不需要太纠结，毕竟实习和工作都是应聘者和公司的双向选择，如果价值观极其不相符，入职了也没什么意义。性格测试时间限制为2小时，一般速度大概1小时左右完工。</p><h2 id="0x02-技术面试"><a href="#0x02-技术面试" class="headerlink" title="0x02 技术面试"></a>0x02 技术面试</h2><p>今年由于疫情影响，面试都调整为线上进行，使用Zoom会议软件。邮件通知为上午9：30开始，然后9：16发来短信告知会议房间号。进去之后一位非常和蔼的小哥哥戴着口罩，笑眯眯地坐在镜头前。大致问了以下几个问题：</p><ul><li><p>Q1：自我介绍</p></li><li><p>Q2：看你的简历上写了比赛经历，能不能给我详细介绍一下“美亚杯”电子取证比赛的经历呢？</p></li><li><p>Q3：该比赛中，你和你的队友如何分配任务？</p></li><li><p>Q4：既然你投了隐私保护这个岗位，对密码学有什么了解？常见的加密手段有哪些？</p></li><li><p>Q5：代码能力如何？掌握哪些编程语言？</p></li><li><p>Q6：手写代码部分。由于是线上面试，该部分可以选择手写或者IDE共享屏幕（这个选择权也是根据岗位的不同而异，网络安全岗就限制了只能手写）。如果使用IDE可以自行输出和debug。</p><p>题目：分割子串问题。给定任意全字母组合的非空字符串及对应子串相异字母数k。针对每一子串，对其中包含字符的数量不作限制，只限制不同字母的数量为k。</p><p>例如：选定子串为”abcdefffff”，选定相异字母数k=2。则所有分割结果为：”ab”，”bc”，”cd”，”de”，”ef”，”eff”，”efff”，”effff”，”efffff”，共9个。</p><p>解题代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">str_test = <span class="string">"aabcdefaaaaa"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_component</span><span class="params">(str_test, k)</span>:</span></span><br><span class="line">    result_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str_test)-(k<span class="number">-1</span>)):</span><br><span class="line">        tmp = <span class="string">''</span></span><br><span class="line">        index_offset = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> len(set(tmp)) &lt;= k <span class="keyword">and</span> i+index_offset != len(str_test)<span class="number">-1</span>:</span><br><span class="line">            tmp += str_test[i+index_offset]</span><br><span class="line">            index_offset += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> len(set(tmp)) != k:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> tmp <span class="keyword">not</span> <span class="keyword">in</span> result_list:</span><br><span class="line">                result_list.append(tmp)</span><br><span class="line">    <span class="keyword">return</span> result_list</span><br><span class="line"></span><br><span class="line">block_length = int(input())</span><br><span class="line"><span class="keyword">print</span> get_all_component(str_test, block_length)</span><br></pre></td></tr></table></figure><p>说来惭愧，刚开始代码写的并不完美，没有考虑字符串末尾出现大量相同字符时如何处理。最后进行适当调整满足了题目要求。</p></li></ul><p>整体面试体验就是非常的nice，面试官也非常和蔼可亲，在面试者回答问题的时候会轻声附和，在代码调试过程中会给出指导，整套流程下来大概四十分钟左右。基本上没有什么需要注意的地方，因为应聘的是隐私保护这个岗位，问到的技术问题不算太难，手撕代码是面试的祖传项目，需要好好准备。不过前一天晚上准备的大量项目经历没有派上用场，甚至没有提及简历上写的项目。</p><h2 id="0x03-主管面试"><a href="#0x03-主管面试" class="headerlink" title="0x03 主管面试"></a>0x03 主管面试</h2><p>大多数主管面试会安排在技术面试结束后的第二天，少部分会安排在当天。主管面试邮件通知时间为14：30，结果前面一直在排队，拖到了16：40才进入面试会议房间。面试过程中大概问了以下问题，涵盖技术问题、工作理念、未来规划以及逻辑题目，同样没怎么关注项目经历。</p><ul><li>Q1：介绍一下简历上的”美亚杯“电子数据取证比赛</li><li>Q2：电子数据取证分析是如何对Windows内存镜像进行分析的？</li><li>Q3：对密码学了解多少？</li><li>Q4：常见的密码学攻击手段？</li><li>Q5：既然是做隐私保护的，应该对入侵攻击有所了解，简要说明一下SQL注入相关内容</li><li>Q6：家是哪里的？未来打算在哪个城市生活与工作？</li><li>Q7：平时有什么爱好？</li><li>Q8：逻辑题：一个村子里共100个人，其中男人只说真话，女人只说假话。一位探险家来到村子，从第一个人询问至第一百个人村子里女人的数量，得到的回答依次为1，2，3，4，5…..100，则村子里共有多少女人？</li><li>Q9：近日对华为有什么了解？华为受到美国制裁，发展前景堪忧，为什么还考虑来这里工作？</li><li>Q10：如何看待华为的文化？</li><li>Q11：如何看待996的加班机制？</li><li>Q12：有什么问题想要问我吗？</li></ul><p>整体面试时间为半小时左右，期间明显感觉到压力较大（面试官一脸严肃）。可以看到，首先提问技术方面的问题，重点关注参加的比赛及校内获取的奖项，当然也关注简历上注明的研究方向。随后了解个人价值取向，包括未来规划以及个人爱好。最后询问针对华为文化的看法，这里的回答就见仁见智了，不过如果希望拿到实习生职位还是迎合着讲比较好。</p><h2 id="0x04-后续"><a href="#0x04-后续" class="headerlink" title="0x04 后续"></a>0x04 后续</h2><p>6.28 给了入职通知，由于需要考研并且去西安比较麻烦，所以没有去。</p><p>虽然大三暑期实习没有直接转正的机会，但是秋招的时候华为会专门安排实习生招聘专场，面试的流程也比较快。据参加华为实习的朋友讲，实习体验总体令人满意。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-投递流程&quot;&gt;&lt;a href=&quot;#0x00-投递流程&quot; class=&quot;headerlink&quot; title=&quot;0x00 投递流程&quot;&gt;&lt;/a&gt;0x00 投递流程&lt;/h2&gt;&lt;p&gt;由于专业对口原因，选择的岗位是&lt;strong&gt;网络安全与隐私保护工程师&lt;/stron
      
    
    </summary>
    
      <category term="Interview" scheme="https://blank-vax.github.io/categories/Interview/"/>
    
    
      <category term="HUAWEI" scheme="https://blank-vax.github.io/tags/HUAWEI/"/>
    
  </entry>
  
  <entry>
    <title>Bristol Cryptography Blog（三）—— 不同组件的计算和存储能力</title>
    <link href="https://blank-vax.github.io/2020/05/10/Bristol-Cryptography-Blog%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%A1%E7%AE%97%E5%92%8C%E5%AD%98%E5%82%A8%E8%83%BD%E5%8A%9B/"/>
    <id>https://blank-vax.github.io/2020/05/10/Bristol-Cryptography-Blog（三）——不同组件的计算和存储能力/</id>
    <published>2020-05-10T03:08:00.000Z</published>
    <updated>2020-11-09T03:27:36.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文为布里斯托大学推出的<code>52 Things Every PhD Student Should Know to do Cryptography</code>系列学习笔记中的第二篇。原文连接：<a href="http://bristolcrypto.blogspot.com/2014/10/52-things-q3-computational-and-storage.html" target="_blank" rel="noopener">52 Things: Number 3: Computational and storage power of different form factors</a>。</p><h2 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h2><p>简要讨论以下几类组件的计算与存储能力：</p><ul><li>智能卡</li><li>微控制器（例如传感器节点）</li><li>嵌入式或移动计算机（例如移动电话或掌上电脑PDA）</li><li>笔记本电脑或台式机</li></ul><h2 id="计算能力评估"><a href="#计算能力评估" class="headerlink" title="计算能力评估"></a>计算能力评估</h2><p>我们可以通过评估处理器的时钟速率来衡量设备的计算能力。然而如果处理器允许某种形式的并行处理，该评估结果相应地具有误导性——显然在2GHz频率上运行的双核处理器显然比对应频率的单核处理器具有更强的计算能力。因此找到计算能力的直接量化指标并不现实。</p><p>对于诸如通用图形卡之类的特定设备，通常将该类设备能够承受的总FLOPS（Floating Point Operations Per Second，每秒浮点操作数——针对单精度或双精度运算）作为衡量标准。然而该方法应用到特定问题时仍存在局限性。实际上，某些服务可以通过在各种问题实例上对不同设备的性能进行基准测试来衡量计算能力，其中最具代表性的服务即为CompuBench。幸运的是，问题中包含的设备其功能范围使得答案对定量指标具有较低的依赖性。</p><h2 id="存储能力评估"><a href="#存储能力评估" class="headerlink" title="存储能力评估"></a>存储能力评估</h2><p>衡量每个设备存储能力的方法要容易得多：我们可以简单比较设备永久存储信息的大概字节数。</p><h2 id="智能卡相关性能"><a href="#智能卡相关性能" class="headerlink" title="智能卡相关性能"></a>智能卡相关性能</h2><p>智能卡是计算能力最差的设备。尽管时钟速率因不同的实现方法而有所差异，但智能卡的计算核心速度只能达到20MHz左右。在存储方面，典型的智能卡具有2KB左右的可用存储空间。</p><h2 id="微控制器相关性能"><a href="#微控制器相关性能" class="headerlink" title="微控制器相关性能"></a>微控制器相关性能</h2><p>微控制器是<strong>“包含核心处理器、存储器和可编程输入/输出外围设备的单个集成电路上的小型计算机”</strong>。</p><p>由于微控制器的确切定义不同，其可用的存储空间与计算能力范围将有很大区别。这里以前面提及的传感器节点为例，其作为典型的微控制器具有与智能卡类似的计算能力，并且可用的存储量略多（大概在几KB到几MB的数量级）。</p><h2 id="嵌入式或移动计算机相关性能"><a href="#嵌入式或移动计算机相关性能" class="headerlink" title="嵌入式或移动计算机相关性能"></a>嵌入式或移动计算机相关性能</h2><p>诸如移动电话之类的移动计算机具有更强的存储能力和计算能力，并且随着时间的推移，可用算力正在迅速增加。以2008年的iPhone和2013年的Nexus 5手机为例，iPhone使用了412MHz 32位的RISC ARM内核，而Nexus 5 则使用了频率为2.3GHz的四核处理器。在存储方面，如果我们忽略某些具有移动存储功能的手机，2013年的高端手机会提供约16至32GB的存储空间，当然64GB至128GB的手机存储空间在现在看来也是司空见惯了。</p><h2 id="笔记本-台式机相关性能"><a href="#笔记本-台式机相关性能" class="headerlink" title="笔记本/台式机相关性能"></a>笔记本/台式机相关性能</h2><p>大多数笔记本电脑或台式机理所当然地具有比手机更强的处理能力。高端英特尔”Haswell” i7 4960K处理器具有四个处理核心，每个核心的主频率为4GHz，而AMD “Piledriver” FX-9590 CPU包含八个4.7GHz的处理核心。需要注意的是，这两个处理器之间计算能力的比较不仅仅需要评估内核数量及时钟速率，还有其他因素会影响台式机或便携式计算机的计算能力——尤其是增加图形处理单元可以大大提高处理某些问题的性能。笔记本电脑或台式机的存储容量可能相差很大，但是消费者计算机中的典型存储量可能在数百GB到几TB之间。目前为止，最大的单个硬盘驱动器容量约为8TB。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文为布里斯托大学推出的&lt;code&gt;52 Things Every PhD Student Should Know to do Crypto
      
    
    </summary>
    
      <category term="Crypto_Knowledge" scheme="https://blank-vax.github.io/categories/Crypto-Knowledge/"/>
    
    
      <category term="Notes" scheme="https://blank-vax.github.io/tags/Notes/"/>
    
  </entry>
  
</feed>
